{"prompt": "Animate a colorful logo composed of shapes (circle, square, triangle, and M symbol) moving towards the center.", "response": "class ManimCELogo(Scene):\n    def construct(self):\n        self.camera.background_color = \"#ece6e2\"\n        logo_green = \"#87c2a5\"\n        logo_blue = \"#525893\"\n        logo_red = \"#e07a5f\"\n        logo_black = \"#343434\"\n        ds_m = MathTex(r\"\\mathbb{M}\", fill_color=logo_black).scale(7)\n        ds_m.shift(2.25 * LEFT + 1.5 * UP)\n        circle = Circle(color=logo_green, fill_opacity=1).shift(LEFT)\n        square = Square(color=logo_blue, fill_opacity=1).shift(UP)\n        triangle = Triangle(color=logo_red, fill_opacity=1).shift(RIGHT)\n        logo = VGroup(triangle, square, circle, ds_m)  # order matters\n        logo.move_to(ORIGIN)\n        self.add(logo)", "original_prompt": "ManimCELogo"}
{"prompt": "Animate a rotating line segment with two dots and two floating brace annotations.", "response": "class BraceAnnotation(Scene):\n    def construct(self):\n        dot = Dot([-2, -1, 0])\n        dot2 = Dot([2, 1, 0])\n        line = Line(dot.get_center(), dot2.get_center()).set_color(ORANGE)\n        b1 = Brace(line)\n        b1text = b1.get_text(\"Horizontal distance\")\n        b2 = Brace(line, direction=line.copy().rotate(PI / 2).get_unit_vector())\n        b2text = b2.get_tex(\"x-x_1\")\n        self.add(line, dot, dot2, b1, b2, b1text, b2text)", "original_prompt": "BraceAnnotation"}
{"prompt": "Animate a red dot on a number plane that moves from (0, 0) to (2, 2).", "response": "class VectorArrow(Scene):\n    def construct(self):\n        dot = Dot(ORIGIN)\n        arrow = Arrow(ORIGIN, [2, 2, 0], buff=0)\n        numberplane = NumberPlane()\n        origin_text = Text('(0, 0)').next_to(dot, DOWN)\n        tip_text = Text('(2, 2)').next_to(arrow.get_end(), RIGHT)\n        self.add(numberplane, dot, arrow, origin_text, tip_text)", "original_prompt": "VectorArrow"}
{"prompt": "\"Generate a gradient image and display it as a growing circle with green background.\"\n\nHowever, I would like to modify the prompt slightly to better match the Manim animation:\n\n\"Animate a 2D gradient image scaling up into view within a surrounding green rectangle.\"", "response": "class GradientImageFromArray(Scene):\n    def construct(self):\n        n = 256\n        imageArray = np.uint8(\n            [[i * 256 / n for i in range(0, n)] for _ in range(0, n)]\n        )\n        image = ImageMobject(imageArray).scale(2)\n        image.background_rectangle = SurroundingRectangle(image, color=GREEN)\n        self.add(image, image.background_rectangle)", "original_prompt": "GradientImageFromArray"}
{"prompt": "Animate overlapping ellipses to display different boolean operations: Ellipse 1 & Ellipse 2 transform into intersection, union, exclusion, and difference shapes while changing color and size.", "response": "class BooleanOperations(Scene):\n    def construct(self):\n        ellipse1 = Ellipse(\n            width=4.0, height=5.0, fill_opacity=0.5, color=BLUE, stroke_width=10\n        ).move_to(LEFT)\n        ellipse2 = ellipse1.copy().set_color(color=RED).move_to(RIGHT)\n        bool_ops_text = MarkupText(\"Boolean Operation\").next_to(ellipse1, UP * 3)\n        ellipse_group = Group(bool_ops_text, ellipse1, ellipse2).move_to(LEFT * 3)\n        self.play(FadeIn(ellipse_group))\n\n        i = Intersection(ellipse1, ellipse2, color=GREEN, fill_opacity=0.5)\n        self.play(i.animate.scale(0.25).move_to(RIGHT * 5 + UP * 2.5))\n        intersection_text = Text(\"Intersection\", font_size=23).next_to(i, UP)\n        self.play(FadeIn(intersection_text))\n\n        u = Union(ellipse1, ellipse2, color=ORANGE, fill_opacity=0.5)\n        union_text = Text(\"Union\", font_size=23)\n        self.play(u.animate.scale(0.3).next_to(i, DOWN, buff=union_text.height * 3))\n        union_text.next_to(u, UP)\n        self.play(FadeIn(union_text))\n\n        e = Exclusion(ellipse1, ellipse2, color=YELLOW, fill_opacity=0.5)\n        exclusion_text = Text(\"Exclusion\", font_size=23)\n        self.play(e.animate.scale(0.3).next_to(u, DOWN, buff=exclusion_text.height * 3.5))\n        exclusion_text.next_to(e, UP)\n        self.play(FadeIn(exclusion_text))\n\n        d = Difference(ellipse1, ellipse2, color=PINK, fill_opacity=0.5)\n        difference_text = Text(\"Difference\", font_size=23)\n        self.play(d.animate.scale(0.3).next_to(u, LEFT, buff=difference_text.height * 3.5))\n        difference_text.next_to(d, UP)\n        self.play(FadeIn(difference_text))", "original_prompt": "BooleanOperations"}
{"prompt": "\"Animate a dot moving along a growing circle with rotation while showing a static line.\"", "response": "class PointMovingOnShapes(Scene):\n    def construct(self):\n        circle = Circle(radius=1, color=BLUE)\n        dot = Dot()\n        dot2 = dot.copy().shift(RIGHT)\n        self.add(dot)\n\n        line = Line([3, 0, 0], [5, 0, 0])\n        self.add(line)\n\n        self.play(GrowFromCenter(circle))\n        self.play(Transform(dot, dot2))\n        self.play(MoveAlongPath(dot, circle), run_time=2, rate_func=linear)\n        self.play(Rotating(dot, about_point=[2, 0, 0]), run_time=1.5)\n        self.wait()", "original_prompt": "PointMovingOnShapes"}
{"prompt": "\"Fade in a small orange square that rotates around the center, then scales down and shifts left.\"", "response": "class MovingAround(Scene):\n    def construct(self):\n        square = Square(color=BLUE, fill_opacity=1)\n\n        self.play(square.animate.shift(LEFT))\n        self.play(square.animate.set_fill(ORANGE))\n        self.play(square.animate.scale(0.3))\n        self.play(square.animate.rotate(0.4))", "original_prompt": "MovingAround"}
{"prompt": "\"Show a rotating line with an evolving angle notation, gradually changing color and position.\"", "response": "class MovingAngle(Scene):\n    def construct(self):\n        rotation_center = LEFT\n\n        theta_tracker = ValueTracker(110)\n        line1 = Line(LEFT, RIGHT)\n        line_moving = Line(LEFT, RIGHT)\n        line_ref = line_moving.copy()\n        line_moving.rotate(\n            theta_tracker.get_value() * DEGREES, about_point=rotation_center\n        )\n        a = Angle(line1, line_moving, radius=0.5, other_angle=False)\n        tex = MathTex(r\"\\theta\").move_to(\n            Angle(\n                line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False\n            ).point_from_proportion(0.5)\n        )\n\n        self.add(line1, line_moving, a, tex)\n        self.wait()\n\n        line_moving.add_updater(\n            lambda x: x.become(line_ref.copy()).rotate(\n                theta_tracker.get_value() * DEGREES, about_point=rotation_center\n            )\n        )\n\n        a.add_updater(\n            lambda x: x.become(Angle(line1, line_moving, radius=0.5, other_angle=False))\n        )\n        tex.add_updater(\n            lambda x: x.move_to(\n                Angle(\n                    line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False\n                ).point_from_proportion(0.5)\n            )\n        )\n\n        self.play(theta_tracker.animate.set_value(40))\n        self.play(theta_tracker.animate.increment_value(140))\n        self.play(tex.animate.set_color(RED), run_time=0.5)\n        self.play(theta_tracker.animate.set_value(350))", "original_prompt": "MovingAngle"}
{"prompt": "Animate two moving dots that transform into a line connecting them, with a fixed distance.", "response": "class MovingDots(Scene):\n    def construct(self):\n        d1,d2=Dot(color=BLUE),Dot(color=GREEN)\n        dg=VGroup(d1,d2).arrange(RIGHT,buff=1)\n        l1=Line(d1.get_center(),d2.get_center()).set_color(RED)\n        x=ValueTracker(0)\n        y=ValueTracker(0)\n        d1.add_updater(lambda z: z.set_x(x.get_value()))\n        d2.add_updater(lambda z: z.set_y(y.get_value()))\n        l1.add_updater(lambda z: z.become(Line(d1.get_center(),d2.get_center())))\n        self.add(d1,d2,l1)\n        self.play(x.animate.set_value(5))\n        self.play(y.animate.set_value(4))\n        self.wait()", "original_prompt": "MovingDots"}
{"prompt": "\"Move a dot to the center of another dot.\"\n\nThis prompt is short and concise, and it accurately describes the key visual element (dot) and transformation (moving from one dot to another).", "response": "class MovingGroupToDestination(Scene):\n    def construct(self):\n        group = VGroup(Dot(LEFT), Dot(ORIGIN), Dot(RIGHT, color=RED), Dot(2 * RIGHT)).scale(1.4)\n        dest = Dot([4, 3, 0], color=YELLOW)\n        self.add(group, dest)\n        self.play(group.animate.shift(dest.get_center() - group[2].get_center()))\n        self.wait(0.5)", "original_prompt": "MovingGroupToDestination"}
{"prompt": "Animate the derivative formula diagram with a box transforming into its expanded form.", "response": "class MovingFrameBox(Scene):\n    def construct(self):\n        text=MathTex(\n            \"\\\\frac{d}{dx}f(x)g(x)=\",\"f(x)\\\\frac{d}{dx}g(x)\",\"+\",\n            \"g(x)\\\\frac{d}{dx}f(x)\"\n        )\n        self.play(Write(text))\n        framebox1 = SurroundingRectangle(text[1], buff = .1)\n        framebox2 = SurroundingRectangle(text[3], buff = .1)\n        self.play(\n            Create(framebox1),\n        )\n        self.wait()\n        self.play(\n            ReplacementTransform(framebox1,framebox2),\n        )\n        self.wait()", "original_prompt": "MovingFrameBox"}
{"prompt": "\"Rotate a yellow line about the origin, then reverse direction, with white reference line.\"", "response": "class RotationUpdater(Scene):\n    def construct(self):\n        def updater_forth(mobj, dt):\n            mobj.rotate_about_origin(dt)\n        def updater_back(mobj, dt):\n            mobj.rotate_about_origin(-dt)\n        line_reference = Line(ORIGIN, LEFT).set_color(WHITE)\n        line_moving = Line(ORIGIN, LEFT).set_color(YELLOW)\n        line_moving.add_updater(updater_forth)\n        self.add(line_reference, line_moving)\n        self.wait(2)\n        line_moving.remove_updater(updater_forth)\n        line_moving.add_updater(updater_back)\n        self.wait(2)\n        line_moving.remove_updater(updater_back)\n        self.wait(0.5)", "original_prompt": "RotationUpdater"}
{"prompt": "Animate a red dot moving around its center in a circle while showing the path it traces.", "response": "class PointWithTrace(Scene):\n    def construct(self):\n        path = VMobject()\n        dot = Dot()\n        path.set_points_as_corners([dot.get_center(), dot.get_center()])\n        def update_path(path):\n            previous_path = path.copy()\n            previous_path.add_points_as_corners([dot.get_center()])\n            path.become(previous_path)\n        path.add_updater(update_path)\n        self.add(path, dot)\n        self.play(Rotating(dot, radians=PI, about_point=RIGHT, run_time=2))\n        self.wait()\n        self.play(dot.animate.shift(UP))\n        self.play(dot.animate.shift(LEFT))\n        self.wait()", "original_prompt": "PointWithTrace"}
{"prompt": "Animate the sine and cosine graphs on a coordinate plane while showing the x-axis.", "response": "class SinAndCosFunctionPlot(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[-10, 10.3, 1],\n            y_range=[-1.5, 1.5, 1],\n            x_length=10,\n            axis_config={\"color\": GREEN},\n            x_axis_config={\n                \"numbers_to_include\": np.arange(-10, 10.01, 2),\n                \"numbers_with_elongated_ticks\": np.arange(-10, 10.01, 2),\n            },\n            tips=False,\n        )\n        axes_labels = axes.get_axis_labels()\n        sin_graph = axes.plot(lambda x: np.sin(x), color=BLUE)\n        cos_graph = axes.plot(lambda x: np.cos(x), color=RED)\n\n        sin_label = axes.get_graph_label(\n            sin_graph, \"\\\\sin(x)\", x_val=-10, direction=UP / 2\n        )\n        cos_label = axes.get_graph_label(cos_graph, label=\"\\\\cos(x)\")\n\n        vert_line = axes.get_vertical_line(\n            axes.i2gp(TAU, cos_graph), color=YELLOW, line_func=Line\n        )\n        line_label = axes.get_graph_label(\n            cos_graph, r\"x=2\\pi\", x_val=TAU, direction=UR, color=WHITE\n        )\n\n        plot = VGroup(axes, sin_graph, cos_graph, vert_line)\n        labels = VGroup(axes_labels, sin_label, cos_label, line_label)\n        self.add(plot, labels)", "original_prompt": "SinAndCosFunctionPlot"}
{"prompt": "\"Animate a red curve that reveals the point where its minimum value is reached along the x-axis.\"", "response": "class ArgMinExample(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 10], y_range=[0, 100, 10], axis_config={\"include_tip\": False}\n        )\n        labels = ax.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")\n\n        t = ValueTracker(0)\n\n        def func(x):\n            return 2 * (x - 5) ** 2\n        graph = ax.plot(func, color=MAROON)\n\n        initial_point = [ax.coords_to_point(t.get_value(), func(t.get_value()))]\n        dot = Dot(point=initial_point)\n\n        dot.add_updater(lambda x: x.move_to(ax.c2p(t.get_value(), func(t.get_value()))))\n        x_space = np.linspace(*ax.x_range[:2],200)\n        minimum_index = func(x_space).argmin()\n\n        self.add(ax, labels, graph, dot)\n        self.play(t.animate.set_value(x_space[minimum_index]))\n        self.wait()", "original_prompt": "ArgMinExample"}
{"prompt": "Animate a blue curve that intersects with another green curve while showing Riemann rectangles and bounded areas.", "response": "class GraphAreaPlot(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            x_axis_config={\"numbers_to_include\": [2, 3]},\n            tips=False,\n        )\n\n        labels = ax.get_axis_labels()\n\n        curve_1 = ax.plot(lambda x: 4 * x - x ** 2, x_range=[0, 4], color=BLUE_C)\n        curve_2 = ax.plot(\n            lambda x: 0.8 * x ** 2 - 3 * x + 4,\n            x_range=[0, 4],\n            color=GREEN_B,\n        )\n\n        line_1 = ax.get_vertical_line(ax.input_to_graph_point(2, curve_1), color=YELLOW)\n        line_2 = ax.get_vertical_line(ax.i2gp(3, curve_1), color=YELLOW)\n\n        riemann_area = ax.get_riemann_rectangles(curve_1, x_range=[0.3, 0.6], dx=0.03, color=BLUE, fill_opacity=0.5)\n        area = ax.get_area(curve_2, [2, 3], bounded_graph=curve_1, color=GREY, opacity=0.5)\n\n        self.add(ax, labels, curve_1, curve_2, line_1, line_2, riemann_area, area)", "original_prompt": "GraphAreaPlot"}
{"prompt": "Animate a dot moving along a curve that scales to show axes and stroke a polygon as it transforms.", "response": "class PolygonOnAxes(Scene):\n    def get_rectangle_corners(self, bottom_left, top_right):\n        return [\n            (top_right[0], top_right[1]),\n            (bottom_left[0], top_right[1]),\n            (bottom_left[0], bottom_left[1]),\n            (top_right[0], bottom_left[1]),\n        ]\n\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 10],\n            y_range=[0, 10],\n            x_length=6,\n            y_length=6,\n            axis_config={\"include_tip\": False},\n        )\n\n        t = ValueTracker(5)\n        k = 25\n\n        graph = ax.plot(\n            lambda x: k / x,\n            color=YELLOW_D,\n            x_range=[k / 10, 10.0, 0.01],\n            use_smoothing=False,\n        )\n\n        def get_rectangle():\n            polygon = Polygon(\n                *[\n                    ax.c2p(*i)\n                    for i in self.get_rectangle_corners(\n                        (0, 0), (t.get_value(), k / t.get_value())\n                    )\n                ]\n            )\n            polygon.stroke_width = 1\n            polygon.set_fill(BLUE, opacity=0.5)\n            polygon.set_stroke(YELLOW_B)\n            return polygon\n\n        polygon = always_redraw(get_rectangle)\n\n        dot = Dot()\n        dot.add_updater(lambda x: x.move_to(ax.c2p(t.get_value(), k / t.get_value())))\n        dot.set_z_index(10)\n\n        self.add(ax, graph, dot)\n        self.play(Create(polygon))\n        self.play(t.animate.set_value(10))\n        self.play(t.animate.set_value(k / 10))\n        self.play(t.animate.set_value(5))", "original_prompt": "PolygonOnAxes"}
{"prompt": "\"Display a temperature plot with rotating axes and fading tips.\"\n\n(Note: The Manim animation does not explicitly include rotations of the 3D objects or mathematical transformations. It only includes a static heat diagram plot with rotating axis labels.)", "response": "class HeatDiagramPlot(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 40, 5],\n            y_range=[-8, 32, 5],\n            x_length=9,\n            y_length=6,\n            x_axis_config={\"numbers_to_include\": np.arange(0, 40, 5)},\n            y_axis_config={\"numbers_to_include\": np.arange(-5, 34, 5)},\n            tips=False,\n        )\n        labels = ax.get_axis_labels(\n            x_label=Tex(r\"$\\Delta Q$\"), y_label=Tex(r\"T[$^\\circ C$]\")\n        )\n\n        x_vals = [0, 8, 38, 39]\n        y_vals = [20, 0, 0, -5]\n        graph = ax.plot_line_graph(x_values=x_vals, y_values=y_vals)\n\n        self.add(ax, labels, graph)", "original_prompt": "HeatDiagramPlot"}
{"prompt": "\"Animate a camera following an orange dot along a sine curve as the axes scale and move in sync.\"", "response": "class FollowingGraphCamera(MovingCameraScene):\n    def construct(self):\n        self.camera.frame.save_state()\n\n        # create the axes and the curve\n        ax = Axes(x_range=[-1, 10], y_range=[-1, 10])\n        graph = ax.plot(lambda x: np.sin(x), color=BLUE, x_range=[0, 3 * PI])\n\n        # create dots based on the graph\n        moving_dot = Dot(ax.i2gp(graph.t_min, graph), color=ORANGE)\n        dot_1 = Dot(ax.i2gp(graph.t_min, graph))\n        dot_2 = Dot(ax.i2gp(graph.t_max, graph))\n\n        self.add(ax, graph, dot_1, dot_2, moving_dot)\n        self.play(self.camera.frame.animate.scale(0.5).move_to(moving_dot))\n\n        def update_curve(mob):\n            mob.move_to(moving_dot.get_center())\n\n        self.camera.frame.add_updater(update_curve)\n        self.play(MoveAlongPath(moving_dot, graph, rate_func=linear))\n        self.camera.frame.remove_updater(update_curve)\n\n        self.play(Restore(self.camera.frame))", "original_prompt": "FollowingGraphCamera"}
{"prompt": "\"Animate a red rectangle unfolding from a purple square while zooming in and scaling down, with a red text label on the bottom.\"", "response": "class MovingZoomedSceneAround(ZoomedScene):\n# contributed by TheoremofBeethoven, www.youtube.com/c/TheoremofBeethoven\n    def __init__(self, **kwargs):\n        ZoomedScene.__init__(\n            self,\n            zoom_factor=0.3,\n            zoomed_display_height=1,\n            zoomed_display_width=6,\n            image_frame_stroke_width=20,\n            zoomed_camera_config={\n                \"default_frame_stroke_width\": 3,\n                },\n            **kwargs\n        )\n\n    def construct(self):\n        dot = Dot().shift(UL * 2)\n        image = ImageMobject(np.uint8([[0, 100, 30, 200],\n                                       [255, 0, 5, 33]]))\n        image.height = 7\n        frame_text = Text(\"Frame\", color=PURPLE, font_size=67)\n        zoomed_camera_text = Text(\"Zoomed camera\", color=RED, font_size=67)\n\n        self.add(image, dot)\n        zoomed_camera = self.zoomed_camera\n        zoomed_display = self.zoomed_display\n        frame = zoomed_camera.frame\n        zoomed_display_frame = zoomed_display.display_frame\n\n        frame.move_to(dot)\n        frame.set_color(PURPLE)\n        zoomed_display_frame.set_color(RED)\n        zoomed_display.shift(DOWN)\n\n        zd_rect = BackgroundRectangle(zoomed_display, fill_opacity=0, buff=MED_SMALL_BUFF)\n        self.add_foreground_mobject(zd_rect)\n\n        unfold_camera = UpdateFromFunc(zd_rect, lambda rect: rect.replace(zoomed_display))\n\n        frame_text.next_to(frame, DOWN)\n\n        self.play(Create(frame), FadeIn(frame_text, shift=UP))\n        self.activate_zooming()\n\n        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera)\n        zoomed_camera_text.next_to(zoomed_display_frame, DOWN)\n        self.play(FadeIn(zoomed_camera_text, shift=UP))\n        # Scale in        x   y  z\n        scale_factor = [0.5, 1.5, 0]\n        self.play(\n            frame.animate.scale(scale_factor),\n            zoomed_display.animate.scale(scale_factor),\n            FadeOut(zoomed_camera_text),\n            FadeOut(frame_text)\n        )\n        self.wait()\n        self.play(ScaleInPlace(zoomed_display, 2))\n        self.wait()\n        self.play(frame.animate.shift(2.5 * DOWN))\n        self.wait()\n        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera, rate_func=lambda t: smooth(1 - t))\n        self.play(Uncreate(zoomed_display_frame), FadeOut(frame))\n        self.wait()", "original_prompt": "MovingZoomedSceneAround"}
{"prompt": "\"Show a rotating, three-dimensional coordinate system with fixed 3D text in the corner.\"", "response": "class FixedInFrameMObjectTest(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES)\n        text3d = Text(\"This is a 3D text\")\n        self.add_fixed_in_frame_mobjects(text3d)\n        text3d.to_corner(UL)\n        self.add(axes)\n        self.wait()", "original_prompt": "FixedInFrameMObjectTest"}
{"prompt": "Animate a rotating circle to demonstrate parametric 3D surface generation with coordinate axes.", "response": "class ThreeDLightSourcePosition(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        sphere = Surface(\n            lambda u, v: np.array([\n                1.5 * np.cos(u) * np.cos(v),\n                1.5 * np.cos(u) * np.sin(v),\n                1.5 * np.sin(u)\n            ]), v_range=[0, TAU], u_range=[-PI / 2, PI / 2],\n            checkerboard_colors=[RED_D, RED_E], resolution=(15, 32)\n        )\n        self.renderer.camera.light_source.move_to(3*IN) # changes the source of the light\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(axes, sphere)", "original_prompt": "ThreeDLightSourcePosition"}
{"prompt": "Rotate the 3D coordinate axes around a fixed point while showing an orbiting circle.", "response": "class ThreeDCameraRotation(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        circle=Circle()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(circle,axes)\n        self.begin_ambient_camera_rotation(rate=0.1)\n        self.wait()\n        self.stop_ambient_camera_rotation()\n        self.move_camera(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.wait()", "original_prompt": "ThreeDCameraRotation"}
{"prompt": "\"Spin a circle within 3D axes while maintaining fixed camera orientation and showing the rotation effect\".", "response": "class ThreeDCameraIllusionRotation(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        circle=Circle()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(circle,axes)\n        self.begin_3dillusion_camera_rotation(rate=2)\n        self.wait(PI/2)\n        self.stop_3dillusion_camera_rotation()", "original_prompt": "ThreeDCameraIllusionRotation"}
{"prompt": "\"Rotate 3D Gaussian plane around axes and fade with checkerboard fill pattern.\"\n\nOr, a bit more descriptive:\n\nAnimate a rotating 3D Gaussian plane with changing colors using a checkerboard pattern.", "response": "class ThreeDSurfacePlot(ThreeDScene):\n    def construct(self):\n        resolution_fa = 24\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-30 * DEGREES)\n\n        def param_gauss(u, v):\n            x = u\n            y = v\n            sigma, mu = 0.4, [0.0, 0.0]\n            d = np.linalg.norm(np.array([x - mu[0], y - mu[1]]))\n            z = np.exp(-(d ** 2 / (2.0 * sigma ** 2)))\n            return np.array([x, y, z])\n\n        gauss_plane = Surface(\n            param_gauss,\n            resolution=(resolution_fa, resolution_fa),\n            v_range=[-2, +2],\n            u_range=[-2, +2]\n        )\n\n        gauss_plane.scale(2, about_point=ORIGIN)\n        gauss_plane.set_style(fill_opacity=1,stroke_color=GREEN)\n        gauss_plane.set_fill_by_checkerboard(ORANGE, BLUE, opacity=0.5)\n        axes = ThreeDAxes()\n        self.add(axes,gauss_plane)", "original_prompt": "ThreeDSurfacePlot"}
{"prompt": "Animate a rotating LaTeX equation on a grid while transforming into a sine wave.", "response": "class OpeningManim(Scene):\n    def construct(self):\n        title = Tex(r\"This is some \\LaTeX\")\n        basel = MathTex(r\"\\sum_{n=1}^\\infty \\frac{1}{n^2} = \\frac{\\pi^2}{6}\")\n        VGroup(title, basel).arrange(DOWN)\n        self.play(\n            Write(title),\n            FadeIn(basel, shift=DOWN),\n        )\n        self.wait()\n\n        transform_title = Tex(\"That was a transform\")\n        transform_title.to_corner(UP + LEFT)\n        self.play(\n            Transform(title, transform_title),\n            LaggedStart(*[FadeOut(obj, shift=DOWN) for obj in basel]),\n        )\n        self.wait()\n\n        grid = NumberPlane()\n        grid_title = Tex(\"This is a grid\", font_size=72)\n        grid_title.move_to(transform_title)\n\n        self.add(grid, grid_title)  # Make sure title is on top of grid\n        self.play(\n            FadeOut(title),\n            FadeIn(grid_title, shift=UP),\n            Create(grid, run_time=3, lag_ratio=0.1),\n        )\n        self.wait()\n\n        grid_transform_title = Tex(\n            r\"That was a non-linear function \\\\ applied to the grid\"\n        )\n        grid_transform_title.move_to(grid_title, UL)\n        grid.prepare_for_nonlinear_transform()\n        self.play(\n            grid.animate.apply_function(\n                lambda p: p\n                          + np.array(\n                    [\n                        np.sin(p[1]),\n                        np.sin(p[0]),\n                        0,\n                    ]\n                )\n            ),\n            run_time=3,\n        )\n        self.wait()\n        self.play(Transform(grid_title, grid_transform_title))\n        self.wait()", "original_prompt": "OpeningManim"}
{"prompt": "Animate a small yellow dot moving around a unit circle while drawing a blue line and a red line with the dot's position on it.", "response": "class SineCurveUnitCircle(Scene):\n    # contributed by heejin_park, https://infograph.tistory.com/230\n    def construct(self):\n        self.show_axis()\n        self.show_circle()\n        self.move_dot_and_draw_curve()\n        self.wait()\n\n    def show_axis(self):\n        x_start = np.array([-6,0,0])\n        x_end = np.array([6,0,0])\n\n        y_start = np.array([-4,-2,0])\n        y_end = np.array([-4,2,0])\n\n        x_axis = Line(x_start, x_end)\n        y_axis = Line(y_start, y_end)\n\n        self.add(x_axis, y_axis)\n        self.add_x_labels()\n\n        self.origin_point = np.array([-4,0,0])\n        self.curve_start = np.array([-3,0,0])\n\n    def add_x_labels(self):\n        x_labels = [\n            MathTex(r\"\\pi\"), MathTex(r\"2 \\pi\"),\n            MathTex(r\"3 \\pi\"), MathTex(r\"4 \\pi\"),\n        ]\n\n        for i in range(len(x_labels)):\n            x_labels[i].next_to(np.array([-1 + 2*i, 0, 0]), DOWN)\n            self.add(x_labels[i])\n\n    def show_circle(self):\n        circle = Circle(radius=1)\n        circle.move_to(self.origin_point)\n        self.add(circle)\n        self.circle = circle\n\n    def move_dot_and_draw_curve(self):\n        orbit = self.circle\n        origin_point = self.origin_point\n\n        dot = Dot(radius=0.08, color=YELLOW)\n        dot.move_to(orbit.point_from_proportion(0))\n        self.t_offset = 0\n        rate = 0.25\n\n        def go_around_circle(mob, dt):\n            self.t_offset += (dt * rate)\n            # print(self.t_offset)\n            mob.move_to(orbit.point_from_proportion(self.t_offset % 1))\n\n        def get_line_to_circle():\n            return Line(origin_point, dot.get_center(), color=BLUE)\n\n        def get_line_to_curve():\n            x = self.curve_start[0] + self.t_offset * 4\n            y = dot.get_center()[1]\n            return Line(dot.get_center(), np.array([x,y,0]), color=YELLOW_A, stroke_width=2 )\n\n\n        self.curve = VGroup()\n        self.curve.add(Line(self.curve_start,self.curve_start))\n        def get_curve():\n            last_line = self.curve[-1]\n            x = self.curve_start[0] + self.t_offset * 4\n            y = dot.get_center()[1]\n            new_line = Line(last_line.get_end(),np.array([x,y,0]), color=YELLOW_D)\n            self.curve.add(new_line)\n\n            return self.curve\n\n        dot.add_updater(go_around_circle)\n\n        origin_to_circle_line = always_redraw(get_line_to_circle)\n        dot_to_curve_line = always_redraw(get_line_to_curve)\n        sine_curve_line = always_redraw(get_curve)\n\n        self.add(dot)\n        self.add(orbit, origin_to_circle_line, dot_to_curve_line, sine_curve_line)\n        self.wait(8.5)\n\n        dot.remove_updater(go_around_circle)", "original_prompt": "SineCurveUnitCircle"}
{"prompt": "\"Create a neural network with layered nodes animating a forward pass.\"", "response": "from manim import *\nfrom manim_ml.neural_network.layers import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n\nclass NeuralNetworkScene(Scene):\n    \"\"\"Test Scene for the Neural Network\"\"\"\n\n    def construct(self):\n        # Make the Layer object\n        layers = [FeedForwardLayer(3), FeedForwardLayer(5), FeedForwardLayer(3)]\n        nn = NeuralNetwork(layers)\n        nn.scale(2)\n        nn.move_to(ORIGIN)\n        # Make Animation\n        self.add(nn)\n        # self.play(Create(nn))\n        forward_propagation_animation = nn.make_forward_pass_animation(\n            run_time=5, passing_flash=True\n        )\n\n        self.play(forward_propagation_animation)\n", "original_prompt": "Basic Neural Network Basic Neural Network"}
{"prompt": "\"Visualize a 3-layer neural network transforming through feedforward passes with flash effects.\"", "response": "from manim import *\nfrom manim_ml.neural_network.layers import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n\nclass NeuralNetworkScene(Scene):\n    \"\"\"Test Scene for the Neural Network\"\"\"\n\n    def construct(self):\n        # Make the Layer object\n        layers = [FeedForwardLayer(3), FeedForwardLayer(5), FeedForwardLayer(3)]\n        nn = NeuralNetwork(layers)\n        nn.scale(2)\n        nn.move_to(ORIGIN)\n        # Make Animation\n        self.add(nn)\n        # self.play(Create(nn))\n        forward_propagation_animation = nn.make_forward_pass_animation(\n            run_time=5, passing_flash=True\n        )\n\n        self.play(forward_propagation_animation)\n", "original_prompt": "Basic Neural Network Basic Neural Network"}
{"prompt": "\"Animate a neural network's activation layers rotating and connecting while showing input and output points.\"", "response": "from manim import *\n\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.math_operation_layer import MathOperationLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        nn = NeuralNetwork({\n            \"feed_forward_1\": FeedForwardLayer(3),\n            \"feed_forward_2\": FeedForwardLayer(3, activation_function=\"ReLU\"),\n            \"feed_forward_3\": FeedForwardLayer(3),\n            \"sum_operation\": MathOperationLayer(\"+\", activation_function=\"ReLU\"),\n        })\n        nn.add_connection(\"feed_forward_1\", \"sum_operation\")\n        self.play(nn.make_forward_pass_animation()) \n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        # background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.38)\n\n    return code\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Add the network\n        nn = NeuralNetwork({\n                \"feed_forward_1\": FeedForwardLayer(3),\n                \"feed_forward_2\": FeedForwardLayer(3, activation_function=\"ReLU\"),\n                \"feed_forward_3\": FeedForwardLayer(3),\n                \"sum_operation\": MathOperationLayer(\"+\", activation_function=\"ReLU\"),\n            },\n            layer_spacing=0.38\n        )\n        # Make connections\n        input_blank_dot = Dot(\n            nn.input_layers_dict[\"feed_forward_1\"].get_left() - np.array([0.65, 0.0, 0.0])\n        )\n        nn.add_connection(input_blank_dot, \"feed_forward_1\", arc_direction=\"straight\")\n        nn.add_connection(\"feed_forward_1\", \"sum_operation\")\n        output_blank_dot = Dot(\n            nn.input_layers_dict[\"sum_operation\"].get_right() + np.array([0.65, 0.0, 0.0])\n        )\n        nn.add_connection(\"sum_operation\", output_blank_dot, arc_direction=\"straight\")\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make code snippet\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        self.add(code)\n        # Group it all\n        group = Group(nn, code)\n        group.move_to(ORIGIN)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)", "original_prompt": "Basic Neural Network Residual Block"}
{"prompt": "Animate a 3D neural network diagram that scales and moves while displaying an image of the MNIST digit \"8\".", "response": "from pathlib import Path\n\nfrom manim import *\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\nROOT_DIR = Path(__file__).parents[2]\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make the neural network\n        nn = NeuralNetwork([\n            # ... Layers at start\n            Convolutional2DLayer(3, 5, 3, activation_function=\"ReLU\"),\n            # ... Layers at end\n        ])\n        # Play the animation\n        self.play(nn.make_forward_pass_animation()) \n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        font=\"Monospace\",\n        background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.45)\n\n    return code\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(ROOT_DIR / \"assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 7),\n                Convolutional2DLayer(3, 5, 3, activation_function=\"ReLU\"),\n                Convolutional2DLayer(5, 3, 3, activation_function=\"ReLU\"),\n                FeedForwardLayer(3),\n                FeedForwardLayer(1),\n            ],\n            layer_spacing=0.25,\n        )\n        # nn.scale(0.7)\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make code snippet\n        # code = make_code_snippet()\n        # code.next_to(nn, DOWN)\n        # self.add(code)\n        # nn.move_to(ORIGIN)\n        # Move everything up\n        # Group(nn, code).move_to(ORIGIN)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)\n", "original_prompt": "Cnn Activation Functions"}
{"prompt": "Animate a neural network diagram unfolding from 3D to 2D while showing code snippet.", "response": "from pathlib import Path\n\nfrom manim import *\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\nROOT_DIR = Path(__file__).parents[2]\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make nn\n        nn = NeuralNetwork([\n            ImageLayer(numpy_image, height=1.5),\n            Convolutional2DLayer(1, 7, 3),\n            Convolutional2DLayer(3, 5, 3),\n            Convolutional2DLayer(5, 3, 1),\n            FeedForwardLayer(3),\n            FeedForwardLayer(3),\n        ])\n        # Play animation\n        self.play(nn.make_forward_pass_animation()) \n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        # background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.50)\n\n    return code\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(ROOT_DIR / \"assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 7, 3, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n                Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n                FeedForwardLayer(3),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make code snippet\n        # code = make_code_snippet()\n        # code.next_to(nn, DOWN)\n        # self.add(code)\n        # Group it all\n        # group = Group(nn, code)\n        # group.move_to(ORIGIN)\n        nn.move_to(ORIGIN)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)\n", "original_prompt": "Cnn Cnn"}
{"prompt": "Animate a 3D neural network model being created, with layers unfolding like a flipbook.", "response": "from manim import *\nfrom PIL import Image\nimport numpy as np\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.layers.max_pooling_2d import MaxPooling2DLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make the neural network\n        nn = NeuralNetwork([\n            ImageLayer(image),\n            Convolutional2DLayer(1, 8),\n            MaxPooling2DLayer(kernel_size=2),\n            Convolutional2DLayer(3, 2, 3),\n        ])\n        # Play the animation\n        self.play(nn.make_forward_pass_animation()) \n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        font=\"Monospace\",\n        background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.4)\n\n    return code\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 8, filter_spacing=0.32),\n                MaxPooling2DLayer(kernel_size=2),\n                Convolutional2DLayer(3, 2, 3, filter_spacing=0.32),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make code snippet\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        Group(code, nn).move_to(ORIGIN)\n        self.add(code)\n        self.wait(5)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)\n", "original_prompt": "Cnn Cnn Max Pool"}
{"prompt": "\"Animate a neural network visualizer that generates an image through convolutional layers.\"", "response": "from pathlib import Path\n\nfrom manim import *\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\nROOT_DIR = Path(__file__).parents[2]\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make nn\n        nn = NeuralNetwork([\n            ImageLayer(numpy_image, height=1.5),\n            Convolutional2DLayer(1, 5, 5, 1, 1),\n            Convolutional2DLayer(4, 5, 5, 1, 1),\n            Convolutional2DLayer(2, 5, 5),\n        ])\n        # Play animation\n        self.play(nn.make_forward_pass_animation()) \n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        # background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.50)\n\n    return code\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(ROOT_DIR / \"assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 5, 1, filter_spacing=0.32),\n                Convolutional2DLayer(4, 5, 1, filter_spacing=0.32),\n                Convolutional2DLayer(2, 5, 5, filter_spacing=0.32),\n            ],\n            layer_spacing=0.4,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make code snippet\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        self.add(code)\n        # Group it all\n        group = Group(nn, code)\n        group.move_to(ORIGIN)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)\n", "original_prompt": "Cnn One By One Convolution"}
{"prompt": "\"Animate a 3D neural network diagram unfolding from a code snippet, with layers displaying image and mathematical transformations.\"", "response": "from manim import *\nfrom manim_ml.neural_network.layers.image import ImageLayer\nimport numpy as np\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nROOT_DIR = Path(__file__).parents[2]\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make nn\n        nn = NeuralNetwork([\n            ImageLayer(numpy_image),\n            Convolutional2DLayer(1, 6, 1, padding=1),\n            Convolutional2DLayer(3, 6, 3),\n            FeedForwardLayer(3),\n            FeedForwardLayer(1),\n        ])\n        # Play animation\n        self.play(nn.make_forward_pass_animation()) \n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        # background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.38)\n\n    return code\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        image = Image.open(ROOT_DIR / \"assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(\n                    num_feature_maps=1,\n                    feature_map_size=6,\n                    padding=1,\n                    padding_dashed=True,\n                ),\n                Convolutional2DLayer(\n                    num_feature_maps=3,\n                    feature_map_size=6,\n                    filter_size=3,\n                    padding=0,\n                    padding_dashed=False,\n                ),\n                FeedForwardLayer(3),\n                FeedForwardLayer(1),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        self.add(nn)\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        self.add(code)\n        Group(code, nn).move_to(ORIGIN)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass, run_time=20)\n", "original_prompt": "Cnn Padding Example"}
{"prompt": "\"Animate a 3D neural network model with residual connections transforming into a functional graph while displaying the MNIST digit image.\"", "response": "from manim import *\nfrom PIL import Image\nimport numpy as np\nfrom manim_ml.neural_network import Convolutional2DLayer, NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make the neural network\n        nn = NeuralNetwork({\n            \"layer1\": Convolutional2DLayer(1, 5, padding=1),\n            \"layer2\": Convolutional2DLayer(1, 5, 3, padding=1),\n            \"layer3\": Convolutional2DLayer(1, 5, 3, padding=1)\n        })\n        # Add the residual connection\n        nn.add_connection(\"layer1\", \"layer3\")\n        # Make the animation\n        self.play(nn.make_forward_pass_animation())\n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        # background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.38)\n\n    return code\n\n\nclass ConvScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n\n        nn = NeuralNetwork(\n            {\n                \"layer1\": Convolutional2DLayer(1, 5, padding=1),\n                \"layer2\": Convolutional2DLayer(1, 5, 3, padding=1),\n                \"layer3\": Convolutional2DLayer(1, 5, 3, padding=1),\n            },\n            layer_spacing=0.25,\n        )\n\n        nn.add_connection(\"layer1\", \"layer3\")\n\n        self.add(nn)\n\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        self.add(code)\n        Group(code, nn).move_to(ORIGIN)\n\n        self.play(nn.make_forward_pass_animation(), run_time=8)\n", "original_prompt": "Cnn Resnet Block"}
{"prompt": "\"Animate a 2D neural network with layers of image and numerical data, transforming into forward pass animation.\"", "response": "from manim import *\nfrom manim_ml.neural_network.layers import FeedForwardLayer, ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nfrom PIL import Image\nimport numpy as np\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass ImageNeuralNetworkScene(Scene):\n    def make_code_snippet(self):\n        code_str = \"\"\"\n            # Make image object\n            image = Image.open('images/image.jpeg')\n            numpy_image = np.asarray(image)\n            # Make Neural Network\n            layers = [\n                ImageLayer(numpy_image, height=1.4),\n                FeedForwardLayer(3), \n                FeedForwardLayer(5),\n                FeedForwardLayer(3)\n            ]\n            nn = NeuralNetwork(layers)\n            self.add(nn)\n            # Play animation\n            self.play(\n                nn.make_forward_pass_animation()\n            )\n        \"\"\"\n\n        code = Code(\n            code=code_str,\n            tab_width=4,\n            background_stroke_width=1,\n            background_stroke_color=WHITE,\n            insert_line_no=False,\n            style=\"monokai\",\n            # background=\"window\",\n            language=\"py\",\n        )\n        code.scale(0.2)\n\n        return code\n\n    def construct(self):\n        image = Image.open(\"../../tests/images/image.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        layers = [\n            ImageLayer(numpy_image, height=1.4),\n            FeedForwardLayer(3),\n            FeedForwardLayer(5),\n            FeedForwardLayer(3),\n            FeedForwardLayer(6),\n        ]\n        nn = NeuralNetwork(layers)\n        nn.scale(0.9)\n        # Center the nn\n        nn.move_to(ORIGIN)\n        nn.rotate(-PI / 2)\n        nn.layers[0].image_mobject.rotate(PI / 2)\n        nn.layers[0].image_mobject.shift([0, -0.4, 0])\n        nn.shift([1.5, 0.3, 0])\n        self.add(nn)\n        # Make code snippet\n        code_snippet = self.make_code_snippet()\n        code_snippet.scale(1.9)\n        code_snippet.shift([-1.25, 0, 0])\n        self.add(code_snippet)\n        # Play animation\n        self.play(nn.make_forward_pass_animation(run_time=10))\n\n\nif __name__ == \"__main__\":\n    \"\"\"Render all scenes\"\"\"\n    # Feed Forward Neural Network\n    ffnn_scene = FeedForwardNeuralNetworkScene()\n    ffnn_scene.render()\n    # Neural Network\n    nn_scene = NeuralNetworkScene()\n    nn_scene.render()\n", "original_prompt": "Code Snippet Image Nn Code Snippet"}
{"prompt": "Animate a neural network diagram with layers transforming into a 3D model, rotating and shifting along axes.", "response": "from manim import *\nfrom manim_ml.neural_network.layers import FeedForwardLayer, ImageLayer, EmbeddingLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nfrom PIL import Image\nimport numpy as np\n\nconfig.pixel_height = 720\nconfig.pixel_width = 720\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass VAECodeSnippetScene(Scene):\n    def make_code_snippet(self):\n        code_str = \"\"\"\n            # Make Neural Network\n            nn = NeuralNetwork([\n                ImageLayer(numpy_image, height=1.2),\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                EmbeddingLayer(),\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n                ImageLayer(numpy_image, height=1.2),\n            ], layer_spacing=0.1)\n            # Play animation\n            self.play(nn.make_forward_pass_animation())\n        \"\"\"\n\n        code = Code(\n            code=code_str,\n            tab_width=4,\n            background_stroke_width=1,\n            # background_stroke_color=WHITE,\n            insert_line_no=False,\n            background=\"window\",\n            # font=\"Monospace\",\n            style=\"one-dark\",\n            language=\"py\",\n        )\n\n        return code\n\n    def construct(self):\n        image = Image.open(\"../../tests/images/image.jpeg\")\n        numpy_image = np.asarray(image)\n        embedding_layer = EmbeddingLayer(dist_theme=\"ellipse\", point_radius=0.04).scale(\n            1.0\n        )\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.2),\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                embedding_layer,\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n                ImageLayer(numpy_image, height=1.2),\n            ],\n            layer_spacing=0.1,\n        )\n\n        nn.scale(1.1)\n        # Center the nn\n        nn.move_to(ORIGIN)\n        # nn.rotate(-PI/2)\n        # nn.all_layers[0].image_mobject.rotate(PI/2)\n        # nn.all_layers[0].image_mobject.shift([0, -0.4, 0])\n        # nn.all_layers[-1].image_mobject.rotate(PI/2)\n        # nn.all_layers[-1].image_mobject.shift([0, -0.4, 0])\n        nn.shift([0, -1.4, 0])\n        self.add(nn)\n        # Make code snippet\n        code_snippet = self.make_code_snippet()\n        code_snippet.scale(0.52)\n        code_snippet.shift([0, 1.25, 0])\n        # code_snippet.shift([-1.25, 0, 0])\n        self.add(code_snippet)\n        # Play animation\n        self.play(nn.make_forward_pass_animation(), run_time=10)\n\n\nif __name__ == \"__main__\":\n    \"\"\"Render all scenes\"\"\"\n    # Neural Network\n    nn_scene = VAECodeSnippetScene()\n    nn_scene.render()\n", "original_prompt": "Code Snippet Vae Code Landscape"}
{"prompt": "Animate a neural network diagram rotating with code snippet overlay, scaling with image objects.", "response": "from manim import *\nfrom manim_ml.neural_network.layers import FeedForwardLayer, ImageLayer, EmbeddingLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nfrom PIL import Image\nimport numpy as np\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass VAECodeSnippetScene(Scene):\n    def make_code_snippet(self):\n        code_str = \"\"\"\n            # Make image object\n            image = Image.open('images/image.jpeg')\n            numpy_image = np.asarray(image)\n            # Make Neural Network\n            nn = NeuralNetwork([\n                ImageLayer(numpy_image, height=1.2),\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                EmbeddingLayer(),\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n                ImageLayer(numpy_image, height=1.2),\n            ], layer_spacing=0.1)\n            self.add(nn)\n            # Play animation\n            self.play(\n                nn.make_forward_pass_animation()\n            )\n        \"\"\"\n\n        code = Code(\n            code=code_str,\n            tab_width=4,\n            background_stroke_width=1,\n            # background_stroke_color=WHITE,\n            insert_line_no=False,\n            background=\"window\",\n            # font=\"Monospace\",\n            style=\"one-dark\",\n            language=\"py\",\n        )\n        code.scale(0.2)\n\n        return code\n\n    def construct(self):\n        image = Image.open(\"../../tests/images/image.jpeg\")\n        numpy_image = np.asarray(image)\n        embedding_layer = EmbeddingLayer(dist_theme=\"ellipse\", point_radius=0.04).scale(\n            1.0\n        )\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.0),\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                embedding_layer,\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n                ImageLayer(numpy_image, height=1.0),\n            ],\n            layer_spacing=0.1,\n        )\n\n        nn.scale(0.65)\n        # Center the nn\n        nn.move_to(ORIGIN)\n        nn.rotate(-PI / 2)\n        nn.all_layers[0].image_mobject.rotate(PI / 2)\n        # nn.all_layers[0].image_mobject.shift([0, -0.4, 0])\n        nn.all_layers[-1].image_mobject.rotate(PI / 2)\n        # nn.all_layers[-1].image_mobject.shift([0, -0.4, 0])\n        nn.shift([1.5, 0.0, 0])\n        self.add(nn)\n        # Make code snippet\n        code_snippet = self.make_code_snippet()\n        code_snippet.scale(1.9)\n        code_snippet.shift([-1.25, 0, 0])\n        self.add(code_snippet)\n        # Play animation\n        self.play(nn.make_forward_pass_animation(), run_time=10)\n\n\nif __name__ == \"__main__\":\n    \"\"\"Render all scenes\"\"\"\n    # Neural Network\n    nn_scene = VAECodeSnippetScene()\n    nn_scene.render()\n", "original_prompt": "Code Snippet Vae Nn Code Snippet"}
{"prompt": "Here is a Python script that uses the Pygame library to create an interactive visualization of the given prompt:\n\n```python\nimport pygame\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Set up some constants\nWIDTH, HEIGHT = 800, 600\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\n\n# Create the game window\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\n\n# Define a font for text rendering\nfont = pygame.font.Font(None, 36)\n\nclass Token:\n    def __init__(self, x, y, text):\n        self.x = x\n        self.y = y\n        self.text = text\n\n    def draw(self):\n        text_surface = font.render(self.text, True, WHITE)\n        screen.blit(text_surface, (self.x, self.y))\n\ndef main():\n    # Set up the prompt and tokenizer\n    prompt = '\"Astronaut riding a horse on the moon\"'\n    tokenizer = Tokenizer()\n\n    # Split the prompt into tokens\n    tokens = tokenizer.tokenize(prompt)\n\n    # Initialize variables for tracking the animation state\n    current_token_index = 0\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_SPACE and current_token_index < len(tokens):\n                    # Move to the next token\n                    current_token_index += 1\n\n        # Draw the background\n        screen.fill(BLACK)\n\n        # Draw the text prompt\n        text_prompt = font.render(prompt, True, WHITE)\n        screen.blit(text_prompt, (WIDTH / 2 - text_prompt.get_width() / 2, HEIGHT / 4))\n\n        # Draw the generated image\n        generated_image = Image()\n        generated_image.draw(screen)\n\n        # Draw the tokenization arrow\n        if current_token_index > 0:\n            previous_token = tokens[current_token_index - 1]\n            next_token = tokens[current_token_index]\n            arrow = Arrow(previous_token.x + font.size(previous_token.text)[0] / 2,\n                          previous_token.y + font.size(previous_token.text)[1] / 2,\n                          next_token.x + font.size(next_token.text)[0] / 2,\n                          next_token.y + font.size(next_token.text)[1] / 2)\n            arrow.draw(screen)\n\n        # Draw the heatmap for the current token\n        if current_token_index < len(tokens):\n            heatmap = Heatmap()\n            heatmap.draw(screen, tokens[current_token_index].text, tokens[current_token_index].x,\n                          tokens[current_token_index].y, tokens[current_token_index].text)\n\n        # Update the screen\n        pygame.display.flip()\n\nclass Tokenizer:\n    def tokenize(self, text):\n        return [Token(i, 0, word) for i, word in enumerate(text.split())]\n\nclass Image:\n    def __init__(self):\n        self.x = WIDTH / 2 - 100\n        self.y = HEIGHT / 4\n\n    def draw(self, screen):\n        pygame.draw.rect(screen, WHITE, (self.x, self.y, 200, 100))\n\nclass Arrow:\n    def __init__(self, x1, y1, x2, y2):\n        self.x1 = x1\n        self.y1 = y1\n        self.x2 = x2\n        self.y2 = y2\n\n    def draw(self, screen):\n        pygame.draw.line(screen, WHITE, (self.x1, self.y1), (self.x2, self.y2))\n\nclass Heatmap:\n    def __init__(self):\n        self.width = 0\n        self.height = 0\n        self.x = 0\n        self.y = 0\n\n    def draw(self, screen, text, x, y, width):\n        self.width = width\n        self.height = 100\n        self.x = x\n        self.y = y\n        pygame.draw.rect(screen, WHITE, (self.x, self.y, self.width, self.height))\n        font_surface = font.render(text, True, BLACK)\n        screen.blit(font_surface, (x + text_size[0] / 2, y))\n\ndef get_text_size(text):\n    return font.size(text)\n\ntext_size = font.size(\"\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis script uses the `Tokenizer` class to split the prompt into tokens and then iterates over the tokens in a loop. For each token, it draws an arrow from the previous token to the current token, as well as a heatmap corresponding to the text of the current token.\n\nPlease note that this is just one possible way to visualize the prompt using Pygame, and you can modify the script to better suit your needs.", "response": "\"\"\"\n    Here I thought it would be interesting to visualize the cross attention\n    maps produced by the UNet of a text-to-image diffusion model. \n\n    The key thing I want to show is how images and text are broken up into tokens (patches for images),\n    and those tokens are used to compute a cross attention score, which can be interpreted\n    as a 2D heatmap over the image patches for each text token. \n    \n\n    Necessary operations:\n        1. [X] Split an image into patches and \"expand\" the patches outward to highlight that they are \n            separate. \n        2. Split text into tokens using the tokenizer and display them. \n        3. Compute the cross attention scores (using DAAM) for each word/token and display them as a heatmap.\n        4. Overlay the heatmap over the image patches. Show the overlaying as a transition animation. \n\"\"\"\nimport torch\nimport cv2\nfrom manim import *\nimport numpy as np\nfrom typing import List\nfrom daam import trace, set_seed\nfrom diffusers import StableDiffusionPipeline\nimport torchvision\nimport matplotlib.pyplot as plt\n\nclass ImagePatches(Group):\n    \"\"\"Container object for a grid of ImageMobjects.\"\"\"\n\n    def __init__(self, image: ImageMobject, grid_width=4):\n        \"\"\"\n        Parameters\n        ----------\n        image : ImageMobject\n            image to split into patches\n        grid_width : int, optional\n            number of patches per row, by default 4\n        \"\"\"\n        self.image = image\n        self.grid_width = grid_width\n        super(Group, self).__init__()\n        self.patch_dict = self._split_image_into_patches(image, grid_width)\n\n    def _split_image_into_patches(self, image, grid_width):\n        \"\"\"Splits the images into a set of patches\n\n        Parameters\n        ----------\n        image : ImageMobject\n            image to split into patches\n        grid_width : int\n            number of patches per row\n        \"\"\"\n        patch_dict = {}\n        # Get a pixel array of the image mobject\n        pixel_array = image.pixel_array\n        # Get the height and width of the image\n        height, width = pixel_array.shape[:2]\n        # Split the image into an equal width grid of patches\n        assert height == width, \"Image must be square\"\n        assert height % grid_width == 0, \"Image width must be divisible by grid_width\"\n        patch_width, patch_height = width // grid_width, height // grid_width\n\n        for patch_i in range(self.grid_width):\n            for patch_j in range(self.grid_width):\n                # Get patch pixels\n                i_start, i_end = patch_i * patch_width, (patch_i + 1) * patch_width\n                j_start, j_end = patch_j * patch_height, (patch_j + 1) * patch_height\n                patch_pixels = pixel_array[i_start:i_end, j_start:j_end, :]\n                # Make the patch\n                image_patch = ImageMobject(patch_pixels)\n                # Move the patch to the correct location on the old image\n                image_width = image.get_width()\n                image_center = image.get_center()\n                image_patch.scale(image_width / grid_width / image_patch.get_width())\n                patch_manim_space_width = image_patch.get_width()\n\n                patch_center = image_center\n                patch_center += (patch_j - self.grid_width / 2 + 0.5) * patch_manim_space_width * RIGHT\n                # patch_center = image_center - (patch_i - self.grid_width / 2 + 0.5) * patch_manim_space_width * RIGHT\n                patch_center -= (patch_i - self.grid_width / 2 + 0.5) * patch_manim_space_width * UP\n                # + (patch_j - self.grid_width / 2) * patch_height / 2 * UP\n\n                image_patch.move_to(patch_center)\n\n                self.add(image_patch)\n                patch_dict[(patch_i, patch_j)] = image_patch\n\n        return patch_dict\n\nclass ExpandPatches(Animation):\n\n    def __init__(self, image_patches: ImagePatches, expansion_scale=2.0):\n        \"\"\"\n        Parameters\n        ----------\n        image_patches : ImagePatches\n            set of image patches\n        expansion_scale : float, optional\n            scale factor for expansion, by default 2.0\n        \"\"\"\n        self.image_patches = image_patches\n        self.expansion_scale = expansion_scale\n        super().__init__(image_patches)\n\n    def interpolate_submobject(self, submobject, starting_submobject, alpha):\n        \"\"\"\n        Parameters\n        ----------\n        submobject : ImageMobject\n            current patch\n        starting_submobject : ImageMobject\n            starting patch\n        alpha : float\n            interpolation alpha\n        \"\"\"\n        patch = submobject\n        starting_patch_center = starting_submobject.get_center()\n        image_center = self.image_patches.image.get_center()\n        # Start image vector\n        starting_patch_vector = starting_patch_center - image_center\n        final_image_vector = image_center + starting_patch_vector * self.expansion_scale\n        # Interpolate vectors\n        current_location = alpha * final_image_vector + (1 - alpha) * starting_patch_center\n        # # Need to compute the direction of expansion as the unit vector from the original image center\n        # # and patch center. \n        patch.move_to(current_location)\n\nclass TokenizedText(Group):\n    \"\"\"Tokenizes the given text and displays the tokens as a list of Text Mobjects.\"\"\"\n\n    def __init__(self, text, tokenizer=None):\n        self.text = text\n        if not tokenizer is None:\n            self.tokenizer = tokenizer\n        else:\n            # TODO load default stable diffusion tokenizer here\n            raise NotImplementedError(\"Tokenizer must be provided\")\n\n        self.token_strings = self._tokenize_text(text)\n        self.token_mobjects = self.make_text_mobjects(self.token_strings)\n\n        super(Group, self).__init__()\n        self.add(*self.token_mobjects)\n        self.arrange(RIGHT, buff=-0.05, aligned_edge=UP)\n\n        token_dict = {} \n        for token_index, token_string in enumerate(self.token_strings):\n            token_dict[token_string] = self.token_mobjects[token_index]\n\n        self.token_dict = token_dict\n\n    def _tokenize_text(self, text):\n        \"\"\"Tokenize the text using the tokenizer.\n\n        Parameters\n        ----------\n        text : str\n            text to tokenize\n        \"\"\"\n        tokens = self.tokenizer.tokenize(text)\n        tokens = [token.replace(\"</w>\", \"\") for token in tokens]\n        return tokens\n\n    def make_text_mobjects(self, tokens_list: List[str]):\n        \"\"\"Converts the tokens into a list of TextMobjects.\"\"\"\n        # Make the tokens\n        # Insert phantom\n        tokens_list = [\"l\" + token + \"g\" for token in tokens_list]\n        token_objects = [\n            Text(token, t2c={'[-1:]': '#000000', '[0:1]': \"#000000\"}, font_size=64) \n            for token in tokens_list\n        ]\n\n        return token_objects\n\ndef compute_stable_diffusion_cross_attention_heatmaps(\n    pipe,\n    prompt: str,\n    seed: int = 2,\n    map_resolution=(32, 32)\n):\n    \"\"\"Computes the cross attention heatmaps for the given prompt.\n\n    Parameters\n    ----------\n    prompt : str\n        the prompt\n    seed : int, optional\n        random seed, by default 0\n    map_resolution : tuple, optional\n        resolution to downscale maps to, by default (16, 16)\n\n    Returns\n    -------\n    _type_\n        _description_\n    \"\"\"\n    # Get tokens\n    tokens = pipe.tokenizer.tokenize(prompt)\n    tokens = [token.replace(\"</w>\", \"\") for token in tokens]\n    # Set torch seeds\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    gen = set_seed(seed)  # for reproducibility\n\n    heatmap_dict = {}\n    image = None\n\n    with torch.cuda.amp.autocast(dtype=torch.float16), torch.no_grad():\n        with trace(pipe) as tc:\n            out = pipe(prompt, num_inference_steps=30, generator=gen)\n            image = out[0][0]\n            global_heat_map = tc.compute_global_heat_map()\n            for token in tokens: \n                word_heat_map = global_heat_map.compute_word_heat_map(token)\n                heatmap = word_heat_map.heatmap\n\n                # Downscale the heatmap\n                heatmap = heatmap.unsqueeze(0).unsqueeze(0)\n                # Save the heatmap\n                heatmap = torchvision.transforms.Resize(\n                    map_resolution, \n                    interpolation=torchvision.transforms.InterpolationMode.NEAREST\n                )(heatmap)\n                heatmap = heatmap.squeeze(0).squeeze(0)\n                # heatmap = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)\n                # plt.imshow(heatmap)\n                # plt.savefig(f\"{token}.png\")\n                # Convert heatmap to rgb color\n                # normalize\n                heatmap = (heatmap - heatmap.min()) / (heatmap.max() - heatmap.min())\n                cmap = plt.get_cmap('inferno')\n                heatmap = cmap(heatmap) * 255\n                print(heatmap)\n\n                # print(heatmap)\n                # Make an image mobject for each heatmap\n                print(heatmap.shape)\n                heatmap = ImageMobject(heatmap)\n                heatmap.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"nearest\"])\n                heatmap_dict[token] = heatmap\n\n    return image, heatmap_dict\n\n# Make the scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 30.0\nconfig.frame_width = 30.0\n\nclass StableDiffusionCrossAttentionScene(Scene):\n\n    def construct(self):\n        # Load the pipeline\n        model_id = 'stabilityai/stable-diffusion-2-base'\n        pipe = StableDiffusionPipeline.from_pretrained(model_id)\n        prompt = \"Astronaut riding a horse on the moon\"\n        # Compute the images and heatmaps\n        image, heatmap_dict = compute_stable_diffusion_cross_attention_heatmaps(pipe, prompt)\n        # 1. Show an image appearing\n        image_mobject = ImageMobject(image)\n        image_mobject.shift(DOWN)\n        image_mobject.scale(0.7)\n        image_mobject.shift(LEFT * 7)\n        self.add(image_mobject)\n        # 1. Show a text prompt and the corresponding generated image\n        paragraph_prompt = '\"Astronaut riding a\\nhorse on the moon\"'\n        text_prompt = Paragraph(paragraph_prompt, alignment=\"center\", font_size=64)\n        text_prompt.next_to(image_mobject, UP, buff=1.5)\n        prompt_title = Text(\"Prompt\", font_size=72)\n        prompt_title.next_to(text_prompt, UP, buff=0.5)\n        self.play(Create(prompt_title))\n        self.play(Create(text_prompt))        \n        # Make an arrow from the text to the image\n        arrow = Arrow(text_prompt.get_bottom(), image_mobject.get_top(), buff=0.5)\n        self.play(GrowArrow(arrow))\n        self.wait(1)\n        self.remove(arrow)\n        # 2. Show the image being split into patches\n        # Make the patches\n        patches = ImagePatches(image_mobject, grid_width=32)\n        # Expand and contract \n        self.remove(image_mobject)\n        self.play(ExpandPatches(patches, expansion_scale=1.2))\n        # Play arrows for visual tokens\n        visual_token_label = Text(\"Visual Tokens\", font_size=72)\n        visual_token_label.next_to(image_mobject, DOWN, buff=1.5)\n        # Draw arrows \n        arrow_animations = []\n        arrows = []\n        for i in range(patches.grid_width):\n            patch = patches.patch_dict[(patches.grid_width - 1, i)]\n            arrow = Line(visual_token_label.get_top(), patch.get_bottom(), buff=0.3)\n            arrow_animations.append(\n                Create(\n                    arrow\n                )\n            )\n            arrows.append(arrow)\n        self.play(AnimationGroup(*arrow_animations, FadeIn(visual_token_label), lag_ratio=0))\n        self.wait(1)\n        self.play(FadeOut(*arrows, visual_token_label))\n        self.play(ExpandPatches(patches, expansion_scale=1/1.2))\n        # 3. Show the text prompt and image being tokenized.\n        tokenized_text = TokenizedText(prompt, pipe.tokenizer)\n        tokenized_text.shift(RIGHT * 7)\n        tokenized_text.shift(DOWN * 7.5)\n        self.play(FadeIn(tokenized_text))\n        # Plot token label\n        token_label = Text(\"Textual Tokens\", font_size=72)\n        token_label.next_to(tokenized_text, DOWN, buff=0.5)\n        arrow_animations = []\n        self.play(Create(token_label)) \n        arrows = []\n        for token_name, token_mobject in tokenized_text.token_dict.items():\n            arrow = Line(token_label.get_top(), token_mobject.get_bottom(), buff=0.3)\n            arrow_animations.append(\n                Create(\n                    arrow\n                )\n            )\n            arrows.append(arrow)\n        self.play(AnimationGroup(*arrow_animations, lag_ratio=0))\n        self.wait(1)\n        self.play(FadeOut(*arrows, token_label))\n        # 4. Show the heatmap corresponding to the cross attention map for each image. \n        surrounding_rectangle = SurroundingRectangle(tokenized_text.token_dict[\"astronaut\"], buff=0.1)\n        self.add(surrounding_rectangle)\n        # Show the heatmap for \"astronaut\"\n        astronaut_heatmap = heatmap_dict[\"astronaut\"]\n        astronaut_heatmap.height = image_mobject.get_height()\n        astronaut_heatmap.shift(RIGHT * 7)\n        astronaut_heatmap.shift(DOWN)\n        self.play(FadeIn(astronaut_heatmap))\n        self.wait(3)\n        self.remove(surrounding_rectangle)\n        surrounding_rectangle = SurroundingRectangle(tokenized_text.token_dict[\"horse\"], buff=0.1)\n        self.add(surrounding_rectangle)\n        # Show the heatmap for \"horse\"\n        horse_heatmap = heatmap_dict[\"horse\"]\n        horse_heatmap.height = image_mobject.get_height()\n        horse_heatmap.move_to(astronaut_heatmap)\n        self.play(FadeOut(astronaut_heatmap))\n        self.play(FadeIn(horse_heatmap))\n        self.wait(3)\n        self.remove(surrounding_rectangle)\n        surrounding_rectangle = SurroundingRectangle(tokenized_text.token_dict[\"riding\"], buff=0.1)\n        self.add(surrounding_rectangle)\n        # Show the heatmap for \"riding\"\n        riding_heatmap = heatmap_dict[\"riding\"]\n        riding_heatmap.height = image_mobject.get_height()\n        riding_heatmap.move_to(horse_heatmap)\n        self.play(FadeOut(horse_heatmap))\n        self.play(FadeIn(riding_heatmap))\n        self.wait(3)\n", "original_prompt": "Cross Attention Vis Cross Attention Vis"}
{"prompt": "\"Graphically illustrate a decision tree's bounding boxes with overlapping rectangles of different colors.\"", "response": "import numpy as np\nfrom collections import deque\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.tree import _tree as ctree\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\n\n\nclass AABB:\n    \"\"\"Axis-aligned bounding box\"\"\"\n\n    def __init__(self, n_features):\n        self.limits = np.array([[-np.inf, np.inf]] * n_features)\n\n    def split(self, f, v):\n        left = AABB(self.limits.shape[0])\n        right = AABB(self.limits.shape[0])\n        left.limits = self.limits.copy()\n        right.limits = self.limits.copy()\n        left.limits[f, 1] = v\n        right.limits[f, 0] = v\n\n        return left, right\n\n\ndef tree_bounds(tree, n_features=None):\n    \"\"\"Compute final decision rule for each node in tree\"\"\"\n    if n_features is None:\n        n_features = np.max(tree.feature) + 1\n    aabbs = [AABB(n_features) for _ in range(tree.node_count)]\n    queue = deque([0])\n    while queue:\n        i = queue.pop()\n        l = tree.children_left[i]\n        r = tree.children_right[i]\n        if l != ctree.TREE_LEAF:\n            aabbs[l], aabbs[r] = aabbs[i].split(tree.feature[i], tree.threshold[i])\n            queue.extend([l, r])\n    return aabbs\n\n\ndef decision_areas(tree_classifier, maxrange, x=0, y=1, n_features=None):\n    \"\"\"Extract decision areas.\n\n    tree_classifier: Instance of a sklearn.tree.DecisionTreeClassifier\n    maxrange: values to insert for [left, right, top, bottom] if the interval is open (+/-inf)\n    x: index of the feature that goes on the x axis\n    y: index of the feature that goes on the y axis\n    n_features: override autodetection of number of features\n    \"\"\"\n    tree = tree_classifier.tree_\n    aabbs = tree_bounds(tree, n_features)\n    maxrange = np.array(maxrange)\n    rectangles = []\n    for i in range(len(aabbs)):\n        if tree.children_left[i] != ctree.TREE_LEAF:\n            continue\n        l = aabbs[i].limits\n        r = [l[x, 0], l[x, 1], l[y, 0], l[y, 1], np.argmax(tree.value[i])]\n        # clip out of bounds indices\n        \"\"\"\n        if r[0] < maxrange[0]:\n            r[0] = maxrange[0]\n        if r[1] > maxrange[1]:\n            r[1] = maxrange[1]\n        if r[2] < maxrange[2]:\n            r[2] = maxrange[2]\n        if r[3] > maxrange[3]:\n            r[3] = maxrange[3]\n        print(r)\n        \"\"\"\n        rectangles.append(r)\n    rectangles = np.array(rectangles)\n    rectangles[:, [0, 2]] = np.maximum(rectangles[:, [0, 2]], maxrange[0::2])\n    rectangles[:, [1, 3]] = np.minimum(rectangles[:, [1, 3]], maxrange[1::2])\n    return rectangles\n\n\ndef plot_areas(rectangles):\n    for rect in rectangles:\n        color = [\"b\", \"r\"][int(rect[4])]\n        print(rect[0], rect[1], rect[2] - rect[0], rect[3] - rect[1])\n        rp = Rectangle(\n            [rect[0], rect[2]],\n            rect[1] - rect[0],\n            rect[3] - rect[2],\n            color=color,\n            alpha=0.3,\n        )\n        plt.gca().add_artist(rp)\n", "original_prompt": "Decision Tree Decision Tree Surface"}
{"prompt": "It appears that you have a long piece of code written in Python, specifically using the Pygame library for animation and mathematical operations on iris dataset.\n\nThe provided code seems to be constructing an animation of a decision tree classifier. Here's a high-level overview of what it does:\n\n1. Creates a `IrisDatasetPlot` object to plot the iris dataset.\n2. Constructs a decision tree classifier using the `make_decision_tree_classifier` method.\n3. Creates a `DecisionTreeSurface` object to visualize the decision tree.\n4. Animates the creation and destruction of the decision tree surface, as well as other elements like lines and peaks.\n\nHere's some sample Python code that might be used to create this animation:\n\n```python\nimport pygame\nfrom math import sin, cos, pi\n\nclass IrisDatasetPlot:\n    def __init__(self):\n        self.data = []\n        # Initialize iris dataset data here...\n\n    def plot(self):\n        # Plot the iris dataset using Pygame...\n        pass\n\nclass DecisionTreeSurface:\n    def __init__(self, classifier, data, axes_group):\n        self.classifier = classifier\n        self.data = data\n        self.axes_group = axes_group\n\n    def draw_tree(self):\n        # Draw the decision tree using Pygame...\n        pass\n\nclass Animation:\n    def __init__(self):\n        self.pygame_init()\n\n    def pygame_init(self):\n        pygame.init()\n        # Set up Pygame display and clock...\n\n    def construct(self, plot, classifier, data):\n        # Create the animation\n        iris_dataset_plot = IrisDatasetPlot()\n        iris_dataset_plot.data = data\n\n        decision_tree_classifier = classifier\n        decision_tree_surface = DecisionTreeSurface(decision_tree_classifier, data, plot.axes_group)\n\n        self.play(Create(iris_dataset_plot))\n        self.play(Create(decision_tree_surface))\n\n        # Add animations for other elements...\n```\n\nThis code snippet provides a basic structure for creating an animation of a decision tree classifier using Pygame. However, it lacks the actual implementation details, which would depend on the specific requirements and functionality of your project.\n\nTo further assist you with your question, I need more information about what specific parts of this code are causing issues or require clarification.", "response": "from sklearn import datasets\nfrom decision_tree_surface import *\nfrom manim import *\nfrom sklearn.tree import DecisionTreeClassifier\nfrom scipy.stats import entropy\nimport math\nfrom PIL import Image\n\niris = datasets.load_iris()\nfont = \"Source Han Sans\"\nfont_scale = 0.75\n\nimages = [\n    Image.open(\"iris_dataset/SetosaFlower.jpeg\"),\n    Image.open(\"iris_dataset/VeriscolorFlower.jpeg\"),\n    Image.open(\"iris_dataset/VirginicaFlower.jpeg\"),\n]\n\n\ndef entropy(class_labels, base=2):\n    # compute the class counts\n    unique, counts = np.unique(class_labels, return_counts=True)\n    dictionary = dict(zip(unique, counts))\n    total = 0.0\n    num_samples = len(class_labels)\n    for class_index in range(0, 3):\n        if not class_index in dictionary:\n            continue\n        prob = dictionary[class_index] / num_samples\n        total += prob * math.log(prob, base)\n    # higher set\n    return -total\n\n\ndef merge_overlapping_polygons(all_polygons, colors=[BLUE, GREEN, ORANGE]):\n    # get all polygons of each color\n    polygon_dict = {\n        str(BLUE).lower(): [],\n        str(GREEN).lower(): [],\n        str(ORANGE).lower(): [],\n    }\n    for polygon in all_polygons:\n        print(polygon_dict)\n        polygon_dict[str(polygon.color).lower()].append(polygon)\n\n    return_polygons = []\n    for color in colors:\n        color = str(color).lower()\n        polygons = polygon_dict[color]\n        points = set()\n        for polygon in polygons:\n            vertices = polygon.get_vertices().tolist()\n            vertices = [tuple(vert) for vert in vertices]\n            for pt in vertices:\n                if pt in points:  # Shared vertice, remove it.\n                    points.remove(pt)\n                else:\n                    points.add(pt)\n        points = list(points)\n        sort_x = sorted(points)\n        sort_y = sorted(points, key=lambda x: x[1])\n\n        edges_h = {}\n        edges_v = {}\n\n        i = 0\n        while i < len(points):\n            curr_y = sort_y[i][1]\n            while i < len(points) and sort_y[i][1] == curr_y:\n                edges_h[sort_y[i]] = sort_y[i + 1]\n                edges_h[sort_y[i + 1]] = sort_y[i]\n                i += 2\n        i = 0\n        while i < len(points):\n            curr_x = sort_x[i][0]\n            while i < len(points) and sort_x[i][0] == curr_x:\n                edges_v[sort_x[i]] = sort_x[i + 1]\n                edges_v[sort_x[i + 1]] = sort_x[i]\n                i += 2\n\n        # Get all the polygons.\n        while edges_h:\n            # We can start with any point.\n            polygon = [(edges_h.popitem()[0], 0)]\n            while True:\n                curr, e = polygon[-1]\n                if e == 0:\n                    next_vertex = edges_v.pop(curr)\n                    polygon.append((next_vertex, 1))\n                else:\n                    next_vertex = edges_h.pop(curr)\n                    polygon.append((next_vertex, 0))\n                if polygon[-1] == polygon[0]:\n                    # Closed polygon\n                    polygon.pop()\n                    break\n            # Remove implementation-markers from the polygon.\n            poly = [point for point, _ in polygon]\n            for vertex in poly:\n                if vertex in edges_h:\n                    edges_h.pop(vertex)\n                if vertex in edges_v:\n                    edges_v.pop(vertex)\n            polygon = Polygon(*poly, color=color, fill_opacity=0.3, stroke_opacity=1.0)\n            return_polygons.append(polygon)\n    return return_polygons\n\n\nclass IrisDatasetPlot(VGroup):\n    def __init__(self):\n        points = iris.data[:, 0:2]\n        labels = iris.feature_names\n        targets = iris.target\n        # Make points\n        self.point_group = self._make_point_group(points, targets)\n        # Make axes\n        self.axes_group = self._make_axes_group(points, labels)\n        # Make legend\n        self.legend_group = self._make_legend(\n            [BLUE, ORANGE, GREEN], iris.target_names, self.axes_group\n        )\n        # Make title\n        # title_text = \"Iris Dataset Plot\"\n        # self.title = Text(title_text).match_y(self.axes_group).shift([0.5, self.axes_group.height / 2 + 0.5, 0])\n        # Make all group\n        self.all_group = Group(self.point_group, self.axes_group, self.legend_group)\n        # scale the groups\n        self.point_group.scale(1.6)\n        self.point_group.match_x(self.axes_group)\n        self.point_group.match_y(self.axes_group)\n        self.point_group.shift([0.2, 0, 0])\n        self.axes_group.scale(0.7)\n        self.all_group.shift([0, 0.2, 0])\n\n    @override_animation(Create)\n    def create_animation(self):\n        animation_group = AnimationGroup(\n            # Perform the animations\n            Create(self.point_group, run_time=2),\n            Wait(0.5),\n            Create(self.axes_group, run_time=2),\n            # add title\n            # Create(self.title),\n            Create(self.legend_group),\n        )\n        return animation_group\n\n    def _make_point_group(self, points, targets, class_colors=[BLUE, ORANGE, GREEN]):\n        point_group = VGroup()\n        for point_index, point in enumerate(points):\n            # draw the dot\n            current_target = targets[point_index]\n            color = class_colors[current_target]\n            dot = Dot(point=np.array([point[0], point[1], 0])).set_color(color)\n            dot.scale(0.5)\n            point_group.add(dot)\n        return point_group\n\n    def _make_legend(self, class_colors, feature_labels, axes):\n        legend_group = VGroup()\n        # Make Text\n        setosa = Text(\"Setosa\", color=BLUE)\n        verisicolor = Text(\"Verisicolor\", color=ORANGE)\n        virginica = Text(\"Virginica\", color=GREEN)\n        labels = VGroup(setosa, verisicolor, virginica).arrange(\n            direction=RIGHT, aligned_edge=LEFT, buff=2.0\n        )\n        labels.scale(0.5)\n        legend_group.add(labels)\n        # surrounding rectangle\n        surrounding_rectangle = SurroundingRectangle(labels, color=WHITE)\n        surrounding_rectangle.move_to(labels)\n        legend_group.add(surrounding_rectangle)\n        # shift the legend group\n        legend_group.move_to(axes)\n        legend_group.shift([0, -3.0, 0])\n        legend_group.match_x(axes[0][0])\n\n        return legend_group\n\n    def _make_axes_group(self, points, labels):\n        axes_group = VGroup()\n        # make the axes\n        x_range = [\n            np.amin(points, axis=0)[0] - 0.2,\n            np.amax(points, axis=0)[0] - 0.2,\n            0.5,\n        ]\n        y_range = [np.amin(points, axis=0)[1] - 0.2, np.amax(points, axis=0)[1], 0.5]\n        axes = Axes(\n            x_range=x_range,\n            y_range=y_range,\n            x_length=9,\n            y_length=6.5,\n            # axis_config={\"number_scale_value\":0.75, \"include_numbers\":True},\n            tips=False,\n        ).shift([0.5, 0.25, 0])\n        axes_group.add(axes)\n        # make axis labels\n        # x_label\n        x_label = (\n            Text(labels[0], font=font)\n            .match_y(axes.get_axes()[0])\n            .shift([0.5, -0.75, 0])\n            .scale(font_scale)\n        )\n        axes_group.add(x_label)\n        # y_label\n        y_label = (\n            Text(labels[1], font=font)\n            .match_x(axes.get_axes()[1])\n            .shift([-0.75, 0, 0])\n            .rotate(np.pi / 2)\n            .scale(font_scale)\n        )\n        axes_group.add(y_label)\n\n        return axes_group\n\n\nclass DecisionTreeSurface(VGroup):\n    def __init__(self, tree_clf, data, axes, class_colors=[BLUE, ORANGE, GREEN]):\n        # take the tree and construct the surface from it\n        self.tree_clf = tree_clf\n        self.data = data\n        self.axes = axes\n        self.class_colors = class_colors\n        self.surface_rectangles = self.generate_surface_rectangles()\n\n    def generate_surface_rectangles(self):\n        # compute data bounds\n        left = np.amin(self.data[:, 0]) - 0.2\n        right = np.amax(self.data[:, 0]) - 0.2\n        top = np.amax(self.data[:, 1])\n        bottom = np.amin(self.data[:, 1]) - 0.2\n        maxrange = [left, right, bottom, top]\n        rectangles = decision_areas(self.tree_clf, maxrange, x=0, y=1, n_features=2)\n        # turn the rectangle objects into manim rectangles\n        def convert_rectangle_to_polygon(rect):\n            # get the points for the rectangle in the plot coordinate frame\n            bottom_left = [rect[0], rect[3]]\n            bottom_right = [rect[1], rect[3]]\n            top_right = [rect[1], rect[2]]\n            top_left = [rect[0], rect[2]]\n            # convert those points into the entire manim coordinates\n            bottom_left_coord = self.axes.coords_to_point(*bottom_left)\n            bottom_right_coord = self.axes.coords_to_point(*bottom_right)\n            top_right_coord = self.axes.coords_to_point(*top_right)\n            top_left_coord = self.axes.coords_to_point(*top_left)\n            points = [\n                bottom_left_coord,\n                bottom_right_coord,\n                top_right_coord,\n                top_left_coord,\n            ]\n            # construct a polygon object from those manim coordinates\n            rectangle = Polygon(\n                *points, color=color, fill_opacity=0.3, stroke_opacity=0.0\n            )\n            return rectangle\n\n        manim_rectangles = []\n        for rect in rectangles:\n            color = self.class_colors[int(rect[4])]\n            rectangle = convert_rectangle_to_polygon(rect)\n            manim_rectangles.append(rectangle)\n\n        manim_rectangles = merge_overlapping_polygons(\n            manim_rectangles, colors=[BLUE, GREEN, ORANGE]\n        )\n\n        return manim_rectangles\n\n    @override_animation(Create)\n    def create_override(self):\n        # play a reveal of all of the surface rectangles\n        animations = []\n        for rectangle in self.surface_rectangles:\n            animations.append(Create(rectangle))\n        animation_group = AnimationGroup(*animations)\n\n        return animation_group\n\n    @override_animation(Uncreate)\n    def uncreate_override(self):\n        # play a reveal of all of the surface rectangles\n        animations = []\n        for rectangle in self.surface_rectangles:\n            animations.append(Uncreate(rectangle))\n        animation_group = AnimationGroup(*animations)\n\n        return animation_group\n\n\nclass DecisionTree:\n    \"\"\"\n    Draw a single tree node\n    \"\"\"\n\n    def _make_node(\n        self,\n        feature,\n        threshold,\n        values,\n        is_leaf=False,\n        depth=0,\n        leaf_colors=[BLUE, ORANGE, GREEN],\n    ):\n        if not is_leaf:\n            node_text = f\"{feature}\\n    <= {threshold:.3f} cm\"\n            # draw decision text\n            decision_text = Text(node_text, color=WHITE)\n            # draw a box\n            bounding_box = SurroundingRectangle(decision_text, buff=0.3, color=WHITE)\n            node = VGroup()\n            node.add(bounding_box)\n            node.add(decision_text)\n            # return the node\n        else:\n            # plot the appropriate image\n            class_index = np.argmax(values)\n            # get image\n            pil_image = images[class_index]\n            leaf_group = Group()\n            node = ImageMobject(pil_image)\n            node.scale(1.5)\n            rectangle = Rectangle(\n                width=node.width + 0.05,\n                height=node.height + 0.05,\n                color=leaf_colors[class_index],\n                stroke_width=6,\n            )\n            rectangle.move_to(node.get_center())\n            rectangle.shift([-0.02, 0.02, 0])\n            leaf_group.add(rectangle)\n            leaf_group.add(node)\n            node = leaf_group\n\n        return node\n\n    def _make_connection(self, top, bottom, is_leaf=False):\n        top_node_bottom_location = top.get_center()\n        top_node_bottom_location[1] -= top.height / 2\n        bottom_node_top_location = bottom.get_center()\n        bottom_node_top_location[1] += bottom.height / 2\n        line = Line(top_node_bottom_location, bottom_node_top_location, color=WHITE)\n        return line\n\n    def _make_tree(self, tree, feature_names=[\"Sepal Length\", \"Sepal Width\"]):\n        tree_group = Group()\n        max_depth = tree.max_depth\n        # make the base node\n        feature_name = feature_names[tree.feature[0]]\n        threshold = tree.threshold[0]\n        values = tree.value[0]\n        nodes_map = {}\n        root_node = self._make_node(feature_name, threshold, values, depth=0)\n        nodes_map[0] = root_node\n        tree_group.add(root_node)\n        # save some information\n        node_height = root_node.height\n        node_width = root_node.width\n        scale_factor = 1.0\n        edge_map = {}\n        # tree height\n        tree_height = scale_factor * node_height * max_depth\n        tree_width = scale_factor * 2**max_depth * node_width\n        # traverse tree\n        def recurse(node, depth, direction, parent_object, parent_node):\n            # make sure it is a valid node\n            # make the node object\n            is_leaf = tree.children_left[node] == tree.children_right[node]\n            feature_name = feature_names[tree.feature[node]]\n            threshold = tree.threshold[node]\n            values = tree.value[node]\n            node_object = self._make_node(\n                feature_name, threshold, values, depth=depth, is_leaf=is_leaf\n            )\n            nodes_map[node] = node_object\n            node_height = node_object.height\n            # set the node position\n            direction_factor = -1 if direction == \"left\" else 1\n            shift_right_amount = (\n                0.8 * direction_factor * scale_factor * tree_width / (2**depth) / 2\n            )\n            if is_leaf:\n                shift_down_amount = -1.0 * scale_factor * node_height\n            else:\n                shift_down_amount = -1.8 * scale_factor * node_height\n            node_object.match_x(parent_object).match_y(parent_object).shift(\n                [shift_right_amount, shift_down_amount, 0]\n            )\n            tree_group.add(node_object)\n            # make a connection\n            connection = self._make_connection(\n                parent_object, node_object, is_leaf=is_leaf\n            )\n            edge_name = str(parent_node) + \",\" + str(node)\n            edge_map[edge_name] = connection\n            tree_group.add(connection)\n            # recurse\n            if not is_leaf:\n                recurse(tree.children_left[node], depth + 1, \"left\", node_object, node)\n                recurse(\n                    tree.children_right[node], depth + 1, \"right\", node_object, node\n                )\n\n        recurse(tree.children_left[0], 1, \"left\", root_node, 0)\n        recurse(tree.children_right[0], 1, \"right\", root_node, 0)\n\n        tree_group.scale(0.35)\n        return tree_group, nodes_map, edge_map\n\n    def color_example_path(\n        self, tree_group, nodes_map, tree, edge_map, example, color=YELLOW, thickness=2\n    ):\n        # get decision path\n        decision_path = tree.decision_path(example)[0]\n        path_indices = decision_path.indices\n        # highlight edges\n        for node_index in range(0, len(path_indices) - 1):\n            current_val = path_indices[node_index]\n            next_val = path_indices[node_index + 1]\n            edge_str = str(current_val) + \",\" + str(next_val)\n            edge = edge_map[edge_str]\n            animation_two = AnimationGroup(\n                nodes_map[current_val].animate.set_color(color)\n            )\n            self.play(animation_two, run_time=0.5)\n            animation_one = AnimationGroup(\n                edge.animate.set_color(color),\n                # edge.animate.set_stroke_width(4),\n            )\n            self.play(animation_one, run_time=0.5)\n        # surround the bottom image\n        last_path_index = path_indices[-1]\n        last_path_rectangle = nodes_map[last_path_index][0]\n        self.play(last_path_rectangle.animate.set_color(color))\n\n    def create_sklearn_tree(self, max_tree_depth=1):\n        # learn the decision tree\n        iris = load_iris()\n        tree = learn_iris_decision_tree(iris, max_depth=max_tree_depth)\n        feature_names = iris.feature_names[0:2]\n        return tree.tree_\n\n    def make_tree(self, max_tree_depth=2):\n        sklearn_tree = self.create_sklearn_tree()\n        # make the tree\n        tree_group, nodes_map, edge_map = self._make_tree(\n            sklearn_tree.tree_, feature_names\n        )\n        tree_group.shift([0, 5.5, 0])\n        return tree_group\n        # self.add(tree_group)\n        # self.play(SpinInFromNothing(tree_group), run_time=3)\n        # self.color_example_path(tree_group, nodes_map, tree, edge_map, iris.data[None, 0, 0:2])\n\n\nclass DecisionTreeSplitScene(Scene):\n    def make_decision_tree_classifier(self, max_depth=4):\n        decision_tree = DecisionTreeClassifier(\n            random_state=1, max_depth=max_depth, max_leaf_nodes=8\n        )\n        decision_tree = decision_tree.fit(iris.data[:, :2], iris.target)\n        # output the decisioin tree in some format\n        return decision_tree\n\n    def make_split_animation(self, data, classes, data_labels, main_axes):\n\n        \"\"\"\n        def make_entropy_animation_and_plot(dim=0, num_entropy_values=50):\n            # calculate the entropy values\n            axes_group = VGroup()\n            # make axes\n            range_vals = [np.amin(data, axis=0)[dim], np.amax(data, axis=0)[dim]]\n            axes = Axes(x_range=range_vals,\n                        y_range=[0, 1.0],\n                        x_length=9,\n                        y_length=4,\n            #            axis_config={\"number_scale_value\":0.75, \"include_numbers\":True},\n                        tips=False,\n                    )\n            axes_group.add(axes)\n            # make axis labels\n            # x_label\n            x_label = Text(data_labels[dim], font=font) \\\n                            .match_y(axes.get_axes()[0]) \\\n                            .shift([0.5, -0.75, 0]) \\\n                            .scale(font_scale*1.2)\n            axes_group.add(x_label)\n            # y_label\n            y_label = Text(\"Information Gain\", font=font) \\\n                .match_x(axes.get_axes()[1]) \\\n                .shift([-0.75, 0, 0]) \\\n                .rotate(np.pi / 2) \\\n                .scale(font_scale * 1.2)\n\n            axes_group.add(y_label)\n            # line animation\n            information_gains = []\n            def entropy_function(split_value):\n                # lower entropy\n                lower_set = np.nonzero(data[:, dim] <= split_value)[0]\n                lower_set = classes[lower_set]\n                lower_entropy = entropy(lower_set)\n                # higher entropy\n                higher_set = np.nonzero(data[:, dim] > split_value)[0]\n                higher_set = classes[higher_set]\n                higher_entropy = entropy(higher_set)\n                # calculate entropies\n                all_entropy = entropy(classes, base=2)\n                lower_entropy = entropy(lower_set, base=2)\n                higher_entropy = entropy(higher_set, base=2)\n                mean_entropy = (lower_entropy + higher_entropy) / 2\n                # calculate information gain\n                lower_prob = len(lower_set) / len(data[:, dim])\n                higher_prob = len(higher_set) / len(data[:, dim])\n                info_gain = all_entropy - (lower_prob * lower_entropy + higher_prob * higher_entropy)\n                information_gains.append((split_value, info_gain))\n                return info_gain\n\n            data_range = np.amin(data[:, dim]), np.amax(data[:, dim])\n\n            entropy_graph = axes.get_graph(\n                entropy_function, \n            #    color=RED, \n            #    x_range=data_range\n            )\n            axes_group.add(entropy_graph)\n            axes_group.shift([4.0, 2, 0])\n            axes_group.scale(0.5)\n            dot_animation = Dot(color=WHITE)\n            axes_group.add(dot_animation)\n            # make animations\n            animation_group = AnimationGroup(\n                Create(axes_group, run_time=2),\n                Wait(3),\n                MoveAlongPath(dot_animation, entropy_graph, run_time=20, rate_func=rate_functions.ease_in_out_quad),\n                Wait(2)\n            )\n\n            return axes_group, animation_group, information_gains\n        \"\"\"\n\n        def make_split_line_animation(dim=0):\n            # make a line along one of the dims and move it up and down\n            origin_coord = [\n                np.amin(data, axis=0)[0] - 0.2,\n                np.amin(data, axis=0)[1] - 0.2,\n            ]\n            origin_point = main_axes.coords_to_point(*origin_coord)\n            top_left_coord = [origin_coord[0], np.amax(data, axis=0)[1]]\n            bottom_right_coord = [np.amax(data, axis=0)[0] - 0.2, origin_coord[1]]\n            if dim == 0:\n                other_coord = top_left_coord\n                moving_line_coord = bottom_right_coord\n            else:\n                other_coord = bottom_right_coord\n                moving_line_coord = top_left_coord\n            other_point = main_axes.coords_to_point(*other_coord)\n            moving_line_point = main_axes.coords_to_point(*moving_line_coord)\n            moving_line = Line(origin_point, other_point, color=RED)\n            movement_line = Line(origin_point, moving_line_point)\n            if dim == 0:\n                movement_line.shift([0, moving_line.height / 2, 0])\n            else:\n                movement_line.shift([moving_line.width / 2, 0, 0])\n            # move the moving line along the movement line\n            animation = MoveAlongPath(\n                moving_line,\n                movement_line,\n                run_time=20,\n                rate_func=rate_functions.ease_in_out_quad,\n            )\n            return animation, moving_line\n\n        # plot the line in white then make it invisible\n        # make an animation along the line\n        # make a\n        # axes_one_group, top_animation_group, info_gains = make_entropy_animation_and_plot(dim=0)\n        line_movement, first_moving_line = make_split_line_animation(dim=0)\n        # axes_two_group, bottom_animation_group, _ = make_entropy_animation_and_plot(dim=1)\n        second_line_movement, second_moving_line = make_split_line_animation(dim=1)\n        # axes_two_group.shift([0, -3, 0])\n        animation_group_one = AnimationGroup(\n            #    top_animation_group,\n            line_movement,\n        )\n\n        animation_group_two = AnimationGroup(\n            #    bottom_animation_group,\n            second_line_movement,\n        )\n        \"\"\"\n        both_axes_group = VGroup(\n            axes_one_group,\n            axes_two_group\n        )\n        \"\"\"\n\n        return (\n            animation_group_one,\n            animation_group_two,\n            first_moving_line,\n            second_moving_line,\n            None,\n            None,\n        )\n        #    both_axes_group, \\\n        #    info_gains\n\n    def construct(self):\n        # make the points\n        iris_dataset_plot = IrisDatasetPlot()\n        iris_dataset_plot.all_group.scale(1.0)\n        iris_dataset_plot.all_group.shift([-3, 0.2, 0])\n        # make the entropy line graph\n        # entropy_line_graph = self.draw_entropy_line_graph()\n        # arrange the plots\n        # do animations\n        self.play(Create(iris_dataset_plot))\n        # make the decision tree classifier\n        decision_tree_classifier = self.make_decision_tree_classifier()\n        decision_tree_surface = DecisionTreeSurface(\n            decision_tree_classifier, iris.data, iris_dataset_plot.axes_group[0]\n        )\n        self.play(Create(decision_tree_surface))\n        self.wait(3)\n        self.play(Uncreate(decision_tree_surface))\n        main_axes = iris_dataset_plot.axes_group[0]\n        (\n            split_animation_one,\n            split_animation_two,\n            first_moving_line,\n            second_moving_line,\n            both_axes_group,\n            info_gains,\n        ) = self.make_split_animation(\n            iris.data[:, 0:2], iris.target, iris.feature_names, main_axes\n        )\n        self.play(split_animation_one)\n        self.wait(0.1)\n        self.play(Uncreate(first_moving_line))\n        self.wait(3)\n        self.play(split_animation_two)\n        self.wait(0.1)\n        self.play(Uncreate(second_moving_line))\n        self.wait(0.1)\n        # highlight the maximum on top\n        # sort by second key\n        \"\"\"\n        highest_info_gain = sorted(info_gains, key=lambda x: x[1])[-1]\n        highest_info_gain_point = both_axes_group[0][0].coords_to_point(*highest_info_gain)\n        highlighted_peak = Dot(highest_info_gain_point, color=YELLOW)\n        # get location of highest info gain point\n        highest_info_gain_point_in_iris_graph = iris_dataset_plot.axes_group[0].coords_to_point(*[highest_info_gain[0], 0])\n        first_moving_line.start[0] = highest_info_gain_point_in_iris_graph[0]\n        first_moving_line.end[0] = highest_info_gain_point_in_iris_graph[0]\n        self.play(Create(highlighted_peak))\n        self.play(Create(first_moving_line))\n        text = Text(\"Highest Information Gain\")\n        text.scale(0.4)\n        text.move_to(highlighted_peak)\n        text.shift([0, 0.5, 0])\n        self.play(Create(text))\n        \"\"\"\n        self.wait(1)\n        # draw the basic tree\n        decision_tree_classifier = self.make_decision_tree_classifier(max_depth=1)\n        decision_tree_surface = DecisionTreeSurface(\n            decision_tree_classifier, iris.data, iris_dataset_plot.axes_group[0]\n        )\n        decision_tree_graph, _, _ = DecisionTree()._make_tree(\n            decision_tree_classifier.tree_\n        )\n        decision_tree_graph.match_y(iris_dataset_plot.axes_group)\n        decision_tree_graph.shift([4, 0, 0])\n        self.play(Create(decision_tree_surface))\n        uncreate_animation = AnimationGroup(\n            #    Uncreate(both_axes_group),\n            #    Uncreate(highlighted_peak),\n            Uncreate(second_moving_line),\n            #    Unwrite(text)\n        )\n        self.play(uncreate_animation)\n        self.wait(0.5)\n        self.play(FadeIn(decision_tree_graph))\n        # self.play(FadeIn(highlighted_peak))\n        self.wait(5)\n", "original_prompt": "Decision Tree Split Scene"}
{"prompt": "Here is the code with comments and improvements:\n\n```python\n# Create a new animation group for the forward diffusion process\nforward_random_walk_animation = RandomWalk(forward_chain, axes=axes).animate_random_walk()\n\n# Create an empty list to store the animations\nsynced_animations = []\n\n# Iterate over each timestep in the forward chain\nfor timestep, transition_animation in enumerate(forward_random_walk_animation.animations):\n    # Make an animation moving the time bar\n    time_bar_animation = current_time.animate.set_value(timestep)\n\n    # Make an animation replacing the current image with the timestep image\n    new_image = ImageMobject(stable_diffusion_images[timestep])\n    new_image = new_image.set_height(image_mobject.get_height())\n    new_image.move_to(image_mobject)\n    replace_image_animation = AnimationGroup(\n        FadeOut(image_mobject),\n        FadeIn(new_image),\n        lag_ratio=1.0\n    )\n\n    # Append the animations to the list\n    synced_animations.append(\n        Succession(\n            transition_animation, \n            time_bar_animation,\n            replace_image_animation,\n            lag_ratio=0.0\n        )\n    )\n\n# Play all the animations in succession\nself.play(\n    Succession(*synced_animations),\n)\n\n# Fade out the random walk\nself.play(forward_random_walk.fade_out_random_walk())\n\n# Update the title\nnew_title = Text(\"Forward Diffusion Process\", font_size=64)\nnew_title.move_to(title)\nself.play(ReplacementTransform(title, new_title))\n\n# Create a new animation group for the reverse diffusion process\nbackward_random_walk_animation = RandomWalk(reverse_chain, axes=axes).animate_random_walk()\n\n# Iterate over each timestep in the reverse chain\nfor timestep, transition_animation in enumerate(backward_random_walk_animation.animations):\n    # Make an animation moving the time bar\n    time_bar_animation = current_time.animate.set_value(timestep)\n\n    # Make an animation replacing the current image with the timestep image\n    new_image = ImageMobject(stable_diffusion_images[timestep])\n    new_image = new_image.set_height(image_mobject.get_height())\n    new_image.move_to(image_mobject)\n    replace_image_animation = AnimationGroup(\n        FadeOut(image_mobject),\n        FadeIn(new_image),\n        lag_ratio=1.0\n    )\n\n    # Append the animations to the list\n    synced_animations.append(\n        Succession(\n            transition_animation, \n            time_bar_animation,\n            replace_image_animation,\n            lag_ratio=0.0\n        )\n    )\n\n# Play all the animations in succession\nself.play(\n    Succession(*synced_animations),\n)\n```\n\nChanges:\n\n*   Added comments to explain what each section of code is doing.\n*   Used `enumerate` to iterate over both the timestep and transition animation in the loop.\n*   Moved the animation creation for each step inside the loop, so that it creates a new animation group for each step instead of reusing the same one.\n\nNote: There was also an issue with updating the `time_dot` value which I did not correct in this example. The line should be updated to use `time_bar_number_to_point(timestep)` instead of `time_bar.number_to_point(0)`.", "response": "\"\"\"\n    Shows video of diffusion process. \n\"\"\"\nimport manim_ml\nfrom manim import *\nfrom PIL import Image\nimport os\nfrom diffusers import StableDiffusionPipeline\nimport numpy as np\nimport scipy\n\nfrom manim_ml.diffusion.mcmc import metropolis_hastings_sampler, gaussian_proposal\nfrom manim_ml.diffusion.random_walk import RandomWalk\nfrom manim_ml.utils.mobjects.probability import make_dist_image_mobject_from_samples\n\ndef generate_stable_diffusion_images(prompt, num_inference_steps=30):\n    \"\"\"Generates a list of progressively denoised images using Stable Diffusion\n\n    Parameters\n    ----------\n    num_inference_steps : int, optional\n        _description_, by default 30\n    \"\"\"\n    pipeline = StableDiffusionPipeline.from_pretrained(\"stabilityai/stable-diffusion-2-1\")\n    image_list = [] \n    # Save image callback\n    def save_image_callback(step, timestep, latents):\n        print(\"Saving image callback\")\n        # Decode the latents\n        image = pipeline.vae.decode(latents)\n        image_list.append(image)\n\n    # Generate the image\n    pipeline(prompt, num_inference_steps=num_inference_steps, callback=save_image_callback)\n\n    return image_list\n\ndef make_time_schedule_bar(num_time_steps=30):\n    \"\"\"Makes a bar that gets moved back and forth according to the diffusion model time\"\"\"\n    # Draw time bar with initial value\n    time_bar = NumberLine(\n        [0, num_time_steps], length=25, stroke_width=10, include_ticks=False, include_numbers=False,\n        color=manim_ml.config.color_scheme.secondary_color\n\n    )\n    time_bar.shift(4.5 * DOWN)\n    current_time = ValueTracker(0.3)\n    time_point = time_bar.number_to_point(current_time.get_value())\n    time_dot = Dot(time_point, color=manim_ml.config.color_scheme.secondary_color, radius=0.2)\n    label_location = time_bar.number_to_point(1.0)\n    label_location -= DOWN * 0.1\n    label_text = MathTex(\"t\", color=manim_ml.config.color_scheme.text_color).scale(1.5)\n    # label_text = Text(\"time\")\n    label_text.move_to(time_bar.get_center())\n    label_text.shift(DOWN * 0.5)\n    # Make an updater for the dot\n    def dot_updater(time_dot):\n        # Get location on time_bar\n        point_loc = time_bar.number_to_point(current_time.get_value())\n        time_dot.move_to(point_loc)\n\n    time_dot.add_updater(dot_updater)\n\n    return time_bar, time_dot, label_text, current_time\n\ndef make_2d_diffusion_space():\n    \"\"\"Makes a 2D axis where the diffusion random walk happens in. \n    There is also a distribution of points representing the true distribution\n    of images. \n    \"\"\"\n    axes_group = Group()\n    x_range = [-8, 8]\n    y_range = [-8, 8]\n    y_length = 13\n    x_length = 13\n    # Make an axis\n    axes = Axes(\n        x_range=x_range,\n        y_range=y_range,\n        x_length=x_length,\n        y_length=y_length,\n        # x_axis_config={\"stroke_opacity\": 1.0, \"stroke_color\": WHITE},\n        # y_axis_config={\"stroke_opacity\": 1.0, \"stroke_color\": WHITE},\n        # tips=True,\n    )\n    # Make the distribution for the true images as some gaussian mixture in \n    # the bottom right\n    gaussian_a = np.random.multivariate_normal(\n        mean=[3.0, -3.2],\n        cov=[[1.0, 0.0], [0.0, 1.0]],\n        size=(100)\n    )\n    gaussian_b = np.random.multivariate_normal(\n        mean=[3.0, 3.0],\n        cov=[[1.0, 0.0], [0.0, 1.0]],\n        size=(100)\n    )\n    gaussian_c = np.random.multivariate_normal(\n        mean=[0.0, -1.6],\n        cov=[[1.0, 0.0], [0.0, 1.0]],\n        size=(200)\n    )\n    all_gaussian_samples = np.concatenate([gaussian_a, gaussian_b, gaussian_c], axis=0)\n    print(f\"Shape of all gaussian samples: {all_gaussian_samples.shape}\")\n\n    image_mobject = make_dist_image_mobject_from_samples(\n        all_gaussian_samples,\n        xlim=(x_range[0], x_range[1]),\n        ylim=(y_range[0], y_range[1])\n    )\n    image_mobject.scale_to_fit_height(\n        axes.get_height()     \n    )\n    image_mobject.move_to(axes)\n\n    axes_group.add(axes)\n    axes_group.add(image_mobject)\n\n    return axes_group\n\ndef generate_forward_and_reverse_chains(start_point, target_point, num_inference_steps=30):\n    \"\"\"Here basically we want to generate a forward and reverse chain\n    for the diffusion model where the reverse chain starts at the end of the forward\n    chain, and the end of the reverse chain ends somewhere within a certain radius of the \n    reverse chain.\n\n    This can be done in a sortof hacky way by doing metropolis hastings from a start point\n    to a distribution centered about the start point and vica versa.\n\n    Parameters\n    ----------\n    start_point : _type_\n        _description_\n    \"\"\"\n    def start_dist_log_prob_fn(x):\n        \"\"\"Log probability of the start distribution\"\"\"\n        # Make it a gaussian in top left of the 2D space\n        gaussian_pdf = scipy.stats.multivariate_normal(\n            mean=target_point,\n            cov=[1.0, 1.0]\n        ).pdf(x)\n\n        return np.log(gaussian_pdf)\n    \n    def end_dist_log_prob_fn(x):\n        gaussian_pdf = scipy.stats.multivariate_normal(\n            mean=start_point,\n            cov=[1.0, 1.0]\n        ).pdf(x)\n\n        return np.log(gaussian_pdf)\n\n    forward_chain, _, _ = metropolis_hastings_sampler(\n        log_prob_fn=start_dist_log_prob_fn, \n        prop_fn=gaussian_proposal,\n        iterations=num_inference_steps,\n        initial_location=start_point\n    )\n\n    end_point = forward_chain[-1]\n\n    reverse_chain, _, _ = metropolis_hastings_sampler(\n        log_prob_fn=end_dist_log_prob_fn,\n        prop_fn=gaussian_proposal,\n        iterations=num_inference_steps,\n        initial_location=end_point\n    )\n\n    return forward_chain, reverse_chain\n\n# Make the scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 30.0\nconfig.frame_width = 30.0\n\nclass DiffusionProcess(Scene):\n\n    def construct(self):\n        # Parameters\n        num_inference_steps = 50\n        image_save_dir = \"diffusion_images\"\n        prompt = \"An oil painting of a dragon.\"\n        start_time = 0\n        # Compute the stable diffusion images\n        if len(os.listdir(image_save_dir)) < num_inference_steps:\n            stable_diffusion_images = generate_stable_diffusion_images(\n                prompt,\n                num_inference_steps=num_inference_steps\n            )\n            for index, image in enumerate(stable_diffusion_images):\n                image.save(f\"{image_save_dir}/{index}.png\")\n        else:\n            stable_diffusion_images = [Image.open(f\"{image_save_dir}/{i}.png\") for i in range(num_inference_steps)]\n        # Reverse order of list to be in line with theory timesteps\n        stable_diffusion_images = stable_diffusion_images[::-1]\n        # Add the initial location of the first image\n        start_image = stable_diffusion_images[start_time]\n        image_mobject = ImageMobject(start_image)\n        image_mobject.scale(0.55)\n        image_mobject.shift(LEFT * 7.5)\n        self.add(image_mobject)\n        # Make the time schedule bar\n        time_bar, time_dot, time_label, current_time = make_time_schedule_bar(num_time_steps=num_inference_steps)\n        # Place the bar at the bottom of the screen\n        time_bar.move_to(image_mobject.get_bottom() + DOWN * 2)\n        time_bar.set_x(0)\n        self.add(time_bar)\n        # Place the time label below the time bar\n        self.add(time_label)\n        time_label.next_to(time_bar, DOWN, buff=0.5)\n        # Add 0 and T labels above the bar\n        zero_label = Text(\"0\")\n        zero_label.next_to(time_bar.get_left(), UP, buff=0.5)\n        self.add(zero_label)\n        t_label = Text(\"T\")\n        t_label.next_to(time_bar.get_right(), UP, buff=0.5)\n        self.add(t_label)\n        # Move the time dot to zero\n        time_dot.set_value(0)\n        time_dot.move_to(time_bar.number_to_point(0))\n        self.add(time_dot)\n        # Add the prompt above the image\n        paragraph_prompt = '\"An oil painting of\\n a flaming dragon.\"'\n        text_prompt = Paragraph(paragraph_prompt, alignment=\"center\", font_size=64)\n        text_prompt.next_to(image_mobject, UP, buff=0.6)\n        self.add(text_prompt)\n        # Generate the chain data\n        forward_chain, reverse_chain = generate_forward_and_reverse_chains(\n            start_point=[3.0, -3.0],\n            target_point=[-7.0, -4.0],\n            num_inference_steps=num_inference_steps\n        )\n        # Make the axes that the distribution and chains go on\n        axes, axes_group = make_2d_diffusion_space()\n        # axes_group.match_height(image_mobject)\n        axes_group.shift(RIGHT * 7.5)\n        axes.shift(RIGHT * 7.5)\n        self.add(axes_group)\n        # Add title below distribution\n        title = Text(\"Distribution of Real Images\", font_size=48, color=RED)\n        title.move_to(axes_group)\n        title.shift(DOWN * 6)\n        line = Line(\n            title.get_top(),\n            axes_group.get_bottom() - 4 * DOWN,\n        )\n        self.add(title)\n        self.add(line)\n        # Add a title above the plot\n        title = Text(\"Reverse Diffusion Process\", font_size=64)\n        title.move_to(axes)\n        title.match_y(text_prompt)\n        self.add(title)\n        # First do the forward noise process of adding noise to an image\n        forward_random_walk = RandomWalk(forward_chain, axes=axes)\n        # Sync up forward random walk\n        synced_animations = []\n        forward_random_walk_animation = forward_random_walk.animate_random_walk()\n        print(len(forward_random_walk_animation.animations))\n        for timestep, transition_animation in enumerate(forward_random_walk_animation.animations):\n            # Make an animation moving the time bar\n            # time_bar_animation = current_time.animate.set_value(timestep)\n            time_bar_animation = current_time.animate.set_value(timestep)\n            # Make an animation replacing the current image with the timestep image\n            new_image = ImageMobject(stable_diffusion_images[timestep])\n            new_image = new_image.set_height(image_mobject.get_height())\n            new_image.move_to(image_mobject)\n            image_mobject = new_image\n            replace_image_animation = AnimationGroup(\n                FadeOut(image_mobject),\n                FadeIn(new_image),\n                lag_ratio=1.0\n            )\n            # Sync them together\n            # synced_animations.append(\n            self.play(\n                Succession(\n                    transition_animation, \n                    time_bar_animation,\n                    replace_image_animation,\n                    lag_ratio=0.0\n                )\n            )\n\n        # Fade out the random walk\n        self.play(forward_random_walk.fade_out_random_walk())\n        # self.play(\n        # Succession(\n        # *synced_animations,\n        # )\n        # )\n        new_title = Text(\"Forward Diffusion Process\", font_size=64)\n        new_title.move_to(title)\n        self.play(ReplacementTransform(title, new_title))\n        # Second do the reverse noise process of removing noise from the image\n        backward_random_walk = RandomWalk(reverse_chain, axes=axes)\n        # Sync up forward random walk\n        synced_animations = []\n        backward_random_walk_animation = backward_random_walk.animate_random_walk()\n        for timestep, transition_animation in enumerate(backward_random_walk_animation.animations):\n            timestep = num_inference_steps - timestep - 1\n            if timestep == num_inference_steps - 1:\n                continue\n            # Make an animation moving the time bar\n            # time_bar_animation = time_dot.animate.set_value(timestep)\n            time_bar_animation = current_time.animate.set_value(timestep)\n            # Make an animation replacing the current image with the timestep image\n            new_image = ImageMobject(stable_diffusion_images[timestep])\n            new_image = new_image.set_height(image_mobject.get_height())\n            new_image.move_to(image_mobject)\n            image_mobject = new_image\n            replace_image_animation = AnimationGroup(\n                FadeOut(image_mobject),\n                FadeIn(new_image),\n                lag_ratio=1.0\n            )\n            # Sync them together\n            # synced_animations.append(\n            self.play(\n                Succession(\n                    transition_animation, \n                    time_bar_animation,\n                    replace_image_animation,\n                    lag_ratio=0.0\n                )\n            )\n        # self.play(\n        # Succession(\n        # *synced_animations,\n        # )\n        # )\n", "original_prompt": "Diffusion Process Diffusion Process"}
{"prompt": "Animate an embedded 2D Gaussian distribution while creating a fading animation of a disentangled VAE image sequence.", "response": "\"\"\"This module is dedicated to visualizing VAE disentanglement\"\"\"\nfrom pathlib import Path\n\nfrom manim import *\n\nfrom manim_ml.neural_network.layers import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nimport pickle\n\nROOT_DIR = Path(__file__).parents[2]\n\n\ndef construct_image_mobject(input_image, height=2.3):\n    \"\"\"Constructs an ImageMobject from a numpy grayscale image\"\"\"\n    # Convert image to rgb\n    if len(input_image.shape) == 2:\n        input_image = np.repeat(input_image, 3, axis=0)\n        input_image = np.rollaxis(input_image, 0, start=3)\n    #  Make the ImageMobject\n    image_mobject = ImageMobject(input_image, image_mode=\"RGB\")\n    image_mobject.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"nearest\"])\n    image_mobject.height = height\n\n    return image_mobject\n\n\nclass DisentanglementVisualization(VGroup):\n    def __init__(\n        self,\n        model_path=ROOT_DIR\n        / \"examples/variational_autoencoder/autoencoder_models/saved_models/model_dim2.pth\",\n        image_height=0.35,\n    ):\n        self.model_path = model_path\n        self.image_height = image_height\n        # Load disentanglement image objects\n        with open(\n            ROOT_DIR\n            / \"examples/variational_autoencoder/autoencoder_models/disentanglement.pkl\",\n            \"rb\",\n        ) as f:\n            self.image_handler = pickle.load(f)\n\n    def make_disentanglement_generation_animation(self):\n        animation_list = []\n        for image_index, image in enumerate(self.image_handler[\"images\"]):\n            image_mobject = construct_image_mobject(image, height=self.image_height)\n            r, c = self.image_handler[\"bin_indices\"][image_index]\n            # Move the image to the correct location\n            r_offset = -1.2\n            c_offset = 0.25\n            image_location = [\n                c_offset + c * self.image_height,\n                r_offset + r * self.image_height,\n                0,\n            ]\n            image_mobject.move_to(image_location)\n            animation_list.append(FadeIn(image_mobject))\n\n        generation_animation = AnimationGroup(*animation_list[::-1], lag_ratio=1.0)\n        return generation_animation\n\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 5.0\nconfig.frame_width = 5.0\n\n\nclass DisentanglementScene(Scene):\n    \"\"\"Disentanglement Scene Object\"\"\"\n\n    def _construct_embedding(self, point_color=BLUE, dot_radius=0.05):\n        \"\"\"Makes a Gaussian-like embedding\"\"\"\n        embedding = VGroup()\n        # Sample points from a Gaussian\n        num_points = 200\n        standard_deviation = [0.6, 0.8]\n        mean = [0, 0]\n        points = np.random.normal(mean, standard_deviation, size=(num_points, 2))\n        # Make an axes\n        embedding.axes = Axes(\n            x_range=[-3, 3],\n            y_range=[-3, 3],\n            x_length=2.2,\n            y_length=2.2,\n            tips=False,\n        )\n        # Add each point to the axes\n        self.point_dots = VGroup()\n        for point in points:\n            point_location = embedding.axes.coords_to_point(*point)\n            dot = Dot(point_location, color=point_color, radius=dot_radius / 2)\n            self.point_dots.add(dot)\n\n        embedding.add(self.point_dots)\n        return embedding\n\n    def construct(self):\n        # Make the VAE decoder\n        vae_decoder = NeuralNetwork(\n            [\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n            ],\n            layer_spacing=0.55,\n        )\n\n        vae_decoder.shift([-0.55, 0, 0])\n        self.play(Create(vae_decoder), run_time=1)\n        # Make the embedding\n        embedding = self._construct_embedding()\n        embedding.scale(0.9)\n        embedding.move_to(vae_decoder.get_left())\n        embedding.shift([-0.85, 0, 0])\n        self.play(Create(embedding))\n        # Make disentanglment visualization\n        disentanglement = DisentanglementVisualization()\n        disentanglement_animation = (\n            disentanglement.make_disentanglement_generation_animation()\n        )\n        self.play(disentanglement_animation, run_time=3)\n        self.play(Wait(2))\n", "original_prompt": "Disentanglement Disentanglement"}
{"prompt": "Animate a set of dots that form a half-moon shape, displaying an epsilon ball animation with color changes and clustering, while showing the underlying axes and coordinate system transformations.", "response": "\"\"\"\n    Example where I draw an epsilon nearest neighbor graph animation\n\"\"\"\nfrom cProfile import label\nfrom manim import *\nfrom sklearn.datasets import make_moons\nfrom sklearn.cluster import SpectralClustering\nimport numpy as np\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1200\nconfig.frame_height = 12.0\nconfig.frame_width = 12.0\n\n\ndef make_moon_points(num_samples=100, noise=0.1, random_seed=1):\n    \"\"\"Make two half moon point shapes\"\"\"\n    # Make sure the points are normalized\n    X, y = make_moons(n_samples=num_samples, noise=noise, random_state=random_seed)\n    X -= np.mean(X, axis=0)\n    X /= np.std(X, axis=0)\n    X[:, 1] += 0.3\n    # X[:, 0] /= 2 # squeeze width\n\n    return X\n\n\ndef make_epsilon_balls(epsilon_value, points, axes, ball_color=RED, opacity=0.0):\n    \"\"\"Draws epsilon balls\"\"\"\n    balls = []\n    for point in points:\n        ball = Circle(epsilon_value, color=ball_color, fill_opacity=opacity)\n        global_location = axes.coords_to_point(*point)\n        ball.move_to(global_location)\n        balls.append(ball)\n\n    return VGroup(*balls)\n\n\ndef make_epsilon_graph(epsilon_value, dots, points, edge_color=ORANGE):\n    \"\"\"Makes an epsilon nearest neighbor graph for the given dots\"\"\"\n    # First compute the adjacency matrix from the epsilon value and the points\n    num_dots = len(dots)\n    adjacency_matrix = np.zeros((num_dots, num_dots))\n    # Note: just doing lower triangular matrix\n    for i in range(num_dots):\n        for j in range(i):\n            dist = np.linalg.norm(dots[i].get_center() - dots[j].get_center())\n            is_connected = 1 if dist < epsilon_value else 0\n            adjacency_matrix[i, j] = is_connected\n    # Draw a graph based on the adjacency matrix\n    edges = []\n    for i in range(num_dots):\n        for j in range(i):\n            is_connected = adjacency_matrix[i, j]\n            if is_connected:\n                # Draw a connection between the corresponding dots\n                dot_a = dots[i]\n                dot_b = dots[j]\n                edge = Line(\n                    dot_a.get_center(),\n                    dot_b.get_center(),\n                    color=edge_color,\n                    stroke_width=3,\n                )\n                edges.append(edge)\n\n    return VGroup(*edges), adjacency_matrix\n\n\ndef perform_spectral_clustering(adjacency_matrix):\n    \"\"\"Performs spectral clustering given adjacency matrix\"\"\"\n    clustering = SpectralClustering(\n        n_clusters=2, affinity=\"precomputed\", random_state=0\n    ).fit(adjacency_matrix)\n    labels = clustering.labels_\n\n    return labels\n\n\ndef make_color_change_animation(labels, dots, colors=[ORANGE, GREEN]):\n    \"\"\"Makes a color change animation\"\"\"\n    anims = []\n\n    for index in range(len(labels)):\n        color = colors[labels[index]]\n        dot = dots[index]\n        anims.append(dot.animate.set_color(color))\n\n    return AnimationGroup(*anims, lag_ratio=0.0)\n\n\nclass EpsilonNearestNeighborScene(Scene):\n    def construct(\n        self,\n        num_points=200,\n        dot_radius=0.1,\n        dot_color=BLUE,\n        ball_color=WHITE,\n        noise=0.1,\n        ball_opacity=0.0,\n        random_seed=2,\n    ):\n        # Make moon shape points\n        # Note: dot is the drawing object and point is the math concept\n        moon_points = make_moon_points(\n            num_samples=num_points, noise=noise, random_seed=random_seed\n        )\n        # Make an axes\n        axes = Axes(\n            x_range=[-6, 6, 1],\n            y_range=[-6, 6, 1],\n            x_length=12,\n            y_length=12,\n            tips=False,\n            axis_config={\"stroke_color\": \"#000000\"},\n        )\n        axes.scale(2.2)\n        self.add(axes)\n        # Draw points\n        dots = []\n        for point in moon_points:\n            axes_location = axes.coords_to_point(*point)\n            dot = Dot(axes_location, color=dot_color, radius=dot_radius, z_index=1)\n            dots.append(dot)\n\n        dots = VGroup(*dots)\n        self.play(Create(dots))\n        # Draw epsilon bar with initial value\n        epsilon_bar = NumberLine(\n            [0, 2], length=8, stroke_width=2, include_ticks=False, include_numbers=False\n        )\n        epsilon_bar.shift(4.5 * DOWN)\n        self.play(Create(epsilon_bar))\n        current_epsilon = ValueTracker(0.3)\n        epsilon_point = epsilon_bar.number_to_point(current_epsilon.get_value())\n        epsilon_dot = Dot(epsilon_point)\n        self.add(epsilon_dot)\n        label_location = epsilon_bar.number_to_point(1.0)\n        label_location -= DOWN * 0.1\n        label_text = MathTex(\"\\epsilon\").scale(1.5)\n        # label_text = Text(\"Epsilon\")\n        label_text.move_to(epsilon_bar.get_center())\n        label_text.shift(DOWN * 0.5)\n        self.add(label_text)\n        # Make an updater for the dot\n        def dot_updater(epsilon_dot):\n            # Get location on epsilon_bar\n            point_loc = epsilon_bar.number_to_point(current_epsilon.get_value())\n            epsilon_dot.move_to(point_loc)\n\n        epsilon_dot.add_updater(dot_updater)\n        # Make the epsilon balls\n        epsilon_balls = make_epsilon_balls(\n            current_epsilon.get_value(),\n            moon_points,\n            axes,\n            ball_color=ball_color,\n            opacity=ball_opacity,\n        )\n        # Set up updater for radius of balls\n        def epsilon_balls_updater(epsilon_balls):\n            for ball in epsilon_balls:\n                ball.set_width(current_epsilon.get_value())\n\n        # Turn epsilon up and down\n        epsilon_balls.add_updater(epsilon_balls_updater)\n        # Fade in the initial balls\n        self.play(FadeIn(epsilon_balls), lag_ratio=0.0)\n        # Iterate through different values of epsilon\n        for value in [1.5, 0.5, 0.9]:\n            self.play(current_epsilon.animate.set_value(value), run_time=2.5)\n        # Perform clustering\n        epsilon_value = 0.9\n        # Show connecting graph\n        epsilon_graph, adjacency_matrix = make_epsilon_graph(\n            current_epsilon.get_value(), dots, moon_points, edge_color=WHITE\n        )\n        self.play(FadeOut(epsilon_balls))\n        self.play(FadeIn(epsilon_graph))\n        # Fade out balls\n        self.play(Wait(1.5))\n        # Perform clustering\n        labels = perform_spectral_clustering(adjacency_matrix)\n        # Change the colors of the dots\n        color_change_animation = make_color_change_animation(labels, dots)\n        self.play(color_change_animation)\n        # Fade out graph edges\n        self.play(FadeOut(epsilon_graph))\n        self.play(Wait(5.0))\n", "original_prompt": "Epsilon Nn Graph Epsilon Nn Graph"}
{"prompt": "Animate a rotating neural network diagram that highlights generator and discriminator rectangles with fading, showing real and fake images.", "response": "import random\nfrom pathlib import Path\n\nfrom PIL import Image\nfrom manim import *\nfrom manim_ml.neural_network.layers.embedding import EmbeddingLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.layers.vector import VectorLayer\n\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nROOT_DIR = Path(__file__).parents[2]\n\nconfig.pixel_height = 1080\nconfig.pixel_width = 1080\nconfig.frame_height = 8.3\nconfig.frame_width = 8.3\n\n\nclass GAN(Mobject):\n    \"\"\"Generative Adversarial Network\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.make_entities()\n        self.place_entities()\n        self.titles = self.make_titles()\n\n    def make_entities(self, image_height=1.2):\n        \"\"\"Makes all of the network entities\"\"\"\n        # Make the fake image layer\n        default_image = Image.open(ROOT_DIR / \"assets/gan/fake_image.png\")\n        numpy_image = np.asarray(default_image)\n        self.fake_image_layer = ImageLayer(\n            numpy_image, height=image_height, show_image_on_create=False\n        )\n        # Make the Generator Network\n        self.generator = NeuralNetwork(\n            [\n                EmbeddingLayer(covariance=np.array([[3.0, 0], [0, 3.0]])).scale(1.3),\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n                self.fake_image_layer,\n            ],\n            layer_spacing=0.1,\n        )\n\n        self.add(self.generator)\n        # Make the Discriminator\n        self.discriminator = NeuralNetwork(\n            [\n                FeedForwardLayer(5),\n                FeedForwardLayer(1),\n                VectorLayer(1, value_func=lambda: random.uniform(0, 1)),\n            ],\n            layer_spacing=0.1,\n        )\n        self.add(self.discriminator)\n        # Make Ground Truth Dataset\n        default_image = Image.open(ROOT_DIR / \"assets/gan/real_image.jpg\")\n        numpy_image = np.asarray(default_image)\n        self.ground_truth_layer = ImageLayer(numpy_image, height=image_height)\n        self.add(self.ground_truth_layer)\n\n        self.scale(1)\n\n    def place_entities(self):\n        \"\"\"Positions entities in correct places\"\"\"\n        # Place relative to generator\n        # Place the ground_truth image layer\n        self.ground_truth_layer.next_to(self.fake_image_layer, DOWN, 0.8)\n        # Group the images\n        image_group = Group(self.ground_truth_layer, self.fake_image_layer)\n        # Move the discriminator to the right of thee generator\n        self.discriminator.next_to(self.generator, RIGHT, 0.2)\n        self.discriminator.match_y(image_group)\n        # Move the discriminator to the height of the center of the image_group\n        # self.discriminator.match_y(image_group)\n        # self.ground_truth_layer.next_to(self.fake_image_layer, DOWN, 0.5)\n\n    def make_titles(self):\n        \"\"\"Makes titles for the different entities\"\"\"\n        titles = VGroup()\n\n        self.ground_truth_layer_title = Text(\"Real Image\").scale(0.3)\n        self.ground_truth_layer_title.next_to(self.ground_truth_layer, UP, 0.1)\n        self.add(self.ground_truth_layer_title)\n        titles.add(self.ground_truth_layer_title)\n        self.fake_image_layer_title = Text(\"Fake Image\").scale(0.3)\n        self.fake_image_layer_title.next_to(self.fake_image_layer, UP, 0.1)\n        self.add(self.fake_image_layer_title)\n        titles.add(self.fake_image_layer_title)\n        # Overhead title\n        overhead_title = Text(\"Generative Adversarial Network\").scale(0.75)\n        overhead_title.shift(np.array([0, 3.5, 0]))\n        titles.add(overhead_title)\n        # Probability title\n        self.probability_title = Text(\"Probability\").scale(0.5)\n        self.probability_title.move_to(self.discriminator.input_layers[-2])\n        self.probability_title.shift(UP)\n        self.probability_title.shift(RIGHT * 1.05)\n        titles.add(self.probability_title)\n\n        return titles\n\n    def make_highlight_generator_rectangle(self):\n        \"\"\"Returns animation that highlights the generators contents\"\"\"\n        group = VGroup()\n\n        generator_surrounding_group = Group(self.generator, self.fake_image_layer_title)\n\n        generator_surrounding_rectangle = SurroundingRectangle(\n            generator_surrounding_group, buff=0.1, stroke_width=4.0, color=\"#0FFF50\"\n        )\n        group.add(generator_surrounding_rectangle)\n        title = Text(\"Generator\").scale(0.5)\n        title.next_to(generator_surrounding_rectangle, UP, 0.2)\n        group.add(title)\n\n        return group\n\n    def make_highlight_discriminator_rectangle(self):\n        \"\"\"Makes a rectangle for highlighting the discriminator\"\"\"\n        discriminator_group = Group(\n            self.discriminator,\n            self.fake_image_layer,\n            self.ground_truth_layer,\n            self.fake_image_layer_title,\n            self.probability_title,\n        )\n\n        group = VGroup()\n\n        discriminator_surrounding_rectangle = SurroundingRectangle(\n            discriminator_group, buff=0.05, stroke_width=4.0, color=\"#0FFF50\"\n        )\n        group.add(discriminator_surrounding_rectangle)\n        title = Text(\"Discriminator\").scale(0.5)\n        title.next_to(discriminator_surrounding_rectangle, UP, 0.2)\n        group.add(title)\n\n        return group\n\n    def make_generator_forward_pass(self):\n        \"\"\"Makes forward pass of the generator\"\"\"\n\n        forward_pass = self.generator.make_forward_pass_animation(dist_theme=\"ellipse\")\n\n        return forward_pass\n\n    def make_discriminator_forward_pass(self):\n        \"\"\"Makes forward pass of the discriminator\"\"\"\n\n        disc_forward = self.discriminator.make_forward_pass_animation()\n\n        return disc_forward\n\n    @override_animation(Create)\n    def _create_override(self):\n        \"\"\"Overrides create\"\"\"\n        animation_group = AnimationGroup(\n            Create(self.generator),\n            Create(self.discriminator),\n            Create(self.ground_truth_layer),\n            Create(self.titles),\n        )\n        return animation_group\n\n\nclass GANScene(Scene):\n    \"\"\"GAN Scene\"\"\"\n\n    def construct(self):\n        gan = GAN().scale(1.70)\n        gan.move_to(ORIGIN)\n        gan.shift(DOWN * 0.35)\n        gan.shift(LEFT * 0.1)\n        self.play(Create(gan), run_time=3)\n        # Highlight generator\n        highlight_generator_rectangle = gan.make_highlight_generator_rectangle()\n        self.play(Create(highlight_generator_rectangle), run_time=1)\n        # Generator forward pass\n        gen_forward_pass = gan.make_generator_forward_pass()\n        self.play(gen_forward_pass, run_time=5)\n        # Fade out generator highlight\n        self.play(Uncreate(highlight_generator_rectangle), run_time=1)\n        # Highlight discriminator\n        highlight_discriminator_rectangle = gan.make_highlight_discriminator_rectangle()\n        self.play(Create(highlight_discriminator_rectangle), run_time=1)\n        # Discriminator forward pass\n        discriminator_forward_pass = gan.make_discriminator_forward_pass()\n        self.play(discriminator_forward_pass, run_time=5)\n        # Unhighlight discriminator\n        self.play(Uncreate(highlight_discriminator_rectangle), run_time=1)\n", "original_prompt": "Gan Gan"}
{"prompt": "Animate a Variational Autoencoder's decoder making multiple forward passes with zooming embeddings.", "response": "\"\"\"Visualization of VAE Interpolation\"\"\"\nimport sys\nimport os\n\nsys.path.append(os.environ[\"PROJECT_ROOT\"])\nfrom manim import *\nimport pickle\nimport numpy as np\nimport manim_ml.neural_network as neural_network\nimport examples.variational_autoencoder.variational_autoencoder as variational_autoencoder\n\n\"\"\"\n    The VAE Scene for the twitter video. \n\"\"\"\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n# Set random seed so point distribution is constant\nnp.random.seed(1)\n\n\nclass InterpolationScene(MovingCameraScene):\n    \"\"\"Scene object for a Variational Autoencoder and Autoencoder\"\"\"\n\n    def construct(self):\n        # Set Scene config\n        vae = variational_autoencoder.VariationalAutoencoder(\n            dot_radius=0.035, layer_spacing=0.5\n        )\n        vae.move_to(ORIGIN)\n        vae.encoder.shift(LEFT * 0.5)\n        vae.decoder.shift(RIGHT * 0.5)\n        mnist_image_handler = variational_autoencoder.MNISTImageHandler()\n        image_pair = mnist_image_handler.image_pairs[3]\n        # Make forward pass animation and DO NOT run it\n        forward_pass_animation = vae.make_forward_pass_animation(image_pair)\n        # Make the interpolation animation\n        interpolation_images = mnist_image_handler.interpolation_images\n        interpolation_animation = vae.make_interpolation_animation(interpolation_images)\n        embedding_zoom_animation = self.camera.auto_zoom(\n            [vae.embedding, vae.decoder, vae.output_image], margin=0.5\n        )\n        # Make animations\n        forward_pass_animations = []\n        for i in range(7):\n            anim = vae.decoder.make_forward_propagation_animation(run_time=0.5)\n            forward_pass_animations.append(anim)\n        forward_pass_animation_group = AnimationGroup(\n            *forward_pass_animations, lag_ratio=1.0\n        )\n        # Make forward pass animations\n        self.play(Create(vae), run_time=1.5)\n        self.play(FadeOut(vae.encoder), run_time=1.0)\n        self.play(embedding_zoom_animation, run_time=1.5)\n        interpolation_animation = AnimationGroup(\n            forward_pass_animation_group, interpolation_animation\n        )\n        self.play(interpolation_animation, run_time=9.0)\n", "original_prompt": "Interpolation Interpolation"}
{"prompt": "Animate a neural network diagram unfolding vertically from the center, with images and layers transforming into their respective components.", "response": "from pathlib import Path\n\nfrom manim import *\nfrom PIL import Image\nimport numpy as np\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.layers.max_pooling_2d import MaxPooling2DLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 20.0\nconfig.frame_width = 20.0\n\nROOT_DIR = Path(__file__).parents[2]\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(ROOT_DIR / \"assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=4.5),\n                Convolutional2DLayer(1, 28),\n                Convolutional2DLayer(6, 28, 5),\n                MaxPooling2DLayer(kernel_size=2),\n                Convolutional2DLayer(16, 10, 5),\n                MaxPooling2DLayer(kernel_size=2),\n                FeedForwardLayer(8),\n                FeedForwardLayer(3),\n                FeedForwardLayer(2),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make code snippet\n        # code = make_code_snippet()\n        # code.next_to(nn, DOWN)\n        # self.add(code)\n        # Group it all\n        # group = Group(nn, code)\n        # group.move_to(ORIGIN)\n        nn.move_to(ORIGIN)\n        # Play animation\n        # forward_pass = nn.make_forward_pass_animation()\n        # self.wait(1)\n        # self.play(forward_pass)\n", "original_prompt": "Lenet Lenet"}
{"prompt": "Animate a 3D neural network diagram appearing under the text \"ManimML\", rotating and moving into view with a dark underline.", "response": "\"\"\"\n    Logo for Manim Machine Learning\n\"\"\"\nfrom manim import *\n\nimport manim_ml\nmanim_ml.config.color_scheme = \"light_mode\"\n\nfrom manim_ml.neural_network.architectures.feed_forward import FeedForwardNeuralNetwork\n\nconfig.pixel_height = 1000\nconfig.pixel_width = 1000\nconfig.frame_height = 4.0\nconfig.frame_width = 4.0\n\n\nclass ManimMLLogo(Scene):\n    def construct(self):\n        self.text = Text(\"ManimML\", color=manim_ml.config.color_scheme.text_color)\n        self.text.scale(1.0)\n        self.neural_network = FeedForwardNeuralNetwork(\n            [3, 5, 3, 6, 3], layer_spacing=0.3, node_color=BLUE\n        )\n        self.neural_network.scale(1.0)\n        self.neural_network.move_to(self.text.get_bottom())\n        self.neural_network.shift(1.25 * DOWN)\n        self.logo_group = Group(self.text, self.neural_network)\n        self.logo_group.scale(1.0)\n        self.logo_group.move_to(ORIGIN)\n        self.play(Write(self.text), run_time=1.0)\n        self.play(Create(self.neural_network), run_time=3.0)\n        # self.surrounding_rectangle = SurroundingRectangle(self.logo_group, buff=0.3, color=BLUE)\n        underline = Underline(self.text, color=BLACK)\n        animation_group = AnimationGroup(\n            self.neural_network.make_forward_pass_animation(run_time=5),\n            Create(underline),\n            # Create(self.surrounding_rectangle)\n        )\n        # self.surrounding_rectangle = SurroundingRectangle(self.logo_group, buff=0.3, color=BLUE)\n        underline = Underline(self.text, color=BLACK)\n        animation_group = AnimationGroup(\n            self.neural_network.make_forward_pass_animation(run_time=5),\n            Create(underline),\n            #    Create(self.surrounding_rectangle)\n        )\n        self.play(animation_group, runtime=5.0)\n        self.wait(5)\n", "original_prompt": "Logo Logo"}
{"prompt": "\"Animate a large blue neural network diagram that emerges and runs for 5 seconds.\"", "response": "\"\"\"\n    Logo for Manim Machine Learning\n\"\"\"\nfrom manim import *\nfrom manim_ml.neural_network.neural_network import FeedForwardNeuralNetwork\n\nconfig.pixel_height = 400\nconfig.pixel_width = 600\nconfig.frame_height = 8.0\nconfig.frame_width = 10.0\n\n\nclass ManimMLLogo(Scene):\n    def construct(self):\n        self.neural_network = FeedForwardNeuralNetwork(\n            [3, 5, 3, 5], layer_spacing=0.6, node_color=BLUE, edge_width=6\n        )\n        self.neural_network.scale(3)\n        self.neural_network.move_to(ORIGIN)\n        self.play(Create(self.neural_network))\n        # self.surrounding_rectangle = SurroundingRectangle(self.logo_group, buff=0.3, color=BLUE)\n        animation_group = AnimationGroup(\n            self.neural_network.make_forward_pass_animation(run_time=5),\n        )\n        self.play(animation_group)\n        self.wait(5)\n", "original_prompt": "Logo Website Logo"}
{"prompt": "Animate a logo of a neural network with equations appearing under it as it scales and transforms into a visualization of a feed-forward neural network.", "response": "\"\"\"\n    Logo for Manim Machine Learning\n\"\"\"\nfrom manim import *\n\nimport manim_ml\nmanim_ml.config.color_scheme = \"light_mode\"\n\nfrom manim_ml.neural_network.architectures.feed_forward import FeedForwardNeuralNetwork\n\nconfig.pixel_height = 1000\nconfig.pixel_width = 2000\nconfig.frame_height = 4.0\nconfig.frame_width = 8.0\n\n\nclass ManimMLLogo(Scene):\n    def construct(self):\n        self.text = Text(\"ManimML\", color=manim_ml.config.color_scheme.text_color)\n        self.text.scale(1.0)\n        self.neural_network = FeedForwardNeuralNetwork(\n            [3, 5, 3, 6, 3], layer_spacing=0.3, node_color=BLUE\n        )\n        self.neural_network.scale(0.8)\n        self.neural_network.next_to(self.text, RIGHT, buff=0.5)\n        # self.neural_network.move_to(self.text.get_right())\n        # self.neural_network.shift(1.25 * DOWN)\n        self.logo_group = Group(self.text, self.neural_network)\n        self.logo_group.scale(1.0)\n        self.logo_group.move_to(ORIGIN)\n        self.play(Write(self.text), run_time=1.0)\n        self.play(Create(self.neural_network), run_time=3.0)\n        # self.surrounding_rectangle = SurroundingRectangle(self.logo_group, buff=0.3, color=BLUE)\n        underline = Underline(self.text, color=BLACK)\n        animation_group = AnimationGroup(\n            self.neural_network.make_forward_pass_animation(run_time=5),\n            Create(underline),\n            # Create(self.surrounding_rectangle)\n        )\n        # self.surrounding_rectangle = SurroundingRectangle(self.logo_group, buff=0.3, color=BLUE)\n        underline = Underline(self.text, color=BLACK)\n        animation_group = AnimationGroup(\n            self.neural_network.make_forward_pass_animation(run_time=5),\n            Create(underline),\n            #    Create(self.surrounding_rectangle)\n        )\n        self.play(animation_group, runtime=5.0)\n        self.wait(5)\n", "original_prompt": "Logo Wide Logo"}
{"prompt": "Animate a Gaussian Mixture Model's log PDF being calculated with sample generation and visualization of Metropolis Hastings chain sampling.", "response": "from manim import *\n\nimport scipy.stats\nfrom manim_ml.diffusion.mcmc import MCMCAxes\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nplt.style.use('dark_background')\n\n# Make the specific scene\nconfig.pixel_height = 720\nconfig.pixel_width = 720\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\n\nclass MCMCWarmupScene(Scene):\n\n    def construct(self):\n        # Define the Gaussian Mixture likelihood\n        def gaussian_mm_logpdf(x):\n            \"\"\"Gaussian Mixture Model Log PDF\"\"\"\n            # Choose two arbitrary Gaussians\n            # Big Gaussian\n            big_gaussian_pdf = scipy.stats.multivariate_normal(\n                mean=[-0.5, -0.5],\n                cov=[1.0, 1.0]\n            ).pdf(x)\n            # Little Gaussian\n            little_gaussian_pdf = scipy.stats.multivariate_normal(\n                mean=[2.3, 1.9],\n                cov=[0.3, 0.3]\n            ).pdf(x)\n            # Sum their likelihoods and take the log\n            logpdf = np.log(big_gaussian_pdf + little_gaussian_pdf)\n\n            return logpdf\n\n        # Generate a bunch of true samples\n        true_samples = []\n        # Generate samples for little gaussian\n        little_gaussian_samples = np.random.multivariate_normal(\n            mean=[2.3, 1.9],\n            cov=[[0.3, 0.0], [0.0, 0.3]],\n            size=(10000)\n        )\n        big_gaussian_samples = np.random.multivariate_normal(\n            mean=[-0.5, -0.5],\n            cov=[[1.0, 0.0], [0.0, 1.0]],\n            size=(10000)\n        )\n        true_samples = np.concatenate((little_gaussian_samples, big_gaussian_samples))\n        # Make the MCMC axes\n        axes = MCMCAxes(\n            x_range=[-5, 5],\n            y_range=[-5, 5],\n            x_length=7.0,\n            y_length=7.0\n        )\n        axes.move_to(ORIGIN)\n        self.play(\n            Create(axes)\n        )\n        # Make the chain sampling animation \n        chain_sampling_animation = axes.visualize_metropolis_hastings_chain_sampling(\n            log_prob_fn=gaussian_mm_logpdf, \n            true_samples=true_samples,\n            sampling_kwargs={\n                \"iterations\": 2000,\n                \"warm_up\": 50,\n                \"initial_location\": np.array([-3.5, 3.5]),\n                \"sampling_seed\": 4\n            },\n        )\n        self.play(chain_sampling_animation)\n        self.wait(3)\n", "original_prompt": "Mcmc Warmup Mcmc"}
{"prompt": "It seems like you have a Python code snippet related to visualizing a Neocognitron model using the Manim library. The code defines classes for the Neocognitron model and its visualization, as well as a scene that displays the model.\n\nTo improve this code, here are some suggestions:\n\n1. **Use meaningful variable names**: Some of the variable names are not very descriptive, making it harder to understand what they represent. For example, `i` could be renamed to `layer_index`.\n\n2. **Consider adding comments**: Comments can help explain complex parts of the code and make it easier for others (or yourself in the future) to understand.\n\n3. **Use consistent naming conventions**: The code uses both camelCase and underscore notation for variable names. It's better to stick with one convention throughout the code.\n\n4. **Error handling**: The code assumes that all inputs are valid, but in a real-world scenario, you should always expect potential errors. Consider adding try-except blocks to handle any unexpected issues.\n\n5. **Consider using more descriptive docstrings**: Docstrings can provide information about what each function or class does and how to use it.\n\n6. **Use Manim's built-in features**: Manim provides a lot of built-in features that can simplify your code, such as `Manim`, `Scene`, `VGroup`, etc.\n\n7. **Consider adding animations**: Animations can make the visualization more engaging. You could add animations to show how the Neocognitron model processes input or performs calculations.\n\nHere is an updated version of your code with some of these suggestions applied:\n\n```python\nclass NeocognitronLayer:\n    \"\"\"A layer in the Neocognitron model.\"\"\"\n    \n    def __init__(self, cells_per_layer, cell_heights, receptive_field_sizes, layer_name):\n        # Initialize the layer properties\n        self.cells_per_layer = cells_per_layer\n        self.cell_heights = cell_heights\n        self.receptive_field_sizes = receptive_field_sizes\n        self.layer_name = layer_name\n\nclass Neocognitron:\n    \"\"\"A Neocognitron model.\"\"\"\n    \n    def __init__(self, layers):\n        # Initialize the layers\n        self.layers = layers\n    \n    def make_forward_pass_animation(self):\n        # Create an animation of the forward pass\n        for i, layer in enumerate(self.layers[:-1]):\n            input_layer = self.layers[i]\n            output_layer = self.layers[i + 1]\n            \n            # Rotate the pair of layers\n            group = VGroup(input_layer.plane_label, output_layer.plane_label)\n            group.move_to(np.array([group.get_center()[0], 0, 0]))\n            group.rotate(40 * DEGREES, axis=UP, about_point=group.get_center())\n            \n            # Shift the pair of layers\n            c_layer = Group(input_layer, output_layer)\n            c_layer.shift(layer_index // 2 * np.array([0, 0, 0.3]))\n\n        return VGroup(*self.layers[-1].plane_label)\n\nclass Scene(ThreeDScene):\n    \"\"\"A scene for visualizing the Neocognitron model.\"\"\"\n    \n    def construct(self):\n        # Create a Neocognitron model\n        neocognitron = Neocognitron([NeocognitronLayer(cells_per_layer, cell_heights, receptive_field_sizes, layer_name) \n                                     for layer_index, (cells_per_layer, cell_heights, receptive_field_sizes, layer_name) \n                                     in enumerate(zip(neocognitron.cells_per_layer, neocognitron.cell_heights, neocognitron.receptive_field_sizes, neocognitron.layer_names))])\n        \n        # Shift the Neocognitron model\n        neocognitron.shift(DOWN*0.5)\n        \n        # Create a title for the scene\n        title = Text(\"Neocognitron\").scale(1)\n        \n        # Add the title to the scene\n        self.add_fixed_in_frame_mobjects(title)\n        title.next_to(neocognitron, UP, buff=0.4)\n        \n        # Play an animation of the forward pass\n        self.play(neocognitron.make_forward_pass_animation())\n```\n\nThis updated code includes more descriptive variable names and docstrings for clarity. Additionally, it uses some Manim's built-in features to simplify the code. The animations are also simplified by using VGroup and shift methods instead of manual transformations.", "response": "from manim import *\n\nfrom manim_ml.neural_network import NeuralNetwork\nfrom manim_ml.neural_network.layers.parent_layers import NeuralNetworkLayer, ConnectiveLayer, ThreeDLayer\nimport manim_ml\n\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 10.5\nconfig.frame_width = 10.5\n\nclass NeocognitronFilter(VGroup):\n    \"\"\"\n        Filter connecting the S and C Cells of a neocognitron layer.\n    \"\"\"\n\n    def __init__(\n        self,\n        input_cell, \n        output_cell, \n        receptive_field_radius, \n        outline_color=BLUE,\n        active_color=ORANGE, \n        **kwargs\n    ):\n        super().__init__(**kwargs)\n        self.outline_color = outline_color\n        self.active_color = active_color\n        self.input_cell = input_cell\n        self.output_cell = output_cell\n        # Draw the receptive field\n        # Make the points of a equilateral triangle in the plane of the \n        # cell about a random center\n        # center_point = input_cell.get_center()\n        shift_amount_x = np.random.uniform(\n            -(input_cell.get_height()/2 - receptive_field_radius - 0.01),\n            input_cell.get_height()/2 - receptive_field_radius - 0.01,\n        )\n        shift_amount_y = np.random.uniform(\n            -(input_cell.get_height()/2 - receptive_field_radius - 0.01),\n            input_cell.get_height()/2 - receptive_field_radius - 0.01,\n        )\n        # center_point += np.array([shift_amount_x, shift_amount_y, 0])\n        # # Make the triangle points\n        # side_length = np.sqrt(3) * receptive_field_radius\n        # normal_vector = np.cross(\n        #     input_cell.get_left() - input_cell.get_center(),\n        #     input_cell.get_top() - input_cell.get_center(),\n        # )\n        # Get vector in the plane of the cell\n        # vector_in_plane = input_cell.get_left() - input_cell.get_center()\n        # point_a = center_point + vector_in_plane * receptive_field_radius\n        # # rotate the vector 120 degrees about the vector normal to the cell\n        # vector_in_plane = rotate_vector(vector_in_plane, PI/3, normal_vector)\n        # point_b = center_point + vector_in_plane * receptive_field_radius\n        # # rotate the vector 120 degrees about the vector normal to the cell\n        # vector_in_plane = rotate_vector(vector_in_plane, PI/3, normal_vector)\n        # point_c = center_point + vector_in_plane * receptive_field_radius\n        # self.receptive_field = Circle.from_three_points(\n        #     point_a, \n        #     point_b,\n        #     point_c,\n        #     color=outline_color,\n        #     stroke_width=2.0,\n        # )\n        self.receptive_field = Circle(\n            radius=receptive_field_radius,\n            color=outline_color,\n            stroke_width=3.0,\n        )\n        self.add(self.receptive_field)\n        # Move receptive field to a random point within the cell\n        # minus the radius of the receptive field\n        self.receptive_field.move_to(\n            input_cell\n        )\n        # Shift a random amount in the x and y direction within \n        self.receptive_field.shift(\n            np.array([shift_amount_x, shift_amount_y, 0])\n        )\n        # Choose a random point on the c_cell\n        shift_amount_x = np.random.uniform(\n            -(output_cell.get_height()/2 - receptive_field_radius - 0.01),\n            output_cell.get_height()/2 - receptive_field_radius - 0.01,\n        )\n        shift_amount_y = np.random.uniform(\n            -(output_cell.get_height()/2 - receptive_field_radius - 0.01),\n            output_cell.get_height()/2 - receptive_field_radius - 0.01,\n        )\n        self.dot = Dot(\n            color=outline_color,\n            radius=0.04\n        )\n        self.dot.move_to(output_cell.get_center() + np.array([shift_amount_x, shift_amount_y, 0]))\n        self.add(self.dot)\n        # Make lines connecting receptive field to the dot\n        self.lines = VGroup()\n        self.lines.add(\n            Line(\n                self.receptive_field.get_center() + np.array([0, receptive_field_radius, 0]),\n                self.dot,\n                color=outline_color,\n                stroke_width=3.0,\n            )\n        )\n        self.lines.add(\n            Line(\n                self.receptive_field.get_center() - np.array([0, receptive_field_radius, 0]),\n                self.dot,\n                color=outline_color,\n                stroke_width=3.0,\n            )\n        )\n        self.add(self.lines)\n\n    def make_filter_pulse_animation(self, **kwargs):\n        succession = Succession(\n            ApplyMethod(\n                self.receptive_field.set_color, \n                self.active_color, \n                run_time=0.25\n            ),\n            ApplyMethod(\n                self.receptive_field.set_color, \n                self.outline_color, \n                run_time=0.25\n            ),\n            ShowPassingFlash(\n                self.lines.copy().set_color(self.active_color),\n                time_width=0.5,\n            ),\n            ApplyMethod(\n                self.dot.set_color, \n                self.active_color, \n                run_time=0.25\n            ),\n            ApplyMethod(\n                self.dot.set_color, \n                self.outline_color, \n                run_time=0.25\n            ),\n        )\n\n        return succession\n\nclass NeocognitronLayer(NeuralNetworkLayer, ThreeDLayer):\n    \n    def __init__(\n        self, \n        num_cells, \n        cell_height,\n        receptive_field_radius,\n        layer_name,\n        active_color=manim_ml.config.color_scheme.active_color,\n        cell_color=manim_ml.config.color_scheme.secondary_color,\n        outline_color=manim_ml.config.color_scheme.primary_color,\n        show_outline=True,\n        **kwargs\n    ):\n        super().__init__(**kwargs)\n        self.num_cells = num_cells\n        self.cell_height = cell_height\n        self.receptive_field_radius = receptive_field_radius\n        self.layer_name = layer_name\n        self.active_color = active_color\n        self.cell_color = cell_color\n        self.outline_color = outline_color\n        self.show_outline = show_outline\n\n        self.plane_label = Text(layer_name).scale(0.4)\n\n    def make_cell_plane(self, layer_name, cell_buffer=0.1, stroke_width=2.0):\n        \"\"\"Makes a plane of cells. \n        \"\"\"\n        cell_plane = VGroup()\n        for cell_index in range(self.num_cells):\n            # Draw the cell box\n            cell_box = Rectangle(\n                width=self.cell_height,\n                height=self.cell_height,\n                color=self.cell_color,\n                fill_color=self.cell_color,\n                fill_opacity=0.3,\n                stroke_width=stroke_width,\n            )\n            if cell_index > 0:\n                cell_box.next_to(cell_plane[-1], DOWN, buff=cell_buffer)\n            cell_plane.add(cell_box)\n        # Draw the outline\n        if self.show_outline:\n            self.plane_outline = SurroundingRectangle(\n                cell_plane,\n                color=self.cell_color,\n                buff=cell_buffer,\n                stroke_width=stroke_width,\n            )\n            cell_plane.add(\n                self.plane_outline\n            )\n        # Draw a label above the container box\n        self.plane_label.next_to(cell_plane, UP, buff=0.2)\n        cell_plane.add(self.plane_label)\n\n        return cell_plane\n\n    def construct_layer(self, input_layer, output_layer, **kwargs):\n        # Make the Cell layer\n        self.cell_plane = self.make_cell_plane(self.layer_name)\n        self.add(self.cell_plane)\n        \n    def make_forward_pass_animation(self, layer_args={}, **kwargs):\n        \"\"\"Forward pass for query\"\"\"\n        # # Pulse and un pulse the cell plane rectangle\n        flash_outline_animations = []\n        for cell in self.cell_plane:\n            flash_outline_animations.append(\n                Succession(\n                    ApplyMethod(\n                        cell.set_stroke_color,\n                        self.active_color,\n                        run_time=0.25\n                    ),\n                    ApplyMethod(\n                        cell.set_stroke_color,\n                        self.outline_color,\n                        run_time=0.25\n                    )\n                )\n            )\n        \n        return AnimationGroup(\n            *flash_outline_animations,\n            lag_ratio=0.0\n        )\n\nclass NeocognitronToNeocognitronLayer(ConnectiveLayer):\n    input_class = NeocognitronLayer\n    output_class = NeocognitronLayer\n\n    def __init__(self, input_layer, output_layer, **kwargs):\n        super().__init__(input_layer, output_layer, **kwargs)\n\n    def construct_layer(self, input_layer, output_layer, **kwargs):\n        self.filters = []\n        for cell_index in range(input_layer.num_cells):\n            input_cell = input_layer.cell_plane[cell_index]\n            # Randomly choose a cell from the output layer\n            output_cell = output_layer.cell_plane[\n                np.random.randint(0, output_layer.num_cells)\n            ]\n            # Make the filter\n            filter = NeocognitronFilter(\n                input_cell=input_cell,\n                output_cell=output_cell,\n                receptive_field_radius=input_layer.receptive_field_radius,\n                outline_color=self.input_layer.outline_color\n            )\n            # filter = NeocognitronFilter(\n            #     outline_color=input_layer.outline_color\n            # )\n            self.filters.append(filter)\n\n        self.add(VGroup(*self.filters))\n\n    def make_forward_pass_animation(self, layer_args={}, **kwargs):\n        \"\"\"Forward pass for query\"\"\"\n        filter_pulses = []\n        for filter in self.filters:\n            filter_pulses.append(\n                filter.make_filter_pulse_animation()\n            )\n        return AnimationGroup(\n            *filter_pulses\n        )\n\nmanim_ml.neural_network.layers.util.register_custom_connective_layer(\n    NeocognitronToNeocognitronLayer,\n)\n\nclass Neocognitron(NeuralNetwork):\n\n    def __init__(\n        self, \n        camera,\n        cells_per_layer=[4, 5, 4, 4, 3, 3, 5, 5],\n        cell_heights=[0.8, 0.8, 0.8*0.75, 0.8*0.75, 0.8*0.75**2, 0.8*0.75**2, 0.8*0.75**3, 0.02],\n        layer_names=[\"S1\", \"C1\", \"S2\", \"C2\", \"S3\", \"C3\", \"S4\", \"C4\"],\n        receptive_field_sizes=[0.2, 0.2, 0.2*0.75, 0.2*0.75, 0.2*0.75**2, 0.2*0.75**2, 0.2*0.75**3, 0.0],\n    ):\n        self.cells_per_layer = cells_per_layer\n        self.cell_heights = cell_heights\n        self.layer_names = layer_names\n        self.receptive_field_sizes = receptive_field_sizes\n        # Make the neo-cognitron input layer\n        input_layers = []\n        input_layers.append(\n            NeocognitronLayer(\n                1,\n                1.5,\n                0.2,\n                \"U0\",\n                show_outline=False,\n            )\n        )\n        # Make the neo-cognitron layers\n        for i in range(len(cells_per_layer)):\n            layer = NeocognitronLayer(\n                cells_per_layer[i],\n                cell_heights[i],\n                receptive_field_sizes[i],\n                layer_names[i]\n            )\n            input_layers.append(layer)\n        \n        # Make all of the layer labels fixed in frame\n        for layer in input_layers:\n            if isinstance(layer, NeocognitronLayer):\n                # camera.add_fixed_orientation_mobjects(layer.plane_label)\n                pass\n\n        all_layers = []\n        for layer_index in range(len(input_layers) - 1):\n            input_layer = input_layers[layer_index]\n            all_layers.append(input_layer)\n            output_layer = input_layers[layer_index + 1]\n            connective_layer = NeocognitronToNeocognitronLayer(\n                input_layer,\n                output_layer\n            )\n            all_layers.append(connective_layer)\n        all_layers.append(input_layers[-1])\n\n        def custom_layout_func(neural_network):\n            # Insert the connective layers\n            # Pass the layers to neural network super class\n            # Rotate pairs of layers\n            layer_index = 1\n            while layer_index < len(input_layers):\n                prev_layer = input_layers[layer_index - 1]\n                s_layer = input_layers[layer_index]\n                s_layer.next_to(prev_layer, RIGHT, buff=0.0)\n                s_layer.shift(RIGHT * 0.4)\n                c_layer = input_layers[layer_index + 1]\n                c_layer.next_to(s_layer, RIGHT, buff=0.0)\n                c_layer.shift(RIGHT * 0.2)\n                # Rotate the pair of layers\n                group = Group(s_layer, c_layer)\n                group.move_to(np.array([group.get_center()[0], 0, 0]))\n\n                # group.shift(layer_index * 3 * np.array([0, 0, 1.0]))\n                # group.rotate(40 * DEGREES, axis=UP, about_point=group.get_center())\n                # c_layer.rotate(40*DEGREES, axis=UP, about_point=group.get_center())\n                # s_layer.shift(\n                #     layer_index // 2 * np.array([0, 0, 0.3])\n                # )\n                # c_layer.shift(\n                #     layer_index // 2 * np.array([0, 0, 0.3])\n                # )\n                layer_index += 2\n            neural_network.move_to(ORIGIN)\n\n        super().__init__(\n            all_layers,\n            layer_spacing=0.5,\n            custom_layout_func=custom_layout_func\n        )\n\nclass Scene(ThreeDScene):\n\n    def construct(self):\n        neocognitron = Neocognitron(self.camera)\n        neocognitron.shift(DOWN*0.5)\n        self.add(neocognitron)\n        title = Text(\"Neocognitron\").scale(1)\n        self.add_fixed_in_frame_mobjects(title)\n        title.next_to(neocognitron, UP, buff=0.4)\n        self.add(title)\n        \"\"\"\n        self.play(\n            neocognitron.make_forward_pass_animation()\n        )\n        \"\"\"\n        print(self.camera.gamma)\n        print(self.camera.theta)\n        print(self.camera.phi)\n        neocognitron.rotate(90*DEGREES, axis=RIGHT)\n        neocognitron.shift(np.array([0, 0, -0.2]))\n        # title.rotate(90*DEGREES, axis=RIGHT)\n        # self.set_camera_orientation(phi=-15*DEGREES)\n        # vec = np.array([0.0, 0.2, 0.0])\n        # vec /= np.linalg.norm(vec)\n        # x, y, z = vec[0], vec[1], vec[2]\n        # theta = np.arccos(z)\n        # phi = np.arctan(y / x)\n        self.set_camera_orientation(phi=90 * DEGREES, theta=-70*DEGREES, gamma=0*DEGREES)\n        # self.set_camera_orientation(theta=theta, phi=phi)\n\n        forward_pass = neocognitron.make_forward_pass_animation()\n        self.play(forward_pass)\n\n", "original_prompt": "Neocognitron Neocognitron"}
{"prompt": "It appears that the code is a part of a larger visualization script, possibly used for explaining or demonstrating a neural network architecture, specifically a Variational Autoencoder (VAE) with an Oracle-guided image synthesis procedure. The provided snippet seems to be a part of the `construct` method, which initializes and sets up various components of the visualization.\n\nTo make this code more readable and maintainable, here are some suggestions:\n\n1.  **Break down the long `construct` method**: It would be beneficial to break this method into smaller, more manageable functions, each responsible for a specific aspect of the visualization (e.g., creating the VAE architecture, implementing the localization procedure, setting up the training loop).\n\n2.  **Use meaningful variable names**: Some variable names, such as `emb_to_ff_ind`, are not very descriptive. Consider renaming them to something like `encoder_to_ff_layer_index` to improve readability.\n\n3.  **Consider adding comments or docstrings**: While the code is relatively self-explanatory for someone familiar with PyTorch and its associated libraries, it would be helpful to include comments or docstrings that explain what each section of the code does, especially for others who may not be as familiar.\n\n4.  **Use type hints**: Adding type hints can make the code more readable and help catch potential type-related errors earlier in the development process.\n\n5.  **Consider using a more modular approach**: Instead of having all the logic in one place, consider breaking this into separate modules or classes that each handle a specific aspect of the visualization (e.g., `VAE`, `localization_procedure`, `training_loop`).\n\nHere is an example of how you might break down the `construct` method:\n\n```python\ndef construct(self):\n    \"\"\"\n    Makes the whole visualization.\n    \n    1. Create the Architecture\n        a. Create the traditional VAE architecture with images\n    \n    2. The Localization Procedure\n        b. The Algorithm Steps\n    \n    3. The Training Procedure\n        c. Unsupervised Image Reconstruction\n        d. Triplet Loss in Latent Space\n    \"\"\"\n    \n    # Step 1: Create the VAE Architecture\n    self.neural_network.scale(1.2)\n    create_vae = Create(self.neural_network)\n    self.play(create_vae, run_time=3)\n    \n    # Set up prior distribution and localization procedure\n    self.set_up_prior_distribution_and_localization()\n    \n    # Step 3: The Training Procedure\n    self.train_model()\n\ndef set_up_prior_distribution_and_localization(self):\n    \"\"\"\n    Sets up the prior distribution and localization procedure.\n    \n    This involves:\n        a. Creating the prior distribution\n        b. Implementing the localization procedure (N queries)\n    \"\"\"\n    \n    # Create prior distribution\n    self.localizer.prior_distribution = PriorDistribution()\n    self.play(Create(self.localizer.prior_distribution))\n    \n    # Make localization iteration\n    old_posterior = self.localizer.prior_distribution\n    for query_index in range(self.localizer.num_queries):\n        old_posterior = self.make_localization_time_step(old_posterior)\n        self.play(Wait(1))\n\ndef train_model(self):\n    \"\"\"\n    Trains the model using the oracle-guided image synthesis procedure.\n    \n    This involves:\n        a. Unsupervised Image Reconstruction\n        b. Triplet Loss in Latent Space\n    \"\"\"\n    \n    # Do unsupervised image reconstruction\n    self.make_embed_input_image_animation(\n        self.input_embed_image_path, self.output_embed_image_path\n    )\n    self.wait(1)\n    \n    # Do triplet forward pass\n    self.make_triplet_forward_animation()\n    self.wait(1)\n```\n\nThis approach allows for more modular code that is easier to understand and maintain.", "response": "\"\"\"\n    Here is a animated explanatory figure for the \"Oracle Guided Image Synthesis with Relative Queries\" paper. \n\"\"\"\nfrom pathlib import Path\n\nfrom manim import *\nfrom manim_ml.neural_network.layers import triplet\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.layers.paired_query import PairedQueryLayer\nfrom manim_ml.neural_network.layers.triplet import TripletLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nfrom manim_ml.neural_network.layers import FeedForwardLayer, EmbeddingLayer\nfrom manim_ml.neural_network.layers.util import get_connective_layer\nimport os\n\nfrom manim_ml.utils.mobjects.probability import GaussianDistribution\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\nROOT_DIR = Path(__file__).parents[3]\n\n\nclass Localizer:\n    \"\"\"\n    Holds the localizer object, which contains the queries, images, etc.\n    needed to represent a localization run.\n    \"\"\"\n\n    def __init__(self, axes):\n        # Set dummy values for these\n        self.index = -1\n        self.axes = axes\n        self.num_queries = 3\n        self.assets_path = ROOT_DIR / \"assets/oracle_guidance\"\n        self.ground_truth_image_path = self.assets_path / \"ground_truth.jpg\"\n        self.ground_truth_location = np.array([2, 3])\n        # Prior distribution\n        print(\"initial gaussian\")\n        self.prior_distribution = GaussianDistribution(\n            self.axes,\n            mean=np.array([0.0, 0.0]),\n            cov=np.array([[3, 0], [0, 3]]),\n            dist_theme=\"ellipse\",\n            color=GREEN,\n        )\n        # Define the query images and embedded locations\n        # Contains image paths [(positive_path, negative_path), ...]\n        self.query_image_paths = [\n            (\n                os.path.join(self.assets_path, \"positive_1.jpg\"),\n                os.path.join(self.assets_path, \"negative_1.jpg\"),\n            ),\n            (\n                os.path.join(self.assets_path, \"positive_2.jpg\"),\n                os.path.join(self.assets_path, \"negative_2.jpg\"),\n            ),\n            (\n                os.path.join(self.assets_path, \"positive_3.jpg\"),\n                os.path.join(self.assets_path, \"negative_3.jpg\"),\n            ),\n        ]\n        # Contains 2D locations for each image [([2, 3], [2, 4]), ...]\n        self.query_locations = [\n            (np.array([-1, -1]), np.array([1, 1])),\n            (np.array([1, -1]), np.array([-1, 1])),\n            (np.array([0.3, -0.6]), np.array([-0.5, 0.7])),\n        ]\n        # Make the covariances for each query\n        self.query_covariances = [\n            (np.array([[0.3, 0], [0.0, 0.2]]), np.array([[0.2, 0], [0.0, 0.2]])),\n            (np.array([[0.2, 0], [0.0, 0.2]]), np.array([[0.2, 0], [0.0, 0.2]])),\n            (np.array([[0.2, 0], [0.0, 0.2]]), np.array([[0.2, 0], [0.0, 0.2]])),\n        ]\n        # Posterior distributions over time GaussianDistribution objects\n        self.posterior_distributions = [\n            GaussianDistribution(\n                self.axes,\n                dist_theme=\"ellipse\",\n                color=GREEN,\n                mean=np.array([-0.3, -0.3]),\n                cov=np.array([[5, -4], [-4, 6]]),\n            ).scale(0.6),\n            GaussianDistribution(\n                self.axes,\n                dist_theme=\"ellipse\",\n                color=GREEN,\n                mean=np.array([0.25, -0.25]),\n                cov=np.array([[3, -2], [-2, 4]]),\n            ).scale(0.35),\n            GaussianDistribution(\n                self.axes,\n                dist_theme=\"ellipse\",\n                color=GREEN,\n                mean=np.array([0.4, -0.35]),\n                cov=np.array([[1, 0], [0, 1]]),\n            ).scale(0.3),\n        ]\n        # Some assumptions\n        assert len(self.query_locations) == len(self.query_image_paths)\n        assert len(self.query_locations) == len(self.posterior_distributions)\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        \"\"\"Steps through each localization time instance\"\"\"\n        if self.index < len(self.query_image_paths):\n            self.index += 1\n        else:\n            raise StopIteration\n\n        # Return query_paths, query_locations, posterior\n        out_tuple = (\n            self.query_image_paths[self.index],\n            self.query_locations[self.index],\n            self.posterior_distributions[self.index],\n            self.query_covariances[self.index],\n        )\n\n        return out_tuple\n\n\nclass OracleGuidanceVisualization(Scene):\n    def __init__(self):\n        super().__init__()\n        self.neural_network, self.embedding_layer = self.make_vae()\n        self.localizer = iter(Localizer(self.embedding_layer.axes))\n        self.subtitle = None\n        self.title = None\n        # Set image paths\n        # VAE embedding animation image paths\n        self.assets_path = ROOT_DIR / \"assets/oracle_guidance\"\n        self.input_embed_image_path = os.path.join(self.assets_path, \"input_image.jpg\")\n        self.output_embed_image_path = os.path.join(\n            self.assets_path, \"output_image.jpg\"\n        )\n\n    def make_vae(self):\n        \"\"\"Makes a simple VAE architecture\"\"\"\n        embedding_layer = EmbeddingLayer(dist_theme=\"ellipse\")\n        self.encoder = NeuralNetwork(\n            [\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                embedding_layer,\n            ]\n        )\n\n        self.decoder = NeuralNetwork(\n            [\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n            ]\n        )\n\n        neural_network = NeuralNetwork([self.encoder, self.decoder])\n\n        neural_network.shift(DOWN * 0.4)\n        return neural_network, embedding_layer\n\n    @override_animation(Create)\n    def _create_animation(self):\n        animation_group = AnimationGroup(Create(self.neural_network))\n\n        return animation_group\n\n    def insert_at_start(self, layer, create=True):\n        \"\"\"Inserts a layer at the beggining of the network\"\"\"\n        # Note: Does not move the rest of the network\n        current_first_layer = self.encoder.all_layers[0]\n        # Get connective layer\n        connective_layer = get_connective_layer(layer, current_first_layer)\n        # Insert both layers\n        self.encoder.all_layers.insert(0, layer)\n        self.encoder.all_layers.insert(1, connective_layer)\n        # Move layers to the correct location\n        # TODO: Fix this cause its hacky\n        layer.shift(DOWN * 0.4)\n        layer.shift(LEFT * 2.35)\n        # Make insert animation\n        if not create:\n            animation_group = AnimationGroup(Create(connective_layer))\n        else:\n            animation_group = AnimationGroup(Create(layer), Create(connective_layer))\n        self.play(animation_group)\n\n    def remove_start_layer(self):\n        \"\"\"Removes the first layer of the network\"\"\"\n        first_layer = self.encoder.all_layers.remove_at_index(0)\n        first_connective = self.encoder.all_layers.remove_at_index(0)\n        # Make remove animations\n        animation_group = AnimationGroup(\n            FadeOut(first_layer), FadeOut(first_connective)\n        )\n\n        self.play(animation_group)\n\n    def insert_at_end(self, layer):\n        \"\"\"Inserts the given layer at the end of the network\"\"\"\n        current_last_layer = self.decoder.all_layers[-1]\n        # Get connective layer\n        connective_layer = get_connective_layer(current_last_layer, layer)\n        # Insert both layers\n        self.decoder.all_layers.add(connective_layer)\n        self.decoder.all_layers.add(layer)\n        # Move layers to the correct location\n        # TODO: Fix this cause its hacky\n        layer.shift(DOWN * 0.4)\n        layer.shift(RIGHT * 2.35)\n        # Make insert animation\n        animation_group = AnimationGroup(Create(layer), Create(connective_layer))\n        self.play(animation_group)\n\n    def remove_end_layer(self):\n        \"\"\"Removes the lsat layer of the network\"\"\"\n        first_layer = self.decoder.all_layers.remove_at_index(-1)\n        first_connective = self.decoder.all_layers.remove_at_index(-1)\n        # Make remove animations\n        animation_group = AnimationGroup(\n            FadeOut(first_layer), FadeOut(first_connective)\n        )\n\n        self.play(animation_group)\n\n    def change_title(self, text, title_location=np.array([0, 1.25, 0]), font_size=24):\n        \"\"\"Changes title to the given text\"\"\"\n        if self.title is None:\n            self.title = Text(text, font_size=font_size)\n            self.title.move_to(title_location)\n            self.add(self.title)\n            self.play(Write(self.title), run_time=1)\n            self.wait(1)\n            return\n\n        self.play(Unwrite(self.title))\n        new_title = Text(text, font_size=font_size)\n        new_title.move_to(self.title)\n        self.title = new_title\n        self.wait(0.1)\n        self.play(Write(self.title))\n\n    def change_subtitle(self, text, title_location=np.array([0, 0.9, 0]), font_size=20):\n        \"\"\"Changes subtitle to the next algorithm step\"\"\"\n        if self.subtitle is None:\n            self.subtitle = Text(text, font_size=font_size)\n            self.subtitle.move_to(title_location)\n            self.play(Write(self.subtitle))\n            return\n\n        self.play(Unwrite(self.subtitle))\n        new_title = Text(text, font_size=font_size)\n        new_title.move_to(title_location)\n        self.subtitle = new_title\n        self.wait(0.1)\n        self.play(Write(self.subtitle))\n\n    def make_embed_input_image_animation(self, input_image_path, output_image_path):\n        \"\"\"Makes embed input image animation\"\"\"\n        # insert the input image at the begginging\n        input_image_layer = ImageLayer.from_path(input_image_path)\n        input_image_layer.scale(0.6)\n        current_first_layer = self.encoder.all_layers[0]\n        # Get connective layer\n        connective_layer = get_connective_layer(input_image_layer, current_first_layer)\n        # Insert both layers\n        self.encoder.all_layers.insert(0, input_image_layer)\n        self.encoder.all_layers.insert(1, connective_layer)\n        # Move layers to the correct location\n        # TODO: Fix this cause its hacky\n        input_image_layer.shift(DOWN * 0.4)\n        input_image_layer.shift(LEFT * 2.35)\n        # Play full forward pass\n        forward_pass = self.neural_network.make_forward_pass_animation(\n            layer_args={\n                self.encoder: {\n                    self.embedding_layer: {\n                        \"dist_args\": {\n                            \"cov\": np.array([[1.5, 0], [0, 1.5]]),\n                            \"mean\": np.array([0.5, 0.5]),\n                            \"dist_theme\": \"ellipse\",\n                            \"color\": ORANGE,\n                        }\n                    }\n                }\n            }\n        )\n        self.play(forward_pass)\n        # insert the output image at the end\n        output_image_layer = ImageLayer.from_path(output_image_path)\n        output_image_layer.scale(0.6)\n        self.insert_at_end(output_image_layer)\n        # Remove the input and output layers\n        self.remove_start_layer()\n        self.remove_end_layer()\n        # Remove the latent distribution\n        self.play(FadeOut(self.embedding_layer.latent_distribution))\n\n    def make_localization_time_step(self, old_posterior):\n        \"\"\"\n        Performs one query update for the localization procedure\n\n        Procedure:\n        a. Embed query input images\n        b. Oracle is asked a query\n        c. Query is embedded\n        d. Show posterior update\n        e. Show current recomendation\n        \"\"\"\n        # Helper functions\n        def embed_query_to_latent_space(query_locations, query_covariance):\n            \"\"\"Makes animation for a paired query\"\"\"\n            # Assumes first layer of neural network is a PairedQueryLayer\n            # Make the embedding animation\n            # Wait\n            self.play(Wait(1))\n            # Embed the query to latent space\n            self.change_subtitle(\"3. Embed the Query in Latent Space\")\n            # Make forward pass animation\n            self.embedding_layer.paired_query_mode = True\n            # Make embedding embed query animation\n            embed_query_animation = self.encoder.make_forward_pass_animation(\n                run_time=5,\n                layer_args={\n                    self.embedding_layer: {\n                        \"positive_dist_args\": {\n                            \"cov\": query_covariance[0],\n                            \"mean\": query_locations[0],\n                            \"dist_theme\": \"ellipse\",\n                            \"color\": BLUE,\n                        },\n                        \"negative_dist_args\": {\n                            \"cov\": query_covariance[1],\n                            \"mean\": query_locations[1],\n                            \"dist_theme\": \"ellipse\",\n                            \"color\": RED,\n                        },\n                    }\n                },\n            )\n            self.play(embed_query_animation)\n\n        # Access localizer information\n        query_paths, query_locations, posterior_distribution, query_covariances = next(\n            self.localizer\n        )\n        positive_path, negative_path = query_paths\n        # Make subtitle for present user with query\n        self.change_subtitle(\"2. Present User with Query\")\n        # Insert the layer into the encoder\n        query_layer = PairedQueryLayer.from_paths(\n            positive_path, negative_path, grayscale=False\n        )\n        query_layer.scale(0.5)\n        self.insert_at_start(query_layer)\n        # Embed query to latent space\n        query_to_latent_space_animation = embed_query_to_latent_space(\n            query_locations, query_covariances\n        )\n        # Wait\n        self.play(Wait(1))\n        # Update the posterior\n        self.change_subtitle(\"4. Update the Posterior\")\n        # Remove the old posterior\n        self.play(ReplacementTransform(old_posterior, posterior_distribution))\n        \"\"\"\n        self.play(\n            self.embedding_layer.remove_gaussian_distribution(self.localizer.posterior_distribution)\n        )\n        \"\"\"\n        # self.embedding_layer.add_gaussian_distribution(posterior_distribution)\n        # self.localizer.posterior_distribution = posterior_distribution\n        # Remove query layer\n        self.remove_start_layer()\n        # Remove query ellipses\n\n        fade_outs = []\n        for dist in self.embedding_layer.gaussian_distributions:\n            self.embedding_layer.gaussian_distributions.remove(dist)\n            fade_outs.append(FadeOut(dist))\n\n        if not len(fade_outs) == 0:\n            fade_outs = AnimationGroup(*fade_outs)\n            self.play(fade_outs)\n\n        return posterior_distribution\n\n    def make_generate_estimate_animation(self, estimate_image_path):\n        \"\"\"Makes the generate estimate animation\"\"\"\n        # Change embedding layer mode\n        self.embedding_layer.paired_query_mode = False\n        # Sample from posterior distribution\n        # self.embedding_layer.latent_distribution = self.localizer.posterior_distribution\n        emb_to_ff_ind = self.neural_network.all_layers.index_of(self.encoder)\n        embedding_to_ff = self.neural_network.all_layers[emb_to_ff_ind + 1]\n        self.play(embedding_to_ff.make_forward_pass_animation())\n        # Pass through decoder\n        self.play(self.decoder.make_forward_pass_animation(), run_time=1)\n        # Create Image layer after the decoder\n        output_image_layer = ImageLayer.from_path(estimate_image_path)\n        output_image_layer.scale(0.5)\n        self.insert_at_end(output_image_layer)\n        # Wait\n        self.wait(1)\n        # Remove the image at the end\n        print(self.neural_network)\n        self.remove_end_layer()\n\n    def make_triplet_forward_animation(self):\n        \"\"\"Make triplet forward animation\"\"\"\n        # Make triplet layer\n        anchor_path = os.path.join(self.assets_path, \"anchor.jpg\")\n        positive_path = os.path.join(self.assets_path, \"positive.jpg\")\n        negative_path = os.path.join(self.assets_path, \"negative.jpg\")\n        triplet_layer = TripletLayer.from_paths(\n            anchor_path,\n            positive_path,\n            negative_path,\n            grayscale=False,\n            font_size=100,\n            buff=1.05,\n        )\n        triplet_layer.scale(0.10)\n        self.insert_at_start(triplet_layer)\n        # Make latent triplet animation\n        self.play(\n            self.encoder.make_forward_pass_animation(\n                layer_args={\n                    self.embedding_layer: {\n                        \"triplet_args\": {\n                            \"anchor_dist\": {\n                                \"cov\": np.array([[0.3, 0], [0, 0.3]]),\n                                \"mean\": np.array([0.7, 1.4]),\n                                \"dist_theme\": \"ellipse\",\n                                \"color\": BLUE,\n                            },\n                            \"positive_dist\": {\n                                \"cov\": np.array([[0.2, 0], [0, 0.2]]),\n                                \"mean\": np.array([0.8, -0.4]),\n                                \"dist_theme\": \"ellipse\",\n                                \"color\": GREEN,\n                            },\n                            \"negative_dist\": {\n                                \"cov\": np.array([[0.4, 0], [0, 0.25]]),\n                                \"mean\": np.array([-1, -1.2]),\n                                \"dist_theme\": \"ellipse\",\n                                \"color\": RED,\n                            },\n                        }\n                    }\n                },\n                run_time=3,\n            )\n        )\n\n    def construct(self):\n        \"\"\"\n        Makes the whole visualization.\n\n        1. Create the Architecture\n            a. Create the traditional VAE architecture with images\n        2. The Localization Procedure\n        3. The Training Procedure\n        \"\"\"\n        # 1. Create the Architecture\n        self.neural_network.scale(1.2)\n        create_vae = Create(self.neural_network)\n        self.play(create_vae, run_time=3)\n        # Make changing title\n        self.change_title(\"Oracle Guided Image Synthesis\\n      with Relative Queries\")\n        # 2. The Localization Procedure\n        self.change_title(\"The Localization Procedure\")\n        # Make algorithm subtitle\n        self.change_subtitle(\"Algorithm Steps\")\n        # Wait\n        self.play(Wait(1))\n        # Make prior distribution subtitle\n        self.change_subtitle(\"1. Calculate Prior Distribution\")\n        # Draw the prior distribution\n        self.play(Create(self.localizer.prior_distribution))\n        old_posterior = self.localizer.prior_distribution\n        # For N queries update the posterior\n        for query_index in range(self.localizer.num_queries):\n            # Make localization iteration\n            old_posterior = self.make_localization_time_step(old_posterior)\n            self.play(Wait(1))\n            if not query_index == self.localizer.num_queries - 1:\n                # Repeat\n                self.change_subtitle(\"5. Repeat\")\n                # Wait a second\n                self.play(Wait(1))\n        # Generate final estimate\n        self.change_subtitle(\"5. Generate Estimate Image\")\n        # Generate an estimate image\n        estimate_image_path = os.path.join(self.assets_path, \"estimate_image.jpg\")\n        self.make_generate_estimate_animation(estimate_image_path)\n        self.wait(1)\n        # Remove old posterior\n        self.play(FadeOut(old_posterior))\n        # 3. The Training Procedure\n        self.change_title(\"The Training Procedure\")\n        # Make training animation\n        # Do an Image forward pass\n        self.change_subtitle(\"1. Unsupervised Image Reconstruction\")\n        self.make_embed_input_image_animation(\n            self.input_embed_image_path, self.output_embed_image_path\n        )\n        self.wait(1)\n        # Do triplet forward pass\n        self.change_subtitle(\"2. Triplet Loss in Latent Space\")\n        self.make_triplet_forward_animation()\n        self.wait(1)\n", "original_prompt": "Paper Visualizations Oracle Guidance Oracle Guidance"}
{"prompt": "\"Show a 3D neural network with three feedforward layers in different sizes, centered at the origin.\"\n\nNote: This prompt is concise and descriptive, focusing on the key visual element (neural network) without going into technical details.", "response": "from manim import *\n\nfrom manim_ml.neural_network import FeedForwardLayer, NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 700\nconfig.pixel_width = 1200\nconfig.frame_height = 4.0\nconfig.frame_width = 4.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                FeedForwardLayer(num_nodes=3),\n                FeedForwardLayer(num_nodes=5),\n                FeedForwardLayer(num_nodes=3),\n            ]\n        )\n        self.add(nn)\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n", "original_prompt": "Readme Example A Simple Feed Forward Network"}
{"prompt": "\"Animate a 3D neural network with convolutional and feedforward layers unfolding like origami.\"", "response": "from manim import *\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                Convolutional2DLayer(1, 7, filter_spacing=0.32),\n                Convolutional2DLayer(\n                    3, 5, 3, filter_spacing=0.32, activation_function=\"ReLU\"\n                ),\n                FeedForwardLayer(3, activation_function=\"Sigmoid\"),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(ChangeSpeed(forward_pass, speedinfo={}), run_time=10)\n        self.wait(1)\n", "original_prompt": "Readme Example Activation Functions"}
{"prompt": "Animate a neural network diagram that unfolds and processes input data with color filters.", "response": "from manim import *\n\nfrom manim_ml.neural_network import (\n    Convolutional2DLayer,\n    FeedForwardLayer,\n    NeuralNetwork,\n)\n\n# Make the specific scene\nconfig.pixel_height = 700\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                Convolutional2DLayer(1, 7, 3, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n                Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n                FeedForwardLayer(3),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(forward_pass)\n", "original_prompt": "Readme Example Animating The Forward Pass"}
{"prompt": "\"Animate a neural network with layered images and filters transforming through multiple convolutional layers\"", "response": "from manim import *\nfrom PIL import Image\nimport numpy as np\n\nfrom manim_ml.neural_network import (\n    Convolutional2DLayer,\n    FeedForwardLayer,\n    NeuralNetwork,\n    ImageLayer,\n)\n\n# Make the specific scene\nconfig.pixel_height = 700\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        image = Image.open(\"../../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 7, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n                Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n                FeedForwardLayer(3),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(ChangeSpeed(forward_pass, speedinfo={}), run_time=10)\n        self.wait(1)\n", "original_prompt": "Readme Example Convolutional Neural Network With Images"}
{"prompt": "\"Animate a 3D neural network diagram with layers transforming into simplified blocks during a fast-forward simulation.\"", "response": "from manim import *\n\nfrom manim_ml.neural_network import (\n    Convolutional2DLayer,\n    FeedForwardLayer,\n    NeuralNetwork,\n)\n\n# Make the specific scene\nconfig.pixel_height = 700\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                Convolutional2DLayer(1, 7, 3, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n                Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n                FeedForwardLayer(3),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(ChangeSpeed(forward_pass, speedinfo={}), run_time=10)\n", "original_prompt": "Readme Example Convolutional Neural Networks"}
{"prompt": "\"Animate a neural network diagram, with layers unfolding and processing data in a feedforward motion.\"", "response": "from manim import *\n\nfrom manim_ml.neural_network import (\n    Convolutional2DLayer,\n    FeedForwardLayer,\n    NeuralNetwork,\n)\n\n# Make the specific scene\nconfig.pixel_height = 700\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                Convolutional2DLayer(1, 7, 3, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n                Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n                FeedForwardLayer(3),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(forward_pass)\n", "original_prompt": "Readme Example Example"}
{"prompt": "\"Animate a 3D neural network diagram moving into frame while performing forward pass calculations.\"", "response": "from manim import *\n\nfrom manim_ml.neural_network import (\n    Convolutional2DLayer,\n    FeedForwardLayer,\n    NeuralNetwork,\n)\n\n# Make the specific scene\nconfig.pixel_height = 700\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                Convolutional2DLayer(1, 7, 3, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n                Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n                FeedForwardLayer(3),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(forward_pass)\n", "original_prompt": "Readme Example First Neural Network"}
{"prompt": "\"Create a 3D animated neural network that undergoes a series of transformations.\"", "response": "from manim import *\nfrom PIL import Image\nimport numpy as np\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.max_pooling_2d import MaxPooling2DLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass MaxPoolingScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                Convolutional2DLayer(1, 8),\n                Convolutional2DLayer(3, 6, 3),\n                MaxPooling2DLayer(kernel_size=2),\n                Convolutional2DLayer(5, 2, 2),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(ChangeSpeed(forward_pass, speedinfo={}), run_time=10)\n        self.wait(1)\n", "original_prompt": "Readme Example Max Pooling"}
{"prompt": "\"Animate a neural network with multiple layers to fade into a drop-out effect.\"", "response": "from manim import *\nfrom manim_ml.neural_network.animations.dropout import (\n    make_neural_network_dropout_animation,\n)\nfrom manim_ml.neural_network import FeedForwardLayer, NeuralNetwork\n\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 5.0\nconfig.frame_width = 5.0\n\n\nclass DropoutNeuralNetworkScene(Scene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                FeedForwardLayer(3, rectangle_color=BLUE),\n                FeedForwardLayer(5, rectangle_color=BLUE),\n                FeedForwardLayer(3, rectangle_color=BLUE),\n                FeedForwardLayer(5, rectangle_color=BLUE),\n                FeedForwardLayer(4, rectangle_color=BLUE),\n            ],\n            layer_spacing=0.4,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        self.play(\n            make_neural_network_dropout_animation(\n                nn, dropout_rate=0.25, do_forward_pass=True\n            )\n        )\n        self.wait(1)\n", "original_prompt": "Readme Example Neural Network Dropout"}
{"prompt": "\"Draw a neural network diagram with layers of 2D convolutional filters, animated forward pass.\"", "response": "from manim import *\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n\nclass ConvolutionalNetworkScene(Scene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                Convolutional2DLayer(1, 7, 3, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n                Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n                FeedForwardLayer(3),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        self.play(nn.make_forward_pass_animation())\n", "original_prompt": "Readme Example Old Example"}
{"prompt": "Animate a simple 3D text label in space.", "response": "from manim import *\n\n# Import modules here\n\n\nclass BasicScene(ThreeDScene):\n    def construct(self):\n        # Your code goes here\n        text = Text(\"Your first scene!\")\n        self.add(text)\n", "original_prompt": "Readme Example Setting Up A Scene"}
{"prompt": "\"Animate a 3D neural network diagram rotating slowly, with layers transforming and showing image input.\"", "response": "from manim import *\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.layers.parent_layers import ThreeDLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 800\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../../assets/doggo.jpeg\")\n        numpy_image = np.asarray(image)\n        # Rotate the Three D layer position\n        ThreeDLayer.rotation_angle = 15 * DEGREES\n        ThreeDLayer.rotation_axis = [1, -1.0, 0]\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 7, 7, 3, 3, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 5, 1, 1, filter_spacing=0.18),\n            ],\n            layer_spacing=0.25,\n            layout_direction=\"top_to_bottom\",\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        nn.scale(1.5)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation(\n            highlight_active_feature_map=True,\n        )\n        self.wait(1)\n        self.play(forward_pass)\n", "original_prompt": "Translation Equivariance Translation Equivariance"}
{"prompt": "\"Rotate a circle around the origin, then fade it into a square with linear motion.\"", "response": "", "original_prompt": "Variational Autoencoder Autoencoder Models   Init  "}
{"prompt": "Animate a 3D histogram that transforms into a 2D scatter plot of digit images, with fading colors over time.", "response": "import pickle\nimport sys\nimport os\n\nsys.path.append(os.environ[\"PROJECT_ROOT\"])\nfrom autoencoder_models.variational_autoencoder import (\n    VAE,\n    load_dataset,\n    load_vae_from_path,\n)\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nimport scipy\nimport scipy.stats\nimport cv2\n\n\ndef binned_images(model_path, num_x_bins=6, plot=False):\n    latent_dim = 2\n    model = load_vae_from_path(model_path, latent_dim)\n    image_dataset = load_dataset(digit=2)\n    # Compute embedding\n    num_images = 500\n    embedding = []\n    images = []\n    for i in range(num_images):\n        image, _ = image_dataset[i]\n        mean, _, recon, _ = model.forward(image)\n        mean = mean.detach().numpy()\n        recon = recon.detach().numpy()\n        recon = recon.reshape(32, 32)\n        images.append(recon.squeeze())\n        if latent_dim > 2:\n            mean = mean[:2]\n        embedding.append(mean)\n    images = np.stack(images)\n    tsne_points = np.array(embedding)\n    tsne_points = (tsne_points - tsne_points.mean(axis=0)) / (tsne_points.std(axis=0))\n    # make vis\n    num_points = np.shape(tsne_points)[0]\n    x_min = np.amin(tsne_points.T[0])\n    y_min = np.amin(tsne_points.T[1])\n    y_max = np.amax(tsne_points.T[1])\n    x_max = np.amax(tsne_points.T[0])\n    # make the bins from the ranges\n    # to keep it square the same width is used for x and y dim\n    x_bins, step = np.linspace(x_min, x_max, num_x_bins, retstep=True)\n    x_bins = x_bins.astype(float)\n    num_y_bins = np.absolute(np.ceil((y_max - y_min) / step)).astype(int)\n    y_bins = np.linspace(y_min, y_max, num_y_bins)\n    # sort the tsne_points into a 2d histogram\n    tsne_points = tsne_points.squeeze()\n    hist_obj = scipy.stats.binned_statistic_dd(\n        tsne_points,\n        np.arange(num_points),\n        statistic=\"count\",\n        bins=[x_bins, y_bins],\n        expand_binnumbers=True,\n    )\n    # sample one point from each bucket\n    binnumbers = hist_obj.binnumber\n    num_x_bins = np.amax(binnumbers[0]) + 1\n    num_y_bins = np.amax(binnumbers[1]) + 1\n    binnumbers = binnumbers.T\n    # some places have no value in a region\n    used_mask = np.zeros((num_y_bins, num_x_bins))\n    image_bins = np.zeros(\n        (num_y_bins, num_x_bins, 3, np.shape(images)[2], np.shape(images)[2])\n    )\n    for i, bin_num in enumerate(list(binnumbers)):\n        used_mask[bin_num[1], bin_num[0]] = 1\n        image_bins[bin_num[1], bin_num[0]] = images[i]\n    # plot a grid of the images\n    fig, axs = plt.subplots(\n        nrows=np.shape(y_bins)[0],\n        ncols=np.shape(x_bins)[0],\n        constrained_layout=False,\n        dpi=50,\n    )\n    images = []\n    bin_indices = []\n    for y in range(num_y_bins):\n        for x in range(num_x_bins):\n            if used_mask[y, x] > 0.0:\n                image = np.uint8(image_bins[y][x].squeeze() * 255)\n                image = np.rollaxis(image, 0, 3)\n                image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n                axs[num_y_bins - 1 - y][x].imshow(image)\n                images.append(image)\n                bin_indices.append((y, x))\n            axs[y, x].axis(\"off\")\n    if plot:\n        plt.axis(\"off\")\n        plt.show()\n    else:\n        return images, bin_indices\n\n\ndef generate_disentanglement(model_path=\"saved_models/model_dim2.pth\"):\n    \"\"\"Generates disentanglement visualization and serializes it\"\"\"\n    # Disentanglement object\n    disentanglement_object = {}\n    # Make Disentanglement\n    images, bin_indices = binned_images(model_path)\n    disentanglement_object[\"images\"] = images\n    disentanglement_object[\"bin_indices\"] = bin_indices\n    # Serialize Images\n    with open(\"disentanglement.pkl\", \"wb\") as f:\n        pickle.dump(disentanglement_object, f)\n\n\nif __name__ == \"__main__\":\n    plot = False\n    if plot:\n        model_path = \"saved_models/model_dim2.pth\"\n        # uniform_image_sample(model_path)\n        binned_images(model_path)\n    else:\n        generate_disentanglement()\n", "original_prompt": "Variational Autoencoder Autoencoder Models Generate Disentanglement"}
{"prompt": "\"Display MNIST images with their VAE reconstructions side-by-side\"", "response": "import torch\nfrom variational_autoencoder import VAE\nimport matplotlib.pyplot as plt\nfrom torchvision import datasets\nfrom torchvision import transforms\nfrom tqdm import tqdm\nimport numpy as np\nimport pickle\n\n# Load model\nvae = VAE(latent_dim=16)\nvae.load_state_dict(torch.load(\"saved_models/model.pth\"))\n# Transforms images to a PyTorch Tensor\ntensor_transform = transforms.ToTensor()\n# Download the MNIST Dataset\ndataset = datasets.MNIST(\n    root=\"./data\", train=True, download=True, transform=tensor_transform\n)\n# Generate reconstructions\nnum_recons = 10\nfig, axs = plt.subplots(num_recons, 2, figsize=(2, num_recons))\nimage_pairs = []\nfor i in range(num_recons):\n    base_image, _ = dataset[i]\n    base_image = base_image.reshape(-1, 28 * 28)\n    _, _, recon_image, _ = vae.forward(base_image)\n    base_image = base_image.detach().numpy()\n    base_image = np.reshape(base_image, (28, 28)) * 255\n    recon_image = recon_image.detach().numpy()\n    recon_image = np.reshape(recon_image, (28, 28)) * 255\n    # Add to plot\n    axs[i][0].imshow(base_image)\n    axs[i][1].imshow(recon_image)\n    # image pairs\n    image_pairs.append((base_image, recon_image))\n\nwith open(\"image_pairs.pkl\", \"wb\") as f:\n    pickle.dump(image_pairs, f)\n\nplt.show()\n", "original_prompt": "Variational Autoencoder Autoencoder Models Generate Images"}
{"prompt": "Animate a series of smoothly interpolated images between two faces on a grid.", "response": "import torch\nfrom variational_autoencoder import VAE, load_dataset\nimport matplotlib.pyplot as plt\nfrom torchvision import datasets\nfrom torchvision import transforms\nfrom tqdm import tqdm\nimport numpy as np\nimport pickle\n\n# Load model\nvae = VAE(latent_dim=16)\nvae.load_state_dict(torch.load(\"saved_models/model.pth\"))\ndataset = load_dataset()\n# Generate reconstructions\nnum_images = 50\nimage_pairs = []\nsave_object = {\"interpolation_path\": [], \"interpolation_images\": []}\n\n# Make interpolation path\nimage_a, image_b = dataset[0][0], dataset[1][0]\nimage_a = image_a.view(32 * 32)\nimage_b = image_b.view(32 * 32)\nz_a, _, _, _ = vae.forward(image_a)\nz_a = z_a.detach().cpu().numpy()\nz_b, _, _, _ = vae.forward(image_b)\nz_b = z_b.detach().cpu().numpy()\ninterpolation_path = np.linspace(z_a, z_b, num=num_images)\n# interpolation_path[:, 4] = np.linspace(-3, 3, num=num_images)\nsave_object[\"interpolation_path\"] = interpolation_path\n\nfor i in range(num_images):\n    # Generate\n    z = torch.Tensor(interpolation_path[i]).unsqueeze(0)\n    gen_image = vae.decode(z).detach().numpy()\n    gen_image = np.reshape(gen_image, (32, 32)) * 255\n    save_object[\"interpolation_images\"].append(gen_image)\n\nfig, axs = plt.subplots(num_images, 1, figsize=(1, num_images))\nimage_pairs = []\nfor i in range(num_images):\n    recon_image = save_object[\"interpolation_images\"][i]\n    # Add to plot\n    axs[i].imshow(recon_image)\n\n# Perform intrpolations\nwith open(\"interpolations.pkl\", \"wb\") as f:\n    pickle.dump(save_object, f)\n\nplt.show()\n", "original_prompt": "Variational Autoencoder Autoencoder Models Generate Interpolation"}
{"prompt": "Here's a breakdown of what this code does and some suggestions for improvement:\n\n**Overview**\n\nThis code defines a Variational Autoencoder (VAE) using PyTorch. The VAE is trained to reconstruct images from their latent space. The model consists of an encoder that maps the input image to a mean and log variance of a Gaussian distribution in the latent space, and a decoder that samples from this distribution to generate reconstructed images.\n\n**Code Structure**\n\nThe code is organized into several sections:\n\n1. **VAE Model Definition**: This section defines the VAE model using PyTorch.\n2. **Training Loop**: This section implements the training loop for the VAE model.\n3. **Loss Function**: This section defines the loss function used to train the VAE model.\n\n**Code Quality**\n\nThe code is well-organized and follows good practices. However, there are a few areas that could be improved:\n\n* **Variable Naming**: Some variable names could be more descriptive. For example, `x` could be renamed to `input_image`.\n* **Comments**: There are no comments in the code to explain what each section does or how it works.\n* **Error Handling**: The code catches `NaN` values that occur during training but does not provide any further error messages.\n\n**Suggestions for Improvement**\n\n1. **Add Comments**: Add comments to explain what each section of the code does and how it works.\n2. **Improve Variable Names**: Rename variables to be more descriptive, such as `input_image` instead of `x`.\n3. **Error Handling**: Consider adding more error handling to handle cases where training fails or other exceptions occur.\n4. **Plotting Losses**: Instead of only plotting the last 100 values, consider plotting all losses over time to get a better sense of how the model is performing.\n\nHere's an updated version of the code with some of these suggestions:\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nimport torchvision\nimport torchvision.transforms as transforms\n\n# Define the VAE model\nclass VAE(nn.Module):\n    def __init__(self, latent_dim):\n        super(VAE, self).__init__()\n        self.encoder = nn.Sequential(\n            nn.Conv2d(1, 64, kernel_size=3),\n            nn.ReLU(),\n            nn.MaxPool2d(2),\n            nn.Conv2d(64, 128, kernel_size=3),\n            nn.ReLU(),\n            nn.MaxPool2d(2)\n        )\n        self.decoder = nn.Sequential(\n            nn.ConvTranspose2d(128, 128, kernel_size=3),\n            nn.ReLU(),\n            nn.ConvTranspose2d(128, 64, kernel_size=3),\n            nn.ReLU()\n        )\n        self.mean = nn.Linear(128*8*8, latent_dim)\n        self.log_var = nn.Linear(128*8*8, latent_dim)\n\n    def encode(self, x):\n        x = self.encoder(x)\n        x = x.view(-1, 128*8*8)\n        mean = self.mean(x)\n        log_var = self.log_var(x)\n        return mean, log_var\n\n    def decode(self, z):\n        z = z.view(-1, 128, 8, 8)\n        x_recon = torch.sigmoid(self.decoder(z))\n        return x_recon\n\n    def forward(self, x):\n        mean, log_var = self.encode(x)\n        eps = torch.randn_like(mean)\n        z = mean + torch.exp(log_var / 2) * eps\n        x_recon = self.decode(z)\n        return mean, log_var, x_recon\n\n# Define the loss function\ndef loss_function(mean, log_var, reconstructed, original):\n    kl = -0.5 * torch.sum(1 + log_var - mean**2 - log_var.exp(), dim=1).sum()\n    recon = torch.nn.functional.mse_loss(reconstructed, original)\n    return 0.01 * kl + recon\n\n# Train the VAE model\ndef train_model(latent_dim, plot=False):\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    vae = VAE(latent_dim).to(device)\n\n    # Initialize the optimizer and scheduler\n    optimizer = optim.Adam(vae.parameters(), lr=1e-4, weight_decay=0e-8)\n    scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=10, gamma=0.5)\n\n    # Define the data loader\n    train_loader = torch.utils.data.DataLoader(\n        torchvision.datasets.MNIST('~/.pytorch/MNIST_data/', download=True, train=True),\n        batch_size=32,\n        shuffle=True,\n        num_workers=2\n    )\n\n    # Train the model\n    for epoch in range(200):\n        for (image, _) in train_loader:\n            image = image.to(device)\n            mean, log_var, reconstructed = vae(image)\n            loss = 0.01 * torch.sum(log_var) + torch.nn.functional.mse_loss(reconstructed, image)\n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.step()\n\n        scheduler.step()\n\n        if plot:\n            plt.plot(loss.item())\n            plt.show()\n\n# Run the training loop\ntrain_model(2, plot=True)\n```\n\nNote that this is just one possible way to improve the code, and there may be other approaches depending on your specific needs.", "response": "import torch\nfrom torchvision import datasets\nfrom torchvision import transforms\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm\nimport math\n\n\"\"\"\n    These are utility functions that help to calculate the input and output\n    sizes of convolutional neural networks\n\"\"\"\n\n\ndef num2tuple(num):\n    return num if isinstance(num, tuple) else (num, num)\n\n\ndef conv2d_output_shape(h_w, kernel_size=1, stride=1, pad=0, dilation=1):\n    h_w, kernel_size, stride, pad, dilation = (\n        num2tuple(h_w),\n        num2tuple(kernel_size),\n        num2tuple(stride),\n        num2tuple(pad),\n        num2tuple(dilation),\n    )\n    pad = num2tuple(pad[0]), num2tuple(pad[1])\n\n    h = math.floor(\n        (h_w[0] + sum(pad[0]) - dilation[0] * (kernel_size[0] - 1) - 1) / stride[0] + 1\n    )\n    w = math.floor(\n        (h_w[1] + sum(pad[1]) - dilation[1] * (kernel_size[1] - 1) - 1) / stride[1] + 1\n    )\n\n    return h, w\n\n\ndef convtransp2d_output_shape(\n    h_w, kernel_size=1, stride=1, pad=0, dilation=1, out_pad=0\n):\n    h_w, kernel_size, stride, pad, dilation, out_pad = (\n        num2tuple(h_w),\n        num2tuple(kernel_size),\n        num2tuple(stride),\n        num2tuple(pad),\n        num2tuple(dilation),\n        num2tuple(out_pad),\n    )\n    pad = num2tuple(pad[0]), num2tuple(pad[1])\n\n    h = (\n        (h_w[0] - 1) * stride[0]\n        - sum(pad[0])\n        + dialation[0] * (kernel_size[0] - 1)\n        + out_pad[0]\n        + 1\n    )\n    w = (\n        (h_w[1] - 1) * stride[1]\n        - sum(pad[1])\n        + dialation[1] * (kernel_size[1] - 1)\n        + out_pad[1]\n        + 1\n    )\n\n    return h, w\n\n\ndef conv2d_get_padding(h_w_in, h_w_out, kernel_size=1, stride=1, dilation=1):\n    h_w_in, h_w_out, kernel_size, stride, dilation = (\n        num2tuple(h_w_in),\n        num2tuple(h_w_out),\n        num2tuple(kernel_size),\n        num2tuple(stride),\n        num2tuple(dilation),\n    )\n\n    p_h = (\n        (h_w_out[0] - 1) * stride[0]\n        - h_w_in[0]\n        + dilation[0] * (kernel_size[0] - 1)\n        + 1\n    )\n    p_w = (\n        (h_w_out[1] - 1) * stride[1]\n        - h_w_in[1]\n        + dilation[1] * (kernel_size[1] - 1)\n        + 1\n    )\n\n    return (math.floor(p_h / 2), math.ceil(p_h / 2)), (\n        math.floor(p_w / 2),\n        math.ceil(p_w / 2),\n    )\n\n\ndef convtransp2d_get_padding(\n    h_w_in, h_w_out, kernel_size=1, stride=1, dilation=1, out_pad=0\n):\n    h_w_in, h_w_out, kernel_size, stride, dilation, out_pad = (\n        num2tuple(h_w_in),\n        num2tuple(h_w_out),\n        num2tuple(kernel_size),\n        num2tuple(stride),\n        num2tuple(dilation),\n        num2tuple(out_pad),\n    )\n\n    p_h = (\n        -(\n            h_w_out[0]\n            - 1\n            - out_pad[0]\n            - dilation[0] * (kernel_size[0] - 1)\n            - (h_w_in[0] - 1) * stride[0]\n        )\n        / 2\n    )\n    p_w = (\n        -(\n            h_w_out[1]\n            - 1\n            - out_pad[1]\n            - dilation[1] * (kernel_size[1] - 1)\n            - (h_w_in[1] - 1) * stride[1]\n        )\n        / 2\n    )\n\n    return (math.floor(p_h / 2), math.ceil(p_h / 2)), (\n        math.floor(p_w / 2),\n        math.ceil(p_w / 2),\n    )\n\n\ndef load_dataset(train=True, digit=None):\n    # Transforms images to a PyTorch Tensor\n    tensor_transform = transforms.Compose([transforms.Pad(2), transforms.ToTensor()])\n\n    # Download the MNIST Dataset\n    dataset = datasets.MNIST(\n        root=\"./data\", train=train, download=True, transform=tensor_transform\n    )\n    # Load specific image\n    if not digit is None:\n        idx = dataset.train_labels == digit\n        dataset.targets = dataset.targets[idx]\n        dataset.data = dataset.data[idx]\n\n    return dataset\n\n\ndef load_vae_from_path(path, latent_dim):\n    model = VAE(latent_dim)\n    model.load_state_dict(torch.load(path))\n\n    return model\n\n\n# Creating a PyTorch class\n# 28*28 ==> 9 ==> 28*28\nclass VAE(torch.nn.Module):\n    def __init__(self, latent_dim=5, layer_count=4, channels=1):\n        super().__init__()\n        self.latent_dim = latent_dim\n        self.in_shape = 32\n        self.layer_count = layer_count\n        self.channels = channels\n        self.d = 128\n        mul = 1\n        inputs = self.channels\n        out_sizes = [(self.in_shape, self.in_shape)]\n        for i in range(self.layer_count):\n            setattr(self, \"conv%d\" % (i + 1), nn.Conv2d(inputs, self.d * mul, 4, 2, 1))\n            setattr(self, \"conv%d_bn\" % (i + 1), nn.BatchNorm2d(self.d * mul))\n            h_w = (out_sizes[-1][-1], out_sizes[-1][-1])\n            out_sizes.append(\n                conv2d_output_shape(h_w, kernel_size=4, stride=2, pad=1, dilation=1)\n            )\n            inputs = self.d * mul\n            mul *= 2\n\n        self.d_max = inputs\n        self.last_size = out_sizes[-1][-1]\n        self.num_linear = self.last_size**2 * self.d_max\n        # Encoder linear layers\n        self.encoder_mean_linear = nn.Linear(self.num_linear, self.latent_dim)\n        self.encoder_logvar_linear = nn.Linear(self.num_linear, self.latent_dim)\n        # Decoder linear layer\n        self.decoder_linear = nn.Linear(self.latent_dim, self.num_linear)\n\n        mul = inputs // self.d // 2\n\n        for i in range(1, self.layer_count):\n            setattr(\n                self,\n                \"deconv%d\" % (i + 1),\n                nn.ConvTranspose2d(inputs, self.d * mul, 4, 2, 1),\n            )\n            setattr(self, \"deconv%d_bn\" % (i + 1), nn.BatchNorm2d(self.d * mul))\n            inputs = self.d * mul\n            mul //= 2\n\n        setattr(\n            self,\n            \"deconv%d\" % (self.layer_count + 1),\n            nn.ConvTranspose2d(inputs, self.channels, 4, 2, 1),\n        )\n\n    def encode(self, x):\n        if len(x.shape) < 3:\n            x = x.unsqueeze(0)\n        if len(x.shape) < 4:\n            x = x.unsqueeze(1)\n        batch_size = x.shape[0]\n\n        for i in range(self.layer_count):\n            x = F.relu(\n                getattr(self, \"conv%d_bn\" % (i + 1))(\n                    getattr(self, \"conv%d\" % (i + 1))(x)\n                )\n            )\n\n        x = x.view(batch_size, -1)\n\n        mean = self.encoder_mean_linear(x)\n        logvar = self.encoder_logvar_linear(x)\n\n        return mean, logvar\n\n    def decode(self, x):\n        x = x.view(x.shape[0], self.latent_dim)\n        x = self.decoder_linear(x)\n        x = x.view(x.shape[0], self.d_max, self.last_size, self.last_size)\n        # x = self.deconv1_bn(x)\n        x = F.leaky_relu(x, 0.2)\n\n        for i in range(1, self.layer_count):\n            x = F.leaky_relu(\n                getattr(self, \"deconv%d_bn\" % (i + 1))(\n                    getattr(self, \"deconv%d\" % (i + 1))(x)\n                ),\n                0.2,\n            )\n        x = getattr(self, \"deconv%d\" % (self.layer_count + 1))(x)\n        x = torch.sigmoid(x)\n        return x\n\n    def forward(self, x):\n        batch_size = x.shape[0]\n        mean, logvar = self.encode(x)\n        eps = torch.randn(batch_size, self.latent_dim)\n        z = mean + torch.exp(logvar / 2) * eps\n        reconstructed = self.decode(z)\n        return mean, logvar, reconstructed, x\n\n\ndef train_model(latent_dim=16, plot=True, digit=1, epochs=200):\n    dataset = load_dataset(train=True, digit=digit)\n    # DataLoader is used to load the dataset\n    # for training\n    loader = torch.utils.data.DataLoader(dataset=dataset, batch_size=32, shuffle=True)\n    # Model Initialization\n    model = VAE(latent_dim=latent_dim)\n    # Validation using MSE Loss function\n    def loss_function(mean, log_var, reconstructed, original, kl_beta=0.0001):\n        kl = torch.mean(\n            -0.5 * torch.sum(1 + log_var - mean**2 - log_var.exp(), dim=1), dim=0\n        )\n        recon = torch.nn.functional.mse_loss(reconstructed, original)\n        # print(f\"KL Error {kl}, Recon Error {recon}\")\n        return kl_beta * kl + recon\n\n    # Using an Adam Optimizer with lr = 0.1\n    optimizer = torch.optim.Adam(model.parameters(), lr=1e-4, weight_decay=0e-8)\n\n    outputs = []\n    losses = []\n    for epoch in tqdm(range(epochs)):\n        for (image, _) in loader:\n            # Output of Autoencoder\n            mean, log_var, reconstructed, image = model(image)\n            # Calculating the loss function\n            loss = loss_function(mean, log_var, reconstructed, image)\n            # The gradients are set to zero,\n            # the the gradient is computed and stored.\n            # .step() performs parameter update\n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.step()\n            # Storing the losses in a list for plotting\n            if torch.isnan(loss):\n                raise Exception()\n            losses.append(loss.detach().cpu())\n            outputs.append((epochs, image, reconstructed))\n\n    torch.save(\n        model.state_dict(),\n        os.path.join(\n            os.environ[\"PROJECT_ROOT\"],\n            f\"examples/variational_autoencoder/autoencoder_model/saved_models/model_dim{latent_dim}.pth\",\n        ),\n    )\n\n    if plot:\n        # Defining the Plot Style\n        plt.style.use(\"fivethirtyeight\")\n        plt.xlabel(\"Iterations\")\n        plt.ylabel(\"Loss\")\n\n        # Plotting the last 100 values\n        plt.plot(losses)\n        plt.show()\n\n\nif __name__ == \"__main__\":\n    train_model(latent_dim=2, digit=2, epochs=40)\n", "original_prompt": "Variational Autoencoder Autoencoder Models Variational Autoencoder"}
{"prompt": "\"Animate a neural network with multiple layers and inputs, generating an output image.\"", "response": "\"\"\"Autoencoder Manim Visualizations\n\nIn this module I define Manim visualizations for Variational Autoencoders\nand Traditional Autoencoders.\n\n\"\"\"\nfrom pathlib import Path\n\nfrom manim import *\nimport numpy as np\nfrom PIL import Image\nfrom manim_ml.neural_network.layers import EmbeddingLayer\nfrom manim_ml.neural_network.layers import FeedForwardLayer\nfrom manim_ml.neural_network.layers import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nROOT_DIR = Path(__file__).parents[2]\n\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\n\n\nclass VAEScene(Scene):\n    \"\"\"Scene object for a Variational Autoencoder and Autoencoder\"\"\"\n\n    def construct(self):\n        numpy_image = np.asarray(Image.open(ROOT_DIR / \"assets/mnist/digit.jpeg\"))\n        vae = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.4),\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                EmbeddingLayer(dist_theme=\"ellipse\"),\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n                ImageLayer(numpy_image, height=1.4),\n            ]\n        )\n\n        self.play(Create(vae))\n        self.play(vae.make_forward_pass_animation(run_time=15))\n", "original_prompt": "Variational Autoencoder Variational Autoencoder"}
{"prompt": "\"Fade in a square with a smooth animation.\"", "response": "Decorator used to mark methods as overrides for specific Animation types. Should only be used to decorate methods of classes derived from Mobject . Animation overrides get inherited to subclasses of the Mobject who defined\nthem. They don\u2019t override subclasses of the Animation they override. See also add_animation_override() Parameters : animation_class ( type [ Animation ] ) \u2013 The animation to be overridden. Returns : The actual decorator. This marks the method as overriding an animation. Return type : Callable[[Callable], Callable] Examples Example: OverrideAnimationExample   from manim import * class MySquare ( Square ): @override_animation ( FadeIn ) def _fade_in_override ( self , ** kwargs ): return Create ( self , ** kwargs ) class OverrideAnimationExample ( Scene ): def construct ( self ): self . play ( FadeIn ( MySquare ())) class MySquare(Square):\n    @override_animation(FadeIn)\n    def _fade_in_override(self, **kwargs):\n        return Create(self, **kwargs)\n\nclass OverrideAnimationExample(Scene):\n    def construct(self):\n        self.play(FadeIn(MySquare()))", "original_prompt": "override_animation(animation_class)"}
{"prompt": "Animate a square that fades in, scales up, and rotates with coordinate axes.", "response": "Returns either an unchanged animation, or the animation built\nfrom a passed animation factory. Examples >>> from manim import Square , FadeIn >>> s = Square () >>> prepare_animation ( FadeIn ( s )) FadeIn(Square) >>> prepare_animation ( s . animate . scale ( 2 ) . rotate ( 42 )) _MethodAnimation(Square) >>> prepare_animation ( 42 ) Traceback (most recent call last): ... TypeError : Object 42 cannot be converted to an animation Parameters : anim ( Animation | _AnimationBuilder ) Return type : Animation", "original_prompt": "prepare_animation(anim)"}
{"prompt": "Animate a grid of circles that fade in with varying delay times while showing no transformations or animations.", "response": "Bases: Animation Add Mobjects to a scene, without animating them in any other way. This\nis similar to the Scene.add() method, but Add is an\nanimation which can be grouped into other animations. Parameters : mobjects ( Mobject ) \u2013 One Mobject or more to add to a scene. run_time ( float ) \u2013 The duration of the animation after adding the mobjects . Defaults\nto 0, which means this is an instant animation without extra wait time\nafter adding them. **kwargs ( Any ) \u2013 Additional arguments to pass to the parent Animation class. Examples Example: DefaultAddScene   from manim import * class DefaultAddScene ( Scene ): def construct ( self ): text_1 = Text ( \"I was added with Add!\" ) text_2 = Text ( \"Me too!\" ) text_3 = Text ( \"And me!\" ) texts = VGroup ( text_1 , text_2 , text_3 ) . arrange ( DOWN ) rect = SurroundingRectangle ( texts , buff = 0.5 ) self . play ( Create ( rect , run_time = 3.0 ), Succession ( Wait ( 1.0 ), # You can Add a Mobject in the middle of an animation... Add ( text_1 ), Wait ( 1.0 ), # ...or multiple Mobjects at once! Add ( text_2 , text_3 ), ), ) self . wait () class DefaultAddScene(Scene):\n    def construct(self):\n        text_1 = Text(\"I was added with Add!\")\n        text_2 = Text(\"Me too!\")\n        text_3 = Text(\"And me!\")\n        texts = VGroup(text_1, text_2, text_3).arrange(DOWN)\n        rect = SurroundingRectangle(texts, buff=0.5)\n\n        self.play(\n            Create(rect, run_time=3.0),\n            Succession(\n                Wait(1.0),\n                # You can Add a Mobject in the middle of an animation...\n                Add(text_1),\n                Wait(1.0),\n                # ...or multiple Mobjects at once!\n                Add(text_2, text_3),\n            ),\n        )\n        self.wait() Example: AddWithRunTimeScene   from manim import * class AddWithRunTimeScene ( Scene ): def construct ( self ): # A 5x5 grid of circles circles = VGroup ( * [ Circle ( radius = 0.5 ) for _ in range ( 25 )] ) . arrange_in_grid ( 5 , 5 ) self . play ( Succession ( # Add a run_time of 0.2 to wait for 0.2 seconds after # adding the circle, instead of using Wait(0.2) after Add! * [ Add ( circle , run_time = 0.2 ) for circle in circles ], rate_func = smooth , ) ) self . wait () class AddWithRunTimeScene(Scene):\n    def construct(self):\n        # A 5x5 grid of circles\n        circles = VGroup(\n            *[Circle(radius=0.5) for _ in range(25)]\n        ).arrange_in_grid(5, 5)\n\n        self.play(\n            Succession(\n                # Add a run_time of 0.2 to wait for 0.2 seconds after\n                # adding the circle, instead of using Wait(0.2) after Add!\n                *[Add(circle, run_time=0.2) for circle in circles],\n                rate_func=smooth,\n            )\n        )\n        self.wait() Methods begin Begin the animation. clean_up_from_scene Clean up the Scene after finishing the animation. finish Finish the animation. interpolate Set the animation progress. update_mobjects Updates things like starting_mobject, and (for Transforms) target_mobject. Attributes run_time _original__init__ ( * mobjects , run_time = 0.0 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobjects ( Mobject ) run_time ( float ) kwargs ( Any ) Return type : None begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None finish ( ) [source]   Finish the animation. This method gets called when the animation is over. Return type : None interpolate ( alpha ) [source]   Set the animation progress. This method gets called for every frame during an animation. Parameters : alpha ( float ) \u2013 The relative time to set the animation to, 0 meaning the start, 1 meaning\nthe end. Return type : None update_mobjects ( dt ) [source]   Updates things like starting_mobject, and (for\nTransforms) target_mobject.  Note, since typically\n(always?) self.mobject will have its updating\nsuspended during the animation, this will do\nnothing to self.mobject. Parameters : dt ( float ) Return type : None", "original_prompt": "class Add(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Here is a code snippet that demonstrates how to create an animation using the Manim library:\n\n```python\nfrom manim import *\n\nclass MyScene(Scene):\n    def construct(self):\n        # Create a rectangle\n        rect = Rectangle(width=4, height=2)\n\n        # Animate the rectangle's size and color over time\n        self.play(FadeOut(rect), rate_func=linear)\n```\n\nIn this example:\n\n1. We import the necessary classes from Manim.\n2. We create a new class `MyScene` that inherits from `Scene`.\n3. In the `construct` method of our scene, we define what will be animated.\n4. We create a rectangle using the `Rectangle` class and store it in the `rect` variable.\n5. We use the `play` function to animate the `FadeOut` of the rectangle over time.\n6. The `rate_func=linear` parameter specifies that we want to use a linear rate function, which means that the animation will start slowly and speed up over time.\n\nThis code will create an animation where the rectangle is fade out over a period of time with a smooth transition.\n\nYou can modify this code by changing the properties of the rectangle or adding more animations.", "response": "Bases: object An animation. Animations have a fixed time span. Parameters : mobject \u2013 The mobject to be animated. This is not required for all types of animations. lag_ratio \u2013 Defines the delay after which the animation is applied to submobjects. This lag\nis relative to the duration of the animation. This does not influence the total\nruntime of the animation. Instead the runtime of individual animations is\nadjusted so that the complete animation has the defined run time. run_time \u2013 The duration of the animation in seconds. rate_func \u2013 The function defining the animation progress based on the relative runtime (see rate_functions ) . For example rate_func(0.5) is the proportion of the animation that is done\nafter half of the animations run time. Return type : Self reverse_rate_function Reverses the rate function of the animation. Setting reverse_rate_function does not have any effect on remover or introducer . These need to be\nset explicitly if an introducer-animation should be turned into a remover one\nand vice versa. name The name of the animation. This gets displayed while rendering the animation.\nDefaults to <class-name>(<Mobject-name>). remover Whether the given mobject should be removed from the scene after this animation. suspend_mobject_updating Whether updaters of the mobject should be suspended during the animation. Note In the current implementation of this class, the specified rate function is applied\nwithin Animation.interpolate_mobject() call as part of the call to Animation.interpolate_submobject() . For subclasses of Animation that are implemented by overriding interpolate_mobject() , the rate function\nhas to be applied manually (e.g., by passing self.rate_func(alpha) instead\nof just alpha ). Examples Example: LagRatios   from manim import * class LagRatios ( Scene ): def construct ( self ): ratios = [ 0 , 0.1 , 0.5 , 1 , 2 ] # demonstrated lag_ratios # Create dot groups group = VGroup ( * [ Dot () for _ in range ( 4 )]) . arrange_submobjects () groups = VGroup ( * [ group . copy () for _ in ratios ]) . arrange_submobjects ( buff = 1 ) self . add ( groups ) # Label groups self . add ( Text ( \"lag_ratio = \" , font_size = 36 ) . next_to ( groups , UP , buff = 1.5 )) for group , ratio in zip ( groups , ratios ): self . add ( Text ( str ( ratio ), font_size = 36 ) . next_to ( group , UP )) #Animate groups with different lag_ratios self . play ( AnimationGroup ( * [ group . animate ( lag_ratio = ratio , run_time = 1.5 ) . shift ( DOWN * 2 ) for group , ratio in zip ( groups , ratios ) ])) # lag_ratio also works recursively on nested submobjects: self . play ( groups . animate ( run_time = 1 , lag_ratio = 0.1 ) . shift ( UP * 2 )) class LagRatios(Scene):\n    def construct(self):\n        ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios\n\n        # Create dot groups\n        group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()\n        groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)\n        self.add(groups)\n\n        # Label groups\n        self.add(Text(\"lag_ratio = \", font_size=36).next_to(groups, UP, buff=1.5))\n        for group, ratio in zip(groups, ratios):\n            self.add(Text(str(ratio), font_size=36).next_to(group, UP))\n\n        #Animate groups with different lag_ratios\n        self.play(AnimationGroup(*[\n            group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)\n            for group, ratio in zip(groups, ratios)\n        ]))\n\n        # lag_ratio also works recursively on nested submobjects:\n        self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2)) Methods begin Begin the animation. clean_up_from_scene Clean up the Scene after finishing the animation. copy Create a copy of the animation. create_starting_mobject finish Finish the animation. get_all_families_zipped get_all_mobjects Get all mobjects involved in the animation. get_all_mobjects_to_update Get all mobjects to be updated during the animation. get_rate_func Get the rate function of the animation. get_run_time Get the run time of the animation. get_sub_alpha Get the animation progress of any submobjects subanimation. interpolate Set the animation progress. interpolate_mobject Interpolates the mobject of the Animation based on alpha value. interpolate_submobject is_introducer Test if the animation is an introducer. is_remover Test if the animation is a remover. set_default Sets the default values of keyword arguments. set_name Set the name of the animation. set_rate_func Set the rate function of the animation. set_run_time Set the run time of the animation. update_mobjects Updates things like starting_mobject, and (for Transforms) target_mobject. Attributes run_time _setup_scene ( scene ) [source]   Setup up the Scene before starting the animation. This includes to add() the Animation\u2019s Mobject if the animation is an introducer. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None copy ( ) [source]   Create a copy of the animation. Returns : A copy of self Return type : Animation finish ( ) [source]   Finish the animation. This method gets called when the animation is over. Return type : None get_all_mobjects ( ) [source]   Get all mobjects involved in the animation. Ordering must match the ordering of arguments to interpolate_submobject Returns : The sequence of mobjects. Return type : Sequence[ Mobject ] get_all_mobjects_to_update ( ) [source]   Get all mobjects to be updated during the animation. Returns : The list of mobjects to be updated during the animation. Return type : List[ Mobject ] get_rate_func ( ) [source]   Get the rate function of the animation. Returns : The rate function of the animation. Return type : Callable[[float], float] get_run_time ( ) [source]   Get the run time of the animation. Returns : The time the animation takes in seconds. Return type : float get_sub_alpha ( alpha , index , num_submobjects ) [source]   Get the animation progress of any submobjects subanimation. Parameters : alpha ( float ) \u2013 The overall animation progress index ( int ) \u2013 The index of the subanimation. num_submobjects ( int ) \u2013 The total count of subanimations. Returns : The progress of the subanimation. Return type : float interpolate ( alpha ) [source]   Set the animation progress. This method gets called for every frame during an animation. Parameters : alpha ( float ) \u2013 The relative time to set the animation to, 0 meaning the start, 1 meaning\nthe end. Return type : None interpolate_mobject ( alpha ) [source]   Interpolates the mobject of the Animation based on alpha value. Parameters : alpha ( float ) \u2013 A float between 0 and 1 expressing the ratio to which the animation\nis completed. For example, alpha-values of 0, 0.5, and 1 correspond\nto the animation being completed 0%, 50%, and 100%, respectively. Return type : None is_introducer ( ) [source]   Test if the animation is an introducer. Returns : True if the animation is an introducer, False otherwise. Return type : bool is_remover ( ) [source]   Test if the animation is a remover. Returns : True if the animation is a remover, False otherwise. Return type : bool classmethod set_default ( ** kwargs ) [source]   Sets the default values of keyword arguments. If this method is called without any additional keyword\narguments, the original default values of the initialization\nmethod of this class are restored. Parameters : kwargs \u2013 Passing any keyword argument will update the default\nvalues of the keyword arguments of the initialization\nfunction of this class. Return type : None Examples Example: ChangeDefaultAnimation   from manim import * class ChangeDefaultAnimation ( Scene ): def construct ( self ): Rotate . set_default ( run_time = 2 , rate_func = rate_functions . linear ) Indicate . set_default ( color = None ) S = Square ( color = BLUE , fill_color = BLUE , fill_opacity = 0.25 ) self . add ( S ) self . play ( Rotate ( S , PI )) self . play ( Indicate ( S )) Rotate . set_default () Indicate . set_default () class ChangeDefaultAnimation(Scene):\n    def construct(self):\n        Rotate.set_default(run_time=2, rate_func=rate_functions.linear)\n        Indicate.set_default(color=None)\n\n        S = Square(color=BLUE, fill_color=BLUE, fill_opacity=0.25)\n        self.add(S)\n        self.play(Rotate(S, PI))\n        self.play(Indicate(S))\n\n        Rotate.set_default()\n        Indicate.set_default() set_name ( name ) [source]   Set the name of the animation. Parameters : name ( str ) \u2013 The new name of the animation. Returns : self Return type : Animation set_rate_func ( rate_func ) [source]   Set the rate function of the animation. Parameters : rate_func ( Callable [ [ float ] , float ] ) \u2013 The new function defining the animation progress based on the\nrelative runtime (see rate_functions ). Returns : self Return type : Animation set_run_time ( run_time ) [source]   Set the run time of the animation. Parameters : run_time ( float ) \u2013 The new time the animation should take in seconds. note:: ( .. ) \u2013 The run_time of an animation should not be changed while it is already\nrunning. Returns : self Return type : Animation update_mobjects ( dt ) [source]   Updates things like starting_mobject, and (for\nTransforms) target_mobject.  Note, since typically\n(always?) self.mobject will have its updating\nsuspended during the animation, this will do\nnothing to self.mobject. Parameters : dt ( float ) Return type : None", "original_prompt": "class Animation(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Fade in an empty screen over time.\"", "response": "Bases: Animation A \u201cno operation\u201d animation. Parameters : run_time ( float ) \u2013 The amount of time that should pass. stop_condition ( Callable [ [ ] , bool ] | None ) \u2013 A function without positional arguments that evaluates to a boolean.\nThe function is evaluated after every new frame has been rendered.\nPlaying the animation stops after the return value is truthy, or\nafter the specified run_time has passed. frozen_frame ( bool | None ) \u2013 Controls whether or not the wait animation is static, i.e., corresponds\nto a frozen frame. If False is passed, the render loop still\nprogresses through the animation as usual and (among other things)\ncontinues to call updater functions. If None (the default value),\nthe Scene.play() call tries to determine whether the Wait call\ncan be static or not itself via Scene.should_mobjects_update() . kwargs \u2013 Keyword arguments to be passed to the parent class, Animation . rate_func ( Callable [ [ float ] , float ] ) Methods begin Begin the animation. clean_up_from_scene Clean up the Scene after finishing the animation. finish Finish the animation. interpolate Set the animation progress. update_mobjects Updates things like starting_mobject, and (for Transforms) target_mobject. Attributes run_time _original__init__ ( run_time=1 , stop_condition=None , frozen_frame=None , rate_func=<function linear> , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : run_time ( float ) stop_condition ( Callable [ [ ] , bool ] | None ) frozen_frame ( bool | None ) rate_func ( Callable [ [ float ] , float ] ) begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None finish ( ) [source]   Finish the animation. This method gets called when the animation is over. Return type : None interpolate ( alpha ) [source]   Set the animation progress. This method gets called for every frame during an animation. Parameters : alpha ( float ) \u2013 The relative time to set the animation to, 0 meaning the start, 1 meaning\nthe end. Return type : None update_mobjects ( dt ) [source]   Updates things like starting_mobject, and (for\nTransforms) target_mobject.  Note, since typically\n(always?) self.mobject will have its updating\nsuspended during the animation, this will do\nnothing to self.mobject. Parameters : dt ( float ) Return type : None", "original_prompt": "class Wait(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate a square changing into a 3D square with fade-in effect.\"\n\nNote: I've kept the prompt concise and under 20 words, avoiding technical terms like 'class' or 'self'. I've also identified key visual elements (square), transformations (fade-in effect) and mentioned animation sequence.", "response": "Decorator used to mark methods as overrides for specific Animation types. Should only be used to decorate methods of classes derived from Mobject . Animation overrides get inherited to subclasses of the Mobject who defined\nthem. They don\u2019t override subclasses of the Animation they override. See also add_animation_override() Parameters : animation_class ( type [ Animation ] ) \u2013 The animation to be overridden. Returns : The actual decorator. This marks the method as overriding an animation. Return type : Callable[[Callable], Callable] Examples Example: OverrideAnimationExample   from manim import * class MySquare ( Square ): @override_animation ( FadeIn ) def _fade_in_override ( self , ** kwargs ): return Create ( self , ** kwargs ) class OverrideAnimationExample ( Scene ): def construct ( self ): self . play ( FadeIn ( MySquare ())) class MySquare(Square):\n    @override_animation(FadeIn)\n    def _fade_in_override(self, **kwargs):\n        return Create(self, **kwargs)\n\nclass OverrideAnimationExample(Scene):\n    def construct(self):\n        self.play(FadeIn(MySquare()))", "original_prompt": "override_animation(animation_class)"}
{"prompt": "Animate a square scaling and rotating over time with fade-in effect, gradually fading in.", "response": "Returns either an unchanged animation, or the animation built\nfrom a passed animation factory. Examples >>> from manim import Square , FadeIn >>> s = Square () >>> prepare_animation ( FadeIn ( s )) FadeIn(Square) >>> prepare_animation ( s . animate . scale ( 2 ) . rotate ( 42 )) _MethodAnimation(Square) >>> prepare_animation ( 42 ) Traceback (most recent call last): ... TypeError : Object 42 cannot be converted to an animation Parameters : anim ( Animation | _AnimationBuilder ) Return type : Animation", "original_prompt": "prepare_animation(anim)"}
{"prompt": "Animate a square that fades in while showing its own creation.", "response": "Decorator used to mark methods as overrides for specific Animation types. Should only be used to decorate methods of classes derived from Mobject . Animation overrides get inherited to subclasses of the Mobject who defined\nthem. They don\u2019t override subclasses of the Animation they override. See also add_animation_override() Parameters : animation_class ( type [ Animation ] ) \u2013 The animation to be overridden. Returns : The actual decorator. This marks the method as overriding an animation. Return type : Callable[[Callable], Callable] Examples Example: OverrideAnimationExample   from manim import * class MySquare ( Square ): @override_animation ( FadeIn ) def _fade_in_override ( self , ** kwargs ): return Create ( self , ** kwargs ) class OverrideAnimationExample ( Scene ): def construct ( self ): self . play ( FadeIn ( MySquare ())) class MySquare(Square):\n    @override_animation(FadeIn)\n    def _fade_in_override(self, **kwargs):\n        return Create(self, **kwargs)\n\nclass OverrideAnimationExample(Scene):\n    def construct(self):\n        self.play(FadeIn(MySquare()))", "original_prompt": "override_animation(animation_class)"}
{"prompt": "Animate a square morphing into another square with a fade-in effect, applying scale and rotation transformations.", "response": "Returns either an unchanged animation, or the animation built\nfrom a passed animation factory. Examples >>> from manim import Square , FadeIn >>> s = Square () >>> prepare_animation ( FadeIn ( s )) FadeIn(Square) >>> prepare_animation ( s . animate . scale ( 2 ) . rotate ( 42 )) _MethodAnimation(Square) >>> prepare_animation ( 42 ) Traceback (most recent call last): ... TypeError : Object 42 cannot be converted to an animation Parameters : anim ( Animation | _AnimationBuilder ) Return type : Animation", "original_prompt": "prepare_animation(anim)"}
{"prompt": "\"Animate a text object changing color in a circular pattern.\"", "response": "Bases: VGroup Boundary of a VMobject with animated color change. Examples Example: AnimatedBoundaryExample   from manim import * class AnimatedBoundaryExample ( Scene ): def construct ( self ): text = Text ( \"So shiny!\" ) boundary = AnimatedBoundary ( text , colors = [ RED , GREEN , BLUE ], cycle_rate = 3 ) self . add ( text , boundary ) self . wait ( 2 ) class AnimatedBoundaryExample(Scene):\n    def construct(self):\n        text = Text(\"So shiny!\")\n        boundary = AnimatedBoundary(text, colors=[RED, GREEN, BLUE],\n                                    cycle_rate=3)\n        self.add(text, boundary)\n        self.wait(2) Methods full_family_become_partial update_boundary_copies Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( vmobject, colors=[ManimColor('#29ABCA'), ManimColor('#9CDCEB'), ManimColor('#236B8E'), ManimColor('#736357')], max_stroke_width=3, cycle_rate=0.5, back_and_forth=True, draw_rate_func=<function smooth>, fade_rate_func=<function smooth>, **kwargs )   Initialize self.  See help(type(self)) for accurate signature.", "original_prompt": "class AnimatedBoundary(vmobject, colors="}
{"prompt": "Animate a circle tracing its center path with dissolving trail while rotating and shifting in place", "response": "Bases: VMobject Traces the path of a point returned by a function call. Parameters : traced_point_func ( Callable ) \u2013 The function to be traced. stroke_width ( float ) \u2013 The width of the trace. stroke_color ( ParsableManimColor | None ) \u2013 The color of the trace. dissipating_time ( float | None ) \u2013 The time taken for the path to dissipate. Default set to None which disables dissipation. Examples Example: TracedPathExample   from manim import * class TracedPathExample ( Scene ): def construct ( self ): circ = Circle ( color = RED ) . shift ( 4 * LEFT ) dot = Dot ( color = RED ) . move_to ( circ . get_start ()) rolling_circle = VGroup ( circ , dot ) trace = TracedPath ( circ . get_start ) rolling_circle . add_updater ( lambda m : m . rotate ( - 0.3 )) self . add ( trace , rolling_circle ) self . play ( rolling_circle . animate . shift ( 8 * RIGHT ), run_time = 4 , rate_func = linear ) class TracedPathExample(Scene):\n    def construct(self):\n        circ = Circle(color=RED).shift(4*LEFT)\n        dot = Dot(color=RED).move_to(circ.get_start())\n        rolling_circle = VGroup(circ, dot)\n        trace = TracedPath(circ.get_start)\n        rolling_circle.add_updater(lambda m: m.rotate(-0.3))\n        self.add(trace, rolling_circle)\n        self.play(rolling_circle.animate.shift(8*RIGHT), run_time=4, rate_func=linear) Example: DissipatingPathExample   from manim import * class DissipatingPathExample ( Scene ): def construct ( self ): a = Dot ( RIGHT * 2 ) b = TracedPath ( a . get_center , dissipating_time = 0.5 , stroke_opacity = [ 0 , 1 ]) self . add ( a , b ) self . play ( a . animate ( path_arc = PI / 4 ) . shift ( LEFT * 2 )) self . play ( a . animate ( path_arc =- PI / 4 ) . shift ( LEFT * 2 )) self . wait () class DissipatingPathExample(Scene):\n    def construct(self):\n        a = Dot(RIGHT * 2)\n        b = TracedPath(a.get_center, dissipating_time=0.5, stroke_opacity=[0, 1])\n        self.add(a, b)\n        self.play(a.animate(path_arc=PI / 4).shift(LEFT * 2))\n        self.play(a.animate(path_arc=-PI / 4).shift(LEFT * 2))\n        self.wait() Methods update_path Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( traced_point_func , stroke_width = 2 , stroke_color = ManimColor('#FFFFFF') , dissipating_time = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : traced_point_func ( Callable ) stroke_width ( float ) stroke_color ( ParsableManimColor | None ) dissipating_time ( float | None )", "original_prompt": "class TracedPath(traced_point_func, stroke_width=2, stroke_color=ManimColor('#FFFFFF'), dissipating_time=None, **kwargs)"}
{"prompt": "\"Animate a series of animations fading in and out while showing coordinate axes\"\n\nNote: I've identified key visual elements (coordinate axes), transformations (fading in and out), and no mathematical concepts mentioned. This prompt is concise, under 20 words, and avoids technical terms like 'class' or 'self'.", "response": "Bases: Animation Plays a group or series of Animation . Parameters : animations ( Animation | Iterable [ Animation ] | types.GeneratorType [ Animation ] ) \u2013 Sequence of Animation objects to be played. group ( Group | VGroup | OpenGLGroup | OpenGLVGroup ) \u2013 A group of multiple Mobject . run_time ( float | None ) \u2013 The duration of the animation in seconds. rate_func ( Callable [ [ float ] , float ] ) \u2013 The function defining the animation progress based on the relative\nruntime (see rate_functions ) . lag_ratio ( float ) \u2013 Defines the delay after which the animation is applied to submobjects. A lag_ratio of n.nn means the next animation will play when nnn% of the current animation has played.\nDefaults to 0.0, meaning that all animations will be played together. This does not influence the total runtime of the animation. Instead the runtime\nof individual animations is adjusted so that the complete animation has the defined\nrun time. Methods begin Begin the animation. build_animations_with_timings Creates a list of triplets of the form (anim, start_time, end_time). clean_up_from_scene Clean up the Scene after finishing the animation. finish Finish the animation. get_all_mobjects Get all mobjects involved in the animation. init_run_time Calculates the run time of the animation, if different from run_time . interpolate Set the animation progress. update_mobjects Updates things like starting_mobject, and (for Transforms) target_mobject. Attributes run_time _original__init__ ( *animations , group=None , run_time=None , rate_func=<function linear> , lag_ratio=0 , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : animations ( Animation | Iterable [ Animation ] | types.GeneratorType [ Animation ] ) group ( Group | VGroup | OpenGLGroup | OpenGLVGroup ) run_time ( float | None ) rate_func ( Callable [ [ float ] , float ] ) lag_ratio ( float ) Return type : None _setup_scene ( scene ) [source]   Setup up the Scene before starting the animation. This includes to add() the Animation\u2019s Mobject if the animation is an introducer. Parameters : scene \u2013 The scene the animation should be cleaned up from. Return type : None begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None build_animations_with_timings ( ) [source]   Creates a list of triplets of the form (anim, start_time, end_time). Return type : None clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None finish ( ) [source]   Finish the animation. This method gets called when the animation is over. Return type : None get_all_mobjects ( ) [source]   Get all mobjects involved in the animation. Ordering must match the ordering of arguments to interpolate_submobject Returns : The sequence of mobjects. Return type : Sequence[ Mobject ] init_run_time ( run_time ) [source]   Calculates the run time of the animation, if different from run_time . Parameters : run_time \u2013 The duration of the animation in seconds. Returns : The duration of the animation in seconds. Return type : run_time interpolate ( alpha ) [source]   Set the animation progress. This method gets called for every frame during an animation. Parameters : alpha ( float ) \u2013 The relative time to set the animation to, 0 meaning the start, 1 meaning\nthe end. Return type : None update_mobjects ( dt ) [source]   Updates things like starting_mobject, and (for\nTransforms) target_mobject.  Note, since typically\n(always?) self.mobject will have its updating\nsuspended during the animation, this will do\nnothing to self.mobject. Parameters : dt ( float ) Return type : None", "original_prompt": "class AnimationGroup(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a series of dots shifting to the right with a delayed stagger, illustrating a lagged animation effect.", "response": "Bases: AnimationGroup Adjusts the timing of a series of Animation according to lag_ratio . Parameters : animations ( Animation ) \u2013 Sequence of Animation objects to be played. lag_ratio ( float ) \u2013 Defines the delay after which the animation is applied to submobjects. A lag_ratio of n.nn means the next animation will play when nnn% of the current animation has played.\nDefaults to 0.05, meaning that the next animation will begin when 5% of the current\nanimation has played. This does not influence the total runtime of the animation. Instead the runtime\nof individual animations is adjusted so that the complete animation has the defined\nrun time. Examples Example: LaggedStartExample   from manim import * class LaggedStartExample ( Scene ): def construct ( self ): title = Text ( \"lag_ratio = 0.25\" ) . to_edge ( UP ) dot1 = Dot ( point = LEFT * 2 + UP , radius = 0.16 ) dot2 = Dot ( point = LEFT * 2 , radius = 0.16 ) dot3 = Dot ( point = LEFT * 2 + DOWN , radius = 0.16 ) line_25 = DashedLine ( start = LEFT + UP * 2 , end = LEFT + DOWN * 2 , color = RED ) label = Text ( \"25%\" , font_size = 24 ) . next_to ( line_25 , UP ) self . add ( title , dot1 , dot2 , dot3 , line_25 , label ) self . play ( LaggedStart ( dot1 . animate . shift ( RIGHT * 4 ), dot2 . animate . shift ( RIGHT * 4 ), dot3 . animate . shift ( RIGHT * 4 ), lag_ratio = 0.25 , run_time = 4 )) class LaggedStartExample(Scene):\n    def construct(self):\n        title = Text(\"lag_ratio = 0.25\").to_edge(UP)\n\n        dot1 = Dot(point=LEFT * 2 + UP, radius=0.16)\n        dot2 = Dot(point=LEFT * 2, radius=0.16)\n        dot3 = Dot(point=LEFT * 2 + DOWN, radius=0.16)\n        line_25 = DashedLine(\n            start=LEFT + UP * 2,\n            end=LEFT + DOWN * 2,\n            color=RED\n        )\n        label = Text(\"25%\", font_size=24).next_to(line_25, UP)\n        self.add(title, dot1, dot2, dot3, line_25, label)\n\n        self.play(LaggedStart(\n            dot1.animate.shift(RIGHT * 4),\n            dot2.animate.shift(RIGHT * 4),\n            dot3.animate.shift(RIGHT * 4),\n            lag_ratio=0.25,\n            run_time=4\n        )) Methods Attributes run_time _original__init__ ( * animations , lag_ratio = 0.05 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : animations ( Animation ) lag_ratio ( float )", "original_prompt": "class LaggedStart(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a yellow ripple effect around dots and title text that gradually changes color.", "response": "Bases: LaggedStart Plays a series of Animation while mapping a function to submobjects. Parameters : AnimationClass ( Callable [ ... , Animation ] ) \u2013 Animation to apply to mobject. mobject ( Mobject ) \u2013 Mobject whose submobjects the animation, and optionally the function,\nare to be applied. arg_creator ( Callable [ [ Mobject ] , str ] ) \u2013 Function which will be applied to Mobject . run_time ( float ) \u2013 The duration of the animation in seconds. Examples Example: LaggedStartMapExample   from manim import * class LaggedStartMapExample ( Scene ): def construct ( self ): title = Tex ( \"LaggedStartMap\" ) . to_edge ( UP , buff = LARGE_BUFF ) dots = VGroup ( * [ Dot ( radius = 0.16 ) for _ in range ( 35 )] ) . arrange_in_grid ( rows = 5 , cols = 7 , buff = MED_LARGE_BUFF ) self . add ( dots , title ) # Animate yellow ripple effect for mob in dots , title : self . play ( LaggedStartMap ( ApplyMethod , mob , lambda m : ( m . set_color , YELLOW ), lag_ratio = 0.1 , rate_func = there_and_back , run_time = 2 )) class LaggedStartMapExample(Scene):\n    def construct(self):\n        title = Tex(\"LaggedStartMap\").to_edge(UP, buff=LARGE_BUFF)\n        dots = VGroup(\n            *[Dot(radius=0.16) for _ in range(35)]\n            ).arrange_in_grid(rows=5, cols=7, buff=MED_LARGE_BUFF)\n        self.add(dots, title)\n\n        # Animate yellow ripple effect\n        for mob in dots, title:\n            self.play(LaggedStartMap(\n                ApplyMethod, mob,\n                lambda m : (m.set_color, YELLOW),\n                lag_ratio = 0.1,\n                rate_func = there_and_back,\n                run_time = 2\n            )) Methods Attributes run_time _original__init__ ( AnimationClass , mobject , arg_creator = None , run_time = 2 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : AnimationClass ( Callable [ [ ... ] , Animation ] ) mobject ( Mobject ) arg_creator ( Callable [ [ Mobject ] , str ] ) run_time ( float ) Return type : None", "original_prompt": "class LaggedStartMap(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a series of dots moving in succession with smooth transitions between them.", "response": "Bases: AnimationGroup Plays a series of animations in succession. Parameters : animations ( Animation ) \u2013 Sequence of Animation objects to be played. lag_ratio ( float ) \u2013 Defines the delay after which the animation is applied to submobjects. A lag_ratio of n.nn means the next animation will play when nnn% of the current animation has played.\nDefaults to 1.0, meaning that the next animation will begin when 100% of the current\nanimation has played. This does not influence the total runtime of the animation. Instead the runtime\nof individual animations is adjusted so that the complete animation has the defined\nrun time. Examples Example: SuccessionExample   from manim import * class SuccessionExample ( Scene ): def construct ( self ): dot1 = Dot ( point = LEFT * 2 + UP * 2 , radius = 0.16 , color = BLUE ) dot2 = Dot ( point = LEFT * 2 + DOWN * 2 , radius = 0.16 , color = MAROON ) dot3 = Dot ( point = RIGHT * 2 + DOWN * 2 , radius = 0.16 , color = GREEN ) dot4 = Dot ( point = RIGHT * 2 + UP * 2 , radius = 0.16 , color = YELLOW ) self . add ( dot1 , dot2 , dot3 , dot4 ) self . play ( Succession ( dot1 . animate . move_to ( dot2 ), dot2 . animate . move_to ( dot3 ), dot3 . animate . move_to ( dot4 ), dot4 . animate . move_to ( dot1 ) )) class SuccessionExample(Scene):\n    def construct(self):\n        dot1 = Dot(point=LEFT * 2 + UP * 2, radius=0.16, color=BLUE)\n        dot2 = Dot(point=LEFT * 2 + DOWN * 2, radius=0.16, color=MAROON)\n        dot3 = Dot(point=RIGHT * 2 + DOWN * 2, radius=0.16, color=GREEN)\n        dot4 = Dot(point=RIGHT * 2 + UP * 2, radius=0.16, color=YELLOW)\n        self.add(dot1, dot2, dot3, dot4)\n\n        self.play(Succession(\n            dot1.animate.move_to(dot2),\n            dot2.animate.move_to(dot3),\n            dot3.animate.move_to(dot4),\n            dot4.animate.move_to(dot1)\n        )) Methods begin Begin the animation. finish Finish the animation. interpolate Set the animation progress. next_animation Proceeds to the next animation. update_active_animation update_mobjects Updates things like starting_mobject, and (for Transforms) target_mobject. Attributes run_time _original__init__ ( * animations , lag_ratio = 1 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : animations ( Animation ) lag_ratio ( float ) Return type : None _setup_scene ( scene ) [source]   Setup up the Scene before starting the animation. This includes to add() the Animation\u2019s Mobject if the animation is an introducer. Parameters : scene \u2013 The scene the animation should be cleaned up from. Return type : None begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None finish ( ) [source]   Finish the animation. This method gets called when the animation is over. Return type : None interpolate ( alpha ) [source]   Set the animation progress. This method gets called for every frame during an animation. Parameters : alpha ( float ) \u2013 The relative time to set the animation to, 0 meaning the start, 1 meaning\nthe end. Return type : None next_animation ( ) [source]   Proceeds to the next animation. This method is called right when the active animation finishes. Return type : None update_mobjects ( dt ) [source]   Updates things like starting_mobject, and (for\nTransforms) target_mobject.  Note, since typically\n(always?) self.mobject will have its updating\nsuspended during the animation, this will do\nnothing to self.mobject. Parameters : dt ( float ) Return type : None", "original_prompt": "class Succession(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Display a single letter on screen, then fade in subsequent letters at a specified interval.\"", "response": "Bases: ShowIncreasingSubsets Show a Text letter by letter on the scene. Parameters : time_per_char ( float ) \u2013 Frequency of appearance of the letters. tip:: ( .. ) \u2013 This is currently only possible for class: ~.Text and not for class: ~.MathTex text ( Text ) suspend_mobject_updating ( bool ) int_func ( Callable [ [ np.ndarray ] , np.ndarray ] ) rate_func ( Callable [ [ float ] , float ] ) run_time ( float | None ) Methods Attributes run_time _original__init__ ( text , suspend_mobject_updating=False , int_func=<ufunc 'ceil'> , rate_func=<function linear> , time_per_char=0.1 , run_time=None , reverse_rate_function=False , introducer=True , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : text ( Text ) suspend_mobject_updating ( bool ) int_func ( Callable [ [ np.ndarray ] , np.ndarray ] ) rate_func ( Callable [ [ float ] , float ] ) time_per_char ( float ) run_time ( float | None ) Return type : None", "original_prompt": "class AddTextLetterByLetter(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Display a single word of 'Succession' on the screen, then another, in sequential animation.\"", "response": "Bases: Succession Show a Text word by word on the scene. Note: currently broken. Methods Attributes run_time Parameters : text_mobject ( Text ) run_time ( float ) time_per_char ( float ) _original__init__ ( text_mobject , run_time = None , time_per_char = 0.06 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : text_mobject ( Text ) run_time ( float ) time_per_char ( float ) Return type : None", "original_prompt": "class AddTextWordByWord(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a square that appears and grows with introduction of a VMobject.", "response": "Bases: ShowPartial Incrementally show a VMobject. Parameters : mobject ( VMobject | OpenGLVMobject | OpenGLSurface ) \u2013 The VMobject to animate. lag_ratio ( float ) introducer ( bool ) Raises : TypeError \u2013 If mobject is not an instance of VMobject . Examples Example: CreateScene   from manim import * class CreateScene ( Scene ): def construct ( self ): self . play ( Create ( Square ())) class CreateScene(Scene):\n    def construct(self):\n        self.play(Create(Square())) See also ShowPassingFlash Methods Attributes run_time _original__init__ ( mobject , lag_ratio = 1.0 , introducer = True , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( VMobject | OpenGLVMobject | OpenGLSurface ) lag_ratio ( float ) introducer ( bool ) Return type : None", "original_prompt": "class Create(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Show a square's border and then fill it with orange, gradually revealing its outline.\"", "response": "Bases: Animation Draw the border first and then show the fill. Examples Example: ShowDrawBorderThenFill   from manim import * class ShowDrawBorderThenFill ( Scene ): def construct ( self ): self . play ( DrawBorderThenFill ( Square ( fill_opacity = 1 , fill_color = ORANGE ))) class ShowDrawBorderThenFill(Scene):\n    def construct(self):\n        self.play(DrawBorderThenFill(Square(fill_opacity=1, fill_color=ORANGE))) Methods begin Begin the animation. get_all_mobjects Get all mobjects involved in the animation. get_outline get_stroke_color interpolate_submobject Attributes run_time Parameters : vmobject ( VMobject | OpenGLVMobject ) run_time ( float ) rate_func ( Callable [ [ float ] , float ] ) stroke_width ( float ) stroke_color ( str ) draw_border_animation_config ( dict ) fill_animation_config ( dict ) introducer ( bool ) _original__init__ ( vmobject , run_time=2 , rate_func=<function double_smooth> , stroke_width=2 , stroke_color=None , draw_border_animation_config={} , fill_animation_config={} , introducer=True , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : vmobject ( VMobject | OpenGLVMobject ) run_time ( float ) rate_func ( Callable [ [ float ] , float ] ) stroke_width ( float ) stroke_color ( str ) draw_border_animation_config ( dict ) fill_animation_config ( dict ) introducer ( bool ) Return type : None begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None get_all_mobjects ( ) [source]   Get all mobjects involved in the animation. Ordering must match the ordering of arguments to interpolate_submobject Returns : The sequence of mobjects. Return type : Sequence[ Mobject ]", "original_prompt": "class DrawBorderThenFill(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Remove text letter by letter from the scene.\" \n\nThis prompt captures the main action of removing individual letters from a displayed text, which is a key visual element in the animation. It also implies some level of transformation or interaction with the text, without specifying details about the underlying mathematical concepts.", "response": "Bases: AddTextLetterByLetter Remove a Text letter by letter from the scene. Parameters : time_per_char ( float ) \u2013 Frequency of appearance of the letters. tip:: ( .. ) \u2013 This is currently only possible for class: ~.Text and not for class: ~.MathTex text ( Text ) suspend_mobject_updating ( bool ) int_func ( Callable [ [ np.ndarray ] , np.ndarray ] ) rate_func ( Callable [ [ float ] , float ] ) run_time ( float | None ) Methods Attributes run_time _original__init__ ( text , suspend_mobject_updating=False , int_func=<ufunc 'ceil'> , rate_func=<function linear> , time_per_char=0.1 , run_time=None , reverse_rate_function=True , introducer=False , remover=True , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : text ( Text ) suspend_mobject_updating ( bool ) int_func ( Callable [ [ np.ndarray ] , np.ndarray ] ) rate_func ( Callable [ [ float ] , float ] ) time_per_char ( float ) run_time ( float | None ) Return type : None", "original_prompt": "class RemoveTextLetterByLetter(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a sequence of shapes (dot, square, triangle) emerging from the screen, each transforming into its next shape in an increasing order while showing a gradual fade-out effect with their sizes decreasing over time.", "response": "Bases: Animation Show one submobject at a time, leaving all previous ones displayed on screen. Examples Example: ShowIncreasingSubsetsScene   from manim import * class ShowIncreasingSubsetsScene ( Scene ): def construct ( self ): p = VGroup ( Dot (), Square (), Triangle ()) self . add ( p ) self . play ( ShowIncreasingSubsets ( p )) self . wait () class ShowIncreasingSubsetsScene(Scene):\n    def construct(self):\n        p = VGroup(Dot(), Square(), Triangle())\n        self.add(p)\n        self.play(ShowIncreasingSubsets(p))\n        self.wait() Methods interpolate_mobject Interpolates the mobject of the Animation based on alpha value. update_submobject_list Attributes run_time Parameters : group ( Mobject ) suspend_mobject_updating ( bool ) int_func ( Callable [ [ np.ndarray ] , np.ndarray ] ) _original__init__ ( group , suspend_mobject_updating=False , int_func=<ufunc 'floor'> , reverse_rate_function=False , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : group ( Mobject ) suspend_mobject_updating ( bool ) int_func ( Callable [ [ ndarray ] , ndarray ] ) Return type : None interpolate_mobject ( alpha ) [source]   Interpolates the mobject of the Animation based on alpha value. Parameters : alpha ( float ) \u2013 A float between 0 and 1 expressing the ratio to which the animation\nis completed. For example, alpha-values of 0, 0.5, and 1 correspond\nto the animation being completed 0%, 50%, and 100%, respectively. Return type : None", "original_prompt": "class ShowIncreasingSubsets(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Show a rotating sphere that smoothly appears with flashes of its outline, starting from an empty space.\"", "response": "Bases: Animation Abstract class for Animations that show the VMobject partially. Raises : TypeError \u2013 If mobject is not an instance of VMobject . Parameters : mobject ( VMobject | OpenGLVMobject | OpenGLSurface | None ) See also Create , ShowPassingFlash Methods interpolate_submobject Attributes run_time _original__init__ ( mobject , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( VMobject | OpenGLVMobject | OpenGLSurface | None )", "original_prompt": "class ShowPartial(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Display a sequence of subsets in a set, each with increasing size and number.\"\n\n(Note: This prompt focuses on the visual elements of subsets within a set, but does not mention any transformations or mathematical concepts.)", "response": "Bases: ShowIncreasingSubsets Show one submobject at a time, removing all previously displayed ones from screen. Methods update_submobject_list Attributes run_time Parameters : group ( Iterable [ Mobject ] ) int_func ( Callable [ [ np.ndarray ] , np.ndarray ] ) _original__init__ ( group , int_func=<ufunc 'ceil'> , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : group ( Iterable [ Mobject ] ) int_func ( Callable [ [ ndarray ] , ndarray ] ) Return type : None", "original_prompt": "class ShowSubmobjectsOneByOne(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate a VGroup of shapes flying in on spiral trajectories with fading.\"", "response": "Bases: Animation Create the Mobject with sub-Mobjects flying in on spiral trajectories. Parameters : shapes ( Mobject ) \u2013 The Mobject on which to be operated. scale_factor ( float ) \u2013 The factor used for scaling the effect. fade_in_fraction \u2013 Fractional duration of initial fade-in of sub-Mobjects as they fly inward. Examples Example: SpiralInExample   from manim import * class SpiralInExample ( Scene ): def construct ( self ): pi = MathTex ( r \"\\pi\" ) . scale ( 7 ) pi . shift ( 2.25 * LEFT + 1.5 * UP ) circle = Circle ( color = GREEN_C , fill_opacity = 1 ) . shift ( LEFT ) square = Square ( color = BLUE_D , fill_opacity = 1 ) . shift ( UP ) shapes = VGroup ( pi , circle , square ) self . play ( SpiralIn ( shapes )) class SpiralInExample(Scene):\n    def construct(self):\n        pi = MathTex(r\"\\pi\").scale(7)\n        pi.shift(2.25 * LEFT + 1.5 * UP)\n        circle = Circle(color=GREEN_C, fill_opacity=1).shift(LEFT)\n        square = Square(color=BLUE_D, fill_opacity=1).shift(UP)\n        shapes = VGroup(pi, circle, square)\n        self.play(SpiralIn(shapes)) Methods interpolate_mobject Interpolates the mobject of the Animation based on alpha value. Attributes run_time _original__init__ ( shapes , scale_factor = 8 , fade_in_fraction = 0.3 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : shapes ( Mobject ) scale_factor ( float ) Return type : None interpolate_mobject ( alpha ) [source]   Interpolates the mobject of the Animation based on alpha value. Parameters : alpha ( float ) \u2013 A float between 0 and 1 expressing the ratio to which the animation\nis completed. For example, alpha-values of 0, 0.5, and 1 correspond\nto the animation being completed 0%, 50%, and 100%, respectively. Return type : None", "original_prompt": "class SpiralIn(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate a text with flashing cursor that gradually appears letter by letter, with customizable timing and cursor position.\"", "response": "Bases: AddTextLetterByLetter Similar to AddTextLetterByLetter , but with an additional cursor mobject at the end. Parameters : time_per_char ( float ) \u2013 Frequency of appearance of the letters. cursor ( Mobject ) \u2013 Mobject shown after the last added letter. buff ( float ) \u2013 Controls how far away the cursor is to the right of the last added letter. keep_cursor_y ( bool ) \u2013 If True , the cursor\u2019s y-coordinate is set to the center of the Text and remains the same throughout the animation. Otherwise, it is set to the center of the last added letter. leave_cursor_on ( bool ) \u2013 Whether to show the cursor after the animation. tip:: ( .. ) \u2013 This is currently only possible for class: ~.Text and not for class: ~.MathTex . text ( Text ) Examples Example: InsertingTextExample   from manim import * class InsertingTextExample ( Scene ): def construct ( self ): text = Text ( \"Inserting\" , color = PURPLE ) . scale ( 1.5 ) . to_edge ( LEFT ) cursor = Rectangle ( color = GREY_A , fill_color = GREY_A , fill_opacity = 1.0 , height = 1.1 , width = 0.5 , ) . move_to ( text [ 0 ]) # Position the cursor self . play ( TypeWithCursor ( text , cursor )) self . play ( Blink ( cursor , blinks = 2 )) class InsertingTextExample(Scene):\n    def construct(self):\n        text = Text(\"Inserting\", color=PURPLE).scale(1.5).to_edge(LEFT)\n        cursor = Rectangle(\n            color = GREY_A,\n            fill_color = GREY_A,\n            fill_opacity = 1.0,\n            height = 1.1,\n            width = 0.5,\n        ).move_to(text[0]) # Position the cursor\n\n        self.play(TypeWithCursor(text, cursor))\n        self.play(Blink(cursor, blinks=2)) References: Blink Methods begin Begin the animation. clean_up_from_scene Clean up the Scene after finishing the animation. finish Finish the animation. update_submobject_list Attributes run_time _original__init__ ( text , cursor , buff = 0.1 , keep_cursor_y = True , leave_cursor_on = True , time_per_char = 0.1 , reverse_rate_function = False , introducer = True , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : text ( Text ) cursor ( Mobject ) buff ( float ) keep_cursor_y ( bool ) leave_cursor_on ( bool ) time_per_char ( float ) Return type : None begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None finish ( ) [source]   Finish the animation. This method gets called when the animation is over. Return type : None", "original_prompt": "class TypeWithCursor(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Uncreate a square that disappears.\"\n\n(Note: This prompt is concise and under 20 words, and it accurately describes the animation being created without using technical terms like 'class' or 'self'.)", "response": "Bases: Create Like Create but in reverse. Examples Example: ShowUncreate   from manim import * class ShowUncreate ( Scene ): def construct ( self ): self . play ( Uncreate ( Square ())) class ShowUncreate(Scene):\n    def construct(self):\n        self.play(Uncreate(Square())) See also Create Methods Attributes run_time Parameters : mobject ( VMobject | OpenGLVMobject ) reverse_rate_function ( bool ) remover ( bool ) _original__init__ ( mobject , reverse_rate_function = True , remover = True , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( VMobject | OpenGLVMobject ) reverse_rate_function ( bool ) remover ( bool ) Return type : None", "original_prompt": "class Uncreate(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Fade out 'Deleting' text, followed by a blinking grey cursor that moves along the last letter, with a purple color gradient.\"", "response": "Bases: TypeWithCursor Similar to RemoveTextLetterByLetter , but with an additional cursor mobject at the end. Parameters : time_per_char ( float ) \u2013 Frequency of appearance of the letters. cursor ( VMobject | None ) \u2013 Mobject shown after the last added letter. buff \u2013 Controls how far away the cursor is to the right of the last added letter. keep_cursor_y \u2013 If True , the cursor\u2019s y-coordinate is set to the center of the Text and remains the same throughout the animation. Otherwise, it is set to the center of the last added letter. leave_cursor_on \u2013 Whether to show the cursor after the animation. tip:: ( .. ) \u2013 This is currently only possible for class: ~.Text and not for class: ~.MathTex . text ( Text ) Examples Example: DeletingTextExample   from manim import * class DeletingTextExample ( Scene ): def construct ( self ): text = Text ( \"Deleting\" , color = PURPLE ) . scale ( 1.5 ) . to_edge ( LEFT ) cursor = Rectangle ( color = GREY_A , fill_color = GREY_A , fill_opacity = 1.0 , height = 1.1 , width = 0.5 , ) . move_to ( text [ 0 ]) # Position the cursor self . play ( UntypeWithCursor ( text , cursor )) self . play ( Blink ( cursor , blinks = 2 )) class DeletingTextExample(Scene):\n    def construct(self):\n        text = Text(\"Deleting\", color=PURPLE).scale(1.5).to_edge(LEFT)\n        cursor = Rectangle(\n            color = GREY_A,\n            fill_color = GREY_A,\n            fill_opacity = 1.0,\n            height = 1.1,\n            width = 0.5,\n        ).move_to(text[0]) # Position the cursor\n\n        self.play(UntypeWithCursor(text, cursor))\n        self.play(Blink(cursor, blinks=2)) References: Blink Methods Attributes run_time _original__init__ ( text , cursor = None , time_per_char = 0.1 , reverse_rate_function = True , introducer = False , remover = True , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : text ( Text ) cursor ( VMobject | None ) time_per_char ( float ) Return type : None", "original_prompt": "class UntypeWithCursor(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Simulate erasing a text bubble by hand, reversing the direction of erasure.\"\n\nOr, in a more detailed format:\n\n\"Draw a large 'Alice and Bob' text, then animate its erasure in reverse order.\"", "response": "Bases: Write Simulate erasing by hand a Text or a VMobject . Parameters : reverse ( bool ) \u2013 Set True to have the animation start erasing from the last submobject first. vmobject ( VMobject ) rate_func ( Callable [ [ float ] , float ] ) Examples Example: UnwriteReverseTrue   from manim import * class UnwriteReverseTrue ( Scene ): def construct ( self ): text = Tex ( \"Alice and Bob\" ) . scale ( 3 ) self . add ( text ) self . play ( Unwrite ( text )) class UnwriteReverseTrue(Scene):\n    def construct(self):\n        text = Tex(\"Alice and Bob\").scale(3)\n        self.add(text)\n        self.play(Unwrite(text)) Example: UnwriteReverseFalse   from manim import * class UnwriteReverseFalse ( Scene ): def construct ( self ): text = Tex ( \"Alice and Bob\" ) . scale ( 3 ) self . add ( text ) self . play ( Unwrite ( text , reverse = False )) class UnwriteReverseFalse(Scene):\n    def construct(self):\n        text = Tex(\"Alice and Bob\").scale(3)\n        self.add(text)\n        self.play(Unwrite(text, reverse=False)) Methods Attributes run_time _original__init__ ( vmobject , rate_func=<function linear> , reverse=True , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : vmobject ( VMobject ) rate_func ( Callable [ [ float ] , float ] ) reverse ( bool ) Return type : None", "original_prompt": "class Unwrite(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a bold \"Hello\" text writing and erasing sequence with customizable reverse option.", "response": "Bases: DrawBorderThenFill Simulate hand-writing a Text or hand-drawing a VMobject . Examples Example: ShowWrite   from manim import * class ShowWrite ( Scene ): def construct ( self ): self . play ( Write ( Text ( \"Hello\" , font_size = 144 ))) class ShowWrite(Scene):\n    def construct(self):\n        self.play(Write(Text(\"Hello\", font_size=144))) Example: ShowWriteReversed   from manim import * class ShowWriteReversed ( Scene ): def construct ( self ): self . play ( Write ( Text ( \"Hello\" , font_size = 144 ), reverse = True , remover = False )) class ShowWriteReversed(Scene):\n    def construct(self):\n        self.play(Write(Text(\"Hello\", font_size=144), reverse=True, remover=False)) Tests Check that creating empty Write animations works: >>> from manim import Write , Text >>> Write ( Text ( '' )) Write(Text('')) Methods begin Begin the animation. finish Finish the animation. reverse_submobjects Attributes run_time Parameters : vmobject ( VMobject | OpenGLVMobject ) rate_func ( Callable [ [ float ] , float ] ) reverse ( bool ) _original__init__ ( vmobject , rate_func=<function linear> , reverse=False , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : vmobject ( VMobject | OpenGLVMobject ) rate_func ( Callable [ [ float ] , float ] ) reverse ( bool ) Return type : None begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None finish ( ) [source]   Finish the animation. This method gets called when the animation is over. Return type : None", "original_prompt": "class Write(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a dot that fades into view with various parameters, showcasing the effects of shift, target position, and scale on the fade-in animation.", "response": "Bases: _Fade Fade in Mobject s. Parameters : mobjects ( Mobject ) \u2013 The mobjects to be faded in. shift \u2013 The vector by which the mobject shifts while being faded in. target_position \u2013 The position from which the mobject starts while being faded in. In case\nanother mobject is given as target position, its center is used. scale \u2013 The factor by which the mobject is scaled initially before being rescaling to\nits original size while being faded in. Examples Example: FadeInExample   from manim import * class FadeInExample ( Scene ): def construct ( self ): dot = Dot ( UP * 2 + LEFT ) self . add ( dot ) tex = Tex ( \"FadeIn with \" , \"shift \" , r \" or target\\_position\" , \" and scale\" ) . scale ( 1 ) animations = [ FadeIn ( tex [ 0 ]), FadeIn ( tex [ 1 ], shift = DOWN ), FadeIn ( tex [ 2 ], target_position = dot ), FadeIn ( tex [ 3 ], scale = 1.5 ), ] self . play ( AnimationGroup ( * animations , lag_ratio = 0.5 )) class FadeInExample(Scene):\n    def construct(self):\n        dot = Dot(UP * 2 + LEFT)\n        self.add(dot)\n        tex = Tex(\n            \"FadeIn with \", \"shift \", r\" or target\\_position\", \" and scale\"\n        ).scale(1)\n        animations = [\n            FadeIn(tex[0]),\n            FadeIn(tex[1], shift=DOWN),\n            FadeIn(tex[2], target_position=dot),\n            FadeIn(tex[3], scale=1.5),\n        ]\n        self.play(AnimationGroup(*animations, lag_ratio=0.5)) Methods create_starting_mobject create_target Attributes path_arc path_func run_time _original__init__ ( * mobjects , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobjects ( Mobject ) Return type : None", "original_prompt": "class FadeIn(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Fade out text with shifting and scaling, demonstrating vector transformations and animation sequence.\"", "response": "Bases: _Fade Fade out Mobject s. Parameters : mobjects ( Mobject ) \u2013 The mobjects to be faded out. shift \u2013 The vector by which the mobject shifts while being faded out. target_position \u2013 The position to which the mobject moves while being faded out. In case another\nmobject is given as target position, its center is used. scale \u2013 The factor by which the mobject is scaled while being faded out. Examples Example: FadeInExample   from manim import * class FadeInExample ( Scene ): def construct ( self ): dot = Dot ( UP * 2 + LEFT ) self . add ( dot ) tex = Tex ( \"FadeOut with \" , \"shift \" , r \" or target\\_position\" , \" and scale\" ) . scale ( 1 ) animations = [ FadeOut ( tex [ 0 ]), FadeOut ( tex [ 1 ], shift = DOWN ), FadeOut ( tex [ 2 ], target_position = dot ), FadeOut ( tex [ 3 ], scale = 0.5 ), ] self . play ( AnimationGroup ( * animations , lag_ratio = 0.5 )) class FadeInExample(Scene):\n    def construct(self):\n        dot = Dot(UP * 2 + LEFT)\n        self.add(dot)\n        tex = Tex(\n            \"FadeOut with \", \"shift \", r\" or target\\_position\", \" and scale\"\n        ).scale(1)\n        animations = [\n            FadeOut(tex[0]),\n            FadeOut(tex[1], shift=DOWN),\n            FadeOut(tex[2], target_position=dot),\n            FadeOut(tex[3], scale=0.5),\n        ]\n        self.play(AnimationGroup(*animations, lag_ratio=0.5)) Methods clean_up_from_scene Clean up the Scene after finishing the animation. create_target Attributes path_arc path_func run_time _original__init__ ( * mobjects , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobjects ( Mobject ) Return type : None clean_up_from_scene ( scene = None ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None", "original_prompt": "class FadeOut(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate two arrows growing from their starting points towards their tips, changing color mid-growth.", "response": "Bases: GrowFromPoint Introduce an Arrow by growing it from its start toward its tip. Parameters : arrow ( Arrow ) \u2013 The arrow to be introduced. point_color ( str ) \u2013 Initial color of the arrow before growing to its full size. Leave empty to match arrow\u2019s color. Examples Example: GrowArrowExample   from manim import * class GrowArrowExample ( Scene ): def construct ( self ): arrows = [ Arrow ( 2 * LEFT , 2 * RIGHT ), Arrow ( 2 * DR , 2 * UL )] VGroup ( * arrows ) . set_x ( 0 ) . arrange ( buff = 2 ) self . play ( GrowArrow ( arrows [ 0 ])) self . play ( GrowArrow ( arrows [ 1 ], point_color = RED )) class GrowArrowExample(Scene):\n    def construct(self):\n        arrows = [Arrow(2 * LEFT, 2 * RIGHT), Arrow(2 * DR, 2 * UL)]\n        VGroup(*arrows).set_x(0).arrange(buff=2)\n        self.play(GrowArrow(arrows[0]))\n        self.play(GrowArrow(arrows[1], point_color=RED)) Methods create_starting_mobject Attributes path_arc path_func run_time _original__init__ ( arrow , point_color = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : arrow ( Arrow ) point_color ( str ) Return type : None", "original_prompt": "class GrowArrow(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate two squares growing from their centers, one red and the other normal color.\"", "response": "Bases: GrowFromPoint Introduce an Mobject by growing it from its center. Parameters : mobject ( Mobject ) \u2013 The mobjects to be introduced. point_color ( str ) \u2013 Initial color of the mobject before growing to its full size. Leave empty to match mobject\u2019s color. Examples Example: GrowFromCenterExample   from manim import * class GrowFromCenterExample ( Scene ): def construct ( self ): squares = [ Square () for _ in range ( 2 )] VGroup ( * squares ) . set_x ( 0 ) . arrange ( buff = 2 ) self . play ( GrowFromCenter ( squares [ 0 ])) self . play ( GrowFromCenter ( squares [ 1 ], point_color = RED )) class GrowFromCenterExample(Scene):\n    def construct(self):\n        squares = [Square() for _ in range(2)]\n        VGroup(*squares).set_x(0).arrange(buff=2)\n        self.play(GrowFromCenter(squares[0]))\n        self.play(GrowFromCenter(squares[1], point_color=RED)) Methods Attributes path_arc path_func run_time _original__init__ ( mobject , point_color = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) point_color ( str ) Return type : None", "original_prompt": "class GrowFromCenter(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a red square growing from its top-right corner, while showing the square's other three counterparts growing from their respective edges.", "response": "Bases: GrowFromPoint Introduce an Mobject by growing it from one of its bounding box edges. Parameters : mobject ( Mobject ) \u2013 The mobjects to be introduced. edge ( np.ndarray ) \u2013 The direction to seek bounding box edge of mobject. point_color ( str ) \u2013 Initial color of the mobject before growing to its full size. Leave empty to match mobject\u2019s color. Examples Example: GrowFromEdgeExample   from manim import * class GrowFromEdgeExample ( Scene ): def construct ( self ): squares = [ Square () for _ in range ( 4 )] VGroup ( * squares ) . set_x ( 0 ) . arrange ( buff = 1 ) self . play ( GrowFromEdge ( squares [ 0 ], DOWN )) self . play ( GrowFromEdge ( squares [ 1 ], RIGHT )) self . play ( GrowFromEdge ( squares [ 2 ], UR )) self . play ( GrowFromEdge ( squares [ 3 ], UP , point_color = RED )) class GrowFromEdgeExample(Scene):\n    def construct(self):\n        squares = [Square() for _ in range(4)]\n        VGroup(*squares).set_x(0).arrange(buff=1)\n        self.play(GrowFromEdge(squares[0], DOWN))\n        self.play(GrowFromEdge(squares[1], RIGHT))\n        self.play(GrowFromEdge(squares[2], UR))\n        self.play(GrowFromEdge(squares[3], UP, point_color=RED)) Methods Attributes path_arc path_func run_time _original__init__ ( mobject , edge , point_color = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) edge ( np.ndarray ) point_color ( str ) Return type : None", "original_prompt": "class GrowFromEdge(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate a green dot growing into four squares, each transforming from a different location with a change in color.\"", "response": "Bases: Transform Introduce an Mobject by growing it from a point. Parameters : mobject ( Mobject ) \u2013 The mobjects to be introduced. point ( np.ndarray ) \u2013 The point from which the mobject grows. point_color ( str ) \u2013 Initial color of the mobject before growing to its full size. Leave empty to match mobject\u2019s color. Examples Example: GrowFromPointExample   from manim import * class GrowFromPointExample ( Scene ): def construct ( self ): dot = Dot ( 3 * UR , color = GREEN ) squares = [ Square () for _ in range ( 4 )] VGroup ( * squares ) . set_x ( 0 ) . arrange ( buff = 1 ) self . add ( dot ) self . play ( GrowFromPoint ( squares [ 0 ], ORIGIN )) self . play ( GrowFromPoint ( squares [ 1 ], [ - 2 , 2 , 0 ])) self . play ( GrowFromPoint ( squares [ 2 ], [ 3 , - 2 , 0 ], RED )) self . play ( GrowFromPoint ( squares [ 3 ], dot , dot . get_color ())) class GrowFromPointExample(Scene):\n    def construct(self):\n        dot = Dot(3 * UR, color=GREEN)\n        squares = [Square() for _ in range(4)]\n        VGroup(*squares).set_x(0).arrange(buff=1)\n        self.add(dot)\n        self.play(GrowFromPoint(squares[0], ORIGIN))\n        self.play(GrowFromPoint(squares[1], [-2, 2, 0]))\n        self.play(GrowFromPoint(squares[2], [3, -2, 0], RED))\n        self.play(GrowFromPoint(squares[3], dot, dot.get_color())) Methods create_starting_mobject create_target Attributes path_arc path_func run_time _original__init__ ( mobject , point , point_color = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) point ( np.ndarray ) point_color ( str ) Return type : None", "original_prompt": "class GrowFromPoint(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate a spinning square, growing from its center with increasing brightness.\"", "response": "Bases: GrowFromCenter Introduce an Mobject spinning and growing it from its center. Parameters : mobject ( Mobject ) \u2013 The mobjects to be introduced. angle ( float ) \u2013 The amount of spinning before mobject reaches its full size. E.g. 2*PI means\nthat the object will do one full spin before being fully introduced. point_color ( str ) \u2013 Initial color of the mobject before growing to its full size. Leave empty to match mobject\u2019s color. Examples Example: SpinInFromNothingExample   from manim import * class SpinInFromNothingExample ( Scene ): def construct ( self ): squares = [ Square () for _ in range ( 3 )] VGroup ( * squares ) . set_x ( 0 ) . arrange ( buff = 2 ) self . play ( SpinInFromNothing ( squares [ 0 ])) self . play ( SpinInFromNothing ( squares [ 1 ], angle = 2 * PI )) self . play ( SpinInFromNothing ( squares [ 2 ], point_color = RED )) class SpinInFromNothingExample(Scene):\n    def construct(self):\n        squares = [Square() for _ in range(3)]\n        VGroup(*squares).set_x(0).arrange(buff=2)\n        self.play(SpinInFromNothing(squares[0]))\n        self.play(SpinInFromNothing(squares[1], angle=2 * PI))\n        self.play(SpinInFromNothing(squares[2], point_color=RED)) Methods Attributes path_arc path_func run_time _original__init__ ( mobject , angle = 1.5707963267948966 , point_color = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) angle ( float ) point_color ( str ) Return type : None", "original_prompt": "class SpinInFromNothing(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a moving Tex object that wiggles up and down in waves, creating oscillations with adjustable frequency.", "response": "Bases: Homotopy Send a wave through the Mobject distorting it temporarily. Parameters : mobject ( Mobject ) \u2013 The mobject to be distorted. direction ( np.ndarray ) \u2013 The direction in which the wave nudges points of the shape amplitude ( float ) \u2013 The distance points of the shape get shifted wave_func ( Callable [ [ float ] , float ] ) \u2013 The function defining the shape of one wave flank. time_width ( float ) \u2013 The length of the wave relative to the width of the mobject. ripples ( int ) \u2013 The number of ripples of the wave run_time ( float ) \u2013 The duration of the animation. Examples Example: ApplyingWaves   from manim import * class ApplyingWaves ( Scene ): def construct ( self ): tex = Tex ( \"WaveWaveWaveWaveWave\" ) . scale ( 2 ) self . play ( ApplyWave ( tex )) self . play ( ApplyWave ( tex , direction = RIGHT , time_width = 0.5 , amplitude = 0.3 )) self . play ( ApplyWave ( tex , rate_func = linear , ripples = 4 )) class ApplyingWaves(Scene):\n    def construct(self):\n        tex = Tex(\"WaveWaveWaveWaveWave\").scale(2)\n        self.play(ApplyWave(tex))\n        self.play(ApplyWave(\n            tex,\n            direction=RIGHT,\n            time_width=0.5,\n            amplitude=0.3\n        ))\n        self.play(ApplyWave(\n            tex,\n            rate_func=linear,\n            ripples=4\n        )) Methods Attributes run_time _original__init__ ( mobject , direction=array([0. , 1. , 0.]) , amplitude=0.2 , wave_func=<function smooth> , time_width=1 , ripples=1 , run_time=2 , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) direction ( ndarray ) amplitude ( float ) wave_func ( Callable [ [ float ] , float ] ) time_width ( float ) ripples ( int ) run_time ( float ) Return type : None", "original_prompt": "class ApplyWave(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Display 'Blinking' text in succession of brief appearances and disappearances.\"", "response": "Bases: Succession Blink the mobject. Parameters : mobject ( Mobject ) \u2013 The mobject to be blinked. time_on ( float ) \u2013 The duration that the mobject is shown for one blink. time_off ( float ) \u2013 The duration that the mobject is hidden for one blink. blinks ( int ) \u2013 The number of blinks hide_at_end ( bool ) \u2013 Whether to hide the mobject at the end of the animation. kwargs \u2013 Additional arguments to be passed to the Succession constructor. Examples Example: BlinkingExample   from manim import * class BlinkingExample ( Scene ): def construct ( self ): text = Text ( \"Blinking\" ) . scale ( 1.5 ) self . add ( text ) self . play ( Blink ( text , blinks = 3 )) class BlinkingExample(Scene):\n    def construct(self):\n        text = Text(\"Blinking\").scale(1.5)\n        self.add(text)\n        self.play(Blink(text, blinks=3)) Methods Attributes run_time _original__init__ ( mobject , time_on = 0.5 , time_off = 0.5 , blinks = 1 , hide_at_end = False , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) time_on ( float ) time_off ( float ) blinks ( int ) hide_at_end ( bool )", "original_prompt": "class Blink(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a temporary line surrounding the given Tex label as it changes into different shapes with various transformations and animations.", "response": "Bases: Succession Draw a temporary line surrounding the mobject. Parameters : mobject ( Mobject ) \u2013 The mobject to be circumscribed. shape ( type ) \u2013 The shape with which to surround the given mobject. Should be either Rectangle or Circle fade_in \u2013 Whether to make the surrounding shape to fade in. It will be drawn otherwise. fade_out \u2013 Whether to make the surrounding shape to fade out. It will be undrawn otherwise. time_width \u2013 The time_width of the drawing and undrawing. Gets ignored if either fade_in or fade_out is True . buff ( float ) \u2013 The distance between the surrounding shape and the given mobject. color ( ParsableManimColor ) \u2013 The color of the surrounding shape. run_time \u2013 The duration of the entire animation. kwargs \u2013 Additional arguments to be passed to the Succession constructor Examples Example: UsingCircumscribe   from manim import * class UsingCircumscribe ( Scene ): def construct ( self ): lbl = Tex ( r \"Circum- \\\\ scribe\" ) . scale ( 2 ) self . add ( lbl ) self . play ( Circumscribe ( lbl )) self . play ( Circumscribe ( lbl , Circle )) self . play ( Circumscribe ( lbl , fade_out = True )) self . play ( Circumscribe ( lbl , time_width = 2 )) self . play ( Circumscribe ( lbl , Circle , True )) class UsingCircumscribe(Scene):\n    def construct(self):\n        lbl = Tex(r\"Circum-\\\\scribe\").scale(2)\n        self.add(lbl)\n        self.play(Circumscribe(lbl))\n        self.play(Circumscribe(lbl, Circle))\n        self.play(Circumscribe(lbl, fade_out=True))\n        self.play(Circumscribe(lbl, time_width=2))\n        self.play(Circumscribe(lbl, Circle, True)) Methods Attributes run_time _original__init__ ( mobject , shape=<class 'manim.mobject.geometry.polygram.Rectangle'> , fade_in=False , fade_out=False , time_width=0.3 , buff=0.1 , color=ManimColor('#FFFF00') , run_time=1 , stroke_width=4 , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) shape ( type ) buff ( float ) color ( ParsableManimColor )", "original_prompt": "class Circumscribe(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Create a burst of yellow lines emanating from the bottom center with increasing density and speed.\"", "response": "Bases: AnimationGroup Send out lines in all directions. Parameters : point ( np.ndarray | Mobject ) \u2013 The center of the flash lines. If it is a Mobject its center will be used. line_length ( float ) \u2013 The length of the flash lines. num_lines ( int ) \u2013 The number of flash lines. flash_radius ( float ) \u2013 The distance from point at which the flash lines start. line_stroke_width ( int ) \u2013 The stroke width of the flash lines. color ( str ) \u2013 The color of the flash lines. time_width ( float ) \u2013 The time width used for the flash lines. See ShowPassingFlash for more details. run_time ( float ) \u2013 The duration of the animation. kwargs \u2013 Additional arguments to be passed to the Succession constructor Examples Example: UsingFlash   from manim import * class UsingFlash ( Scene ): def construct ( self ): dot = Dot ( color = YELLOW ) . shift ( DOWN ) self . add ( Tex ( \"Flash the dot below:\" ), dot ) self . play ( Flash ( dot )) self . wait () class UsingFlash(Scene):\n    def construct(self):\n        dot = Dot(color=YELLOW).shift(DOWN)\n        self.add(Tex(\"Flash the dot below:\"), dot)\n        self.play(Flash(dot))\n        self.wait() Example: FlashOnCircle   from manim import * class FlashOnCircle ( Scene ): def construct ( self ): radius = 2 circle = Circle ( radius ) self . add ( circle ) self . play ( Flash ( circle , line_length = 1 , num_lines = 30 , color = RED , flash_radius = radius + SMALL_BUFF , time_width = 0.3 , run_time = 2 , rate_func = rush_from )) class FlashOnCircle(Scene):\n    def construct(self):\n        radius = 2\n        circle = Circle(radius)\n        self.add(circle)\n        self.play(Flash(\n            circle, line_length=1,\n            num_lines=30, color=RED,\n            flash_radius=radius+SMALL_BUFF,\n            time_width=0.3, run_time=2,\n            rate_func = rush_from\n        )) Methods create_line_anims create_lines Attributes run_time _original__init__ ( point , line_length = 0.2 , num_lines = 12 , flash_radius = 0.1 , line_stroke_width = 3 , color = ManimColor('#FFFF00') , time_width = 1 , run_time = 1.0 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : point ( ndarray | Mobject ) line_length ( float ) num_lines ( int ) flash_radius ( float ) line_stroke_width ( int ) color ( str ) time_width ( float ) run_time ( float ) Return type : None", "original_prompt": "class Flash(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate a yellow dot moving into view with a spotlight that shrinks to its position.\"", "response": "Bases: Transform Shrink a spotlight to a position. Parameters : focus_point ( np.ndarray | Mobject ) \u2013 The point at which to shrink the spotlight. If it is a Mobject its center will be used. opacity ( float ) \u2013 The opacity of the spotlight. color ( str ) \u2013 The color of the spotlight. run_time ( float ) \u2013 The duration of the animation. Examples Example: UsingFocusOn   from manim import * class UsingFocusOn ( Scene ): def construct ( self ): dot = Dot ( color = YELLOW ) . shift ( DOWN ) self . add ( Tex ( \"Focusing on the dot below:\" ), dot ) self . play ( FocusOn ( dot )) self . wait () class UsingFocusOn(Scene):\n    def construct(self):\n        dot = Dot(color=YELLOW).shift(DOWN)\n        self.add(Tex(\"Focusing on the dot below:\"), dot)\n        self.play(FocusOn(dot))\n        self.wait() Methods create_target Attributes path_arc path_func run_time _original__init__ ( focus_point , opacity = 0.2 , color = ManimColor('#888888') , run_time = 2 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : focus_point ( ndarray | Mobject ) opacity ( float ) color ( str ) run_time ( float ) Return type : None", "original_prompt": "class FocusOn(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a Tex object that scales up and changes color over time, with a short pause in between.", "response": "Bases: Transform Indicate a Mobject by temporarily resizing and recoloring it. Parameters : mobject ( Mobject ) \u2013 The mobject to indicate. scale_factor ( float ) \u2013 The factor by which the mobject will be temporally scaled color ( str ) \u2013 The color the mobject temporally takes. rate_func ( Callable [ [ float , float | None ] , np.ndarray ] ) \u2013 The function defining the animation progress at every point in time. kwargs \u2013 Additional arguments to be passed to the Succession constructor Examples Example: UsingIndicate   from manim import * class UsingIndicate ( Scene ): def construct ( self ): tex = Tex ( \"Indicate\" ) . scale ( 3 ) self . play ( Indicate ( tex )) self . wait () class UsingIndicate(Scene):\n    def construct(self):\n        tex = Tex(\"Indicate\").scale(3)\n        self.play(Indicate(tex))\n        self.wait() Methods create_target Attributes path_arc path_func run_time _original__init__ ( mobject , scale_factor=1.2 , color=ManimColor('#FFFF00') , rate_func=<function there_and_back> , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) scale_factor ( float ) color ( str ) rate_func ( Callable [ [ float , float | None ] , ndarray ] ) Return type : None", "original_prompt": "class Indicate(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate a gray polygon that scales and changes color, gradually displaying 'time_width' values with flashing blue text.\"", "response": "Bases: ShowPartial Show only a sliver of the VMobject each frame. Parameters : mobject ( VMobject ) \u2013 The mobject whose stroke is animated. time_width ( float ) \u2013 The length of the sliver relative to the length of the stroke. Examples Example: TimeWidthValues   from manim import * class TimeWidthValues ( Scene ): def construct ( self ): p = RegularPolygon ( 5 , color = DARK_GRAY , stroke_width = 6 ) . scale ( 3 ) lbl = VMobject () self . add ( p , lbl ) p = p . copy () . set_color ( BLUE ) for time_width in [ 0.2 , 0.5 , 1 , 2 ]: lbl . become ( Tex ( r \"\\texttt{time\\_width={{ %.1f }}}\" % time_width )) self . play ( ShowPassingFlash ( p . copy () . set_color ( BLUE ), run_time = 2 , time_width = time_width )) class TimeWidthValues(Scene):\n    def construct(self):\n        p = RegularPolygon(5, color=DARK_GRAY, stroke_width=6).scale(3)\n        lbl = VMobject()\n        self.add(p, lbl)\n        p = p.copy().set_color(BLUE)\n        for time_width in [0.2, 0.5, 1, 2]:\n            lbl.become(Tex(r\"\\texttt{time\\_width={{%.1f}}}\"%time_width))\n            self.play(ShowPassingFlash(\n                p.copy().set_color(BLUE),\n                run_time=2,\n                time_width=time_width\n            )) See also Create Methods clean_up_from_scene Clean up the Scene after finishing the animation. Attributes run_time _original__init__ ( mobject , time_width = 0.1 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( VMobject ) time_width ( float ) Return type : None clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None", "original_prompt": "class ShowPassingFlash(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Rotate and scale a circle to fit within a square, with axis scaling.\"", "response": "Bases: AnimationGroup Methods Attributes run_time _original__init__ ( vmobject , n_segments = 10 , time_width = 0.1 , remover = True , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature.", "original_prompt": "class ShowPassingFlashWithThinningStrokeWidth(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a wobbly text object that scales and rotates over time.", "response": "Bases: Animation Wiggle a Mobject. Parameters : mobject ( Mobject ) \u2013 The mobject to wiggle. scale_value ( float ) \u2013 The factor by which the mobject will be temporarily scaled. rotation_angle ( float ) \u2013 The wiggle angle. n_wiggles ( int ) \u2013 The number of wiggles. scale_about_point ( np.ndarray | None ) \u2013 The point about which the mobject gets scaled. rotate_about_point ( np.ndarray | None ) \u2013 The point around which the mobject gets rotated. run_time ( float ) \u2013 The duration of the animation Examples Example: ApplyingWaves   from manim import * class ApplyingWaves ( Scene ): def construct ( self ): tex = Tex ( \"Wiggle\" ) . scale ( 3 ) self . play ( Wiggle ( tex )) self . wait () class ApplyingWaves(Scene):\n    def construct(self):\n        tex = Tex(\"Wiggle\").scale(3)\n        self.play(Wiggle(tex))\n        self.wait() Methods get_rotate_about_point get_scale_about_point interpolate_submobject Attributes run_time _original__init__ ( mobject , scale_value = 1.1 , rotation_angle = 0.06283185307179587 , n_wiggles = 6 , scale_about_point = None , rotate_about_point = None , run_time = 2 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) scale_value ( float ) rotation_angle ( float ) n_wiggles ( int ) scale_about_point ( ndarray | None ) rotate_about_point ( ndarray | None ) run_time ( float ) Return type : None", "original_prompt": "class Wiggle(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a circle morphing smoothly along the real axis of an imaginary number line with fading.", "response": "Bases: Homotopy Complex Homotopy a function Cx[0, 1] to C Methods Attributes run_time Parameters : complex_homotopy ( Callable [ [ complex ] , float ] ) mobject ( Mobject ) _original__init__ ( complex_homotopy , mobject , ** kwargs )   Complex Homotopy a function Cx[0, 1] to C Parameters : complex_homotopy ( Callable [ [ complex ] , float ] ) mobject ( Mobject ) Return type : None", "original_prompt": "class ComplexHomotopy(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a square morphing into a wave-like shape while moving along the x-axis over time.", "response": "Bases: Animation A Homotopy. This is an animation transforming the points of a mobject according\nto the specified transformation function. With the parameter \\(t\\) moving from 0 to 1 throughout the animation and \\((x, y, z)\\) describing the coordinates of the point of a mobject,\nthe function passed to the homotopy keyword argument should\ntransform the tuple \\((x, y, z, t)\\) to \\((x', y', z')\\) ,\nthe coordinates the original point is transformed to at time \\(t\\) . Parameters : homotopy ( Callable [ [ float , float , float , float ] , tuple [ float , float , float ] ] ) \u2013 A function mapping \\((x, y, z, t)\\) to \\((x', y', z')\\) . mobject ( Mobject ) \u2013 The mobject transformed under the given homotopy. run_time ( float ) \u2013 The run time of the animation. apply_function_kwargs ( dict [ str , Any ] | None ) \u2013 Keyword arguments propagated to Mobject.apply_function() . kwargs \u2013 Further keyword arguments passed to the parent class. Examples Example: HomotopyExample   from manim import * class HomotopyExample ( Scene ): def construct ( self ): square = Square () def homotopy ( x , y , z , t ): if t <= 0.25 : progress = t / 0.25 return ( x , y + progress * 0.2 * np . sin ( x ), z ) else : wave_progress = ( t - 0.25 ) / 0.75 return ( x , y + 0.2 * np . sin ( x + 10 * wave_progress ), z ) self . play ( Homotopy ( homotopy , square , rate_func = linear , run_time = 2 )) class HomotopyExample(Scene):\n    def construct(self):\n        square = Square()\n\n        def homotopy(x, y, z, t):\n            if t <= 0.25:\n                progress = t / 0.25\n                return (x, y + progress * 0.2 * np.sin(x), z)\n            else:\n                wave_progress = (t - 0.25) / 0.75\n                return (x, y + 0.2 * np.sin(x + 10 * wave_progress), z)\n\n        self.play(Homotopy(homotopy, square, rate_func= linear, run_time=2)) Methods function_at_time_t interpolate_submobject Attributes run_time _original__init__ ( homotopy , mobject , run_time = 3 , apply_function_kwargs = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : homotopy ( Callable [ [ float , float , float , float ] , tuple [ float , float , float ] ] ) mobject ( Mobject ) run_time ( float ) apply_function_kwargs ( dict [ str , Any ] | None ) Return type : None", "original_prompt": "class Homotopy(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate a dot moving along a line while its color gradually changes to orange.\"", "response": "Bases: Animation Make one mobject move along the path of another mobject. Example: MoveAlongPathExample   from manim import * class MoveAlongPathExample ( Scene ): def construct ( self ): d1 = Dot () . set_color ( ORANGE ) l1 = Line ( LEFT , RIGHT ) l2 = VMobject () self . add ( d1 , l1 , l2 ) l2 . add_updater ( lambda x : x . become ( Line ( LEFT , d1 . get_center ()) . set_color ( ORANGE ))) self . play ( MoveAlongPath ( d1 , l1 ), rate_func = linear ) class MoveAlongPathExample(Scene):\n    def construct(self):\n        d1 = Dot().set_color(ORANGE)\n        l1 = Line(LEFT, RIGHT)\n        l2 = VMobject()\n        self.add(d1, l1, l2)\n        l2.add_updater(lambda x: x.become(Line(LEFT, d1.get_center()).set_color(ORANGE)))\n        self.play(MoveAlongPath(d1, l1), rate_func=linear) Methods interpolate_mobject Interpolates the mobject of the Animation based on alpha value. Attributes run_time Parameters : mobject ( Mobject ) path ( VMobject ) suspend_mobject_updating ( bool | None ) _original__init__ ( mobject , path , suspend_mobject_updating = False , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) path ( VMobject ) suspend_mobject_updating ( bool | None ) Return type : None interpolate_mobject ( alpha ) [source]   Interpolates the mobject of the Animation based on alpha value. Parameters : alpha ( float ) \u2013 A float between 0 and 1 expressing the ratio to which the animation\nis completed. For example, alpha-values of 0, 0.5, and 1 correspond\nto the animation being completed 0%, 50%, and 100%, respectively. Return type : None", "original_prompt": "class MoveAlongPath(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate a line graph that smoothly fades from 50% to full view with a linear time function\"", "response": "Bases: Animation Methods interpolate_mobject Interpolates the mobject of the Animation based on alpha value. Attributes run_time Parameters : function ( Callable [ [ np.ndarray ] , np.ndarray ] ) mobject ( Mobject ) virtual_time ( float ) suspend_mobject_updating ( bool ) rate_func ( Callable [ [ float ] , float ] ) _original__init__ ( function , mobject , virtual_time=1 , suspend_mobject_updating=False , rate_func=<function linear> , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : function ( Callable [ [ np.ndarray ] , np.ndarray ] ) mobject ( Mobject ) virtual_time ( float ) suspend_mobject_updating ( bool ) rate_func ( Callable [ [ float ] , float ] ) Return type : None interpolate_mobject ( alpha ) [source]   Interpolates the mobject of the Animation based on alpha value. Parameters : alpha ( float ) \u2013 A float between 0 and 1 expressing the ratio to which the animation\nis completed. For example, alpha-values of 0, 0.5, and 1 correspond\nto the animation being completed 0%, 50%, and 100%, respectively. Return type : None", "original_prompt": "class PhaseFlow(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate a parabola opening upwards along the x-axis with smooth vertex movement.\"", "response": "Bases: Homotopy Methods interpolate_submobject Attributes run_time Parameters : homotopy ( Callable [ [ float , float , float , float ] , tuple [ float , float , float ] ] ) mobject ( Mobject ) run_time ( float ) apply_function_kwargs ( dict [ str , Any ] | None ) _original__init__ ( homotopy , mobject , run_time = 3 , apply_function_kwargs = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : homotopy ( Callable [ [ float , float , float , float ] , tuple [ float , float , float ] ] ) mobject ( Mobject ) run_time ( float ) apply_function_kwargs ( dict [ str , Any ] | None ) Return type : None", "original_prompt": "class SmoothedVectorizedHomotopy(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a decimal number growing from 1 to a target value with changing digits.", "response": "Bases: ChangingDecimal Methods Attributes run_time Parameters : decimal_mob ( DecimalNumber ) target_number ( int ) _original__init__ ( decimal_mob , target_number , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : decimal_mob ( DecimalNumber ) target_number ( int ) Return type : None", "original_prompt": "class ChangeDecimalToValue(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a circle with alpha value changes over time.", "response": "Bases: Animation Methods check_validity_of_input interpolate_mobject Interpolates the mobject of the Animation based on alpha value. Attributes run_time Parameters : decimal_mob ( DecimalNumber ) number_update_func ( Callable [ [ float ] , float ] ) suspend_mobject_updating ( bool | None ) _original__init__ ( decimal_mob , number_update_func , suspend_mobject_updating = False , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : decimal_mob ( DecimalNumber ) number_update_func ( Callable [ [ float ] , float ] ) suspend_mobject_updating ( bool | None ) Return type : None interpolate_mobject ( alpha ) [source]   Interpolates the mobject of the Animation based on alpha value. Parameters : alpha ( float ) \u2013 A float between 0 and 1 expressing the ratio to which the animation\nis completed. For example, alpha-values of 0, 0.5, and 1 correspond\nto the animation being completed 0%, 50%, and 100%, respectively. Return type : None", "original_prompt": "class ChangingDecimal(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate a square rotating around its center point, with an additional smaller square rotating simultaneously.\"", "response": "Bases: Transform Animation that rotates a Mobject. Parameters : mobject ( Mobject ) \u2013 The mobject to be rotated. angle ( float ) \u2013 The rotation angle. axis ( np.ndarray ) \u2013 The rotation axis as a numpy vector. about_point ( Sequence [ float ] | None ) \u2013 The rotation center. about_edge ( Sequence [ float ] | None ) \u2013 If about_point is None , this argument specifies\nthe direction of the bounding box point to be taken as\nthe rotation center. Examples Example: UsingRotate   from manim import * class UsingRotate ( Scene ): def construct ( self ): self . play ( Rotate ( Square ( side_length = 0.5 ) . shift ( UP * 2 ), angle = 2 * PI , about_point = ORIGIN , rate_func = linear , ), Rotate ( Square ( side_length = 0.5 ), angle = 2 * PI , rate_func = linear ), ) class UsingRotate(Scene):\n    def construct(self):\n        self.play(\n            Rotate(\n                Square(side_length=0.5).shift(UP * 2),\n                angle=2*PI,\n                about_point=ORIGIN,\n                rate_func=linear,\n            ),\n            Rotate(Square(side_length=0.5), angle=2*PI, rate_func=linear),\n            ) Methods create_target Attributes path_arc path_func run_time _original__init__ ( mobject , angle = 3.141592653589793 , axis = array([0., 0., 1.]) , about_point = None , about_edge = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) angle ( float ) axis ( np.ndarray ) about_point ( Sequence [ float ] | None ) about_edge ( Sequence [ float ] | None ) Return type : None", "original_prompt": "class Rotate(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate a sphere that smoothly transforms from one position to another along a straight line.\"", "response": "Bases: Animation Methods interpolate_mobject Interpolates the mobject of the Animation based on alpha value. Attributes run_time Parameters : mobject ( Mobject ) axis ( np.ndarray ) radians ( np.ndarray ) about_point ( np.ndarray | None ) about_edge ( np.ndarray | None ) run_time ( float ) rate_func ( Callable [ [ float ] , float ] ) _original__init__ ( mobject , axis=array([0. , 0. , 1.]) , radians=6.283185307179586 , about_point=None , about_edge=None , run_time=5 , rate_func=<function linear> , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) axis ( np.ndarray ) radians ( np.ndarray ) about_point ( np.ndarray | None ) about_edge ( np.ndarray | None ) run_time ( float ) rate_func ( Callable [ [ float ] , float ] ) Return type : None interpolate_mobject ( alpha ) [source]   Interpolates the mobject of the Animation based on alpha value. Parameters : alpha ( float ) \u2013 A float between 0 and 1 expressing the ratio to which the animation\nis completed. For example, alpha-values of 0, 0.5, and 1 correspond\nto the animation being completed 0%, 50%, and 100%, respectively. Return type : None", "original_prompt": "class Rotating(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a circle that broadcasts multiple, diminishing, teal-colored circles from the center.", "response": "Bases: LaggedStart Broadcast a mobject starting from an initial_width , up to the actual size of the mobject. Parameters : mobject \u2013 The mobject to be broadcast. focal_point ( Sequence [ float ] ) \u2013 The center of the broadcast, by default ORIGIN. n_mobs ( int ) \u2013 The number of mobjects that emerge from the focal point, by default 5. initial_opacity ( float ) \u2013 The starting stroke opacity of the mobjects emitted from the broadcast, by default 1. final_opacity ( float ) \u2013 The final stroke opacity of the mobjects emitted from the broadcast, by default 0. initial_width ( float ) \u2013 The initial width of the mobjects, by default 0.0. remover ( bool ) \u2013 Whether the mobjects should be removed from the scene after the animation, by default True. lag_ratio ( float ) \u2013 The time between each iteration of the mobject, by default 0.2. run_time ( float ) \u2013 The total duration of the animation, by default 3. kwargs ( Any ) \u2013 Additional arguments to be passed to LaggedStart . Examples Example: BroadcastExample   from manim import * class BroadcastExample ( Scene ): def construct ( self ): mob = Circle ( radius = 4 , color = TEAL_A ) self . play ( Broadcast ( mob )) class BroadcastExample(Scene):\n    def construct(self):\n        mob = Circle(radius=4, color=TEAL_A)\n        self.play(Broadcast(mob)) Methods Attributes run_time _original__init__ ( mobject , focal_point = array([0., 0., 0.]) , n_mobs = 5 , initial_opacity = 1 , final_opacity = 0 , initial_width = 0.0 , remover = True , lag_ratio = 0.2 , run_time = 3 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : focal_point ( Sequence [ float ] ) n_mobs ( int ) initial_opacity ( float ) final_opacity ( float ) initial_width ( float ) remover ( bool ) lag_ratio ( float ) run_time ( float ) kwargs ( Any )", "original_prompt": "class Broadcast(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a Dot() shifting to the right at an accelerated pace with a gradual speed increase.", "response": "Bases: Animation Modifies the speed of passed animation. AnimationGroup with different lag_ratio can also be used\nwhich combines multiple animations into one.\nThe run_time of the passed animation is changed to modify the speed. Parameters : anim ( Animation | _AnimationBuilder ) \u2013 Animation of which the speed is to be modified. speedinfo ( dict [ float , float ] ) \u2013 Contains nodes (percentage of run_time ) and its corresponding speed factor. rate_func ( Callable [ [ float ] , float ] | None ) \u2013 Overrides rate_func of passed animation, applied before changing speed. affects_speed_updaters ( bool ) Examples Example: SpeedModifierExample   from manim import * class SpeedModifierExample ( Scene ): def construct ( self ): a = Dot () . shift ( LEFT * 4 ) b = Dot () . shift ( RIGHT * 4 ) self . add ( a , b ) self . play ( ChangeSpeed ( AnimationGroup ( a . animate ( run_time = 1 ) . shift ( RIGHT * 8 ), b . animate ( run_time = 1 ) . shift ( LEFT * 8 ), ), speedinfo = { 0.3 : 1 , 0.4 : 0.1 , 0.6 : 0.1 , 1 : 1 }, rate_func = linear , ) ) class SpeedModifierExample(Scene):\n    def construct(self):\n        a = Dot().shift(LEFT * 4)\n        b = Dot().shift(RIGHT * 4)\n        self.add(a, b)\n        self.play(\n            ChangeSpeed(\n                AnimationGroup(\n                    a.animate(run_time=1).shift(RIGHT * 8),\n                    b.animate(run_time=1).shift(LEFT * 8),\n                ),\n                speedinfo={0.3: 1, 0.4: 0.1, 0.6: 0.1, 1: 1},\n                rate_func=linear,\n            )\n        ) Example: SpeedModifierUpdaterExample   from manim import * class SpeedModifierUpdaterExample ( Scene ): def construct ( self ): a = Dot () . shift ( LEFT * 4 ) self . add ( a ) ChangeSpeed . add_updater ( a , lambda x , dt : x . shift ( RIGHT * 4 * dt )) self . play ( ChangeSpeed ( Wait ( 2 ), speedinfo = { 0.4 : 1 , 0.5 : 0.2 , 0.8 : 0.2 , 1 : 1 }, affects_speed_updaters = True , ) ) class SpeedModifierUpdaterExample(Scene):\n    def construct(self):\n        a = Dot().shift(LEFT * 4)\n        self.add(a)\n\n        ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))\n        self.play(\n            ChangeSpeed(\n                Wait(2),\n                speedinfo={0.4: 1, 0.5: 0.2, 0.8: 0.2, 1: 1},\n                affects_speed_updaters=True,\n            )\n        ) Example: SpeedModifierUpdaterExample2   from manim import * class SpeedModifierUpdaterExample2 ( Scene ): def construct ( self ): a = Dot () . shift ( LEFT * 4 ) self . add ( a ) ChangeSpeed . add_updater ( a , lambda x , dt : x . shift ( RIGHT * 4 * dt )) self . wait () self . play ( ChangeSpeed ( Wait (), speedinfo = { 1 : 0 }, affects_speed_updaters = True , ) ) class SpeedModifierUpdaterExample2(Scene):\n    def construct(self):\n        a = Dot().shift(LEFT * 4)\n        self.add(a)\n\n        ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))\n        self.wait()\n        self.play(\n            ChangeSpeed(\n                Wait(),\n                speedinfo={1: 0},\n                affects_speed_updaters=True,\n            )\n        ) Methods add_updater This static method can be used to apply speed change to updaters. begin Begin the animation. clean_up_from_scene Clean up the Scene after finishing the animation. finish Finish the animation. get_scaled_total_time The time taken by the animation under the assumption that the run_time is 1. interpolate Set the animation progress. setup update_mobjects Updates things like starting_mobject, and (for Transforms) target_mobject. Attributes dt is_changing_dt run_time _original__init__ ( anim , speedinfo , rate_func = None , affects_speed_updaters = True , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : anim ( Animation | _AnimationBuilder ) speedinfo ( dict [ float , float ] ) rate_func ( Callable [ [ float ] , float ] | None ) affects_speed_updaters ( bool ) Return type : None _setup_scene ( scene ) [source]   Setup up the Scene before starting the animation. This includes to add() the Animation\u2019s Mobject if the animation is an introducer. Parameters : scene \u2013 The scene the animation should be cleaned up from. Return type : None classmethod add_updater ( mobject , update_function , index = None , call_updater = False ) [source]   This static method can be used to apply speed change to updaters. This updater will follow speed and rate function of any ChangeSpeed animation that is playing with affects_speed_updaters=True . By default,\nupdater functions added via the usual Mobject.add_updater() method\ndo not respect the change of animation speed. Parameters : mobject ( Mobject ) \u2013 The mobject to which the updater should be attached. update_function ( Updater ) \u2013 The function that is called whenever a new frame is rendered. index ( int | None ) \u2013 The position in the list of the mobject\u2019s updaters at which the\nfunction should be inserted. call_updater ( bool ) \u2013 If True , calls the update function when attaching it to the\nmobject. See also ChangeSpeed , Mobject.add_updater() begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None finish ( ) [source]   Finish the animation. This method gets called when the animation is over. Return type : None get_scaled_total_time ( ) [source]   The time taken by the animation under the assumption that the run_time is 1. Return type : float interpolate ( alpha ) [source]   Set the animation progress. This method gets called for every frame during an animation. Parameters : alpha ( float ) \u2013 The relative time to set the animation to, 0 meaning the start, 1 meaning\nthe end. Return type : None update_mobjects ( dt ) [source]   Updates things like starting_mobject, and (for\nTransforms) target_mobject.  Note, since typically\n(always?) self.mobject will have its updating\nsuspended during the animation, this will do\nnothing to self.mobject. Parameters : dt ( float ) Return type : None", "original_prompt": "class ChangeSpeed(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Draw a circle centered at the origin and expand it into an ellipse with its major axis along the x-axis.\"", "response": "Bases: ApplyMethod Methods Attributes path_arc path_func run_time Parameters : function ( types.MethodType ) mobject ( Mobject ) _original__init__ ( function , mobject , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : function ( MethodType ) mobject ( Mobject ) Return type : None", "original_prompt": "class ApplyComplexFunction(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Draw a parabola that opens upwards with fading, showing its vertex at the x-axis.\"", "response": "Bases: Transform Methods create_target Attributes path_arc path_func run_time Parameters : function ( types.MethodType ) mobject ( Mobject ) _original__init__ ( function , mobject , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : function ( MethodType ) mobject ( Mobject ) Return type : None", "original_prompt": "class ApplyFunction(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Rotate and apply a transformation to a text message, displaying it on a plane.\"", "response": "Bases: ApplyPointwiseFunction Applies a matrix transform to an mobject. Parameters : matrix ( np.ndarray ) \u2013 The transformation matrix. mobject ( Mobject ) \u2013 The Mobject . about_point ( np.ndarray ) \u2013 The origin point for the transform. Defaults to ORIGIN . kwargs \u2013 Further keyword arguments that are passed to ApplyPointwiseFunction . Examples Example: ApplyMatrixExample   from manim import * class ApplyMatrixExample ( Scene ): def construct ( self ): matrix = [[ 1 , 1 ], [ 0 , 2 / 3 ]] self . play ( ApplyMatrix ( matrix , Text ( \"Hello World!\" )), ApplyMatrix ( matrix , NumberPlane ())) class ApplyMatrixExample(Scene):\n    def construct(self):\n        matrix = [[1, 1], [0, 2/3]]\n        self.play(ApplyMatrix(matrix, Text(\"Hello World!\")), ApplyMatrix(matrix, NumberPlane())) Methods initialize_matrix Attributes path_arc path_func run_time _original__init__ ( matrix , mobject , about_point = array([0., 0., 0.]) , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : matrix ( ndarray ) mobject ( Mobject ) about_point ( ndarray ) Return type : None", "original_prompt": "class ApplyMatrix(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate a transformed shape by applying a mathematical function to its coordinates, with continuous motion.\"", "response": "Bases: Transform Animates a mobject by applying a method. Note that only the method needs to be passed to this animation,\nit is not required to pass the corresponding mobject. Furthermore,\nthis animation class only works if the method returns the modified\nmobject. Parameters : method ( Callable ) \u2013 The method that will be applied in the animation. args \u2013 Any positional arguments to be passed when applying the method. kwargs \u2013 Any keyword arguments passed to Transform . Methods check_validity_of_input create_target Attributes path_arc path_func run_time _original__init__ ( method , * args , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : method ( Callable ) Return type : None", "original_prompt": "class ApplyMethod(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Fade in a square and transform it into a wavy line using complex numbers.\"\n\n(Note: I've kept the prompt concise, under 20 words, and avoided technical terms. I've also identified key visual elements, transformations, and mathematical concepts involved.)", "response": "Bases: ApplyMethod Animation that applies a pointwise function to a mobject. Examples Example: WarpSquare   from manim import * class WarpSquare ( Scene ): def construct ( self ): square = Square () self . play ( ApplyPointwiseFunction ( lambda point : complex_to_R3 ( np . exp ( R3_to_complex ( point ))), square ) ) self . wait () class WarpSquare(Scene):\n    def construct(self):\n        square = Square()\n        self.play(\n            ApplyPointwiseFunction(\n                lambda point: complex_to_R3(np.exp(R3_to_complex(point))), square\n            )\n        )\n        self.wait() Methods Attributes path_arc path_func run_time Parameters : function ( types.MethodType ) mobject ( Mobject ) run_time ( float ) _original__init__ ( function , mobject , run_time = 3.0 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : function ( MethodType ) mobject ( Mobject ) run_time ( float ) Return type : None", "original_prompt": "class ApplyPointwiseFunction(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a moving arc with transformations applied, illustrating mathematical concepts and visual elements over time.", "response": "Bases: ApplyPointwiseFunction Methods begin Begin the animation. Attributes path_arc path_func run_time Parameters : function ( types.MethodType ) mobject ( Mobject ) _original__init__ ( function , mobject , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : function ( MethodType ) mobject ( Mobject ) Return type : None begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None", "original_prompt": "class ApplyPointwiseFunctionToCenter(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Rotate and transform two groups of geometric shapes in a circular motion around their respective centers.\"", "response": "Bases: Transform Transforms the points of a mobject along a clockwise oriented arc. See also Transform , CounterclockwiseTransform Examples Example: ClockwiseExample   from manim import * class ClockwiseExample ( Scene ): def construct ( self ): dl , dr = Dot (), Dot () sl , sr = Square (), Square () VGroup ( dl , sl ) . arrange ( DOWN ) . shift ( 2 * LEFT ) VGroup ( dr , sr ) . arrange ( DOWN ) . shift ( 2 * RIGHT ) self . add ( dl , dr ) self . wait () self . play ( ClockwiseTransform ( dl , sl ), Transform ( dr , sr ) ) self . wait () class ClockwiseExample(Scene):\n    def construct(self):\n        dl, dr = Dot(), Dot()\n        sl, sr = Square(), Square()\n\n        VGroup(dl, sl).arrange(DOWN).shift(2*LEFT)\n        VGroup(dr, sr).arrange(DOWN).shift(2*RIGHT)\n\n        self.add(dl, dr)\n        self.wait()\n        self.play(\n            ClockwiseTransform(dl, sl),\n            Transform(dr, sr)\n        )\n        self.wait() Methods Attributes path_arc path_func run_time Parameters : mobject ( Mobject ) target_mobject ( Mobject ) path_arc ( float ) _original__init__ ( mobject , target_mobject , path_arc = -3.141592653589793 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) target_mobject ( Mobject ) path_arc ( float ) Return type : None", "original_prompt": "class ClockwiseTransform(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a circle that rotates around an axis while another identical shape moves straight up on the same axis, highlighting their differences in transformation behavior.", "response": "Bases: Transform Transforms the points of a mobject along a counterclockwise oriented arc. See also Transform , ClockwiseTransform Examples Example: CounterclockwiseTransform_vs_Transform   from manim import * class CounterclockwiseTransform_vs_Transform ( Scene ): def construct ( self ): # set up the numbers c_transform = VGroup ( DecimalNumber ( number = 3.141 , num_decimal_places = 3 ), DecimalNumber ( number = 1.618 , num_decimal_places = 3 )) text_1 = Text ( \"CounterclockwiseTransform\" , color = RED ) c_transform . add ( text_1 ) transform = VGroup ( DecimalNumber ( number = 1.618 , num_decimal_places = 3 ), DecimalNumber ( number = 3.141 , num_decimal_places = 3 )) text_2 = Text ( \"Transform\" , color = BLUE ) transform . add ( text_2 ) ints = VGroup ( c_transform , transform ) texts = VGroup ( text_1 , text_2 ) . scale ( 0.75 ) c_transform . arrange ( direction = UP , buff = 1 ) transform . arrange ( direction = UP , buff = 1 ) ints . arrange ( buff = 2 ) self . add ( ints , texts ) # The mobs move in clockwise direction for ClockwiseTransform() self . play ( CounterclockwiseTransform ( c_transform [ 0 ], c_transform [ 1 ])) # The mobs move straight up for Transform() self . play ( Transform ( transform [ 0 ], transform [ 1 ])) class CounterclockwiseTransform_vs_Transform(Scene):\n    def construct(self):\n        # set up the numbers\n        c_transform = VGroup(DecimalNumber(number=3.141, num_decimal_places=3), DecimalNumber(number=1.618, num_decimal_places=3))\n        text_1 = Text(\"CounterclockwiseTransform\", color=RED)\n        c_transform.add(text_1)\n\n        transform = VGroup(DecimalNumber(number=1.618, num_decimal_places=3), DecimalNumber(number=3.141, num_decimal_places=3))\n        text_2 = Text(\"Transform\", color=BLUE)\n        transform.add(text_2)\n\n        ints = VGroup(c_transform, transform)\n        texts = VGroup(text_1, text_2).scale(0.75)\n        c_transform.arrange(direction=UP, buff=1)\n        transform.arrange(direction=UP, buff=1)\n\n        ints.arrange(buff=2)\n        self.add(ints, texts)\n\n        # The mobs move in clockwise direction for ClockwiseTransform()\n        self.play(CounterclockwiseTransform(c_transform[0], c_transform[1]))\n\n        # The mobs move straight up for Transform()\n        self.play(Transform(transform[0], transform[1])) Methods Attributes path_arc path_func run_time Parameters : mobject ( Mobject ) target_mobject ( Mobject ) path_arc ( float ) _original__init__ ( mobject , target_mobject , path_arc = 3.141592653589793 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) target_mobject ( Mobject ) path_arc ( float ) Return type : None", "original_prompt": "class CounterclockwiseTransform(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a group of shapes moving cyclically in a clockwise direction around the origin.", "response": "Bases: Transform An animation moving mobjects cyclically. In particular, this means: the first mobject takes the place\nof the second mobject, the second one takes the place of\nthe third mobject, and so on. The last mobject takes the\nplace of the first one. Parameters : mobjects ( Mobject ) \u2013 List of mobjects to be transformed. path_arc ( float ) \u2013 The angle of the arc (in radians) that the mobjects will follow to reach\ntheir target. kwargs \u2013 Further keyword arguments that are passed to Transform . Examples Example: CyclicReplaceExample   from manim import * class CyclicReplaceExample ( Scene ): def construct ( self ): group = VGroup ( Square (), Circle (), Triangle (), Star ()) group . arrange ( RIGHT ) self . add ( group ) for _ in range ( 4 ): self . play ( CyclicReplace ( * group )) class CyclicReplaceExample(Scene):\n    def construct(self):\n        group = VGroup(Square(), Circle(), Triangle(), Star())\n        group.arrange(RIGHT)\n        self.add(group)\n\n        for _ in range(4):\n            self.play(CyclicReplace(*group)) Methods create_target Attributes path_arc path_func run_time _original__init__ ( * mobjects , path_arc = 1.5707963267948966 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobjects ( Mobject ) path_arc ( float ) Return type : None", "original_prompt": "class CyclicReplace(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a yellow text \"Hello World!\" fading into red with color changing animation.", "response": "Bases: ApplyMethod Animation that changes color of a mobject. Examples Example: FadeToColorExample   from manim import * class FadeToColorExample ( Scene ): def construct ( self ): self . play ( FadeToColor ( Text ( \"Hello World!\" ), color = RED )) class FadeToColorExample(Scene):\n    def construct(self):\n        self.play(FadeToColor(Text(\"Hello World!\"), color=RED)) Methods Attributes path_arc path_func run_time Parameters : mobject ( Mobject ) color ( str ) _original__init__ ( mobject , color , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) color ( str ) Return type : None", "original_prompt": "class FadeToColor(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a Rectangle transforming into a Circle while showing the effect of stretch and matching dimensions.", "response": "Bases: Transform Fades one mobject into another. Parameters : mobject \u2013 The starting Mobject . target_mobject \u2013 The target Mobject . stretch \u2013 Controls whether the target Mobject is stretched during\nthe animation. Default: True . dim_to_match \u2013 If the target mobject is not stretched automatically, this allows\nto adjust the initial scale of the target Mobject while\nit is shifted in. Setting this to 0, 1, and 2, respectively,\nmatches the length of the target with the length of the starting Mobject in x, y, and z direction, respectively. kwargs \u2013 Further keyword arguments are passed to the parent class. Examples Example: DifferentFadeTransforms   from manim import * class DifferentFadeTransforms ( Scene ): def construct ( self ): starts = [ Rectangle ( width = 4 , height = 1 ) for _ in range ( 3 )] VGroup ( * starts ) . arrange ( DOWN , buff = 1 ) . shift ( 3 * LEFT ) targets = [ Circle ( fill_opacity = 1 ) . scale ( 0.25 ) for _ in range ( 3 )] VGroup ( * targets ) . arrange ( DOWN , buff = 1 ) . shift ( 3 * RIGHT ) self . play ( * [ FadeIn ( s ) for s in starts ]) self . play ( FadeTransform ( starts [ 0 ], targets [ 0 ], stretch = True ), FadeTransform ( starts [ 1 ], targets [ 1 ], stretch = False , dim_to_match = 0 ), FadeTransform ( starts [ 2 ], targets [ 2 ], stretch = False , dim_to_match = 1 ) ) self . play ( * [ FadeOut ( mobj ) for mobj in self . mobjects ]) class DifferentFadeTransforms(Scene):\n    def construct(self):\n        starts = [Rectangle(width=4, height=1) for _ in range(3)]\n        VGroup(*starts).arrange(DOWN, buff=1).shift(3*LEFT)\n        targets = [Circle(fill_opacity=1).scale(0.25) for _ in range(3)]\n        VGroup(*targets).arrange(DOWN, buff=1).shift(3*RIGHT)\n\n        self.play(*[FadeIn(s) for s in starts])\n        self.play(\n            FadeTransform(starts[0], targets[0], stretch=True),\n            FadeTransform(starts[1], targets[1], stretch=False, dim_to_match=0),\n            FadeTransform(starts[2], targets[2], stretch=False, dim_to_match=1)\n        )\n\n        self.play(*[FadeOut(mobj) for mobj in self.mobjects]) Methods begin Initial setup for the animation. clean_up_from_scene Clean up the Scene after finishing the animation. get_all_families_zipped get_all_mobjects Get all mobjects involved in the animation. ghost_to Replaces the source by the target and sets the opacity to 0. Attributes path_arc path_func run_time _original__init__ ( mobject , target_mobject , stretch = True , dim_to_match = 1 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. begin ( ) [source]   Initial setup for the animation. The mobject to which this animation is bound is a group consisting of\nboth the starting and the ending mobject. At the start, the ending\nmobject replaces the starting mobject (and is completely faded). In the\nend, it is set to be the other way around. clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene \u2013 The scene the animation should be cleaned up from. get_all_mobjects ( ) [source]   Get all mobjects involved in the animation. Ordering must match the ordering of arguments to interpolate_submobject Returns : The sequence of mobjects. Return type : Sequence[ Mobject ] ghost_to ( source , target ) [source]   Replaces the source by the target and sets the opacity to 0. If the provided target has no points, and thus a location of [0, 0, 0]\nthe source will simply fade out where it currently is.", "original_prompt": "class FadeTransform(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a Square and Circle transforming into a Circle and Triangle while fading out all objects on screen.", "response": "Bases: FadeTransform Fades submobjects of one mobject into submobjects of another one. See also FadeTransform Examples Example: FadeTransformSubmobjects   from manim import * class FadeTransformSubmobjects ( Scene ): def construct ( self ): src = VGroup ( Square (), Circle () . shift ( LEFT + UP )) src . shift ( 3 * LEFT + 2 * UP ) src_copy = src . copy () . shift ( 4 * DOWN ) target = VGroup ( Circle (), Triangle () . shift ( RIGHT + DOWN )) target . shift ( 3 * RIGHT + 2 * UP ) target_copy = target . copy () . shift ( 4 * DOWN ) self . play ( FadeIn ( src ), FadeIn ( src_copy )) self . play ( FadeTransform ( src , target ), FadeTransformPieces ( src_copy , target_copy ) ) self . play ( * [ FadeOut ( mobj ) for mobj in self . mobjects ]) class FadeTransformSubmobjects(Scene):\n    def construct(self):\n        src = VGroup(Square(), Circle().shift(LEFT + UP))\n        src.shift(3*LEFT + 2*UP)\n        src_copy = src.copy().shift(4*DOWN)\n\n        target = VGroup(Circle(), Triangle().shift(RIGHT + DOWN))\n        target.shift(3*RIGHT + 2*UP)\n        target_copy = target.copy().shift(4*DOWN)\n\n        self.play(FadeIn(src), FadeIn(src_copy))\n        self.play(\n            FadeTransform(src, target),\n            FadeTransformPieces(src_copy, target_copy)\n        )\n        self.play(*[FadeOut(mobj) for mobj in self.mobjects]) Methods begin Initial setup for the animation. ghost_to Replaces the source submobjects by the target submobjects and sets the opacity to 0. Attributes path_arc path_func run_time _original__init__ ( mobject , target_mobject , stretch = True , dim_to_match = 1 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. begin ( ) [source]   Initial setup for the animation. The mobject to which this animation is bound is a group consisting of\nboth the starting and the ending mobject. At the start, the ending\nmobject replaces the starting mobject (and is completely faded). In the\nend, it is set to be the other way around. ghost_to ( source , target ) [source]   Replaces the source submobjects by the target submobjects and sets\nthe opacity to 0.", "original_prompt": "class FadeTransformPieces(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate a circle moving to its mirrored position with a green tint and scale.\"", "response": "Bases: Transform Transforms a mobject to the mobject stored in its target attribute. After calling the generate_target() method, the target attribute of the mobject is populated with a copy of it. After modifying the attribute,\nplaying the MoveToTarget animation transforms the original mobject\ninto the modified one stored in the target attribute. Examples Example: MoveToTargetExample   from manim import * class MoveToTargetExample ( Scene ): def construct ( self ): c = Circle () c . generate_target () c . target . set_fill ( color = GREEN , opacity = 0.5 ) c . target . shift ( 2 * RIGHT + UP ) . scale ( 0.5 ) self . add ( c ) self . play ( MoveToTarget ( c )) class MoveToTargetExample(Scene):\n    def construct(self):\n        c = Circle()\n\n        c.generate_target()\n        c.target.set_fill(color=GREEN, opacity=0.5)\n        c.target.shift(2*RIGHT + UP).scale(0.5)\n\n        self.add(c)\n        self.play(MoveToTarget(c)) Methods check_validity_of_input Attributes path_arc path_func run_time Parameters : mobject ( Mobject ) _original__init__ ( mobject , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) Return type : None", "original_prompt": "class MoveToTarget(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate integers morphing and replacing each other with fading in of labels.\"", "response": "Bases: Transform Replaces and morphs a mobject into a target mobject. Parameters : mobject ( Mobject ) \u2013 The starting Mobject . target_mobject ( Mobject ) \u2013 The target Mobject . kwargs \u2013 Further keyword arguments that are passed to Transform . Examples Example: ReplacementTransformOrTransform   from manim import * class ReplacementTransformOrTransform ( Scene ): def construct ( self ): # set up the numbers r_transform = VGroup ( * [ Integer ( i ) for i in range ( 1 , 4 )]) text_1 = Text ( \"ReplacementTransform\" , color = RED ) r_transform . add ( text_1 ) transform = VGroup ( * [ Integer ( i ) for i in range ( 4 , 7 )]) text_2 = Text ( \"Transform\" , color = BLUE ) transform . add ( text_2 ) ints = VGroup ( r_transform , transform ) texts = VGroup ( text_1 , text_2 ) . scale ( 0.75 ) r_transform . arrange ( direction = UP , buff = 1 ) transform . arrange ( direction = UP , buff = 1 ) ints . arrange ( buff = 2 ) self . add ( ints , texts ) # The mobs replace each other and none are left behind self . play ( ReplacementTransform ( r_transform [ 0 ], r_transform [ 1 ])) self . play ( ReplacementTransform ( r_transform [ 1 ], r_transform [ 2 ])) # The mobs linger after the Transform() self . play ( Transform ( transform [ 0 ], transform [ 1 ])) self . play ( Transform ( transform [ 1 ], transform [ 2 ])) self . wait () class ReplacementTransformOrTransform(Scene):\n    def construct(self):\n        # set up the numbers\n        r_transform = VGroup(*[Integer(i) for i in range(1,4)])\n        text_1 = Text(\"ReplacementTransform\", color=RED)\n        r_transform.add(text_1)\n\n        transform = VGroup(*[Integer(i) for i in range(4,7)])\n        text_2 = Text(\"Transform\", color=BLUE)\n        transform.add(text_2)\n\n        ints = VGroup(r_transform, transform)\n        texts = VGroup(text_1, text_2).scale(0.75)\n        r_transform.arrange(direction=UP, buff=1)\n        transform.arrange(direction=UP, buff=1)\n\n        ints.arrange(buff=2)\n        self.add(ints, texts)\n\n        # The mobs replace each other and none are left behind\n        self.play(ReplacementTransform(r_transform[0], r_transform[1]))\n        self.play(ReplacementTransform(r_transform[1], r_transform[2]))\n\n        # The mobs linger after the Transform()\n        self.play(Transform(transform[0], transform[1]))\n        self.play(Transform(transform[1], transform[2]))\n        self.wait() Methods Attributes path_arc path_func run_time _original__init__ ( mobject , target_mobject , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) target_mobject ( Mobject ) Return type : None", "original_prompt": "class ReplacementTransform(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a square transforming into purple with fading in, scaling, shifting and rotating while showing its path over time.", "response": "Bases: ApplyMethod Transforms a mobject to its last saved state. To save the state of a mobject, use the save_state() method. Examples Example: RestoreExample   from manim import * class RestoreExample ( Scene ): def construct ( self ): s = Square () s . save_state () self . play ( FadeIn ( s )) self . play ( s . animate . set_color ( PURPLE ) . set_opacity ( 0.5 ) . shift ( 2 * LEFT ) . scale ( 3 )) self . play ( s . animate . shift ( 5 * DOWN ) . rotate ( PI / 4 )) self . wait () self . play ( Restore ( s ), run_time = 2 ) class RestoreExample(Scene):\n    def construct(self):\n        s = Square()\n        s.save_state()\n        self.play(FadeIn(s))\n        self.play(s.animate.set_color(PURPLE).set_opacity(0.5).shift(2*LEFT).scale(3))\n        self.play(s.animate.shift(5*DOWN).rotate(PI/4))\n        self.wait()\n        self.play(Restore(s), run_time=2) Methods Attributes path_arc path_func run_time Parameters : mobject ( Mobject ) _original__init__ ( mobject , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) Return type : None", "original_prompt": "class Restore(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Scale a 'Hello World!' text bubble into view with rapid expansion.\"", "response": "Bases: ApplyMethod Animation that scales a mobject by a certain factor. Examples Example: ScaleInPlaceExample   from manim import * class ScaleInPlaceExample ( Scene ): def construct ( self ): self . play ( ScaleInPlace ( Text ( \"Hello World!\" ), 2 )) class ScaleInPlaceExample(Scene):\n    def construct(self):\n        self.play(ScaleInPlace(Text(\"Hello World!\"), 2)) Methods Attributes path_arc path_func run_time Parameters : mobject ( Mobject ) scale_factor ( float ) _original__init__ ( mobject , scale_factor , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) scale_factor ( float ) Return type : None", "original_prompt": "class ScaleInPlace(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Shrink a centered text to tiny size.\"\n\nThis prompt is concise and straightforward, describing the key visual element of the animation and its outcome.", "response": "Bases: ScaleInPlace Animation that makes a mobject shrink to center. Examples Example: ShrinkToCenterExample   from manim import * class ShrinkToCenterExample ( Scene ): def construct ( self ): self . play ( ShrinkToCenter ( Text ( \"Hello World!\" ))) class ShrinkToCenterExample(Scene):\n    def construct(self):\n        self.play(ShrinkToCenter(Text(\"Hello World!\"))) Methods Attributes path_arc path_func run_time Parameters : mobject ( Mobject ) _original__init__ ( mobject , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) Return type : None", "original_prompt": "class ShrinkToCenter(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Show a circle tracing out the unit circle, gradually replacing its outline with a straight line.\"", "response": "Bases: CyclicReplace Methods Attributes path_arc path_func run_time Parameters : mobjects ( Mobject ) path_arc ( float ) _original__init__ ( * mobjects , path_arc = 1.5707963267948966 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobjects ( Mobject ) path_arc ( float ) Return type : None", "original_prompt": "class Swap(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate a circle that transforms into another while moving along an arc, with color changes and text description.\"", "response": "Bases: Animation A Transform transforms a Mobject into a target Mobject. Parameters : mobject ( Mobject | None ) \u2013 The Mobject to be transformed. It will be mutated to become the target_mobject . target_mobject ( Mobject | None ) \u2013 The target of the transformation. path_func ( Callable | None ) \u2013 A function defining the path that the points of the mobject are being moved\nalong until they match the points of the target_mobject , see utils.paths . path_arc ( float ) \u2013 The arc angle (in radians) that the points of mobject will follow to reach\nthe points of the target if using a circular path arc, see path_arc_centers .\nSee also manim.utils.paths.path_along_arc() . path_arc_axis ( np.ndarray ) \u2013 The axis to rotate along if using a circular path arc, see path_arc_centers . path_arc_centers ( np.ndarray ) \u2013 The center of the circular arcs along which the points of mobject are\nmoved by the transformation. If this is set and path_func is not set, then a path_along_circles path will be generated\nusing the path_arc parameters and stored in path_func . If path_func is set, this and the\nother path_arc fields are set as attributes, but a path_func is not generated from it. replace_mobject_with_target_in_scene ( bool ) \u2013 Controls which mobject is replaced when the transformation is complete. If set to True, mobject will be removed from the scene and target_mobject will\nreplace it. Otherwise, target_mobject is never added and mobject just takes its shape. Examples Example: TransformPathArc   from manim import * class TransformPathArc ( Scene ): def construct ( self ): def make_arc_path ( start , end , arc_angle ): points = [] p_fn = path_along_arc ( arc_angle ) # alpha animates between 0.0 and 1.0, where 0.0 # is the beginning of the animation and 1.0 is the end. for alpha in range ( 0 , 11 ): points . append ( p_fn ( start , end , alpha / 10.0 )) path = VMobject ( stroke_color = YELLOW ) path . set_points_smoothly ( points ) return path left = Circle ( stroke_color = BLUE_E , fill_opacity = 1.0 , radius = 0.5 ) . move_to ( LEFT * 2 ) colors = [ TEAL_A , TEAL_B , TEAL_C , TEAL_D , TEAL_E , GREEN_A ] # Positive angles move counter-clockwise, negative angles move clockwise. examples = [ - 90 , 0 , 30 , 90 , 180 , 270 ] anims = [] for idx , angle in enumerate ( examples ): left_c = left . copy () . shift (( 3 - idx ) * UP ) left_c . fill_color = colors [ idx ] right_c = left_c . copy () . shift ( 4 * RIGHT ) path_arc = make_arc_path ( left_c . get_center (), right_c . get_center (), arc_angle = angle * DEGREES ) desc = Text ( ' %d \u00b0' % examples [ idx ]) . next_to ( left_c , LEFT ) # Make the circles in front of the text in front of the arcs. self . add ( path_arc . set_z_index ( 1 ), desc . set_z_index ( 2 ), left_c . set_z_index ( 3 ), ) anims . append ( Transform ( left_c , right_c , path_arc = angle * DEGREES )) self . play ( * anims , run_time = 2 ) self . wait () class TransformPathArc(Scene):\n    def construct(self):\n        def make_arc_path(start, end, arc_angle):\n            points = []\n            p_fn = path_along_arc(arc_angle)\n            # alpha animates between 0.0 and 1.0, where 0.0\n            # is the beginning of the animation and 1.0 is the end.\n            for alpha in range(0, 11):\n                points.append(p_fn(start, end, alpha / 10.0))\n            path = VMobject(stroke_color=YELLOW)\n            path.set_points_smoothly(points)\n            return path\n\n        left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)\n        colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]\n        # Positive angles move counter-clockwise, negative angles move clockwise.\n        examples = [-90, 0, 30, 90, 180, 270]\n        anims = []\n        for idx, angle in enumerate(examples):\n            left_c = left.copy().shift((3 - idx) * UP)\n            left_c.fill_color = colors[idx]\n            right_c = left_c.copy().shift(4 * RIGHT)\n            path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),\n                                     arc_angle=angle * DEGREES)\n            desc = Text('%d\u00b0' % examples[idx]).next_to(left_c, LEFT)\n            # Make the circles in front of the text in front of the arcs.\n            self.add(\n                path_arc.set_z_index(1),\n                desc.set_z_index(2),\n                left_c.set_z_index(3),\n            )\n            anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))\n\n        self.play(*anims, run_time=2)\n        self.wait() Methods begin Begin the animation. clean_up_from_scene Clean up the Scene after finishing the animation. create_target get_all_families_zipped get_all_mobjects Get all mobjects involved in the animation. interpolate_submobject Attributes path_arc path_func run_time _original__init__ ( mobject , target_mobject = None , path_func = None , path_arc = 0 , path_arc_axis = array([0., 0., 1.]) , path_arc_centers = None , replace_mobject_with_target_in_scene = False , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject | None ) target_mobject ( Mobject | None ) path_func ( Callable | None ) path_arc ( float ) path_arc_axis ( ndarray ) path_arc_centers ( ndarray ) replace_mobject_with_target_in_scene ( bool ) Return type : None begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None get_all_mobjects ( ) [source]   Get all mobjects involved in the animation. Ordering must match the ordering of arguments to interpolate_submobject Returns : The sequence of mobjects. Return type : Sequence[ Mobject ]", "original_prompt": "class Transform(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate a circle growing from a small square with increasing transparency.\" \n\nNote: This prompt focuses on key visual elements and transformation without delving into technical terms or mathematical concepts beyond general understanding of growth and transparency.", "response": "Bases: Transform Methods interpolate Set the animation progress. Attributes path_arc path_func run_time Parameters : start_anim ( Animation ) end_anim ( Animation ) rate_func ( Callable ) _original__init__ ( start_anim , end_anim , rate_func=<function squish_rate_func.<locals>.result> , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : start_anim ( Animation ) end_anim ( Animation ) rate_func ( Callable ) Return type : None interpolate ( alpha ) [source]   Set the animation progress. This method gets called for every frame during an animation. Parameters : alpha ( float ) \u2013 The relative time to set the animation to, 0 meaning the start, 1 meaning\nthe end. Return type : None", "original_prompt": "class TransformAnimations(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate a shape moving towards another as their paths intersect over time with smooth transitions.\"", "response": "Bases: Transform Performs a reversed Transform Methods interpolate Set the animation progress. Attributes path_arc path_func run_time Parameters : mobject ( Mobject ) target_mobject ( Mobject ) _original__init__ ( mobject , target_mobject , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) target_mobject ( Mobject ) Return type : None interpolate ( alpha ) [source]   Set the animation progress. This method gets called for every frame during an animation. Parameters : alpha ( float ) \u2013 The relative time to set the animation to, 0 meaning the start, 1 meaning\nthe end. Return type : None", "original_prompt": "class TransformFromCopy(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate a 3D transformation of shapes into matching targets with controlled fading and transformations.\"", "response": "Bases: AnimationGroup Abstract base class for transformations that keep track of matching parts. Subclasses have to implement the two static methods get_mobject_parts() and get_mobject_key() . Basically, this transformation first maps all submobjects returned\nby the get_mobject_parts method to certain keys by applying the get_mobject_key method. Then, submobjects with matching keys\nare transformed into each other. Parameters : mobject ( Mobject ) \u2013 The starting Mobject . target_mobject ( Mobject ) \u2013 The target Mobject . transform_mismatches ( bool ) \u2013 Controls whether submobjects without a matching key are transformed\ninto each other by using Transform . Default: False . fade_transform_mismatches ( bool ) \u2013 Controls whether submobjects without a matching key are transformed\ninto each other by using FadeTransform . Default: False . key_map ( dict | None ) \u2013 Optional. A dictionary mapping keys belonging to some of the starting mobject\u2019s\nsubmobjects (i.e., the return values of the get_mobject_key method)\nto some keys belonging to the target mobject\u2019s submobjects that should\nbe transformed although the keys don\u2019t match. kwargs \u2013 All further keyword arguments are passed to the submobject transformations. Note If neither transform_mismatches nor fade_transform_mismatches are set to True , submobjects without matching keys in the starting\nmobject are faded out in the direction of the unmatched submobjects in\nthe target mobject, and unmatched submobjects in the target mobject\nare faded in from the direction of the unmatched submobjects in the\nstart mobject. Methods clean_up_from_scene Clean up the Scene after finishing the animation. get_mobject_key get_mobject_parts get_shape_map Attributes run_time _original__init__ ( mobject , target_mobject , transform_mismatches = False , fade_transform_mismatches = False , key_map = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) target_mobject ( Mobject ) transform_mismatches ( bool ) fade_transform_mismatches ( bool ) key_map ( dict | None ) clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None", "original_prompt": "class TransformMatchingAbstractBase(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Transform 'the morse code' into 'here come dots', matching shape transformations, with animated dot addition.\"", "response": "Bases: TransformMatchingAbstractBase An animation trying to transform groups by matching the shape\nof their submobjects. Two submobjects match if the hash of their point coordinates after\nnormalization (i.e., after translation to the origin, fixing the submobject\nheight at 1 unit, and rounding the coordinates to three decimal places)\nmatches. See also TransformMatchingAbstractBase Examples Example: Anagram   from manim import * class Anagram ( Scene ): def construct ( self ): src = Text ( \"the morse code\" ) tar = Text ( \"here come dots\" ) self . play ( Write ( src )) self . wait ( 0.5 ) self . play ( TransformMatchingShapes ( src , tar , path_arc = PI / 2 )) self . wait ( 0.5 ) class Anagram(Scene):\n    def construct(self):\n        src = Text(\"the morse code\")\n        tar = Text(\"here come dots\")\n        self.play(Write(src))\n        self.wait(0.5)\n        self.play(TransformMatchingShapes(src, tar, path_arc=PI/2))\n        self.wait(0.5) Methods get_mobject_key get_mobject_parts Attributes run_time Parameters : mobject ( Mobject ) target_mobject ( Mobject ) transform_mismatches ( bool ) fade_transform_mismatches ( bool ) key_map ( dict | None ) _original__init__ ( mobject , target_mobject , transform_mismatches = False , fade_transform_mismatches = False , key_map = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) target_mobject ( Mobject ) transform_mismatches ( bool ) fade_transform_mismatches ( bool ) key_map ( dict | None )", "original_prompt": "class TransformMatchingShapes(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "\"Animate a parallelogram with labeled variables 'a', 'b', and 'c' sliding into another parallelogram, revealing equations of motion.\"", "response": "Bases: TransformMatchingAbstractBase A transformation trying to transform rendered LaTeX strings. Two submobjects match if their tex_string matches. See also TransformMatchingAbstractBase Examples Example: MatchingEquationParts   from manim import * class MatchingEquationParts ( Scene ): def construct ( self ): variables = VGroup ( MathTex ( \"a\" ), MathTex ( \"b\" ), MathTex ( \"c\" )) . arrange_submobjects () . shift ( UP ) eq1 = MathTex ( \"{{x}}^2\" , \"+\" , \"{{y}}^2\" , \"=\" , \"{{z}}^2\" ) eq2 = MathTex ( \"{{a}}^2\" , \"+\" , \"{{b}}^2\" , \"=\" , \"{{c}}^2\" ) eq3 = MathTex ( \"{{a}}^2\" , \"=\" , \"{{c}}^2\" , \"-\" , \"{{b}}^2\" ) self . add ( eq1 ) self . wait ( 0.5 ) self . play ( TransformMatchingTex ( Group ( eq1 , variables ), eq2 )) self . wait ( 0.5 ) self . play ( TransformMatchingTex ( eq2 , eq3 )) self . wait ( 0.5 ) class MatchingEquationParts(Scene):\n    def construct(self):\n        variables = VGroup(MathTex(\"a\"), MathTex(\"b\"), MathTex(\"c\")).arrange_submobjects().shift(UP)\n\n        eq1 = MathTex(\"{{x}}^2\", \"+\", \"{{y}}^2\", \"=\", \"{{z}}^2\")\n        eq2 = MathTex(\"{{a}}^2\", \"+\", \"{{b}}^2\", \"=\", \"{{c}}^2\")\n        eq3 = MathTex(\"{{a}}^2\", \"=\", \"{{c}}^2\", \"-\", \"{{b}}^2\")\n\n        self.add(eq1)\n        self.wait(0.5)\n        self.play(TransformMatchingTex(Group(eq1, variables), eq2))\n        self.wait(0.5)\n        self.play(TransformMatchingTex(eq2, eq3))\n        self.wait(0.5) Methods get_mobject_key get_mobject_parts Attributes run_time Parameters : mobject ( Mobject ) target_mobject ( Mobject ) transform_mismatches ( bool ) fade_transform_mismatches ( bool ) key_map ( dict | None ) _original__init__ ( mobject , target_mobject , transform_mismatches = False , fade_transform_mismatches = False , key_map = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) target_mobject ( Mobject ) transform_mismatches ( bool ) fade_transform_mismatches ( bool ) key_map ( dict | None )", "original_prompt": "class TransformMatchingTex(mobject=None, *args, use_override=True, **kwargs)"}
{"prompt": "Animate a rotating circle with fading text that moves along a straight line, displaying a changing color scheme.", "response": "Bases: object Auxiliary class that handles displaying vectorized mobjects with\na set background image. Parameters : camera ( Camera ) \u2013 Camera object to use. Methods display Displays the colored VMobjects. get_background_array Gets the background array that has the passed file_name. reset_pixel_array resize_background_array Resizes the pixel array representing the background. resize_background_array_to_match Resizes the background array to match the passed pixel array. display ( * cvmobjects ) [source]   Displays the colored VMobjects. Parameters : *cvmobjects ( VMobject ) \u2013 The VMobjects Returns : The pixel array with the cvmobjects displayed. Return type : np.array get_background_array ( image ) [source]   Gets the background array that has the passed file_name. Parameters : image ( Image | Path | str ) \u2013 The background image or its file name. Returns : The pixel array of the image. Return type : np.ndarray resize_background_array ( background_array , new_width , new_height , mode = 'RGBA' ) [source]   Resizes the pixel array representing the background. Parameters : background_array ( ndarray ) \u2013 The pixel new_width ( float ) \u2013 The new width of the background new_height ( float ) \u2013 The new height of the background mode ( str ) \u2013 The PIL image mode, by default \u201cRGBA\u201d Returns : The numpy pixel array of the resized background. Return type : np.array resize_background_array_to_match ( background_array , pixel_array ) [source]   Resizes the background array to match the passed pixel array. Parameters : background_array ( ndarray ) \u2013 The prospective pixel array. pixel_array ( ndarray ) \u2013 The pixel array whose width and height should be matched. Returns : The resized background array. Return type : np.array", "original_prompt": "class BackgroundColoredVMobjectDisplayer(camera)"}
{"prompt": "This appears to be a Python library for creating animations and graphics, specifically Manim, which is used in the MIT OpenCourseWare platform for teaching linear algebra. The text provided seems to be documenting the classes and functions available in this library.\n\nHowever, it does not appear to be a question that requires a specific answer or solution. Instead, it appears to be a code snippet that is providing documentation for the Manim library. \n\nIf you're looking for help with a specific issue related to this library, I'd be happy to try and assist you further! Can you please provide more context or clarify what you're trying to accomplish?", "response": "Bases: object Base camera class. This is the object which takes care of what exactly is displayed\non screen at any given moment. Parameters : background_image ( str | None ) \u2013 The path to an image that should be the background image.\nIf not set, the background is filled with self.background_color background ( np.ndarray | None ) \u2013 What background is set to. By default, None . pixel_height ( int | None ) \u2013 The height of the scene in pixels. pixel_width ( int | None ) \u2013 The width of the scene in pixels. kwargs \u2013 Additional arguments ( background_color , background_opacity )\nto be set. frame_center ( np.ndarray ) image_mode ( str ) n_channels ( int ) pixel_array_dtype ( str ) cairo_line_width_multiple ( float ) use_z_index ( bool ) frame_height ( float | None ) frame_width ( float | None ) frame_rate ( float | None ) background_color ( ParsableManimColor | None ) background_opacity ( float | None ) Methods adjust_out_of_range_points If any of the points in the passed array are out of the viable range, they are adjusted suitably. adjusted_thickness Computes the adjusted stroke width for a zoomed camera. apply_fill Fills the cairo context apply_stroke Applies a stroke to the VMobject in the cairo context. cache_cairo_context Caches the passed Pixel array into a Cairo Context capture_mobject Capture mobjects by storing it in pixel_array . capture_mobjects Capture mobjects by printing them on pixel_array . convert_pixel_array Converts a pixel array from values that have floats in then to proper RGB values. display_image_mobject Displays an ImageMobject by changing the pixel_array suitably. display_multiple_background_colored_vmobjects Displays multiple vmobjects that have the same color as the background. display_multiple_image_mobjects Displays multiple image mobjects by modifying the passed pixel_array. display_multiple_non_background_colored_vmobjects Displays multiple VMobjects in the cairo context, as long as they don't have background colors. display_multiple_point_cloud_mobjects Displays multiple PMobjects by modifying the passed pixel array. display_multiple_vectorized_mobjects Displays multiple VMobjects in the pixel_array display_point_cloud Displays a PMobject by modifying the pixel array suitably. display_vectorized Displays a VMobject in the cairo context get_background_colored_vmobject_displayer Returns the background_colored_vmobject_displayer if it exists or makes one and returns it if not. get_cached_cairo_context Returns the cached cairo context of the passed pixel array if it exists, and None if it doesn't. get_cairo_context Returns the cairo context for a pixel array after caching it to self.pixel_array_to_cairo_context If that array has already been cached, it returns the cached version instead. get_coords_of_all_pixels Returns the cartesian coordinates of each pixel. get_fill_rgbas Returns the RGBA array of the fill of the passed VMobject get_image Returns an image from the passed pixel array, or from the current frame if the passed pixel array is none. get_mobjects_to_display Used to get the list of mobjects to display with the camera. get_stroke_rgbas Gets the RGBA array for the stroke of the passed VMobject. get_thickening_nudges Determine a list of vectors used to nudge two-dimensional pixel coordinates. init_background Initialize the background. is_in_frame Checks whether the passed mobject is in frame or not. make_background_from_func Makes a pixel array for the background by using coords_to_colors_func to determine each pixel's color. on_screen_pixels Returns array of pixels that are on the screen from a given array of pixel_coordinates overlay_PIL_image Overlays a PIL image on the passed pixel array. overlay_rgba_array Overlays an RGBA array on top of the given Pixel array. points_to_pixel_coords reset Resets the camera's pixel array to that of the background reset_pixel_shape This method resets the height and width of a single pixel to the passed new_height and new_width. resize_frame_shape Changes frame_shape to match the aspect ratio of the pixels, where fixed_dimension determines whether frame_height or frame_width remains fixed while the other changes accordingly. set_background Sets the background to the passed pixel_array after converting to valid RGB values. set_background_from_func Sets the background to a pixel array using coords_to_colors_func to determine each pixel's color. set_cairo_context_color Sets the color of the cairo context set_cairo_context_path Sets a path for the cairo context with the vmobject passed set_frame_to_background set_pixel_array Sets the pixel array of the camera to the passed pixel array. thickened_coordinates Returns thickened coordinates for a passed array of pixel coords and a thickness to thicken by. transform_points_pre_display type_or_raise Return the type of mobject, if it is a type that can be rendered. Attributes background_color background_opacity adjust_out_of_range_points ( points ) [source]   If any of the points in the passed array are out of\nthe viable range, they are adjusted suitably. Parameters : points ( ndarray ) \u2013 The points to adjust Returns : The adjusted points. Return type : np.array adjusted_thickness ( thickness ) [source]   Computes the adjusted stroke width for a zoomed camera. Parameters : thickness ( float ) \u2013 The stroke width of a mobject. Returns : The adjusted stroke width that reflects zooming in with\nthe camera. Return type : float apply_fill ( ctx , vmobject ) [source]   Fills the cairo context Parameters : ctx ( Context ) \u2013 The cairo context vmobject ( VMobject ) \u2013 The VMobject Returns : The camera object. Return type : Camera apply_stroke ( ctx , vmobject , background = False ) [source]   Applies a stroke to the VMobject in the cairo context. Parameters : ctx ( Context ) \u2013 The cairo context vmobject ( VMobject ) \u2013 The VMobject background ( bool ) \u2013 Whether or not to consider the background when applying this\nstroke width, by default False Returns : The camera object with the stroke applied. Return type : Camera cache_cairo_context ( pixel_array , ctx ) [source]   Caches the passed Pixel array into a Cairo Context Parameters : pixel_array ( ndarray ) \u2013 The pixel array to cache ctx ( Context ) \u2013 The context to cache it into. capture_mobject ( mobject , ** kwargs ) [source]   Capture mobjects by storing it in pixel_array . This is a single-mobject version of capture_mobjects() . Parameters : mobject ( Mobject ) \u2013 Mobject to capture. kwargs ( Any ) \u2013 Keyword arguments to be passed to get_mobjects_to_display() . capture_mobjects ( mobjects , ** kwargs ) [source]   Capture mobjects by printing them on pixel_array . This is the essential function that converts the contents of a Scene\ninto an array, which is then converted to an image or video. Parameters : mobjects ( Iterable [ Mobject ] ) \u2013 Mobjects to capture. kwargs \u2013 Keyword arguments to be passed to get_mobjects_to_display() . Notes For a list of classes that can currently be rendered, see display_funcs() . convert_pixel_array ( pixel_array , convert_from_floats = False ) [source]   Converts a pixel array from values that have floats in then\nto proper RGB values. Parameters : pixel_array ( ndarray | list | tuple ) \u2013 Pixel array to convert. convert_from_floats ( bool ) \u2013 Whether or not to convert float values to ints, by default False Returns : The new, converted pixel array. Return type : np.array display_image_mobject ( image_mobject , pixel_array ) [source]   Displays an ImageMobject by changing the pixel_array suitably. Parameters : image_mobject ( AbstractImageMobject ) \u2013 The imageMobject to display pixel_array ( ndarray ) \u2013 The Pixel array to put the imagemobject in. display_multiple_background_colored_vmobjects ( cvmobjects , pixel_array ) [source]   Displays multiple vmobjects that have the same color as the background. Parameters : cvmobjects ( list ) \u2013 List of Colored VMobjects pixel_array ( ndarray ) \u2013 The pixel array. Returns : The camera object. Return type : Camera display_multiple_image_mobjects ( image_mobjects , pixel_array ) [source]   Displays multiple image mobjects by modifying the passed pixel_array. Parameters : image_mobjects ( list ) \u2013 list of ImageMobjects pixel_array ( ndarray ) \u2013 The pixel array to modify. display_multiple_non_background_colored_vmobjects ( vmobjects , pixel_array ) [source]   Displays multiple VMobjects in the cairo context, as long as they don\u2019t have\nbackground colors. Parameters : vmobjects ( list ) \u2013 list of the VMobjects pixel_array ( ndarray ) \u2013 The Pixel array to add the VMobjects to. display_multiple_point_cloud_mobjects ( pmobjects , pixel_array ) [source]   Displays multiple PMobjects by modifying the passed pixel array. Parameters : pmobjects ( list ) \u2013 List of PMobjects pixel_array ( ndarray ) \u2013 The pixel array to modify. display_multiple_vectorized_mobjects ( vmobjects , pixel_array ) [source]   Displays multiple VMobjects in the pixel_array Parameters : vmobjects ( list ) \u2013 list of VMobjects to display pixel_array ( ndarray ) \u2013 The pixel array display_point_cloud ( pmobject , points , rgbas , thickness , pixel_array ) [source]   Displays a PMobject by modifying the pixel array suitably. TODO: Write a description for the rgbas argument. Parameters : pmobject ( PMobject ) \u2013 Point Cloud Mobject points ( list ) \u2013 The points to display in the point cloud mobject rgbas ( ndarray ) thickness ( float ) \u2013 The thickness of each point of the PMobject pixel_array ( ndarray ) \u2013 The pixel array to modify. display_vectorized ( vmobject , ctx ) [source]   Displays a VMobject in the cairo context Parameters : vmobject ( VMobject ) \u2013 The Vectorized Mobject to display ctx ( Context ) \u2013 The cairo context to use. Returns : The camera object Return type : Camera get_background_colored_vmobject_displayer ( ) [source]   Returns the background_colored_vmobject_displayer\nif it exists or makes one and returns it if not. Returns : Object that displays VMobjects that have the same color\nas the background. Return type : BackGroundColoredVMobjectDisplayer get_cached_cairo_context ( pixel_array ) [source]   Returns the cached cairo context of the passed\npixel array if it exists, and None if it doesn\u2019t. Parameters : pixel_array ( ndarray ) \u2013 The pixel array to check. Returns : The cached cairo context. Return type : cairo.Context get_cairo_context ( pixel_array ) [source]   Returns the cairo context for a pixel array after\ncaching it to self.pixel_array_to_cairo_context\nIf that array has already been cached, it returns the\ncached version instead. Parameters : pixel_array ( ndarray ) \u2013 The Pixel array to get the cairo context of. Returns : The cairo context of the pixel array. Return type : cairo.Context get_coords_of_all_pixels ( ) [source]   Returns the cartesian coordinates of each pixel. Returns : The array of cartesian coordinates. Return type : np.ndarray get_fill_rgbas ( vmobject ) [source]   Returns the RGBA array of the fill of the passed VMobject Parameters : vmobject ( VMobject ) \u2013 The VMobject Returns : The RGBA Array of the fill of the VMobject Return type : np.array get_image ( pixel_array = None ) [source]   Returns an image from the passed\npixel array, or from the current frame\nif the passed pixel array is none. Parameters : pixel_array ( ndarray | list | tuple | None ) \u2013 The pixel array from which to get an image, by default None Returns : The PIL image of the array. Return type : PIL.Image get_mobjects_to_display ( mobjects , include_submobjects = True , excluded_mobjects = None ) [source]   Used to get the list of mobjects to display\nwith the camera. Parameters : mobjects ( Iterable [ Mobject ] ) \u2013 The Mobjects include_submobjects ( bool ) \u2013 Whether or not to include the submobjects of mobjects, by default True excluded_mobjects ( list | None ) \u2013 Any mobjects to exclude, by default None Returns : list of mobjects Return type : list get_stroke_rgbas ( vmobject , background = False ) [source]   Gets the RGBA array for the stroke of the passed\nVMobject. Parameters : vmobject ( VMobject ) \u2013 The VMobject background ( bool ) \u2013 Whether or not to consider the background when getting the stroke\nRGBAs, by default False Returns : The RGBA array of the stroke. Return type : np.ndarray get_thickening_nudges ( thickness ) [source]   Determine a list of vectors used to nudge\ntwo-dimensional pixel coordinates. Parameters : thickness ( float ) Return type : np.array init_background ( ) [source]   Initialize the background.\nIf self.background_image is the path of an image\nthe image is set as background; else, the default\nbackground color fills the background. is_in_frame ( mobject ) [source]   Checks whether the passed mobject is in\nframe or not. Parameters : mobject ( Mobject ) \u2013 The mobject for which the checking needs to be done. Returns : True if in frame, False otherwise. Return type : bool make_background_from_func ( coords_to_colors_func ) [source]   Makes a pixel array for the background by using coords_to_colors_func to determine each pixel\u2019s color. Each input\npixel\u2019s color. Each input to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not\npixel coordinates), and each output is expected to be an RGBA array of 4 floats. Parameters : coords_to_colors_func ( Callable [ [ ndarray ] , ndarray ] ) \u2013 The function whose input is an (x,y) pair of coordinates and\nwhose return values must be the colors for that point Returns : The pixel array which can then be passed to set_background. Return type : np.array on_screen_pixels ( pixel_coords ) [source]   Returns array of pixels that are on the screen from a given\narray of pixel_coordinates Parameters : pixel_coords ( ndarray ) \u2013 The pixel coords to check. Returns : The pixel coords on screen. Return type : np.array overlay_PIL_image ( pixel_array , image ) [source]   Overlays a PIL image on the passed pixel array. Parameters : pixel_array ( ndarray ) \u2013 The Pixel array image ( <module 'PIL.Image' from '/home/docs/checkouts/readthedocs.org/user_builds/manimce/envs/stable/lib/python3.13/site-packages/PIL/Image.py'> ) \u2013 The Image to overlay. overlay_rgba_array ( pixel_array , new_array ) [source]   Overlays an RGBA array on top of the given Pixel array. Parameters : pixel_array ( ndarray ) \u2013 The original pixel array to modify. new_array ( ndarray ) \u2013 The new pixel array to overlay. reset ( ) [source]   Resets the camera\u2019s pixel array\nto that of the background Returns : The camera object after setting the pixel array. Return type : Camera reset_pixel_shape ( new_height , new_width ) [source]   This method resets the height and width\nof a single pixel to the passed new_height and new_width. Parameters : new_height ( float ) \u2013 The new height of the entire scene in pixels new_width ( float ) \u2013 The new width of the entire scene in pixels resize_frame_shape ( fixed_dimension = 0 ) [source]   Changes frame_shape to match the aspect ratio\nof the pixels, where fixed_dimension determines\nwhether frame_height or frame_width\nremains fixed while the other changes accordingly. Parameters : fixed_dimension ( int ) \u2013 If 0, height is scaled with respect to width\nelse, width is scaled with respect to height. set_background ( pixel_array , convert_from_floats = False ) [source]   Sets the background to the passed pixel_array after converting\nto valid RGB values. Parameters : pixel_array ( ndarray | list | tuple ) \u2013 The pixel array to set the background to. convert_from_floats ( bool ) \u2013 Whether or not to convert floats values to proper RGB valid ones, by default False set_background_from_func ( coords_to_colors_func ) [source]   Sets the background to a pixel array using coords_to_colors_func to determine each pixel\u2019s color. Each input\npixel\u2019s color. Each input to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not\npixel coordinates), and each output is expected to be an RGBA array of 4 floats. Parameters : coords_to_colors_func ( Callable [ [ ndarray ] , ndarray ] ) \u2013 The function whose input is an (x,y) pair of coordinates and\nwhose return values must be the colors for that point set_cairo_context_color ( ctx , rgbas , vmobject ) [source]   Sets the color of the cairo context Parameters : ctx ( Context ) \u2013 The cairo context rgbas ( ndarray ) \u2013 The RGBA array with which to color the context. vmobject ( VMobject ) \u2013 The VMobject with which to set the color. Returns : The camera object Return type : Camera set_cairo_context_path ( ctx , vmobject ) [source]   Sets a path for the cairo context with the vmobject passed Parameters : ctx ( Context ) \u2013 The cairo context vmobject ( VMobject ) \u2013 The VMobject Returns : Camera object after setting cairo_context_path Return type : Camera set_pixel_array ( pixel_array , convert_from_floats = False ) [source]   Sets the pixel array of the camera to the passed pixel array. Parameters : pixel_array ( ndarray | list | tuple ) \u2013 The pixel array to convert and then set as the camera\u2019s pixel array. convert_from_floats ( bool ) \u2013 Whether or not to convert float values to proper RGB values, by default False thickened_coordinates ( pixel_coords , thickness ) [source]   Returns thickened coordinates for a passed array of pixel coords and\na thickness to thicken by. Parameters : pixel_coords ( ndarray ) \u2013 Pixel coordinates thickness ( float ) \u2013 Thickness Returns : Array of thickened pixel coords. Return type : np.array type_or_raise ( mobject ) [source]   Return the type of mobject, if it is a type that can be rendered. If mobject is an instance of a class that inherits from a class that\ncan be rendered, return the super class.  For example, an instance of a\nSquare is also an instance of VMobject, and these can be rendered.\nTherefore, type_or_raise(Square()) returns True. Parameters : mobject ( Mobject ) \u2013 The object to take the type of. Notes For a list of classes that can currently be rendered, see display_funcs() . Returns : The type of mobjects, if it can be rendered. Return type : Type[ Mobject ] Raises : TypeError \u2013 When mobject is not an instance of a class that can be rendered. Parameters : mobject ( Mobject )", "original_prompt": "class Camera(background_image=None, frame_center=array("}
{"prompt": "Animate a camera object capturing mobjects on pixel_array with varying background colors and opacities.", "response": "Bases: Camera Camera object that allows mapping\nbetween objects. Methods capture_mobjects Capture mobjects by printing them on pixel_array . points_to_pixel_coords Attributes background_color background_opacity capture_mobjects ( mobjects , ** kwargs ) [source]   Capture mobjects by printing them on pixel_array . This is the essential function that converts the contents of a Scene\ninto an array, which is then converted to an image or video. Parameters : mobjects \u2013 Mobjects to capture. kwargs \u2013 Keyword arguments to be passed to get_mobjects_to_display() . Notes For a list of classes that can currently be rendered, see display_funcs() .", "original_prompt": "class MappingCamera(mapping_func=<function MappingCamera.<lambda>>, min_num_curves=50, allow_object_intrusion=False, **kwargs)"}
{"prompt": "\"Show a rotating 3D cube with fading animation on a white background.\"", "response": "Bases: Camera Methods capture_mobjects Capture mobjects by printing them on pixel_array . init_background Initialize the background. set_background Sets the background to the passed pixel_array after converting to valid RGB values. set_pixel_array Sets the pixel array of the camera to the passed pixel array. Attributes background_color background_opacity capture_mobjects ( mobjects , ** kwargs ) [source]   Capture mobjects by printing them on pixel_array . This is the essential function that converts the contents of a Scene\ninto an array, which is then converted to an image or video. Parameters : mobjects \u2013 Mobjects to capture. kwargs \u2013 Keyword arguments to be passed to get_mobjects_to_display() . Notes For a list of classes that can currently be rendered, see display_funcs() . init_background ( ) [source]   Initialize the background.\nIf self.background_image is the path of an image\nthe image is set as background; else, the default\nbackground color fills the background. set_background ( pixel_array , ** kwargs ) [source]   Sets the background to the passed pixel_array after converting\nto valid RGB values. Parameters : pixel_array \u2013 The pixel array to set the background to. convert_from_floats \u2013 Whether or not to convert floats values to proper RGB valid ones, by default False set_pixel_array ( pixel_array , ** kwargs ) [source]   Sets the pixel array of the camera to the passed pixel array. Parameters : pixel_array \u2013 The pixel array to convert and then set as the camera\u2019s pixel array. convert_from_floats \u2013 Whether or not to convert float values to proper RGB values, by default False", "original_prompt": "class OldMultiCamera(*cameras_with_start_positions, **kwargs)"}
{"prompt": "\"Fade in an old camera with a dark background, gradually brightening.\"", "response": "Bases: OldMultiCamera Methods Attributes background_color background_opacity", "original_prompt": "class SplitScreenCamera(left_camera, right_camera, **kwargs)"}
{"prompt": "\"Zoom into a scene with a fixed camera, capturing and displaying objects in the frame.\"", "response": "Bases: Camera Stays in line with the height, width and position of it\u2019s \u2018frame\u2019, which is a Rectangle See also MovingCameraScene Frame is a Mobject, (should almost certainly be a rectangle)\ndetermining which region of space the camera displays Methods auto_zoom Zooms on to a given array of mobjects (or a singular mobject) and automatically resizes to frame all the mobjects. cache_cairo_context Since the frame can be moving around, the cairo context used for updating should be regenerated at each frame. capture_mobjects Capture mobjects by printing them on pixel_array . get_cached_cairo_context Since the frame can be moving around, the cairo context used for updating should be regenerated at each frame. get_mobjects_indicating_movement Returns all mobjects whose movement implies that the camera should think of all other mobjects on the screen as moving Attributes background_color background_opacity frame_center Returns the centerpoint of the frame in cartesian coordinates. frame_height Returns the height of the frame. frame_width Returns the width of the frame auto_zoom ( mobjects , margin = 0 , only_mobjects_in_frame = False , animate = True ) [source]   Zooms on to a given array of mobjects (or a singular mobject)\nand automatically resizes to frame all the mobjects. Note This method only works when 2D-objects in the XY-plane are considered, it\nwill not work correctly when the camera has been rotated. Parameters : mobjects ( list [ Mobject ] ) \u2013 The mobject or array of mobjects that the camera will focus on. margin ( float ) \u2013 The width of the margin that is added to the frame (optional, 0 by default). only_mobjects_in_frame ( bool ) \u2013 If set to True , only allows focusing on mobjects that are already in frame. animate ( bool ) \u2013 If set to False , applies the changes instead of returning the corresponding animation Returns : _AnimationBuilder that zooms the camera view to a given list of mobjects\nor ScreenRectangle with position and size updated to zoomed position. Return type : Union [_AnimationBuilder, ScreenRectangle ] cache_cairo_context ( pixel_array , ctx ) [source]   Since the frame can be moving around, the cairo\ncontext used for updating should be regenerated\nat each frame.  So no caching. capture_mobjects ( mobjects , ** kwargs ) [source]   Capture mobjects by printing them on pixel_array . This is the essential function that converts the contents of a Scene\ninto an array, which is then converted to an image or video. Parameters : mobjects \u2013 Mobjects to capture. kwargs \u2013 Keyword arguments to be passed to get_mobjects_to_display() . Notes For a list of classes that can currently be rendered, see display_funcs() . property frame_center   Returns the centerpoint of the frame in cartesian coordinates. Returns : The cartesian coordinates of the center of the frame. Return type : np.array property frame_height   Returns the height of the frame. Returns : The height of the frame. Return type : float property frame_width   Returns the width of the frame Returns : The width of the frame. Return type : float get_cached_cairo_context ( pixel_array ) [source]   Since the frame can be moving around, the cairo\ncontext used for updating should be regenerated\nat each frame.  So no caching. get_mobjects_indicating_movement ( ) [source]   Returns all mobjects whose movement implies that the camera\nshould think of all other mobjects on the screen as moving Return type : list", "original_prompt": "class MovingCamera(frame=None, fixed_dimension=0, default_frame_stroke_color=ManimColor('#FFFFFF'), default_frame_stroke_width=0, **kwargs)"}
{"prompt": "Animate a moving camera that captures and displays various mobjects, including images and 3D objects, as it moves through different scenes.", "response": "Bases: MovingCamera Camera Object that allows for multiple perspectives. Initialises the MultiCamera Parameters : image_mobjects_from_cameras ( ImageMobject | None ) kwargs \u2013 Any valid keyword arguments of MovingCamera. Methods add_image_mobject_from_camera Adds an ImageMobject that's been obtained from the camera into the list self.image_mobject_from_cameras capture_mobjects Capture mobjects by printing them on pixel_array . get_mobjects_indicating_movement Returns all mobjects whose movement implies that the camera should think of all other mobjects on the screen as moving reset Resets the MultiCamera. update_sub_cameras Reshape sub_camera pixel_arrays Attributes background_color background_opacity frame_center Returns the centerpoint of the frame in cartesian coordinates. frame_height Returns the height of the frame. frame_width Returns the width of the frame add_image_mobject_from_camera ( image_mobject_from_camera ) [source]   Adds an ImageMobject that\u2019s been obtained from the camera\ninto the list self.image_mobject_from_cameras Parameters : image_mobject_from_camera ( ImageMobject ) \u2013 The ImageMobject to add to self.image_mobject_from_cameras capture_mobjects ( mobjects , ** kwargs ) [source]   Capture mobjects by printing them on pixel_array . This is the essential function that converts the contents of a Scene\ninto an array, which is then converted to an image or video. Parameters : mobjects \u2013 Mobjects to capture. kwargs \u2013 Keyword arguments to be passed to get_mobjects_to_display() . Notes For a list of classes that can currently be rendered, see display_funcs() . get_mobjects_indicating_movement ( ) [source]   Returns all mobjects whose movement implies that the camera\nshould think of all other mobjects on the screen as moving Return type : list reset ( ) [source]   Resets the MultiCamera. Returns : The reset MultiCamera Return type : MultiCamera update_sub_cameras ( ) [source]   Reshape sub_camera pixel_arrays", "original_prompt": "class MultiCamera(image_mobjects_from_cameras=None, allow_cameras_to_capture_their_own_display=False, **kwargs)"}
{"prompt": "Animate a 3D rotating cube with a dynamic background, displaying the camera's focal distance and rotation angles on the screen.", "response": "Bases: Camera Initializes the ThreeDCamera Parameters : *kwargs \u2013 Any keyword argument of Camera. Methods add_fixed_in_frame_mobjects This method allows the mobject to have a fixed position, even when the camera moves around. add_fixed_orientation_mobjects This method allows the mobject to have a fixed orientation, even when the camera moves around. capture_mobjects Capture mobjects by printing them on pixel_array . generate_rotation_matrix Generates a rotation matrix based off the current position of the camera. get_fill_rgbas Returns the RGBA array of the fill of the passed VMobject get_focal_distance Returns focal_distance of the Camera. get_gamma Returns the rotation of the camera about the vector from the ORIGIN to the Camera. get_mobjects_to_display Used to get the list of mobjects to display with the camera. get_phi Returns the Polar angle (the angle off Z_AXIS) phi. get_rotation_matrix Returns the matrix corresponding to the current position of the camera. get_stroke_rgbas Gets the RGBA array for the stroke of the passed VMobject. get_theta Returns the Azimuthal i.e the angle that spins the camera around the Z_AXIS. get_value_trackers A list of ValueTrackers of phi, theta, focal_distance, gamma and zoom. get_zoom Returns the zoom amount of the camera. modified_rgbas project_point Applies the current rotation_matrix as a projection matrix to the passed point. project_points Applies the current rotation_matrix as a projection matrix to the passed array of points. remove_fixed_in_frame_mobjects If a mobject was fixed in frame by passing it through add_fixed_in_frame_mobjects() , then this undoes that fixing. remove_fixed_orientation_mobjects If a mobject was fixed in its orientation by passing it through add_fixed_orientation_mobjects() , then this undoes that fixing. reset_rotation_matrix Sets the value of self.rotation_matrix to the matrix corresponding to the current position of the camera set_focal_distance Sets the focal_distance of the Camera. set_gamma Sets the angle of rotation of the camera about the vector from the ORIGIN to the Camera. set_phi Sets the polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians. set_theta Sets the azimuthal angle i.e the angle that spins the camera around Z_AXIS in radians. set_zoom Sets the zoom amount of the camera. transform_points_pre_display Attributes background_color background_opacity frame_center add_fixed_in_frame_mobjects ( * mobjects ) [source]   This method allows the mobject to have a fixed position,\neven when the camera moves around.\nE.G If it was passed through this method, at the top of the frame, it\nwill continue to be displayed at the top of the frame. Highly useful when displaying Titles or formulae or the like. Parameters : **mobjects ( Mobject ) \u2013 The mobject to fix in frame. add_fixed_orientation_mobjects ( * mobjects , use_static_center_func = False , center_func = None ) [source]   This method allows the mobject to have a fixed orientation,\neven when the camera moves around.\nE.G If it was passed through this method, facing the camera, it\nwill continue to face the camera even as the camera moves.\nHighly useful when adding labels to graphs and the like. Parameters : *mobjects ( Mobject ) \u2013 The mobject whose orientation must be fixed. use_static_center_func ( bool ) \u2013 Whether or not to use the function that takes the mobject\u2019s\ncenter as centerpoint, by default False center_func ( Callable [ [ ] , ndarray ] | None ) \u2013 The function which returns the centerpoint\nwith respect to which the mobject will be oriented, by default None capture_mobjects ( mobjects , ** kwargs ) [source]   Capture mobjects by printing them on pixel_array . This is the essential function that converts the contents of a Scene\ninto an array, which is then converted to an image or video. Parameters : mobjects \u2013 Mobjects to capture. kwargs \u2013 Keyword arguments to be passed to get_mobjects_to_display() . Notes For a list of classes that can currently be rendered, see display_funcs() . generate_rotation_matrix ( ) [source]   Generates a rotation matrix based off the current position of the camera. Returns : The matrix corresponding to the current position of the camera. Return type : np.array get_fill_rgbas ( vmobject ) [source]   Returns the RGBA array of the fill of the passed VMobject Parameters : vmobject \u2013 The VMobject Returns : The RGBA Array of the fill of the VMobject Return type : np.array get_focal_distance ( ) [source]   Returns focal_distance of the Camera. Returns : The focal_distance of the Camera in MUnits. Return type : float get_gamma ( ) [source]   Returns the rotation of the camera about the vector from the ORIGIN to the Camera. Returns : The angle of rotation of the camera about the vector\nfrom the ORIGIN to the Camera in radians Return type : float get_mobjects_to_display ( * args , ** kwargs ) [source]   Used to get the list of mobjects to display\nwith the camera. Parameters : mobjects \u2013 The Mobjects include_submobjects \u2013 Whether or not to include the submobjects of mobjects, by default True excluded_mobjects \u2013 Any mobjects to exclude, by default None Returns : list of mobjects Return type : list get_phi ( ) [source]   Returns the Polar angle (the angle off Z_AXIS) phi. Returns : The Polar angle in radians. Return type : float get_rotation_matrix ( ) [source]   Returns the matrix corresponding to the current position of the camera. Returns : The matrix corresponding to the current position of the camera. Return type : np.array get_stroke_rgbas ( vmobject , background = False ) [source]   Gets the RGBA array for the stroke of the passed\nVMobject. Parameters : vmobject \u2013 The VMobject background \u2013 Whether or not to consider the background when getting the stroke\nRGBAs, by default False Returns : The RGBA array of the stroke. Return type : np.ndarray get_theta ( ) [source]   Returns the Azimuthal i.e the angle that spins the camera around the Z_AXIS. Returns : The Azimuthal angle in radians. Return type : float get_value_trackers ( ) [source]   A list of ValueTrackers of phi, theta, focal_distance,\ngamma and zoom. Returns : list of ValueTracker objects Return type : list get_zoom ( ) [source]   Returns the zoom amount of the camera. Returns : The zoom amount of the camera. Return type : float project_point ( point ) [source]   Applies the current rotation_matrix as a projection\nmatrix to the passed point. Parameters : point ( list | ndarray ) \u2013 The point to project. Returns : The point after projection. Return type : np.array project_points ( points ) [source]   Applies the current rotation_matrix as a projection\nmatrix to the passed array of points. Parameters : points ( ndarray | list ) \u2013 The list of points to project. Returns : The points after projecting. Return type : np.array remove_fixed_in_frame_mobjects ( * mobjects ) [source]   If a mobject was fixed in frame by passing it through add_fixed_in_frame_mobjects() , then this undoes that fixing.\nThe Mobject will no longer be fixed in frame. Parameters : mobjects ( Mobject ) \u2013 The mobjects which need not be fixed in frame any longer. remove_fixed_orientation_mobjects ( * mobjects ) [source]   If a mobject was fixed in its orientation by passing it through add_fixed_orientation_mobjects() , then this undoes that fixing.\nThe Mobject will no longer have a fixed orientation. Parameters : mobjects ( Mobject ) \u2013 The mobjects whose orientation need not be fixed any longer. reset_rotation_matrix ( ) [source]   Sets the value of self.rotation_matrix to\nthe matrix corresponding to the current position of the camera set_focal_distance ( value ) [source]   Sets the focal_distance of the Camera. Parameters : value ( float ) \u2013 The focal_distance of the Camera. set_gamma ( value ) [source]   Sets the angle of rotation of the camera about the vector from the ORIGIN to the Camera. Parameters : value ( float ) \u2013 The new angle of rotation of the camera. set_phi ( value ) [source]   Sets the polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians. Parameters : value ( float ) \u2013 The new value of the polar angle in radians. set_theta ( value ) [source]   Sets the azimuthal angle i.e the angle that spins the camera around Z_AXIS in radians. Parameters : value ( float ) \u2013 The new value of the azimuthal angle in radians. set_zoom ( value ) [source]   Sets the zoom amount of the camera. Parameters : value ( float ) \u2013 The zoom amount of the camera.", "original_prompt": "class ThreeDCamera(focal_distance=20.0, shading_factor=0.2, default_distance=5.0, light_source_start_point=array("}
{"prompt": "Animate global Manim configuration settings, switching to a temporary modified version within the block.", "response": "Context manager that temporarily modifies the global config object. Inside the with statement, the modified config will be used.  After\ncontext manager exits, the config will be restored to its original state. Parameters : temp ( ManimConfig | dict [ str , Any ] ) \u2013 Object whose keys will be used to temporarily update the global config . Return type : Generator [None, None, None] Examples Use with tempconfig({...}) to temporarily change the default values of\ncertain config options. >>> config [ \"frame_height\" ] 8.0 >>> with tempconfig ({ \"frame_height\" : 100.0 }): ... print ( config [ \"frame_height\" ]) 100.0 >>> config [ \"frame_height\" ] 8.0", "original_prompt": "tempconfig(temp)"}
{"prompt": "\"Show library search paths as an unfolding scroll with a faint background, highlighting each path in order of precedence.\"", "response": "The paths where .cfg files will be searched for. When manim is first imported, it processes any .cfg files it finds.  This\nfunction returns the locations in which these files are searched for.  In\nascending order of precedence, these are: the library-wide config file, the\nuser-wide config file, and the folder-wide config file. The library-wide config file determines manim\u2019s default behavior.  The\nuser-wide config file is stored in the user\u2019s home folder, and determines\nthe behavior of manim whenever the user invokes it from anywhere in the\nsystem.  The folder-wide config file only affects scenes that are in the\nsame folder.  The latter two files are optional. These files, if they exist, are meant to loaded into a single configparser.ConfigParser object, and then processed by ManimConfig . Returns : List of paths which may contain .cfg files, in ascending order of\nprecedence. Return type : List[ Path ] See also make_config_parser() , ManimConfig.digest_file() , ManimConfig.digest_parser() Notes The location of the user-wide config file is OS-specific.", "original_prompt": "config_file_paths()"}
{"prompt": "\"Display user configuration from a cfg file, overriding library and folder configurations.\"", "response": "Make a ConfigParser object and load any .cfg files. The user-wide file, if it exists, overrides the library-wide file.  The\nfolder-wide file, if it exists, overrides the other two. The folder-wide file can be ignored by passing custom_file .  However,\nthe user-wide and library-wide config files cannot be ignored. Parameters : custom_file ( StrPath | None ) \u2013 Path to a custom config file.  If used, the folder-wide file in the\nrelevant directory will be ignored, if it exists.  If None, the\nfolder-wide file will be used, if it exists. Returns : A parser containing the config options found in the .cfg files that\nwere found.  It is guaranteed to contain at least the config options\nfound in the library-wide file. Return type : ConfigParser See also config_file_paths()", "original_prompt": "make_config_parser(custom_file=None)"}
{"prompt": "\"Set up Manim's logger and console with customizable verbosity.\"", "response": "Make the manim logger and console. Parameters : parser ( SectionProxy ) \u2013 A parser containing any .cfg files in use. verbosity ( str ) \u2013 The verbosity level of the logger. Returns : The manim logger and consoles. The first console outputs\nto stdout, the second to stderr. All use the theme returned by parse_theme() . Return type : logging.Logger , rich.Console , rich.Console See also make_config_parser() , parse_theme() Notes The parser is assumed to contain only the options related to\nconfiguring the logger at the top level.", "original_prompt": "make_logger(parser, verbosity)"}
{"prompt": "\"Display a console with a configured rich logger style, setting the overall output tone.\"", "response": "Configure the rich style of logger and console output. Parameters : parser ( SectionProxy ) \u2013 A parser containing any .cfg files in use. Returns : The rich theme to be used by the manim logger. Return type : rich.Theme See also make_logger()", "original_prompt": "parse_theme(parser)"}
{"prompt": "\"Add a file handler to Manim logger with specified scene and module names and destination path.\"", "response": "Add a file handler to manim logger. The path to the file is built using config.log_dir . Parameters : scene_name ( str ) \u2013 The name of the scene, used in the name of the log file. module_name ( str ) \u2013 The name of the module, used in the name of the log file. log_dir ( Path ) \u2013 Path to the folder where log files are stored. Return type : None", "original_prompt": "set_file_logger(scene_name, module_name, log_dir)"}
{"prompt": "\"Animate a rectangle changing shape and size with various colors and depths, gradually showing its filled color.\"", "response": "Bases: ScreenRectangle Methods Attributes animate Used to animate the application of any method of self . animation_overrides aspect_ratio The aspect ratio. color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( ** kwargs )   Initialize self.  See help(type(self)) for accurate signature.", "original_prompt": "class FullScreenRectangle(**kwargs)"}
{"prompt": "\"Animate a rectangle with changing colors and stroke widths over time, with smooth transformations.\"", "response": "Bases: Rectangle Methods Attributes animate Used to animate the application of any method of self . animation_overrides aspect_ratio The aspect ratio. color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( aspect_ratio = 1.7777777777777777 , height = 4 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. property aspect_ratio   The aspect ratio. When set, the width is stretched to accommodate\nthe new aspect ratio.", "original_prompt": "class ScreenRectangle(aspect_ratio=1.7777777777777777, height=4, **kwargs)"}
{"prompt": "\"Render a network of connected nodes, with edges forming a Digraph that transforms into a Graph.\"", "response": "nx . classes . graph . Graph | nx . classes . digraph . DiGraph", "original_prompt": "class NxGraph"}
{"prompt": "Animate an undirected graph with nodes as blue dots, edges as red lines, growing in size from left to right.", "response": "nx . classes . graph . Graph | nx . classes . digraph . DiGraph", "original_prompt": "class NxGraph"}
{"prompt": "It seems like you've provided a code snippet from the Manim library, which is used for creating animated mathematical content. The code appears to be related to graph visualization and animation.\n\nHowever, I don't see a specific question or prompt in your text. Could you please clarify what you're asking me to do? Are you trying to:\n\n* Explain how this code works?\n* Provide an example of using this code to create a graph visualization?\n* Fix a bug or issue with the code?\n* Something else?\n\nIf you could provide more context or information, I'd be happy to help.", "response": "Bases: GenericGraph A directed graph. Note In contrast to undirected graphs, the order in which vertices in a given\nedge are specified is relevant here. See also GenericGraph Parameters : vertices ( Sequence [ Hashable ] ) \u2013 A list of vertices. Must be hashable elements. edges ( Sequence [ tuple [ Hashable , Hashable ] ] ) \u2013 A list of edges, specified as tuples (u, v) where both u and v are vertices. The edge is directed from u to v . labels ( bool | dict ) \u2013 Controls whether or not vertices are labeled. If False (the default),\nthe vertices are not labeled; if True they are labeled using their\nnames (as specified in vertices ) via MathTex . Alternatively,\ncustom labels can be specified by passing a dictionary whose keys are\nthe vertices, and whose values are the corresponding vertex labels\n(rendered via, e.g., Text or Tex ). label_fill_color ( str ) \u2013 Sets the fill color of the default labels generated when labels is set to True . Has no effect for other values of labels . layout ( LayoutName | dict [ Hashable , Point3DLike ] | LayoutFunction ) \u2013 Either one of \"spring\" (the default), \"circular\" , \"kamada_kawai\" , \"planar\" , \"random\" , \"shell\" , \"spectral\" , \"spiral\" , \"tree\" , and \"partite\" for automatic vertex positioning using networkx (see their documentation for more details), or a dictionary specifying a coordinate (value)\nfor each vertex (key) for manual positioning. layout_config ( dict | None ) \u2013 Only for automatically generated layouts. A dictionary whose entries\nare passed as keyword arguments to the automatic layout algorithm\nspecified via layout of networkx .\nThe tree layout also accepts a special parameter vertex_spacing passed as a keyword argument inside the layout_config dictionary.\nPassing a tuple (space_x, space_y) as this argument overrides\nthe value of layout_scale and ensures that vertices are arranged\nin a way such that the centers of siblings in the same layer are\nat least space_x units apart horizontally, and neighboring layers\nare spaced space_y units vertically. layout_scale ( float | tuple [ float , float , float ] ) \u2013 The scale of automatically generated layouts: the vertices will\nbe arranged such that the coordinates are located within the\ninterval [-scale, scale] . Some layouts accept a tuple (scale_x, scale_y) causing the first coordinate to be in the interval [-scale_x, scale_x] ,\nand the second in [-scale_y, scale_y] . Default: 2. vertex_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying vertices in the scene. vertex_config ( dict | None ) \u2013 Either a dictionary containing keyword arguments to be passed to\nthe class specified via vertex_type , or a dictionary whose keys\nare the vertices, and whose values are dictionaries containing keyword\narguments for the mobject related to the corresponding vertex. vertex_mobjects ( dict | None ) \u2013 A dictionary whose keys are the vertices, and whose values are\nmobjects to be used as vertices. Passing vertices here overrides\nall other configuration options for a vertex. edge_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying edges in the scene. edge_config ( dict | None ) \u2013 Either a dictionary containing keyword arguments to be passed\nto the class specified via edge_type , or a dictionary whose\nkeys are the edges, and whose values are dictionaries containing\nkeyword arguments for the mobject related to the corresponding edge.\nYou can further customize the tip by adding a tip_config dictionary\nfor global styling, or by adding the dict to a specific edge_config . partitions ( Sequence [ Sequence [ Hashable ] ] | None ) root_vertex ( Hashable | None ) Examples Example: MovingDiGraph   from manim import * class MovingDiGraph ( Scene ): def construct ( self ): vertices = [ 1 , 2 , 3 , 4 ] edges = [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 1 , 3 ), ( 1 , 4 )] g = DiGraph ( vertices , edges ) self . add ( g ) self . play ( g [ 1 ] . animate . move_to ([ 1 , 1 , 1 ]), g [ 2 ] . animate . move_to ([ - 1 , 1 , 2 ]), g [ 3 ] . animate . move_to ([ 1 , - 1 , - 1 ]), g [ 4 ] . animate . move_to ([ - 1 , - 1 , 0 ]), ) self . wait () class MovingDiGraph(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]\n\n        g = DiGraph(vertices, edges)\n\n        self.add(g)\n        self.play(\n            g[1].animate.move_to([1, 1, 1]),\n            g[2].animate.move_to([-1, 1, 2]),\n            g[3].animate.move_to([1, -1, -1]),\n            g[4].animate.move_to([-1, -1, 0]),\n        )\n        self.wait() You can customize the edges and arrow tips globally or locally. Example: CustomDiGraph   from manim import * class CustomDiGraph ( Scene ): def construct ( self ): vertices = [ i for i in range ( 5 )] edges = [ ( 0 , 1 ), ( 1 , 2 ), ( 3 , 2 ), ( 3 , 4 ), ] edge_config = { \"stroke_width\" : 2 , \"tip_config\" : { \"tip_shape\" : ArrowSquareTip , \"tip_length\" : 0.15 , }, ( 3 , 4 ): { \"color\" : RED , \"tip_config\" : { \"tip_length\" : 0.25 , \"tip_width\" : 0.25 } }, } g = DiGraph ( vertices , edges , labels = True , layout = \"circular\" , edge_config = edge_config , ) . scale ( 1.4 ) self . play ( Create ( g )) self . wait () class CustomDiGraph(Scene):\n    def construct(self):\n        vertices = [i for i in range(5)]\n        edges = [\n            (0, 1),\n            (1, 2),\n            (3, 2),\n            (3, 4),\n        ]\n\n        edge_config = {\n            \"stroke_width\": 2,\n            \"tip_config\": {\n                \"tip_shape\": ArrowSquareTip,\n                \"tip_length\": 0.15,\n            },\n            (3, 4): {\n                \"color\": RED,\n                \"tip_config\": {\"tip_length\": 0.25, \"tip_width\": 0.25}\n            },\n        }\n\n        g = DiGraph(\n            vertices,\n            edges,\n            labels=True,\n            layout=\"circular\",\n            edge_config=edge_config,\n        ).scale(1.4)\n\n        self.play(Create(g))\n        self.wait() Since this implementation respects the labels boundary you can also use\nit for an undirected moving graph with labels. Example: UndirectedMovingDiGraph   from manim import * class UndirectedMovingDiGraph ( Scene ): def construct ( self ): vertices = [ i for i in range ( 5 )] edges = [ ( 0 , 1 ), ( 1 , 2 ), ( 3 , 2 ), ( 3 , 4 ), ] edge_config = { \"stroke_width\" : 2 , \"tip_config\" : { \"tip_length\" : 0 , \"tip_width\" : 0 }, ( 3 , 4 ): { \"color\" : RED }, } g = DiGraph ( vertices , edges , labels = True , layout = \"circular\" , edge_config = edge_config , ) . scale ( 1.4 ) self . play ( Create ( g )) self . wait () self . play ( g [ 1 ] . animate . move_to ([ 1 , 1 , 1 ]), g [ 2 ] . animate . move_to ([ - 1 , 1 , 2 ]), g [ 3 ] . animate . move_to ([ - 1.5 , - 1.5 , - 1 ]), g [ 4 ] . animate . move_to ([ 1 , - 2 , - 1 ]), ) self . wait () class UndirectedMovingDiGraph(Scene):\n    def construct(self):\n        vertices = [i for i in range(5)]\n        edges = [\n            (0, 1),\n            (1, 2),\n            (3, 2),\n            (3, 4),\n        ]\n\n        edge_config = {\n            \"stroke_width\": 2,\n            \"tip_config\": {\"tip_length\": 0, \"tip_width\": 0},\n            (3, 4): {\"color\": RED},\n        }\n\n        g = DiGraph(\n            vertices,\n            edges,\n            labels=True,\n            layout=\"circular\",\n            edge_config=edge_config,\n        ).scale(1.4)\n\n        self.play(Create(g))\n        self.wait()\n\n        self.play(\n            g[1].animate.move_to([1, 1, 1]),\n            g[2].animate.move_to([-1, 1, 2]),\n            g[3].animate.move_to([-1.5, -1.5, -1]),\n            g[4].animate.move_to([1, -2, -1]),\n        )\n        self.wait() Methods update_edges Updates the edges to stick at their corresponding vertices. Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. static _empty_networkx_graph ( ) [source]   Return an empty networkx graph for the given graph type. Return type : DiGraph _original__init__ ( vertices , edges , labels=False , label_fill_color=ManimColor('#000000') , layout='spring' , layout_scale=2 , layout_config=None , vertex_type=<class 'manim.mobject.geometry.arc.Dot'> , vertex_config=None , vertex_mobjects=None , edge_type=<class 'manim.mobject.geometry.line.Line'> , partitions=None , root_vertex=None , edge_config=None )   Initialize self.  See help(type(self)) for accurate signature. Parameters : vertices ( Sequence [ Hashable ] ) edges ( Sequence [ tuple [ Hashable , Hashable ] ] ) labels ( bool | dict ) label_fill_color ( str ) layout ( Literal [ 'circular' , 'kamada_kawai' , 'partite' , 'planar' , 'random' , 'shell' , 'spectral' , 'spiral' , 'spring' , 'tree' ] | dict [ ~collections.abc.Hashable , ~manim.typing.Point3DLike ] | ~manim.mobject.graph.LayoutFunction ) layout_scale ( float | tuple [ float , float , float ] ) layout_config ( dict | None ) vertex_type ( type [ Mobject ] ) vertex_config ( dict | None ) vertex_mobjects ( dict | None ) edge_type ( type [ Mobject ] ) partitions ( Sequence [ Sequence [ Hashable ] ] | None ) root_vertex ( Hashable | None ) edge_config ( dict | None ) Return type : None _populate_edge_dict ( edges , edge_type ) [source]   Helper method for populating the edges of the graph. Parameters : edges ( list [ tuple [ Hashable , Hashable ] ] ) edge_type ( type [ Mobject ] ) update_edges ( graph ) [source]   Updates the edges to stick at their corresponding vertices. Arrow tips need to be repositioned since otherwise they can be\ndeformed.", "original_prompt": "class DiGraph(vertices, edges, labels=False, label_fill_color=ManimColor('#000000'), layout='spring', layout_scale=2, layout_config=None, vertex_type=<class 'manim.mobject.geometry.arc.Dot'>, vertex_config=None, vertex_mobjects=None, edge_type=<class 'manim.mobject.geometry.line.Line'>, partitions=None, root_vertex=None, edge_config=None)"}
{"prompt": "It appears that you are asking for help with a specific function in the `manim` library. The function is not explicitly stated in your prompt, but based on the code snippet provided, it seems like you are trying to remove an edge from a graph.\n\nTo answer your question, I will provide an example of how to use the `remove_edges` function from the `Graph` class:\n\n```python\nclass RemoveEdge(Scene):\n    def construct(self):\n        G = Graph([1, 2, 3], [(1, 2), (2, 3)])\n        edge_to_remove = (1, 2)\n        removed = G.remove_edges(edge_to_remove)\n```\n\nIn this example, we create a graph `G` with two vertices and one edge. We then specify the edge to be removed using the tuple `(1, 2)`. The `remove_edges` function returns a group of edges that were removed from the graph.\n\nIf you want to remove multiple edges at once, you can pass multiple tuples to the `remove_edges` function:\n\n```python\nclass RemoveMultipleEdges(Scene):\n    def construct(self):\n        G = Graph([1, 2, 3], [(1, 2), (2, 3)])\n        edge_to_remove_1 = (1, 2)\n        edge_to_remove_2 = (2, 3)\n        removed = G.remove_edges(edge_to_remove_1 + edge_to_remove_2)\n```\n\nI hope this helps! Let me know if you have any further questions.", "response": "Bases: VMobject Abstract base class for graphs (that is, a collection of vertices\nconnected with edges). Graphs can be instantiated by passing both a list of (distinct, hashable)\nvertex names, together with list of edges (as tuples of vertex names). See\nthe examples for concrete implementations of this class for details. Note This implementation uses updaters to make the edges move with\nthe vertices. See also Graph , DiGraph Parameters : vertices ( Sequence [ Hashable ] ) \u2013 A list of vertices. Must be hashable elements. edges ( Sequence [ tuple [ Hashable , Hashable ] ] ) \u2013 A list of edges, specified as tuples (u, v) where both u and v are vertices. labels ( bool | dict ) \u2013 Controls whether or not vertices are labeled. If False (the default),\nthe vertices are not labeled; if True they are labeled using their\nnames (as specified in vertices ) via MathTex . Alternatively,\ncustom labels can be specified by passing a dictionary whose keys are\nthe vertices, and whose values are the corresponding vertex labels\n(rendered via, e.g., Text or Tex ). label_fill_color ( str ) \u2013 Sets the fill color of the default labels generated when labels is set to True . Has no effect for other values of labels . layout ( LayoutName | dict [ Hashable , Point3DLike ] | LayoutFunction ) \u2013 Either one of \"spring\" (the default), \"circular\" , \"kamada_kawai\" , \"planar\" , \"random\" , \"shell\" , \"spectral\" , \"spiral\" , \"tree\" , and \"partite\" for automatic vertex positioning primarily using networkx (see their documentation for more details), a dictionary specifying a coordinate (value)\nfor each vertex (key) for manual positioning, or a .:class: ~.LayoutFunction with a user-defined automatic layout. layout_config ( dict | None ) \u2013 Only for automatic layouts. A dictionary whose entries\nare passed as keyword arguments to the named layout or automatic layout function\nspecified via layout .\nThe tree layout also accepts a special parameter vertex_spacing passed as a keyword argument inside the layout_config dictionary.\nPassing a tuple (space_x, space_y) as this argument overrides\nthe value of layout_scale and ensures that vertices are arranged\nin a way such that the centers of siblings in the same layer are\nat least space_x units apart horizontally, and neighboring layers\nare spaced space_y units vertically. layout_scale ( float | tuple [ float , float , float ] ) \u2013 The scale of automatically generated layouts: the vertices will\nbe arranged such that the coordinates are located within the\ninterval [-scale, scale] . Some layouts accept a tuple (scale_x, scale_y) causing the first coordinate to be in the interval [-scale_x, scale_x] ,\nand the second in [-scale_y, scale_y] . Default: 2. vertex_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying vertices in the scene. vertex_config ( dict | None ) \u2013 Either a dictionary containing keyword arguments to be passed to\nthe class specified via vertex_type , or a dictionary whose keys\nare the vertices, and whose values are dictionaries containing keyword\narguments for the mobject related to the corresponding vertex. vertex_mobjects ( dict | None ) \u2013 A dictionary whose keys are the vertices, and whose values are\nmobjects to be used as vertices. Passing vertices here overrides\nall other configuration options for a vertex. edge_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying edges in the scene.\nMust be a subclass of Line for default updaters to work. edge_config ( dict | None ) \u2013 Either a dictionary containing keyword arguments to be passed\nto the class specified via edge_type , or a dictionary whose\nkeys are the edges, and whose values are dictionaries containing\nkeyword arguments for the mobject related to the corresponding edge. partitions ( Sequence [ Sequence [ Hashable ] ] | None ) root_vertex ( Hashable | None ) Methods add_edges Add new edges to the graph. add_vertices Add a list of vertices to the graph. change_layout Change the layout of this graph. from_networkx Build a Graph or DiGraph from a given networkx graph. remove_edges Remove several edges from the graph. remove_vertices Remove several vertices from the graph. Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _add_edge ( edge , edge_type=<class 'manim.mobject.geometry.line.Line'> , edge_config=None ) [source]   Add a new edge to the graph. Parameters : edge ( tuple [ Hashable , Hashable ] ) \u2013 The edge (as a tuple of vertex identifiers) to be added. If a non-existing\nvertex is passed, a new vertex with default settings will be created. Create\nnew vertices yourself beforehand to customize them. edge_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying edges in the scene. edge_config ( dict | None ) \u2013 A dictionary containing keyword arguments to be passed\nto the class specified via edge_type . Returns : A group containing all newly added vertices and edges. Return type : Group _add_vertex ( vertex , position=None , label=False , label_fill_color=ManimColor('#000000') , vertex_type=<class 'manim.mobject.geometry.arc.Dot'> , vertex_config=None , vertex_mobject=None ) [source]   Add a vertex to the graph. Parameters : vertex ( Hashable ) \u2013 A hashable vertex identifier. position ( Point3DLike | None ) \u2013 The coordinates where the new vertex should be added. If None , the center\nof the graph is used. label ( bool ) \u2013 Controls whether or not the vertex is labeled. If False (the default),\nthe vertex is not labeled; if True it is labeled using its\nnames (as specified in vertex ) via MathTex . Alternatively,\nany Mobject can be passed to be used as the label. label_fill_color ( str ) \u2013 Sets the fill color of the default labels generated when labels is set to True . Has no effect for other values of label . vertex_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying vertices in the scene. vertex_config ( dict | None ) \u2013 A dictionary containing keyword arguments to be passed to\nthe class specified via vertex_type . vertex_mobject ( dict | None ) \u2013 The mobject to be used as the vertex. Overrides all other\nvertex customization options. Return type : Mobject static _empty_networkx_graph ( ) [source]   Return an empty networkx graph for the given graph type. Return type : Graph _original__init__ ( vertices , edges , labels=False , label_fill_color=ManimColor('#000000') , layout='spring' , layout_scale=2 , layout_config=None , vertex_type=<class 'manim.mobject.geometry.arc.Dot'> , vertex_config=None , vertex_mobjects=None , edge_type=<class 'manim.mobject.geometry.line.Line'> , partitions=None , root_vertex=None , edge_config=None )   Initialize self.  See help(type(self)) for accurate signature. Parameters : vertices ( Sequence [ Hashable ] ) edges ( Sequence [ tuple [ Hashable , Hashable ] ] ) labels ( bool | dict ) label_fill_color ( str ) layout ( Literal [ 'circular' , 'kamada_kawai' , 'partite' , 'planar' , 'random' , 'shell' , 'spectral' , 'spiral' , 'spring' , 'tree' ] | dict [ ~collections.abc.Hashable , ~manim.typing.Point3DLike ] | ~manim.mobject.graph.LayoutFunction ) layout_scale ( float | tuple [ float , float , float ] ) layout_config ( dict | None ) vertex_type ( type [ Mobject ] ) vertex_config ( dict | None ) vertex_mobjects ( dict | None ) edge_type ( type [ Mobject ] ) partitions ( Sequence [ Sequence [ Hashable ] ] | None ) root_vertex ( Hashable | None ) edge_config ( dict | None ) Return type : None _populate_edge_dict ( edges , edge_type ) [source]   Helper method for populating the edges of the graph. Parameters : edges ( list [ tuple [ Hashable , Hashable ] ] ) edge_type ( type [ Mobject ] ) _remove_edge ( edge ) [source]   Remove an edge from the graph. Parameters : edge ( tuple [ Hashable ] ) \u2013 The edge (i.e., a tuple of vertex identifiers) to be removed from the graph. Returns : The removed edge. Return type : Mobject _remove_vertex ( vertex ) [source]   Remove a vertex (as well as all incident edges) from the graph. Parameters : vertex \u2013 The identifier of a vertex to be removed. Returns : A mobject containing all removed objects. Return type : Group add_edges ( *edges , edge_type=<class 'manim.mobject.geometry.line.Line'> , edge_config=None , **kwargs ) [source]   Add new edges to the graph. Parameters : edges ( tuple [ Hashable , Hashable ] ) \u2013 Edges (as tuples of vertex identifiers) to be added. If a non-existing\nvertex is passed, a new vertex with default settings will be created. Create\nnew vertices yourself beforehand to customize them. edge_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying edges in the scene. edge_config ( dict | None ) \u2013 A dictionary either containing keyword arguments to be passed\nto the class specified via edge_type , or a dictionary\nwhose keys are the edge tuples, and whose values are dictionaries\ncontaining keyword arguments to be passed for the construction\nof the corresponding edge. kwargs \u2013 Any further keyword arguments are passed to add_vertices() which is used to create new vertices in the passed edges. Returns : A group containing all newly added vertices and edges. Return type : Group add_vertices ( *vertices , positions=None , labels=False , label_fill_color=ManimColor('#000000') , vertex_type=<class 'manim.mobject.geometry.arc.Dot'> , vertex_config=None , vertex_mobjects=None ) [source]   Add a list of vertices to the graph. Parameters : vertices ( Hashable ) \u2013 Hashable vertex identifiers. positions ( dict | None ) \u2013 A dictionary specifying the coordinates where the new vertices should be added.\nIf None , all vertices are created at the center of the graph. labels ( bool ) \u2013 Controls whether or not the vertex is labeled. If False (the default),\nthe vertex is not labeled; if True it is labeled using its\nnames (as specified in vertex ) via MathTex . Alternatively,\nany Mobject can be passed to be used as the label. label_fill_color ( str ) \u2013 Sets the fill color of the default labels generated when labels is set to True . Has no effect for other values of labels . vertex_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying vertices in the scene. vertex_config ( dict | None ) \u2013 A dictionary containing keyword arguments to be passed to\nthe class specified via vertex_type . vertex_mobjects ( dict | None ) \u2013 A dictionary whose keys are the vertex identifiers, and whose\nvalues are mobjects that should be used as vertices. Overrides\nall other vertex customization options. self ( Graph ) change_layout ( layout = 'spring' , layout_scale = 2 , layout_config = None , partitions = None , root_vertex = None ) [source]   Change the layout of this graph. See the documentation of Graph for details about the\nkeyword arguments. Examples Example: ChangeGraphLayout   from manim import * class ChangeGraphLayout ( Scene ): def construct ( self ): G = Graph ([ 1 , 2 , 3 , 4 , 5 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 5 )], layout = { 1 : [ - 2 , 0 , 0 ], 2 : [ - 1 , 0 , 0 ], 3 : [ 0 , 0 , 0 ], 4 : [ 1 , 0 , 0 ], 5 : [ 2 , 0 , 0 ]} ) self . play ( Create ( G )) self . play ( G . animate . change_layout ( \"circular\" )) self . wait () class ChangeGraphLayout(Scene):\n    def construct(self):\n        G = Graph([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)],\n                  layout={1: [-2, 0, 0], 2: [-1, 0, 0], 3: [0, 0, 0],\n                          4: [1, 0, 0], 5: [2, 0, 0]}\n                  )\n        self.play(Create(G))\n        self.play(G.animate.change_layout(\"circular\"))\n        self.wait() Parameters : layout ( Literal [ 'circular' , 'kamada_kawai' , 'partite' , 'planar' , 'random' , 'shell' , 'spectral' , 'spiral' , 'spring' , 'tree' ] | dict [ ~collections.abc.Hashable , ~manim.typing.Point3DLike ] | ~manim.mobject.graph.LayoutFunction ) layout_scale ( float | tuple [ float , float , float ] ) layout_config ( dict [ str , Any ] | None ) partitions ( list [ list [ Hashable ] ] | None ) root_vertex ( Hashable | None ) Return type : Graph classmethod from_networkx ( nxgraph , ** kwargs ) [source]   Build a Graph or DiGraph from a\ngiven networkx graph. Parameters : nxgraph ( Graph | DiGraph ) \u2013 A networkx graph or digraph. **kwargs \u2013 Keywords to be passed to the constructor of Graph . Examples Example: ImportNetworkxGraph   from manim import * import networkx as nx nxgraph = nx . erdos_renyi_graph ( 14 , 0.5 ) class ImportNetworkxGraph ( Scene ): def construct ( self ): G = Graph . from_networkx ( nxgraph , layout = \"spring\" , layout_scale = 3.5 ) self . play ( Create ( G )) self . play ( * [ G [ v ] . animate . move_to ( 5 * RIGHT * np . cos ( ind / 7 * PI ) + 3 * UP * np . sin ( ind / 7 * PI )) for ind , v in enumerate ( G . vertices )]) self . play ( Uncreate ( G )) import networkx as nx\n\nnxgraph = nx.erdos_renyi_graph(14, 0.5)\n\nclass ImportNetworkxGraph(Scene):\n    def construct(self):\n        G = Graph.from_networkx(nxgraph, layout=\"spring\", layout_scale=3.5)\n        self.play(Create(G))\n        self.play(*[G[v].animate.move_to(5*RIGHT*np.cos(ind/7 * PI) +\n                                         3*UP*np.sin(ind/7 * PI))\n                    for ind, v in enumerate(G.vertices)])\n        self.play(Uncreate(G)) remove_edges ( * edges ) [source]   Remove several edges from the graph. Parameters : edges ( tuple [ Hashable ] ) \u2013 Edges to be removed from the graph. Returns : A group containing all removed edges. Return type : Group remove_vertices ( * vertices ) [source]   Remove several vertices from the graph. Parameters : vertices \u2013 Vertices to be removed from the graph. Examples >>> G = Graph ([ 1 , 2 , 3 ], [( 1 , 2 ), ( 2 , 3 )]) >>> removed = G . remove_vertices ( 2 , 3 ); removed VGroup(Line, Line, Dot, Dot) >>> G Undirected graph on 1 vertices and 0 edges", "original_prompt": "class GenericGraph(vertices, edges, labels=False, label_fill_color=ManimColor('#000000'), layout='spring', layout_scale=2, layout_config=None, vertex_type=<class 'manim.mobject.geometry.arc.Dot'>, vertex_config=None, vertex_mobjects=None, edge_type=<class 'manim.mobject.geometry.line.Line'>, partitions=None, root_vertex=None, edge_config=None)"}
{"prompt": "I can help you with a problem related to the NetworkX library and Manim.\n\nHowever, I don't see a specific problem or question in your prompt. Could you please provide more details or clarify what you need help with?\n\nAre you trying to create a graph with a specific layout using NetworkX and Manim, but encountering an issue? Or perhaps you're trying to understand how to use certain features of the library?\n\nIf you could provide more context or clarify what you're trying to accomplish, I'd be happy to try and assist you further.", "response": "Bases: GenericGraph An undirected graph (vertices connected with edges). The graph comes with an updater which makes the edges stick to\nthe vertices when moved around. See DiGraph for\na version with directed edges. See also GenericGraph Parameters : vertices ( Sequence [ Hashable ] ) \u2013 A list of vertices. Must be hashable elements. edges ( Sequence [ tuple [ Hashable , Hashable ] ] ) \u2013 A list of edges, specified as tuples (u, v) where both u and v are vertices. The vertex order is irrelevant. labels ( bool | dict ) \u2013 Controls whether or not vertices are labeled. If False (the default),\nthe vertices are not labeled; if True they are labeled using their\nnames (as specified in vertices ) via MathTex . Alternatively,\ncustom labels can be specified by passing a dictionary whose keys are\nthe vertices, and whose values are the corresponding vertex labels\n(rendered via, e.g., Text or Tex ). label_fill_color ( str ) \u2013 Sets the fill color of the default labels generated when labels is set to True . Has no effect for other values of labels . layout ( LayoutName | dict [ Hashable , Point3DLike ] | LayoutFunction ) \u2013 Either one of \"spring\" (the default), \"circular\" , \"kamada_kawai\" , \"planar\" , \"random\" , \"shell\" , \"spectral\" , \"spiral\" , \"tree\" , and \"partite\" for automatic vertex positioning using networkx (see their documentation for more details), or a dictionary specifying a coordinate (value)\nfor each vertex (key) for manual positioning. layout_config ( dict | None ) \u2013 Only for automatically generated layouts. A dictionary whose entries\nare passed as keyword arguments to the automatic layout algorithm\nspecified via layout of networkx .\nThe tree layout also accepts a special parameter vertex_spacing passed as a keyword argument inside the layout_config dictionary.\nPassing a tuple (space_x, space_y) as this argument overrides\nthe value of layout_scale and ensures that vertices are arranged\nin a way such that the centers of siblings in the same layer are\nat least space_x units apart horizontally, and neighboring layers\nare spaced space_y units vertically. layout_scale ( float | tuple [ float , float , float ] ) \u2013 The scale of automatically generated layouts: the vertices will\nbe arranged such that the coordinates are located within the\ninterval [-scale, scale] . Some layouts accept a tuple (scale_x, scale_y) causing the first coordinate to be in the interval [-scale_x, scale_x] ,\nand the second in [-scale_y, scale_y] . Default: 2. vertex_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying vertices in the scene. vertex_config ( dict | None ) \u2013 Either a dictionary containing keyword arguments to be passed to\nthe class specified via vertex_type , or a dictionary whose keys\nare the vertices, and whose values are dictionaries containing keyword\narguments for the mobject related to the corresponding vertex. vertex_mobjects ( dict | None ) \u2013 A dictionary whose keys are the vertices, and whose values are\nmobjects to be used as vertices. Passing vertices here overrides\nall other configuration options for a vertex. edge_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying edges in the scene. edge_config ( dict | None ) \u2013 Either a dictionary containing keyword arguments to be passed\nto the class specified via edge_type , or a dictionary whose\nkeys are the edges, and whose values are dictionaries containing\nkeyword arguments for the mobject related to the corresponding edge. partitions ( Sequence [ Sequence [ Hashable ] ] | None ) root_vertex ( Hashable | None ) Examples First, we create a small graph and demonstrate that the edges move\ntogether with the vertices. Example: MovingVertices   from manim import * class MovingVertices ( Scene ): def construct ( self ): vertices = [ 1 , 2 , 3 , 4 ] edges = [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 1 , 3 ), ( 1 , 4 )] g = Graph ( vertices , edges ) self . play ( Create ( g )) self . wait () self . play ( g [ 1 ] . animate . move_to ([ 1 , 1 , 0 ]), g [ 2 ] . animate . move_to ([ - 1 , 1 , 0 ]), g [ 3 ] . animate . move_to ([ 1 , - 1 , 0 ]), g [ 4 ] . animate . move_to ([ - 1 , - 1 , 0 ])) self . wait () class MovingVertices(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]\n        g = Graph(vertices, edges)\n        self.play(Create(g))\n        self.wait()\n        self.play(g[1].animate.move_to([1, 1, 0]),\n                  g[2].animate.move_to([-1, 1, 0]),\n                  g[3].animate.move_to([1, -1, 0]),\n                  g[4].animate.move_to([-1, -1, 0]))\n        self.wait() There are several automatic positioning algorithms to choose from: Example: GraphAutoPosition   from manim import * class GraphAutoPosition ( Scene ): def construct ( self ): vertices = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] edges = [( 1 , 7 ), ( 1 , 8 ), ( 2 , 3 ), ( 2 , 4 ), ( 2 , 5 ), ( 2 , 8 ), ( 3 , 4 ), ( 6 , 1 ), ( 6 , 2 ), ( 6 , 3 ), ( 7 , 2 ), ( 7 , 4 )] autolayouts = [ \"spring\" , \"circular\" , \"kamada_kawai\" , \"planar\" , \"random\" , \"shell\" , \"spectral\" , \"spiral\" ] graphs = [ Graph ( vertices , edges , layout = lt ) . scale ( 0.5 ) for lt in autolayouts ] r1 = VGroup ( * graphs [: 3 ]) . arrange () r2 = VGroup ( * graphs [ 3 : 6 ]) . arrange () r3 = VGroup ( * graphs [ 6 :]) . arrange () self . add ( VGroup ( r1 , r2 , r3 ) . arrange ( direction = DOWN )) class GraphAutoPosition(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4, 5, 6, 7, 8]\n        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\n                 (2, 8), (3, 4), (6, 1), (6, 2),\n                 (6, 3), (7, 2), (7, 4)]\n        autolayouts = [\"spring\", \"circular\", \"kamada_kawai\",\n                       \"planar\", \"random\", \"shell\",\n                       \"spectral\", \"spiral\"]\n        graphs = [Graph(vertices, edges, layout=lt).scale(0.5)\n                  for lt in autolayouts]\n        r1 = VGroup(*graphs[:3]).arrange()\n        r2 = VGroup(*graphs[3:6]).arrange()\n        r3 = VGroup(*graphs[6:]).arrange()\n        self.add(VGroup(r1, r2, r3).arrange(direction=DOWN)) Vertices can also be positioned manually: Example: GraphManualPosition   from manim import * class GraphManualPosition ( Scene ): def construct ( self ): vertices = [ 1 , 2 , 3 , 4 ] edges = [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 1 )] lt = { 1 : [ 0 , 0 , 0 ], 2 : [ 1 , 1 , 0 ], 3 : [ 1 , - 1 , 0 ], 4 : [ - 1 , 0 , 0 ]} G = Graph ( vertices , edges , layout = lt ) self . add ( G ) class GraphManualPosition(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2), (2, 3), (3, 4), (4, 1)]\n        lt = {1: [0, 0, 0], 2: [1, 1, 0], 3: [1, -1, 0], 4: [-1, 0, 0]}\n        G = Graph(vertices, edges, layout=lt)\n        self.add(G) The vertices in graphs can be labeled, and configurations for vertices\nand edges can be modified both by default and for specific vertices and\nedges. Note In edge_config , edges can be passed in both directions: if (u, v) is an edge in the graph, both (u, v) as well\nas (v, u) can be used as keys in the dictionary. Example: LabeledModifiedGraph   from manim import * class LabeledModifiedGraph ( Scene ): def construct ( self ): vertices = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] edges = [( 1 , 7 ), ( 1 , 8 ), ( 2 , 3 ), ( 2 , 4 ), ( 2 , 5 ), ( 2 , 8 ), ( 3 , 4 ), ( 6 , 1 ), ( 6 , 2 ), ( 6 , 3 ), ( 7 , 2 ), ( 7 , 4 )] g = Graph ( vertices , edges , layout = \"circular\" , layout_scale = 3 , labels = True , vertex_config = { 7 : { \"fill_color\" : RED }}, edge_config = {( 1 , 7 ): { \"stroke_color\" : RED }, ( 2 , 7 ): { \"stroke_color\" : RED }, ( 4 , 7 ): { \"stroke_color\" : RED }}) self . add ( g ) class LabeledModifiedGraph(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4, 5, 6, 7, 8]\n        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\n                 (2, 8), (3, 4), (6, 1), (6, 2),\n                 (6, 3), (7, 2), (7, 4)]\n        g = Graph(vertices, edges, layout=\"circular\", layout_scale=3,\n                  labels=True, vertex_config={7: {\"fill_color\": RED}},\n                  edge_config={(1, 7): {\"stroke_color\": RED},\n                               (2, 7): {\"stroke_color\": RED},\n                               (4, 7): {\"stroke_color\": RED}})\n        self.add(g) You can also lay out a partite graph on columns by specifying\na list of the vertices on each side and choosing the partite layout. Note All vertices in your graph which are not listed in any of the partitions\nare collected in their own partition and rendered in the rightmost column. Example: PartiteGraph   from manim import * import networkx as nx class PartiteGraph ( Scene ): def construct ( self ): G = nx . Graph () G . add_nodes_from ([ 0 , 1 , 2 , 3 ]) G . add_edges_from ([( 0 , 2 ), ( 0 , 3 ), ( 1 , 2 )]) graph = Graph ( list ( G . nodes ), list ( G . edges ), layout = \"partite\" , partitions = [[ 0 , 1 ]]) self . play ( Create ( graph )) import networkx as nx\n\nclass PartiteGraph(Scene):\n    def construct(self):\n        G = nx.Graph()\n        G.add_nodes_from([0, 1, 2, 3])\n        G.add_edges_from([(0, 2), (0,3), (1, 2)])\n        graph = Graph(list(G.nodes), list(G.edges), layout=\"partite\", partitions=[[0, 1]])\n        self.play(Create(graph)) The representation of a linear artificial neural network is facilitated\nby the use of the partite layout and defining partitions for each layer. Example: LinearNN   from manim import * class LinearNN ( Scene ): def construct ( self ): edges = [] partitions = [] c = 0 layers = [ 2 , 3 , 3 , 2 ] # the number of neurons in each layer for i in layers : partitions . append ( list ( range ( c + 1 , c + i + 1 ))) c += i for i , v in enumerate ( layers [ 1 :]): last = sum ( layers [: i + 1 ]) for j in range ( v ): for k in range ( last - layers [ i ], last ): edges . append (( k + 1 , j + last + 1 )) vertices = np . arange ( 1 , sum ( layers ) + 1 ) graph = Graph ( vertices , edges , layout = 'partite' , partitions = partitions , layout_scale = 3 , vertex_config = { 'radius' : 0.20 }, ) self . add ( graph ) class LinearNN(Scene):\n    def construct(self):\n        edges = []\n        partitions = []\n        c = 0\n        layers = [2, 3, 3, 2]  # the number of neurons in each layer\n\n        for i in layers:\n            partitions.append(list(range(c + 1, c + i + 1)))\n            c += i\n        for i, v in enumerate(layers[1:]):\n                last = sum(layers[:i+1])\n                for j in range(v):\n                    for k in range(last - layers[i], last):\n                        edges.append((k + 1, j + last + 1))\n\n        vertices = np.arange(1, sum(layers) + 1)\n\n        graph = Graph(\n            vertices,\n            edges,\n            layout='partite',\n            partitions=partitions,\n            layout_scale=3,\n            vertex_config={'radius': 0.20},\n        )\n        self.add(graph) The custom tree layout can be used to show the graph\nby distance from the root vertex. You must pass the root vertex\nof the tree. Example: Tree   from manim import * import networkx as nx class Tree ( Scene ): def construct ( self ): G = nx . Graph () G . add_node ( \"ROOT\" ) for i in range ( 5 ): G . add_node ( \"Child_ %i \" % i ) G . add_node ( \"Grandchild_ %i \" % i ) G . add_node ( \"Greatgrandchild_ %i \" % i ) G . add_edge ( \"ROOT\" , \"Child_ %i \" % i ) G . add_edge ( \"Child_ %i \" % i , \"Grandchild_ %i \" % i ) G . add_edge ( \"Grandchild_ %i \" % i , \"Greatgrandchild_ %i \" % i ) self . play ( Create ( Graph ( list ( G . nodes ), list ( G . edges ), layout = \"tree\" , root_vertex = \"ROOT\" ))) import networkx as nx\n\nclass Tree(Scene):\n    def construct(self):\n        G = nx.Graph()\n\n        G.add_node(\"ROOT\")\n\n        for i in range(5):\n            G.add_node(\"Child_%i\" % i)\n            G.add_node(\"Grandchild_%i\" % i)\n            G.add_node(\"Greatgrandchild_%i\" % i)\n\n            G.add_edge(\"ROOT\", \"Child_%i\" % i)\n            G.add_edge(\"Child_%i\" % i, \"Grandchild_%i\" % i)\n            G.add_edge(\"Grandchild_%i\" % i, \"Greatgrandchild_%i\" % i)\n\n        self.play(Create(\n            Graph(list(G.nodes), list(G.edges), layout=\"tree\", root_vertex=\"ROOT\"))) The following code sample illustrates the use of the vertex_spacing layout parameter specific to the \"tree\" layout. As mentioned\nabove, setting vertex_spacing overrides the specified value\nfor layout_scale , and as such it is harder to control the size\nof the mobject. However, we can adjust the captured frame and\nzoom out by using a MovingCameraScene : class LargeTreeGeneration ( MovingCameraScene ): DEPTH = 4 CHILDREN_PER_VERTEX = 3 LAYOUT_CONFIG = { \"vertex_spacing\" : ( 0.5 , 1 )} VERTEX_CONF = { \"radius\" : 0.25 , \"color\" : BLUE_B , \"fill_opacity\" : 1 } def expand_vertex ( self , g , vertex_id : str , depth : int ): new_vertices = [ f \" { vertex_id } / { i } \" for i in range ( self . CHILDREN_PER_VERTEX ) ] new_edges = [( vertex_id , child_id ) for child_id in new_vertices ] g . add_edges ( * new_edges , vertex_config = self . VERTEX_CONF , positions = { k : g . vertices [ vertex_id ] . get_center () + 0.1 * DOWN for k in new_vertices }, ) if depth < self . DEPTH : for child_id in new_vertices : self . expand_vertex ( g , child_id , depth + 1 ) return g def construct ( self ): g = Graph ([ \"ROOT\" ], [], vertex_config = self . VERTEX_CONF ) g = self . expand_vertex ( g , \"ROOT\" , 1 ) self . add ( g ) self . play ( g . animate . change_layout ( \"tree\" , root_vertex = \"ROOT\" , layout_config = self . LAYOUT_CONFIG , ) ) self . play ( self . camera . auto_zoom ( g , margin = 1 ), run_time = 0.5 ) Methods update_edges Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. static _empty_networkx_graph ( ) [source]   Return an empty networkx graph for the given graph type. Return type : Graph _original__init__ ( vertices , edges , labels=False , label_fill_color=ManimColor('#000000') , layout='spring' , layout_scale=2 , layout_config=None , vertex_type=<class 'manim.mobject.geometry.arc.Dot'> , vertex_config=None , vertex_mobjects=None , edge_type=<class 'manim.mobject.geometry.line.Line'> , partitions=None , root_vertex=None , edge_config=None )   Initialize self.  See help(type(self)) for accurate signature. Parameters : vertices ( Sequence [ Hashable ] ) edges ( Sequence [ tuple [ Hashable , Hashable ] ] ) labels ( bool | dict ) label_fill_color ( str ) layout ( Literal [ 'circular' , 'kamada_kawai' , 'partite' , 'planar' , 'random' , 'shell' , 'spectral' , 'spiral' , 'spring' , 'tree' ] | dict [ ~collections.abc.Hashable , ~manim.typing.Point3DLike ] | ~manim.mobject.graph.LayoutFunction ) layout_scale ( float | tuple [ float , float , float ] ) layout_config ( dict | None ) vertex_type ( type [ Mobject ] ) vertex_config ( dict | None ) vertex_mobjects ( dict | None ) edge_type ( type [ Mobject ] ) partitions ( Sequence [ Sequence [ Hashable ] ] | None ) root_vertex ( Hashable | None ) edge_config ( dict | None ) Return type : None _populate_edge_dict ( edges , edge_type ) [source]   Helper method for populating the edges of the graph. Parameters : edges ( list [ tuple [ Hashable , Hashable ] ] ) edge_type ( type [ Mobject ] )", "original_prompt": "class Graph(vertices, edges, labels=False, label_fill_color=ManimColor('#000000'), layout='spring', layout_scale=2, layout_config=None, vertex_type=<class 'manim.mobject.geometry.arc.Dot'>, vertex_config=None, vertex_mobjects=None, edge_type=<class 'manim.mobject.geometry.line.Line'>, partitions=None, root_vertex=None, edge_config=None)"}
{"prompt": "It seems like you forgot to include the code or a specific question related to the provided Manim classes. The text appears to be a list of Manim classes representing different graph layouts.\n\nIf you could provide more context or ask a specific question about these classes, I'd be happy to help! For example:\n\n* Are you trying to use one of these layouts in your own code?\n* Do you have any questions about the syntax or behavior of these classes?\n* Are there any errors or issues you're experiencing while using these classes?\n\nPlease feel free to provide more information so I can assist you better.", "response": "Bases: Protocol A protocol for automatic layout functions that compute a layout for a graph to be used in change_layout() . Note The layout function must be a pure function, i.e., it must not modify the graph passed to it. Examples Here is an example that arranges nodes in an n x m grid in sorted order. Example: CustomLayoutExample   from manim import * class CustomLayoutExample ( Scene ): def construct ( self ): import numpy as np import networkx as nx # create custom layout def custom_layout ( graph : nx . Graph , scale : float | tuple [ float , float , float ] = 2 , n : int | None = None , * args : Any , ** kwargs : Any , ): nodes = sorted ( list ( graph )) height = len ( nodes ) // n return { node : ( scale * np . array ([ ( i % n ) - ( n - 1 ) / 2 , - ( i // n ) + height / 2 , 0 ])) for i , node in enumerate ( graph ) } # draw graph n = 4 graph = Graph ( [ i for i in range ( 4 * 2 - 1 )], [( 0 , 1 ), ( 0 , 4 ), ( 1 , 2 ), ( 1 , 5 ), ( 2 , 3 ), ( 2 , 6 ), ( 4 , 5 ), ( 5 , 6 )], labels = True , layout = custom_layout , layout_config = { 'n' : n } ) self . add ( graph ) class CustomLayoutExample(Scene):\n    def construct(self):\n        import numpy as np\n        import networkx as nx\n\n        # create custom layout\n        def custom_layout(\n            graph: nx.Graph,\n            scale: float | tuple[float, float, float] = 2,\n            n: int | None = None,\n            *args: Any,\n            **kwargs: Any,\n        ):\n            nodes = sorted(list(graph))\n            height = len(nodes) // n\n            return {\n                node: (scale * np.array([\n                    (i % n) - (n-1)/2,\n                    -(i // n) + height/2,\n                    0\n                ])) for i, node in enumerate(graph)\n            }\n\n        # draw graph\n        n = 4\n        graph = Graph(\n            [i for i in range(4 * 2 - 1)],\n            [(0, 1), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (4, 5), (5, 6)],\n            labels=True,\n            layout=custom_layout,\n            layout_config={'n': n}\n        )\n        self.add(graph) Several automatic layouts are provided by manim, and can be used by passing their name as the layout parameter to change_layout() .\nAlternatively, a custom layout function can be passed to change_layout() as the layout parameter. Such a function must adhere to the LayoutFunction protocol. The LayoutFunction s provided by manim are illustrated below: Circular Layout: places the vertices on a circle Example: CircularLayout   from manim import * class CircularLayout ( Scene ): def construct ( self ): graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 5 ), ( 5 , 6 ), ( 6 , 1 ), ( 5 , 1 ), ( 1 , 3 ), ( 3 , 5 )], layout = \"circular\" , labels = True ) self . add ( graph ) class CircularLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"circular\",\n            labels=True\n        )\n        self.add(graph) Kamada Kawai Layout: tries to place the vertices such that the given distances between them are respected Example: KamadaKawaiLayout   from manim import * class KamadaKawaiLayout ( Scene ): def construct ( self ): from collections import defaultdict distances : dict [ int , dict [ int , float ]] = defaultdict ( dict ) # set desired distances distances [ 1 ][ 2 ] = 1 # distance between vertices 1 and 2 is 1 distances [ 2 ][ 3 ] = 1 # distance between vertices 2 and 3 is 1 distances [ 3 ][ 4 ] = 2 # etc distances [ 4 ][ 5 ] = 3 distances [ 5 ][ 6 ] = 5 distances [ 6 ][ 1 ] = 8 graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 5 ), ( 5 , 6 ), ( 6 , 1 )], layout = \"kamada_kawai\" , layout_config = { \"dist\" : distances }, layout_scale = 4 , labels = True ) self . add ( graph ) class KamadaKawaiLayout(Scene):\n    def construct(self):\n        from collections import defaultdict\n        distances: dict[int, dict[int, float]] = defaultdict(dict)\n\n        # set desired distances\n        distances[1][2] = 1  # distance between vertices 1 and 2 is 1\n        distances[2][3] = 1  # distance between vertices 2 and 3 is 1\n        distances[3][4] = 2  # etc\n        distances[4][5] = 3\n        distances[5][6] = 5\n        distances[6][1] = 8\n\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)],\n            layout=\"kamada_kawai\",\n            layout_config={\"dist\": distances},\n            layout_scale=4,\n            labels=True\n        )\n        self.add(graph) Partite Layout: places vertices into distinct partitions Example: PartiteLayout   from manim import * class PartiteLayout ( Scene ): def construct ( self ): graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 5 ), ( 5 , 6 ), ( 6 , 1 ), ( 5 , 1 ), ( 1 , 3 ), ( 3 , 5 )], layout = \"partite\" , layout_config = { \"partitions\" : [[ 1 , 2 ],[ 3 , 4 ],[ 5 , 6 ]]}, labels = True ) self . add ( graph ) class PartiteLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"partite\",\n            layout_config={\"partitions\": [[1,2],[3,4],[5,6]]},\n            labels=True\n        )\n        self.add(graph) Planar Layout: places vertices such that edges do not cross Example: PlanarLayout   from manim import * class PlanarLayout ( Scene ): def construct ( self ): graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 5 ), ( 5 , 6 ), ( 6 , 1 ), ( 5 , 1 ), ( 1 , 3 ), ( 3 , 5 )], layout = \"planar\" , layout_scale = 4 , labels = True ) self . add ( graph ) class PlanarLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"planar\",\n            layout_scale=4,\n            labels=True\n        )\n        self.add(graph) Random Layout: randomly places vertices Example: RandomLayout   from manim import * class RandomLayout ( Scene ): def construct ( self ): graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 5 ), ( 5 , 6 ), ( 6 , 1 ), ( 5 , 1 ), ( 1 , 3 ), ( 3 , 5 )], layout = \"random\" , labels = True ) self . add ( graph ) class RandomLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"random\",\n            labels=True\n        )\n        self.add(graph) Shell Layout: places vertices in concentric circles Example: ShellLayout   from manim import * class ShellLayout ( Scene ): def construct ( self ): nlist = [[ 1 , 2 , 3 ], [ 4 , 5 , 6 , 7 , 8 , 9 ]] graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 1 ), ( 4 , 1 ), ( 4 , 2 ), ( 5 , 2 ), ( 6 , 2 ), ( 6 , 3 ), ( 7 , 3 ), ( 8 , 3 ), ( 8 , 1 ), ( 9 , 1 )], layout = \"shell\" , layout_config = { \"nlist\" : nlist }, labels = True ) self . add ( graph ) class ShellLayout(Scene):\n    def construct(self):\n        nlist = [[1, 2, 3], [4, 5, 6, 7, 8, 9]]\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6, 7, 8, 9],\n            [(1, 2), (2, 3), (3, 1), (4, 1), (4, 2), (5, 2), (6, 2), (6, 3), (7, 3), (8, 3), (8, 1), (9, 1)],\n            layout=\"shell\",\n            layout_config={\"nlist\": nlist},\n            labels=True\n        )\n        self.add(graph) Spectral Layout: places vertices using the eigenvectors of the graph Laplacian (clusters nodes which are an approximation of the ratio cut) Example: SpectralLayout   from manim import * class SpectralLayout ( Scene ): def construct ( self ): graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 5 ), ( 5 , 6 ), ( 6 , 1 ), ( 5 , 1 ), ( 1 , 3 ), ( 3 , 5 )], layout = \"spectral\" , labels = True ) self . add ( graph ) class SpectralLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spectral\",\n            labels=True\n        )\n        self.add(graph) Sprial Layout: places vertices in a spiraling pattern Example: SpiralLayout   from manim import * class SpiralLayout ( Scene ): def construct ( self ): graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 5 ), ( 5 , 6 ), ( 6 , 1 ), ( 5 , 1 ), ( 1 , 3 ), ( 3 , 5 )], layout = \"spiral\" , labels = True ) self . add ( graph ) class SpiralLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spiral\",\n            labels=True\n        )\n        self.add(graph) Spring Layout: places nodes according to the Fruchterman-Reingold force-directed algorithm (attempts to minimize edge length while maximizing node separation) Example: SpringLayout   from manim import * class SpringLayout ( Scene ): def construct ( self ): graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 5 ), ( 5 , 6 ), ( 6 , 1 ), ( 5 , 1 ), ( 1 , 3 ), ( 3 , 5 )], layout = \"spring\" , labels = True ) self . add ( graph ) class SpringLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spring\",\n            labels=True\n        )\n        self.add(graph) Tree Layout: places vertices into a tree with a root node and branches (can only be used with legal trees) Example: TreeLayout   from manim import * class TreeLayout ( Scene ): def construct ( self ): graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ], [( 1 , 2 ), ( 1 , 3 ), ( 2 , 4 ), ( 2 , 5 ), ( 3 , 6 ), ( 3 , 7 )], layout = \"tree\" , layout_config = { \"root_vertex\" : 1 }, labels = True ) self . add ( graph ) class TreeLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6, 7],\n            [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)],\n            layout=\"tree\",\n            layout_config={\"root_vertex\": 1},\n            labels=True\n        )\n        self.add(graph) Methods", "original_prompt": "class LayoutFunction(*args, **kwargs)"}
{"prompt": "Animate a LightThemeBanner logo that expands and scales in both directions simultaneously with a 2-second run time, gradually darkening to its default state.", "response": "Bases: VGroup Convenience class representing Manim\u2019s banner. Can be animated using custom methods. Parameters : dark_theme ( bool ) \u2013 If True (the default), the dark theme version of the logo\n(with light text font) will be rendered. Otherwise, if False ,\nthe light theme version (with dark text font) is used. Examples Example: DarkThemeBanner   from manim import * class DarkThemeBanner ( Scene ): def construct ( self ): banner = ManimBanner () self . play ( banner . create ()) self . play ( banner . expand ()) self . wait () self . play ( Unwrite ( banner )) class DarkThemeBanner(Scene):\n    def construct(self):\n        banner = ManimBanner()\n        self.play(banner.create())\n        self.play(banner.expand())\n        self.wait()\n        self.play(Unwrite(banner)) Example: LightThemeBanner   from manim import * class LightThemeBanner ( Scene ): def construct ( self ): self . camera . background_color = \"#ece6e2\" banner = ManimBanner ( dark_theme = False ) self . play ( banner . create ()) self . play ( banner . expand ()) self . wait () self . play ( Unwrite ( banner )) class LightThemeBanner(Scene):\n    def construct(self):\n        self.camera.background_color = \"#ece6e2\"\n        banner = ManimBanner(dark_theme=False)\n        self.play(banner.create())\n        self.play(banner.expand())\n        self.wait()\n        self.play(Unwrite(banner)) Methods create The creation animation for Manim's logo. expand An animation that expands Manim's logo into its banner. scale Scale the banner by the specified scale factor. Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( dark_theme = True )   Initialize self.  See help(type(self)) for accurate signature. Parameters : dark_theme ( bool ) create ( run_time = 2 ) [source]   The creation animation for Manim\u2019s logo. Parameters : run_time ( float ) \u2013 The run time of the animation. Returns : An animation to be used in a Scene.play() call. Return type : AnimationGroup expand ( run_time = 1.5 , direction = 'center' ) [source]   An animation that expands Manim\u2019s logo into its banner. The returned animation transforms the banner from its initial\nstate (representing Manim\u2019s logo with just the icons) to its\nexpanded state (showing the full name together with the icons). See the class documentation for how to use this. Note Before calling this method, the text \u201canim\u201d is not a\nsubmobject of the banner object. After the expansion,\nit is added as a submobject so subsequent animations\nto the banner object apply to the text \u201canim\u201d as well. Parameters : run_time ( float ) \u2013 The run time of the animation. direction \u2013 The direction in which the logo is expanded. Returns : An animation to be used in a Scene.play() call. Return type : Succession Examples Example: ExpandDirections   from manim import * class ExpandDirections ( Scene ): def construct ( self ): banners = [ ManimBanner () . scale ( 0.5 ) . shift ( UP * x ) for x in [ - 2 , 0 , 2 ]] self . play ( banners [ 0 ] . expand ( direction = \"right\" ), banners [ 1 ] . expand ( direction = \"center\" ), banners [ 2 ] . expand ( direction = \"left\" ), ) class ExpandDirections(Scene):\n    def construct(self):\n        banners = [ManimBanner().scale(0.5).shift(UP*x) for x in [-2, 0, 2]]\n        self.play(\n            banners[0].expand(direction=\"right\"),\n            banners[1].expand(direction=\"center\"),\n            banners[2].expand(direction=\"left\"),\n        ) scale ( scale_factor , ** kwargs ) [source]   Scale the banner by the specified scale factor. Parameters : scale_factor ( float ) \u2013 The factor used for scaling the banner. Returns : The scaled banner. Return type : ManimBanner", "original_prompt": "class ManimBanner(dark_theme=True)"}
{"prompt": "\"Animate a scaled matrix with its determinant, rotating around it, with coordinate axes\"", "response": "Helper function to create determinant. Parameters : matrix ( Matrix ) \u2013 The matrix whose determinant is to be created determinant ( int | str | None ) \u2013 The value of the determinant of the matrix background_rect ( bool ) \u2013 The background rectangle initial_scale_factor ( float ) \u2013 The scale of the text det w.r.t the matrix Returns : A VGroup containing the determinant Return type : VGroup Examples Example: DeterminantOfAMatrix   from manim import * class DeterminantOfAMatrix ( Scene ): def construct ( self ): matrix = Matrix ([ [ 2 , 0 ], [ - 1 , 1 ] ]) # scaling down the `det` string det = get_det_text ( matrix , determinant = 3 , initial_scale_factor = 1 ) # must add the matrix self . add ( matrix ) self . add ( det ) class DeterminantOfAMatrix(Scene):\n    def construct(self):\n        matrix = Matrix([\n            [2, 0],\n            [-1, 1]\n        ])\n\n        # scaling down the `det` string\n        det = get_det_text(matrix,\n                    determinant=3,\n                    initial_scale_factor=1)\n\n        # must add the matrix\n        self.add(matrix)\n        self.add(det)", "original_prompt": "get_det_text(matrix, determinant=None, background_rect=False, initial_scale_factor=2)"}
{"prompt": "\"Animate a matrix with rounded decimal entries on the screen.\"", "response": "Bases: Matrix A mobject that displays a matrix with decimal entries on the screen. Examples Example: DecimalMatrixExample   from manim import * class DecimalMatrixExample ( Scene ): def construct ( self ): m0 = DecimalMatrix ( [[ 3.456 , 2.122 ], [ 33.2244 , 12 ]], element_to_mobject_config = { \"num_decimal_places\" : 2 }, left_bracket = \" \\\\ {\" , right_bracket = \" \\\\ }\" ) self . add ( m0 ) class DecimalMatrixExample(Scene):\n    def construct(self):\n        m0 = DecimalMatrix(\n            [[3.456, 2.122], [33.2244, 12]],\n            element_to_mobject_config={\"num_decimal_places\": 2},\n            left_bracket=\"\\\\{\",\n            right_bracket=\"\\\\}\")\n        self.add(m0) Will round/truncate the decimal places as per the provided config. Parameters : matrix ( Iterable ) \u2013 A numpy 2d array or list of lists element_to_mobject ( Mobject ) \u2013 Mobject to use, by default DecimalNumber element_to_mobject_config ( dict [ str , Mobject ] ) \u2013 Config for the desired mobject, by default {\u201cnum_decimal_places\u201d: 1} Methods Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( matrix , element_to_mobject=<class 'manim.mobject.text.numbers.DecimalNumber'> , element_to_mobject_config={'num_decimal_places': 1} , **kwargs )   Will round/truncate the decimal places as per the provided config. Parameters : matrix ( Iterable ) \u2013 A numpy 2d array or list of lists element_to_mobject ( Mobject ) \u2013 Mobject to use, by default DecimalNumber element_to_mobject_config ( dict [ str , Mobject ] ) \u2013 Config for the desired mobject, by default {\u201cnum_decimal_places\u201d: 1}", "original_prompt": "class DecimalMatrix(matrix, element_to_mobject=<class 'manim.mobject.text.numbers.DecimalNumber'>, element_to_mobject_config={'num_decimal_places': 1}, **kwargs)"}
{"prompt": "\"Display a rounded integer matrix on screen.\"", "response": "Bases: Matrix A mobject that displays a matrix with integer entries on the screen. Examples Example: IntegerMatrixExample   from manim import * class IntegerMatrixExample ( Scene ): def construct ( self ): m0 = IntegerMatrix ( [[ 3.7 , 2 ], [ 42.2 , 12 ]], left_bracket = \"(\" , right_bracket = \")\" ) self . add ( m0 ) class IntegerMatrixExample(Scene):\n    def construct(self):\n        m0 = IntegerMatrix(\n            [[3.7, 2], [42.2, 12]],\n            left_bracket=\"(\",\n            right_bracket=\")\")\n        self.add(m0) Will round if there are decimal entries in the matrix. Parameters : matrix ( Iterable ) \u2013 A numpy 2d array or list of lists element_to_mobject ( Mobject ) \u2013 Mobject to use, by default Integer Methods Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( matrix , element_to_mobject=<class 'manim.mobject.text.numbers.Integer'> , **kwargs )   Will round if there are decimal entries in the matrix. Parameters : matrix ( Iterable ) \u2013 A numpy 2d array or list of lists element_to_mobject ( Mobject ) \u2013 Mobject to use, by default Integer", "original_prompt": "class IntegerMatrix(matrix, element_to_mobject=<class 'manim.mobject.text.numbers.Integer'>, **kwargs)"}
{"prompt": "Here is the code in Python that defines a class `Matrix` and its methods:\n\n```python\nimport numpy as np\nfrom manim import *\n\nclass Matrix(VGroup):\n    def __init__(self, elements, **kwargs):\n        super().__init__()\n        self.elements = [Text(elements[i]) for i in range(len(elements))]\n        for element in self.elements:\n            element.set_width(element.get_width() * 0.8)\n            element.set_height(1.5 * element.get_height())\n        if 'column_colors' in kwargs and len(kwargs['column_colors']) != len(self.elements):\n            raise ValueError('Number of column colors does not match number of columns')\n        if 'row_colors' in kwargs and len(kwargs['row_colors']) != len(self.elements):\n            raise ValueError('Number of row colors does not match number of rows')\n\n    def set_column_colors(self, *colors):\n        for i in range(len(colors)):\n            self.elements[i].set_color(colors[i])\n\n    def set_row_colors(self, *colors):\n        for j in range(len(colors)):\n            self.elements[j].set_color(colors[j])\n```\n\nThis class represents a matrix of mathematical elements, each represented as a `Text` object. The matrix can be initialized with a list of elements and optional color specifications for the rows and columns.\n\nThe `set_column_colors` method sets the colors for the columns, while the `set_row_colors` method sets the colors for the rows. These methods take in variable numbers of color arguments, which are applied to each column or row respectively.\n\nExample usage:\n\n```python\nm = Matrix([[r\"\\pi\", 3], [1, 5]])\nm.set_column_colors([RED, BLUE])\nm.set_row_colors(GREEN)\n```\n\nThis would create a matrix with the elements \\(\\pi\\), 3, 1, and 5, and then set the colors for the columns to red and blue, respectively, and for the rows to green.", "response": "Bases: VMobject A mobject that displays a matrix on the screen. Parameters : matrix ( Iterable ) \u2013 A numpy 2d array or list of lists. v_buff ( float ) \u2013 Vertical distance between elements, by default 0.8. h_buff ( float ) \u2013 Horizontal distance between elements, by default 1.3. bracket_h_buff ( float ) \u2013 Distance of the brackets from the matrix, by default MED_SMALL_BUFF . bracket_v_buff ( float ) \u2013 Height of the brackets, by default MED_SMALL_BUFF . add_background_rectangles_to_entries ( bool ) \u2013 True if should add backgraound rectangles to entries, by default False . include_background_rectangle ( bool ) \u2013 True if should include background rectangle, by default False . element_to_mobject ( type [ MathTex ] ) \u2013 The mobject class used to construct the elements, by default MathTex . element_to_mobject_config ( dict ) \u2013 Additional arguments to be passed to the constructor in element_to_mobject ,\nby default {} . element_alignment_corner ( Sequence [ float ] ) \u2013 The corner to which elements are aligned, by default DR . left_bracket ( str ) \u2013 The left bracket type, by default \"[\" . right_bracket ( str ) \u2013 The right bracket type, by default \"]\" . stretch_brackets ( bool ) \u2013 True if should stretch the brackets to fit the height of matrix contents, by default True . bracket_config ( dict ) \u2013 Additional arguments to be passed to MathTex when constructing\nthe brackets. Examples The first example shows a variety of uses of this module while the second example\nexlpains the use of the options add_background_rectangles_to_entries and include_background_rectangle . Example: MatrixExamples   from manim import * class MatrixExamples ( Scene ): def construct ( self ): m0 = Matrix ([[ 2 , r \"\\pi\" ], [ - 1 , 1 ]]) m1 = Matrix ([[ 2 , 0 , 4 ], [ - 1 , 1 , 5 ]], v_buff = 1.3 , h_buff = 0.8 , bracket_h_buff = SMALL_BUFF , bracket_v_buff = SMALL_BUFF , left_bracket = r \"\\{\" , right_bracket = r \"\\}\" ) m1 . add ( SurroundingRectangle ( m1 . get_columns ()[ 1 ])) m2 = Matrix ([[ 2 , 1 ], [ - 1 , 3 ]], element_alignment_corner = UL , left_bracket = \"(\" , right_bracket = \")\" ) m3 = Matrix ([[ 2 , 1 ], [ - 1 , 3 ]], left_bracket = r \"\\langle\" , right_bracket = r \"\\rangle\" ) m4 = Matrix ([[ 2 , 1 ], [ - 1 , 3 ]], ) . set_column_colors ( RED , GREEN ) m5 = Matrix ([[ 2 , 1 ], [ - 1 , 3 ]], ) . set_row_colors ( RED , GREEN ) g = Group ( m0 , m1 , m2 , m3 , m4 , m5 ) . arrange_in_grid ( buff = 2 ) self . add ( g ) class MatrixExamples(Scene):\n    def construct(self):\n        m0 = Matrix([[2, r\"\\pi\"], [-1, 1]])\n        m1 = Matrix([[2, 0, 4], [-1, 1, 5]],\n            v_buff=1.3,\n            h_buff=0.8,\n            bracket_h_buff=SMALL_BUFF,\n            bracket_v_buff=SMALL_BUFF,\n            left_bracket=r\"\\{\",\n            right_bracket=r\"\\}\")\n        m1.add(SurroundingRectangle(m1.get_columns()[1]))\n        m2 = Matrix([[2, 1], [-1, 3]],\n            element_alignment_corner=UL,\n            left_bracket=\"(\",\n            right_bracket=\")\")\n        m3 = Matrix([[2, 1], [-1, 3]],\n            left_bracket=r\"\\langle\",\n            right_bracket=r\"\\rangle\")\n        m4 = Matrix([[2, 1], [-1, 3]],\n        ).set_column_colors(RED, GREEN)\n        m5 = Matrix([[2, 1], [-1, 3]],\n        ).set_row_colors(RED, GREEN)\n        g = Group(\n            m0,m1,m2,m3,m4,m5\n        ).arrange_in_grid(buff=2)\n        self.add(g) Example: BackgroundRectanglesExample   from manim import * class BackgroundRectanglesExample ( Scene ): def construct ( self ): background = Rectangle () . scale ( 3.2 ) background . set_fill ( opacity = .5 ) background . set_color ([ TEAL , RED , YELLOW ]) self . add ( background ) m0 = Matrix ([[ 12 , - 30 ], [ - 1 , 15 ]], add_background_rectangles_to_entries = True ) m1 = Matrix ([[ 2 , 0 ], [ - 1 , 1 ]], include_background_rectangle = True ) m2 = Matrix ([[ 12 , - 30 ], [ - 1 , 15 ]]) g = Group ( m0 , m1 , m2 ) . arrange ( buff = 2 ) self . add ( g ) class BackgroundRectanglesExample(Scene):\n    def construct(self):\n        background= Rectangle().scale(3.2)\n        background.set_fill(opacity=.5)\n        background.set_color([TEAL, RED, YELLOW])\n        self.add(background)\n        m0 = Matrix([[12, -30], [-1, 15]],\n            add_background_rectangles_to_entries=True)\n        m1 = Matrix([[2, 0], [-1, 1]],\n            include_background_rectangle=True)\n        m2 = Matrix([[12, -30], [-1, 15]])\n        g = Group(m0, m1, m2).arrange(buff=2)\n        self.add(g) Methods add_background_to_entries Add a black background rectangle to the matrix, see above for an example. get_brackets Return the bracket mobjects. get_columns Return columns of the matrix as VGroups. get_entries Return the individual entries of the matrix. get_mob_matrix Return the underlying mob matrix mobjects. get_rows Return rows of the matrix as VGroups. set_column_colors Set individual colors for each columns of the matrix. set_row_colors Set individual colors for each row of the matrix. Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _add_brackets ( left = '[' , right = ']' , ** kwargs ) [source]   Adds the brackets to the Matrix mobject. See Latex document for various bracket types. Parameters : left ( str ) \u2013 the left bracket, by default \u201c[\u201d right ( str ) \u2013 the right bracket, by default \u201c]\u201d Returns : The current matrix object (self). Return type : Matrix _original__init__ ( matrix , v_buff=0.8 , h_buff=1.3 , bracket_h_buff=0.25 , bracket_v_buff=0.25 , add_background_rectangles_to_entries=False , include_background_rectangle=False , element_to_mobject=<class 'manim.mobject.text.tex_mobject.MathTex'> , element_to_mobject_config={} , element_alignment_corner=array([ 1. , -1. , 0.]) , left_bracket='[' , right_bracket=']' , stretch_brackets=True , bracket_config={} , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : matrix ( Iterable ) v_buff ( float ) h_buff ( float ) bracket_h_buff ( float ) bracket_v_buff ( float ) add_background_rectangles_to_entries ( bool ) include_background_rectangle ( bool ) element_to_mobject ( type [ MathTex ] ) element_to_mobject_config ( dict ) element_alignment_corner ( Sequence [ float ] ) left_bracket ( str ) right_bracket ( str ) stretch_brackets ( bool ) bracket_config ( dict ) add_background_to_entries ( ) [source]   Add a black background rectangle to the matrix,\nsee above for an example. Returns : The current matrix object (self). Return type : Matrix get_brackets ( ) [source]   Return the bracket mobjects. Returns : Each VGroup contains a bracket Return type : List[ VGroup ] Examples Example: GetBracketsExample   from manim import * class GetBracketsExample ( Scene ): def construct ( self ): m0 = Matrix ([[ \" \\\\ pi\" , 3 ], [ 1 , 5 ]]) bra = m0 . get_brackets () colors = [ BLUE , GREEN ] for k in range ( len ( colors )): bra [ k ] . set_color ( colors [ k ]) self . add ( m0 ) class GetBracketsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 3], [1, 5]])\n        bra = m0.get_brackets()\n        colors = [BLUE, GREEN]\n        for k in range(len(colors)):\n            bra[k].set_color(colors[k])\n        self.add(m0) get_columns ( ) [source]   Return columns of the matrix as VGroups. Returns : Each VGroup contains a column of the matrix. Return type : List[ VGroup ] Examples Example: GetColumnsExample   from manim import * class GetColumnsExample ( Scene ): def construct ( self ): m0 = Matrix ([[ r \"\\pi\" , 3 ], [ 1 , 5 ]]) m0 . add ( SurroundingRectangle ( m0 . get_columns ()[ 1 ])) self . add ( m0 ) class GetColumnsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[r\"\\pi\", 3], [1, 5]])\n        m0.add(SurroundingRectangle(m0.get_columns()[1]))\n        self.add(m0) get_entries ( ) [source]   Return the individual entries of the matrix. Returns : VGroup containing entries of the matrix. Return type : VGroup Examples Example: GetEntriesExample   from manim import * class GetEntriesExample ( Scene ): def construct ( self ): m0 = Matrix ([[ 2 , 3 ], [ 1 , 5 ]]) ent = m0 . get_entries () colors = [ BLUE , GREEN , YELLOW , RED ] for k in range ( len ( colors )): ent [ k ] . set_color ( colors [ k ]) self . add ( m0 ) class GetEntriesExample(Scene):\n    def construct(self):\n        m0 = Matrix([[2, 3], [1, 5]])\n        ent = m0.get_entries()\n        colors = [BLUE, GREEN, YELLOW, RED]\n        for k in range(len(colors)):\n            ent[k].set_color(colors[k])\n        self.add(m0) get_mob_matrix ( ) [source]   Return the underlying mob matrix mobjects. Returns : Each VGroup contains a row of the matrix. Return type : List[ VGroup ] get_rows ( ) [source]   Return rows of the matrix as VGroups. Returns : Each VGroup contains a row of the matrix. Return type : List[ VGroup ] Examples Example: GetRowsExample   from manim import * class GetRowsExample ( Scene ): def construct ( self ): m0 = Matrix ([[ \" \\\\ pi\" , 3 ], [ 1 , 5 ]]) m0 . add ( SurroundingRectangle ( m0 . get_rows ()[ 1 ])) self . add ( m0 ) class GetRowsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 3], [1, 5]])\n        m0.add(SurroundingRectangle(m0.get_rows()[1]))\n        self.add(m0) set_column_colors ( * colors ) [source]   Set individual colors for each columns of the matrix. Parameters : colors ( str ) \u2013 The list of colors; each color specified corresponds to a column. Returns : The current matrix object (self). Return type : Matrix Examples Example: SetColumnColorsExample   from manim import * class SetColumnColorsExample ( Scene ): def construct ( self ): m0 = Matrix ([[ \" \\\\ pi\" , 1 ], [ - 1 , 3 ]], ) . set_column_colors ([ RED , BLUE ], GREEN ) self . add ( m0 ) class SetColumnColorsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 1], [-1, 3]],\n        ).set_column_colors([RED,BLUE], GREEN)\n        self.add(m0) set_row_colors ( * colors ) [source]   Set individual colors for each row of the matrix. Parameters : colors ( str ) \u2013 The list of colors; each color specified corresponds to a row. Returns : The current matrix object (self). Return type : Matrix Examples Example: SetRowColorsExample   from manim import * class SetRowColorsExample ( Scene ): def construct ( self ): m0 = Matrix ([[ \" \\\\ pi\" , 1 ], [ - 1 , 3 ]], ) . set_row_colors ([ RED , BLUE ], GREEN ) self . add ( m0 ) class SetRowColorsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 1], [-1, 3]],\n        ).set_row_colors([RED,BLUE], GREEN)\n        self.add(m0)", "original_prompt": "class Matrix(matrix, v_buff=0.8, h_buff=1.3, bracket_h_buff=0.25, bracket_v_buff=0.25, add_background_rectangles_to_entries=False, include_background_rectangle=False, element_to_mobject=<class 'manim.mobject.text.tex_mobject.MathTex'>, element_to_mobject_config={}, element_alignment_corner=array("}
{"prompt": "\"Animate a grid of shapes that transforms into a matrix, displaying pi.\"", "response": "Bases: Matrix A mobject that displays a matrix of mobject entries on the screen. Examples Example: MobjectMatrixExample   from manim import * class MobjectMatrixExample ( Scene ): def construct ( self ): a = Circle () . scale ( 0.3 ) b = Square () . scale ( 0.3 ) c = MathTex ( \" \\\\ pi\" ) . scale ( 2 ) d = Star () . scale ( 0.3 ) m0 = MobjectMatrix ([[ a , b ], [ c , d ]]) self . add ( m0 ) class MobjectMatrixExample(Scene):\n    def construct(self):\n        a = Circle().scale(0.3)\n        b = Square().scale(0.3)\n        c = MathTex(\"\\\\pi\").scale(2)\n        d = Star().scale(0.3)\n        m0 = MobjectMatrix([[a, b], [c, d]])\n        self.add(m0) Methods Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( matrix , element_to_mobject=<function MobjectMatrix.<lambda>> , **kwargs )   Initialize self.  See help(type(self)) for accurate signature.", "original_prompt": "class MobjectMatrix(matrix, element_to_mobject=<function MobjectMatrix.<lambda>>, **kwargs)"}
{"prompt": "\"Visualize a 2x2 matrix being scaled and displaying its determinant value.\"", "response": "Helper function to create determinant. Parameters : matrix ( Matrix ) \u2013 The matrix whose determinant is to be created determinant ( int | str | None ) \u2013 The value of the determinant of the matrix background_rect ( bool ) \u2013 The background rectangle initial_scale_factor ( float ) \u2013 The scale of the text det w.r.t the matrix Returns : A VGroup containing the determinant Return type : VGroup Examples Example: DeterminantOfAMatrix   from manim import * class DeterminantOfAMatrix ( Scene ): def construct ( self ): matrix = Matrix ([ [ 2 , 0 ], [ - 1 , 1 ] ]) # scaling down the `det` string det = get_det_text ( matrix , determinant = 3 , initial_scale_factor = 1 ) # must add the matrix self . add ( matrix ) self . add ( det ) class DeterminantOfAMatrix(Scene):\n    def construct(self):\n        matrix = Matrix([\n            [2, 0],\n            [-1, 1]\n        ])\n\n        # scaling down the `det` string\n        det = get_det_text(matrix,\n                    determinant=3,\n                    initial_scale_factor=1)\n\n        # must add the matrix\n        self.add(matrix)\n        self.add(det)", "original_prompt": "get_det_text(matrix, determinant=None, background_rect=False, initial_scale_factor=2)"}
{"prompt": "Animate a 2x2 matrix visualizing its determinant value while scaling down the text representation.", "response": "Helper function to create determinant. Parameters : matrix ( Matrix ) \u2013 The matrix whose determinant is to be created determinant ( int | str | None ) \u2013 The value of the determinant of the matrix background_rect ( bool ) \u2013 The background rectangle initial_scale_factor ( float ) \u2013 The scale of the text det w.r.t the matrix Returns : A VGroup containing the determinant Return type : VGroup Examples Example: DeterminantOfAMatrix   from manim import * class DeterminantOfAMatrix ( Scene ): def construct ( self ): matrix = Matrix ([ [ 2 , 0 ], [ - 1 , 1 ] ]) # scaling down the `det` string det = get_det_text ( matrix , determinant = 3 , initial_scale_factor = 1 ) # must add the matrix self . add ( matrix ) self . add ( det ) class DeterminantOfAMatrix(Scene):\n    def construct(self):\n        matrix = Matrix([\n            [2, 0],\n            [-1, 1]\n        ])\n\n        # scaling down the `det` string\n        det = get_det_text(matrix,\n                    determinant=3,\n                    initial_scale_factor=1)\n\n        # must add the matrix\n        self.add(matrix)\n        self.add(det)", "original_prompt": "get_det_text(matrix, determinant=None, background_rect=False, initial_scale_factor=2)"}
{"prompt": "Animate a matrix transformation displaying its determinant as a scaled text.", "response": "Helper function to create determinant. Parameters : matrix ( Matrix ) \u2013 The matrix whose determinant is to be created determinant ( int | str | None ) \u2013 The value of the determinant of the matrix background_rect ( bool ) \u2013 The background rectangle initial_scale_factor ( float ) \u2013 The scale of the text det w.r.t the matrix Returns : A VGroup containing the determinant Return type : VGroup Examples Example: DeterminantOfAMatrix   from manim import * class DeterminantOfAMatrix ( Scene ): def construct ( self ): matrix = Matrix ([ [ 2 , 0 ], [ - 1 , 1 ] ]) # scaling down the `det` string det = get_det_text ( matrix , determinant = 3 , initial_scale_factor = 1 ) # must add the matrix self . add ( matrix ) self . add ( det ) class DeterminantOfAMatrix(Scene):\n    def construct(self):\n        matrix = Matrix([\n            [2, 0],\n            [-1, 1]\n        ])\n\n        # scaling down the `det` string\n        det = get_det_text(matrix,\n                    determinant=3,\n                    initial_scale_factor=1)\n\n        # must add the matrix\n        self.add(matrix)\n        self.add(det)", "original_prompt": "get_det_text(matrix, determinant=None, background_rect=False, initial_scale_factor=2)"}
{"prompt": "\"Graphically display parametric equation of circle, smoothly transitioning between different radii.\"", "response": "Callable [[ 'Mobject' , float ], object ]", "original_prompt": "class TimeBasedUpdater"}
{"prompt": "\"Fade in a circle, then smoothly scale up with increasing radius, highlighting mathematical growth.\"", "response": "Callable [[ 'Mobject' ], object ]", "original_prompt": "class NonTimeBasedUpdater"}
{"prompt": "\"Transition between two mathematical graphs, one based on time and the other constant, over a changing scale.\"", "response": "NonTimeBasedUpdater` | TimeBasedUpdater`", "original_prompt": "class Updater"}
{"prompt": "\"Show a text surrounded by a circle, then fade out the circle while moving it away from the text.\"", "response": "Decorator for overriding method animations. This allows to specify a method (returning an Animation )\nwhich is called when the decorated method is used with the .animate syntax\nfor animating the application of a method. See also Mobject.animate Note Overridden methods cannot be combined with normal or other overridden\nmethods using method chaining with the .animate syntax. Examples Example: AnimationOverrideExample   from manim import * class CircleWithContent ( VGroup ): def __init__ ( self , content ): super () . __init__ () self . circle = Circle () self . content = content self . add ( self . circle , content ) content . move_to ( self . circle . get_center ()) def clear_content ( self ): self . remove ( self . content ) self . content = None @override_animate ( clear_content ) def _clear_content_animation ( self , anim_args = None ): if anim_args is None : anim_args = {} anim = Uncreate ( self . content , ** anim_args ) self . clear_content () return anim class AnimationOverrideExample ( Scene ): def construct ( self ): t = Text ( \"hello!\" ) my_mobject = CircleWithContent ( t ) self . play ( Create ( my_mobject )) self . play ( my_mobject . animate . clear_content ()) self . wait () class CircleWithContent(VGroup):\n    def __init__(self, content):\n        super().__init__()\n        self.circle = Circle()\n        self.content = content\n        self.add(self.circle, content)\n        content.move_to(self.circle.get_center())\n\n    def clear_content(self):\n        self.remove(self.content)\n        self.content = None\n\n    @override_animate(clear_content)\n    def _clear_content_animation(self, anim_args=None):\n        if anim_args is None:\n            anim_args = {}\n        anim = Uncreate(self.content, **anim_args)\n        self.clear_content()\n        return anim\n\nclass AnimationOverrideExample(Scene):\n    def construct(self):\n        t = Text(\"hello!\")\n        my_mobject = CircleWithContent(t)\n        self.play(Create(my_mobject))\n        self.play(my_mobject.animate.clear_content())\n        self.wait() Return type : LambdaType", "original_prompt": "override_animate(method)"}
{"prompt": "\"Draw a parabola with focus at (1,2) opening downwards, shifting left by 3 units.\"\n\n(Note: This prompt is concise and does not require technical terms. It identifies the key visual element - a parabola - and describes its transformations.)", "response": "Callable [[ 'Mobject' , float ], object ]", "original_prompt": "class TimeBasedUpdater"}
{"prompt": "Animate an ellipse that rotates around the origin with a sine wave function.", "response": "Callable [[ 'Mobject' ], object ]", "original_prompt": "class NonTimeBasedUpdater"}
{"prompt": "\"Show an ellipse evolving with increasing frequency, from static to dynamic motion.\"", "response": "NonTimeBasedUpdater` | TimeBasedUpdater`", "original_prompt": "class Updater"}
{"prompt": "\"Animate a circle with content that clears its contents and disappears.\"", "response": "Decorator for overriding method animations. This allows to specify a method (returning an Animation )\nwhich is called when the decorated method is used with the .animate syntax\nfor animating the application of a method. See also Mobject.animate Note Overridden methods cannot be combined with normal or other overridden\nmethods using method chaining with the .animate syntax. Examples Example: AnimationOverrideExample   from manim import * class CircleWithContent ( VGroup ): def __init__ ( self , content ): super () . __init__ () self . circle = Circle () self . content = content self . add ( self . circle , content ) content . move_to ( self . circle . get_center ()) def clear_content ( self ): self . remove ( self . content ) self . content = None @override_animate ( clear_content ) def _clear_content_animation ( self , anim_args = None ): if anim_args is None : anim_args = {} anim = Uncreate ( self . content , ** anim_args ) self . clear_content () return anim class AnimationOverrideExample ( Scene ): def construct ( self ): t = Text ( \"hello!\" ) my_mobject = CircleWithContent ( t ) self . play ( Create ( my_mobject )) self . play ( my_mobject . animate . clear_content ()) self . wait () class CircleWithContent(VGroup):\n    def __init__(self, content):\n        super().__init__()\n        self.circle = Circle()\n        self.content = content\n        self.add(self.circle, content)\n        content.move_to(self.circle.get_center())\n\n    def clear_content(self):\n        self.remove(self.content)\n        self.content = None\n\n    @override_animate(clear_content)\n    def _clear_content_animation(self, anim_args=None):\n        if anim_args is None:\n            anim_args = {}\n        anim = Uncreate(self.content, **anim_args)\n        self.clear_content()\n        return anim\n\nclass AnimationOverrideExample(Scene):\n    def construct(self):\n        t = Text(\"hello!\")\n        my_mobject = CircleWithContent(t)\n        self.play(Create(my_mobject))\n        self.play(my_mobject.animate.clear_content())\n        self.wait() Return type : LambdaType", "original_prompt": "override_animate(method)"}
{"prompt": "\"Smoothly scale an animated graph from point to line.\"", "response": "Callable [[ 'Mobject' , float ], object ]", "original_prompt": "class TimeBasedUpdater"}
{"prompt": "\"Transforming graph into parabola, reflecting across the x-axis, with increasing amplitude.\"", "response": "Callable [[ 'Mobject' ], object ]", "original_prompt": "class NonTimeBasedUpdater"}
{"prompt": "\"Show a non-time based update followed by time-based updates with changing colors.\"", "response": "NonTimeBasedUpdater` | TimeBasedUpdater`", "original_prompt": "class Updater"}
{"prompt": "Animate a CircleWithContent object that creates, reveals and then clears itself.", "response": "Decorator for overriding method animations. This allows to specify a method (returning an Animation )\nwhich is called when the decorated method is used with the .animate syntax\nfor animating the application of a method. See also Mobject.animate Note Overridden methods cannot be combined with normal or other overridden\nmethods using method chaining with the .animate syntax. Examples Example: AnimationOverrideExample   from manim import * class CircleWithContent ( VGroup ): def __init__ ( self , content ): super () . __init__ () self . circle = Circle () self . content = content self . add ( self . circle , content ) content . move_to ( self . circle . get_center ()) def clear_content ( self ): self . remove ( self . content ) self . content = None @override_animate ( clear_content ) def _clear_content_animation ( self , anim_args = None ): if anim_args is None : anim_args = {} anim = Uncreate ( self . content , ** anim_args ) self . clear_content () return anim class AnimationOverrideExample ( Scene ): def construct ( self ): t = Text ( \"hello!\" ) my_mobject = CircleWithContent ( t ) self . play ( Create ( my_mobject )) self . play ( my_mobject . animate . clear_content ()) self . wait () class CircleWithContent(VGroup):\n    def __init__(self, content):\n        super().__init__()\n        self.circle = Circle()\n        self.content = content\n        self.add(self.circle, content)\n        content.move_to(self.circle.get_center())\n\n    def clear_content(self):\n        self.remove(self.content)\n        self.content = None\n\n    @override_animate(clear_content)\n    def _clear_content_animation(self, anim_args=None):\n        if anim_args is None:\n            anim_args = {}\n        anim = Uncreate(self.content, **anim_args)\n        self.clear_content()\n        return anim\n\nclass AnimationOverrideExample(Scene):\n    def construct(self):\n        t = Text(\"hello!\")\n        my_mobject = CircleWithContent(t)\n        self.play(Create(my_mobject))\n        self.play(my_mobject.animate.clear_content())\n        self.wait() Return type : LambdaType", "original_prompt": "override_animate(method)"}
{"prompt": "\"Display a quadratic function graphing in green, then fade out as it intersects the x-axis.\"\n\nor \n\"Animate a circle expanding to a square while showing its radius.\"\n\nor \n\"Visualize a sine wave oscillating with a red arrow indicating its amplitude.\"", "response": "Callable [[ 'Mobject' , float ], object ]", "original_prompt": "class TimeBasedUpdater"}
{"prompt": "\"Fade in graph with x-values increasing, then rotate it around the origin.\"", "response": "Callable [[ 'Mobject' ], object ]", "original_prompt": "class NonTimeBasedUpdater"}
{"prompt": "\"Show a square transforming into a circle with arrows representing velocity and acceleration over time.\"", "response": "NonTimeBasedUpdater` | TimeBasedUpdater`", "original_prompt": "class Updater"}
{"prompt": "\"Animate a circle with text content disappearing from the center.\"", "response": "Decorator for overriding method animations. This allows to specify a method (returning an Animation )\nwhich is called when the decorated method is used with the .animate syntax\nfor animating the application of a method. See also Mobject.animate Note Overridden methods cannot be combined with normal or other overridden\nmethods using method chaining with the .animate syntax. Examples Example: AnimationOverrideExample   from manim import * class CircleWithContent ( VGroup ): def __init__ ( self , content ): super () . __init__ () self . circle = Circle () self . content = content self . add ( self . circle , content ) content . move_to ( self . circle . get_center ()) def clear_content ( self ): self . remove ( self . content ) self . content = None @override_animate ( clear_content ) def _clear_content_animation ( self , anim_args = None ): if anim_args is None : anim_args = {} anim = Uncreate ( self . content , ** anim_args ) self . clear_content () return anim class AnimationOverrideExample ( Scene ): def construct ( self ): t = Text ( \"hello!\" ) my_mobject = CircleWithContent ( t ) self . play ( Create ( my_mobject )) self . play ( my_mobject . animate . clear_content ()) self . wait () class CircleWithContent(VGroup):\n    def __init__(self, content):\n        super().__init__()\n        self.circle = Circle()\n        self.content = content\n        self.add(self.circle, content)\n        content.move_to(self.circle.get_center())\n\n    def clear_content(self):\n        self.remove(self.content)\n        self.content = None\n\n    @override_animate(clear_content)\n    def _clear_content_animation(self, anim_args=None):\n        if anim_args is None:\n            anim_args = {}\n        anim = Uncreate(self.content, **anim_args)\n        self.clear_content()\n        return anim\n\nclass AnimationOverrideExample(Scene):\n    def construct(self):\n        t = Text(\"hello!\")\n        my_mobject = CircleWithContent(t)\n        self.play(Create(my_mobject))\n        self.play(my_mobject.animate.clear_content())\n        self.wait() Return type : LambdaType", "original_prompt": "override_animate(method)"}
{"prompt": "\"Animate a group of shapes with varying depths, heights, and widths, demonstrating depth transformation properties.\"", "response": "Bases: Mobject Groups together multiple Mobjects . Notes When adding the same mobject more than once, repetitions are ignored.\nUse Mobject.copy() to create a separate copy which can then\nbe added to the group. Methods Attributes animate Used to animate the application of any method of self . animation_overrides depth The depth of the mobject. height The height of the mobject. width The width of the mobject. _original__init__ ( * mobjects , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Return type : None", "original_prompt": "class Group(*mobjects, **kwargs)"}
{"prompt": "I don't see a specific prompt provided. Can you please provide the prompt so I can assist you with your question or problem?", "response": "Bases: object Mathematical Object: base class for objects that can be displayed on screen. There is a compatibility layer that allows for\ngetting and setting generic attributes with get_* and set_* methods. See set() for more details. Parameters : color ( ParsableManimColor | list [ ParsableManimColor ] ) name ( str | None ) dim ( int ) z_index ( float ) submobjects   The contained objects. Type : List[ Mobject ] points   The points of the objects. See also VMobject Type : numpy.ndarray Methods add Add mobjects as submobjects. add_animation_override Add an animation override. add_background_rectangle Add a BackgroundRectangle as submobject. add_background_rectangle_to_family_members_with_points add_background_rectangle_to_submobjects add_n_more_submobjects add_to_back Add all passed mobjects to the back of the submobjects. add_updater Add an update function to this mobject. align_data Aligns the data of this mobject with another mobject. align_on_border Direction just needs to be a vector pointing towards side or corner in the 2d plane. align_points align_points_with_larger align_submobjects align_to Aligns mobject to another Mobject in a certain direction. animation_override_for Returns the function defining a specific animation override for this class. apply_complex_function Applies a complex function to a Mobject . apply_function apply_function_to_position apply_function_to_submobject_positions apply_matrix apply_over_attr_arrays apply_points_function_about_point apply_to_family Apply a function to self and every submobject with points recursively. arrange Sorts Mobject next to each other on screen. arrange_in_grid Arrange submobjects in a grid. arrange_submobjects Arrange the position of submobjects with a small buffer. become Edit points, colors and submobjects to be identical to another Mobject center Moves the center of the mobject to the center of the scene. clear_updaters Remove every updater. copy Create and return an identical copy of the Mobject including all submobjects . fade fade_to family_members_with_points flip Flips/Mirrors an mobject about its center. generate_points Initializes points and therefore the shape. generate_target get_all_points Return all points from this mobject and all submobjects. get_array_attrs get_bottom Get bottom Point3Ds of a box bounding the Mobject get_boundary_point get_center Get center Point3Ds get_center_of_mass get_color Returns the color of the Mobject get_coord Meant to generalize get_x , get_y and get_z get_corner Get corner Point3Ds for certain direction. get_critical_point Picture a box bounding the Mobject . get_edge_center Get edge Point3Ds for certain direction. get_end Returns the point, where the stroke that surrounds the Mobject ends. get_extremum_along_dim get_family get_family_updaters get_group_class get_image get_left Get left Point3Ds of a box bounding the Mobject get_merged_array Return all of a given attribute from this mobject and all submobjects. get_midpoint Get Point3Ds of the middle of the path that forms the Mobject . get_mobject_type_class Return the base class of this mobject type. get_nadir Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D Mobject . get_num_points get_pieces get_point_mobject The simplest Mobject to be transformed to or from self. get_points_defining_boundary get_right Get right Point3Ds of a box bounding the Mobject get_start Returns the point, where the stroke that surrounds the Mobject starts. get_start_and_end Returns starting and ending point of a stroke as a tuple . get_time_based_updaters Return all updaters using the dt parameter. get_top Get top Point3Ds of a box bounding the Mobject get_updaters Return all updaters. get_x Returns x Point3D of the center of the Mobject as float get_y Returns y Point3D of the center of the Mobject as float get_z Returns z Point3D of the center of the Mobject as float get_z_index_reference_point get_zenith Get zenith Point3Ds of a box bounding a 3D Mobject . has_no_points Check if Mobject does not contains points. has_points Check if Mobject contains points. has_time_based_updater Test if self has a time based updater. init_colors Initializes the colors. insert Inserts a mobject at a specific position into self.submobjects interpolate Turns this Mobject into an interpolation between mobject1 and mobject2 . interpolate_color invert Inverts the list of submobjects . is_off_screen length_over_dim Measure the length of an Mobject in a certain direction. match_color Match the color with the color of another Mobject . match_coord Match the Point3Ds with the Point3Ds of another Mobject . match_depth Match the depth with the depth of another Mobject . match_dim_size Match the specified dimension with the dimension of another Mobject . match_height Match the height with the height of another Mobject . match_points Edit points, positions, and submobjects to be identical to another Mobject , while keeping the style unchanged. match_updaters Match the updaters of the given mobject. match_width Match the width with the width of another Mobject . match_x Match x coord. match_y Match y coord. match_z Match z coord. move_to Move center of the Mobject to certain Point3D. next_to Move this Mobject next to another's Mobject or Point3D. nonempty_submobjects null_point_align If a Mobject with points is being aligned to one without, treat both as groups, and push the one with points into its own submobjects list. point_from_proportion pose_at_angle proportion_from_point push_self_into_submobjects put_start_and_end_on reduce_across_dimension Find the min or max value from a dimension across all points in this and submobjects. remove Remove submobjects . remove_updater Remove an updater. repeat This can make transition animations nicer repeat_submobject replace rescale_to_fit reset_points Sets points to be an empty array. restore Restores the state that was previously saved with save_state() . resume_updating Enable updating from updaters and animations. reverse_points rotate Rotates the Mobject about a certain point. rotate_about_origin Rotates the Mobject about the ORIGIN, which is at [0,0,0]. save_image Saves an image of only this Mobject at its position to a png file. save_state Save the current state (position, color & size). scale Scale the size by a factor. scale_to_fit_depth Scales the Mobject to fit a depth while keeping width/height proportional. scale_to_fit_height Scales the Mobject to fit a height while keeping width/depth proportional. scale_to_fit_width Scales the Mobject to fit a width while keeping height/depth proportional. set Sets attributes. set_color Condition is function which takes in one arguments, (x, y, z). set_color_by_gradient set_colors_by_radial_gradient set_coord set_default Sets the default values of keyword arguments. set_submobject_colors_by_gradient set_submobject_colors_by_radial_gradient set_x Set x value of the center of the Mobject ( int or float ) set_y Set y value of the center of the Mobject ( int or float ) set_z Set z value of the center of the Mobject ( int or float ) set_z_index Sets the Mobject 's z_index to the value specified in z_index_value . set_z_index_by_z_Point3D Sets the Mobject 's z Point3D to the value of z_index . shift Shift by the given vectors. shift_onto_screen show shuffle Shuffles the list of submobjects . shuffle_submobjects Shuffles the order of submobjects sort Sorts the list of submobjects by a function defined by submob_func . sort_submobjects Sort the submobjects space_out_submobjects split stretch stretch_about_point stretch_to_fit_depth Stretches the Mobject to fit a depth, not keeping width/height proportional. stretch_to_fit_height Stretches the Mobject to fit a height, not keeping width/depth proportional. stretch_to_fit_width Stretches the Mobject to fit a width, not keeping height/depth proportional. surround suspend_updating Disable updating from updaters and animations. throw_error_if_no_points to_corner Moves this Mobject to the given corner of the screen. to_edge Moves this Mobject to the given edge of the screen, without affecting its position in the other dimension. to_original_color update Apply all updaters. Attributes animate Used to animate the application of any method of self . animation_overrides depth The depth of the mobject. height The height of the mobject. width The width of the mobject. classmethod _add_intrinsic_animation_overrides ( ) [source]   Initializes animation overrides marked with the override_animation() decorator. Return type : None _assert_valid_submobjects ( submobjects ) [source]   Check that all submobjects are actually instances of Mobject , and that none of them is self (a Mobject cannot contain itself). This is an auxiliary function called when adding Mobjects to the submobjects list. This function is intended to be overridden by subclasses such as VMobject , which should assert that only other VMobjects\nmay be added into it. Parameters : submobjects ( Iterable [ Mobject ] ) \u2013 The list containing values to validate. Returns : The Mobject itself. Return type : Mobject Raises : TypeError \u2013 If any of the values in submobjects is not a Mobject . ValueError \u2013 If there was an attempt to add a Mobject as its own\n    submobject. add ( * mobjects ) [source]   Add mobjects as submobjects. The mobjects are added to submobjects . Subclasses of mobject may implement + and += dunder methods. Parameters : mobjects ( Mobject ) \u2013 The mobjects to add. Returns : self Return type : Mobject Raises : ValueError \u2013 When a mobject tries to add itself. TypeError \u2013 When trying to add an object that is not an instance of Mobject . Notes A mobject cannot contain itself, and it cannot contain a submobject\nmore than once.  If the parent mobject is displayed, the newly-added\nsubmobjects will also be displayed (i.e. they are automatically added\nto the parent Scene). See also remove() , add_to_back() Examples >>> outer = Mobject () >>> inner = Mobject () >>> outer = outer . add ( inner ) Duplicates are not added again: >>> outer = outer . add ( inner ) >>> len ( outer . submobjects ) 1 Only Mobjects can be added: >>> outer . add ( 3 ) Traceback (most recent call last): ... TypeError : Only values of type Mobject can be added as submobjects of Mobject, but the value 3 (at index 0) is of type int. Adding an object to itself raises an error: >>> outer . add ( outer ) Traceback (most recent call last): ... ValueError : Cannot add Mobject as a submobject of itself (at index 0). A given mobject cannot be added as a submobject\ntwice to some parent: >>> parent = Mobject ( name = \"parent\" ) >>> child = Mobject ( name = \"child\" ) >>> parent . add ( child , child ) [...] WARNING  ... parent >>> parent . submobjects [child] classmethod add_animation_override ( animation_class , override_func ) [source]   Add an animation override. This does not apply to subclasses. Parameters : animation_class ( type [ Animation ] ) \u2013 The animation type to be overridden override_func ( FunctionOverride ) \u2013 The function returning an animation replacing the default animation. It gets\npassed the parameters given to the animation constructor. Raises : MultiAnimationOverrideException \u2013 If the overridden animation was already overridden. Return type : None add_background_rectangle ( color = None , opacity = 0.75 , ** kwargs ) [source]   Add a BackgroundRectangle as submobject. The BackgroundRectangle is added behind other submobjects. This can be used to increase the mobjects visibility in front of a noisy background. Parameters : color ( ParsableManimColor | None ) \u2013 The color of the BackgroundRectangle opacity ( float ) \u2013 The opacity of the BackgroundRectangle kwargs \u2013 Additional keyword arguments passed to the BackgroundRectangle constructor Returns : self Return type : Mobject See also add_to_back() , BackgroundRectangle add_to_back ( * mobjects ) [source]   Add all passed mobjects to the back of the submobjects. If submobjects already contains the given mobjects, they just get moved\nto the back instead. Parameters : mobjects ( Mobject ) \u2013 The mobjects to add. Returns : self Return type : Mobject Note Technically, this is done by adding (or moving) the mobjects to\nthe head of submobjects . The head of this list is rendered\nfirst, which places the corresponding mobjects behind the\nsubsequent list members. Raises : ValueError \u2013 When a mobject tries to add itself. TypeError \u2013 When trying to add an object that is not an instance of Mobject . Parameters : mobjects ( Mobject ) Return type : Self Notes A mobject cannot contain itself, and it cannot contain a submobject\nmore than once.  If the parent mobject is displayed, the newly-added\nsubmobjects will also be displayed (i.e. they are automatically added\nto the parent Scene). See also remove() , add() add_updater ( update_function , index = None , call_updater = False ) [source]   Add an update function to this mobject. Update functions, or updaters in short, are functions that are applied to the\nMobject in every frame. Parameters : update_function ( Updater ) \u2013 The update function to be added.\nWhenever update() is called, this update function gets called using self as the first parameter.\nThe updater can have a second parameter dt . If it uses this parameter,\nit gets called using a second value dt , usually representing the time\nin seconds since the last call of update() . index ( int | None ) \u2013 The index at which the new updater should be added in self.updaters .\nIn case index is None the updater will be added at the end. call_updater ( bool ) \u2013 Whether or not to call the updater initially. If True , the updater will\nbe called using dt=0 . Returns : self Return type : Mobject Examples Example: NextToUpdater   from manim import * class NextToUpdater ( Scene ): def construct ( self ): def dot_position ( mobject ): mobject . set_value ( dot . get_center ()[ 0 ]) mobject . next_to ( dot ) dot = Dot ( RIGHT * 3 ) label = DecimalNumber () label . add_updater ( dot_position ) self . add ( dot , label ) self . play ( Rotating ( dot , about_point = ORIGIN , angle = TAU , run_time = TAU , rate_func = linear )) class NextToUpdater(Scene):\n    def construct(self):\n        def dot_position(mobject):\n            mobject.set_value(dot.get_center()[0])\n            mobject.next_to(dot)\n\n        dot = Dot(RIGHT*3)\n        label = DecimalNumber()\n        label.add_updater(dot_position)\n        self.add(dot, label)\n\n        self.play(Rotating(dot, about_point=ORIGIN, angle=TAU, run_time=TAU, rate_func=linear)) Example: DtUpdater   from manim import * class DtUpdater ( Scene ): def construct ( self ): square = Square () #Let the square rotate 90\u00b0 per second square . add_updater ( lambda mobject , dt : mobject . rotate ( dt * 90 * DEGREES )) self . add ( square ) self . wait ( 2 ) class DtUpdater(Scene):\n    def construct(self):\n        square = Square()\n\n        #Let the square rotate 90\u00b0 per second\n        square.add_updater(lambda mobject, dt: mobject.rotate(dt*90*DEGREES))\n        self.add(square)\n        self.wait(2) See also get_updaters() , remove_updater() , UpdateFromFunc align_data ( mobject , skip_point_alignment = False ) [source]   Aligns the data of this mobject with another mobject. Afterwards, the two mobjects will have the same number of submobjects\n(see align_submobjects() ), the same parent structure (see null_point_align() ). If skip_point_alignment is false,\nthey will also have the same number of points (see align_points() ). Parameters : mobject ( Mobject ) \u2013 The other mobject this mobject should be aligned to. skip_point_alignment ( bool ) \u2013 Controls whether or not the computationally expensive\npoint alignment is skipped (default: False). Return type : None align_on_border ( direction , buff = 0.5 ) [source]   Direction just needs to be a vector pointing towards side or\ncorner in the 2d plane. Parameters : direction ( Vector3D ) buff ( float ) Return type : Self align_to ( mobject_or_point , direction = array([0., 0., 0.]) ) [source]   Aligns mobject to another Mobject in a certain direction. Examples:\nmob1.align_to(mob2, UP) moves mob1 vertically so that its\ntop edge lines ups with mob2\u2019s top edge. Parameters : mobject_or_point ( Mobject | Point3DLike ) direction ( Vector3D ) Return type : Self property animate : _AnimationBuilder | Self   Used to animate the application of any method of self . Any method called on animate is converted to an animation of applying\nthat method on the mobject itself. For example, square.set_fill(WHITE) sets the fill color of a square,\nwhile square.animate.set_fill(WHITE) animates this action. Multiple methods can be put in a single animation once via chaining: self . play ( my_mobject . animate . shift ( RIGHT ) . rotate ( PI )) Warning Passing multiple animations for the same Mobject in one\ncall to play() is discouraged and will most likely\nnot work properly. Instead of writing an animation like self . play ( my_mobject . animate . shift ( RIGHT ), my_mobject . animate . rotate ( PI ) ) make use of method chaining. Keyword arguments that can be passed to Scene.play() can be passed\ndirectly after accessing .animate , like so: self . play ( my_mobject . animate ( rate_func = linear ) . shift ( RIGHT )) This is especially useful when animating simultaneous .animate calls that\nyou want to behave differently: self . play ( mobject1 . animate ( run_time = 2 ) . rotate ( PI ), mobject2 . animate ( rate_func = there_and_back ) . shift ( RIGHT ), ) See also override_animate() Examples Example: AnimateExample   from manim import * class AnimateExample ( Scene ): def construct ( self ): s = Square () self . play ( Create ( s )) self . play ( s . animate . shift ( RIGHT )) self . play ( s . animate . scale ( 2 )) self . play ( s . animate . rotate ( PI / 2 )) self . play ( Uncreate ( s )) class AnimateExample(Scene):\n    def construct(self):\n        s = Square()\n        self.play(Create(s))\n        self.play(s.animate.shift(RIGHT))\n        self.play(s.animate.scale(2))\n        self.play(s.animate.rotate(PI / 2))\n        self.play(Uncreate(s)) Example: AnimateChainExample   from manim import * class AnimateChainExample ( Scene ): def construct ( self ): s = Square () self . play ( Create ( s )) self . play ( s . animate . shift ( RIGHT ) . scale ( 2 ) . rotate ( PI / 2 )) self . play ( Uncreate ( s )) class AnimateChainExample(Scene):\n    def construct(self):\n        s = Square()\n        self.play(Create(s))\n        self.play(s.animate.shift(RIGHT).scale(2).rotate(PI / 2))\n        self.play(Uncreate(s)) Example: AnimateWithArgsExample   from manim import * class AnimateWithArgsExample ( Scene ): def construct ( self ): s = Square () c = Circle () VGroup ( s , c ) . arrange ( RIGHT , buff = 2 ) self . add ( s , c ) self . play ( s . animate ( run_time = 2 ) . rotate ( PI / 2 ), c . animate ( rate_func = there_and_back ) . shift ( RIGHT ), ) class AnimateWithArgsExample(Scene):\n    def construct(self):\n        s = Square()\n        c = Circle()\n\n        VGroup(s, c).arrange(RIGHT, buff=2)\n        self.add(s, c)\n\n        self.play(\n            s.animate(run_time=2).rotate(PI / 2),\n            c.animate(rate_func=there_and_back).shift(RIGHT),\n        ) Warning .animate will interpolate the Mobject between its points prior to .animate and its points after applying .animate to it. This may\nresult in unexpected behavior when attempting to interpolate along paths,\nor rotations.\nIf you want animations to consider the points between, consider using ValueTracker with updaters instead. classmethod animation_override_for ( animation_class ) [source]   Returns the function defining a specific animation override for this class. Parameters : animation_class ( type [ Animation ] ) \u2013 The animation class for which the override function should be returned. Returns : The function returning the override animation or None if no such animation\noverride is defined. Return type : Optional[Callable[[ Mobject , \u2026], Animation ]] apply_complex_function ( function , ** kwargs ) [source]   Applies a complex function to a Mobject .\nThe x and y Point3Ds correspond to the real and imaginary parts respectively. Example Example: ApplyFuncExample   from manim import * class ApplyFuncExample ( Scene ): def construct ( self ): circ = Circle () . scale ( 1.5 ) circ_ref = circ . copy () circ . apply_complex_function ( lambda x : np . exp ( x * 1 j ) ) t = ValueTracker ( 0 ) circ . add_updater ( lambda x : x . become ( circ_ref . copy () . apply_complex_function ( lambda x : np . exp ( x + t . get_value () * 1 j ) )) . set_color ( BLUE ) ) self . add ( circ_ref ) self . play ( TransformFromCopy ( circ_ref , circ )) self . play ( t . animate . set_value ( TAU ), run_time = 3 ) class ApplyFuncExample(Scene):\n    def construct(self):\n        circ = Circle().scale(1.5)\n        circ_ref = circ.copy()\n        circ.apply_complex_function(\n            lambda x: np.exp(x*1j)\n        )\n        t = ValueTracker(0)\n        circ.add_updater(\n            lambda x: x.become(circ_ref.copy().apply_complex_function(\n                lambda x: np.exp(x+t.get_value()*1j)\n            )).set_color(BLUE)\n        )\n        self.add(circ_ref)\n        self.play(TransformFromCopy(circ_ref, circ))\n        self.play(t.animate.set_value(TAU), run_time=3) Parameters : function ( Callable [ [ complex ] , complex ] ) Return type : Self apply_to_family ( func ) [source]   Apply a function to self and every submobject with points recursively. Parameters : func ( Callable [ [ Mobject ] , None ] ) \u2013 The function to apply to each mobject. func gets passed the respective\n(sub)mobject as parameter. Returns : self Return type : Mobject See also family_members_with_points() arrange ( direction = array([1., 0., 0.]) , buff = 0.25 , center = True , ** kwargs ) [source]   Sorts Mobject next to each other on screen. Examples Example: Example   from manim import * class Example ( Scene ): def construct ( self ): s1 = Square () s2 = Square () s3 = Square () s4 = Square () x = VGroup ( s1 , s2 , s3 , s4 ) . set_x ( 0 ) . arrange ( buff = 1.0 ) self . add ( x ) class Example(Scene):\n    def construct(self):\n        s1 = Square()\n        s2 = Square()\n        s3 = Square()\n        s4 = Square()\n        x = VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)\n        self.add(x) Parameters : direction ( Vector3D ) buff ( float ) center ( bool ) Return type : Self arrange_in_grid ( rows = None , cols = None , buff = 0.25 , cell_alignment = array([0., 0., 0.]) , row_alignments = None , col_alignments = None , row_heights = None , col_widths = None , flow_order = 'rd' , ** kwargs ) [source]   Arrange submobjects in a grid. Parameters : rows ( int | None ) \u2013 The number of rows in the grid. cols ( int | None ) \u2013 The number of columns in the grid. buff ( float | tuple [ float , float ] ) \u2013 The gap between grid cells. To specify a different buffer in the horizontal and\nvertical directions, a tuple of two values can be given - (row, col) . cell_alignment ( Vector3D ) \u2013 The way each submobject is aligned in its grid cell. row_alignments ( str | None ) \u2013 The vertical alignment for each row (top to bottom). Accepts the following characters: \"u\" -\nup, \"c\" - center, \"d\" - down. col_alignments ( str | None ) \u2013 The horizontal alignment for each column (left to right). Accepts the following characters \"l\" - left, \"c\" - center, \"r\" - right. row_heights ( Iterable [ float | None ] | None ) \u2013 Defines a list of heights for certain rows (top to bottom). If the list contains None , the corresponding row will fit its height automatically based\non the highest element in that row. col_widths ( Iterable [ float | None ] | None ) \u2013 Defines a list of widths for certain columns (left to right). If the list contains None , the\ncorresponding column will fit its width automatically based on the widest element in that column. flow_order ( str ) \u2013 The order in which submobjects fill the grid. Can be one of the following values:\n\u201crd\u201d, \u201cdr\u201d, \u201cld\u201d, \u201cdl\u201d, \u201cru\u201d, \u201cur\u201d, \u201clu\u201d, \u201cul\u201d. (\u201crd\u201d -> fill rightwards then downwards) Returns : self Return type : Mobject Raises : ValueError \u2013 If rows and cols are too small to fit all submobjects. ValueError \u2013 If cols , col_alignments and col_widths or rows , row_alignments and row_heights have mismatching sizes. Notes If only one of cols and rows is set implicitly, the other one will be chosen big\nenough to fit all submobjects. If neither is set, they will be chosen to be about the same,\ntending towards cols > rows (simply because videos are wider than they are high). If both cell_alignment and row_alignments / col_alignments are\ndefined, the latter has higher priority. Examples Example: ExampleBoxes   from manim import * class ExampleBoxes ( Scene ): def construct ( self ): boxes = VGroup ( * [ Square () for s in range ( 0 , 6 )]) boxes . arrange_in_grid ( rows = 2 , buff = 0.1 ) self . add ( boxes ) class ExampleBoxes(Scene):\n    def construct(self):\n        boxes=VGroup(*[Square() for s in range(0,6)])\n        boxes.arrange_in_grid(rows=2, buff=0.1)\n        self.add(boxes) Example: ArrangeInGrid   from manim import * class ArrangeInGrid ( Scene ): def construct ( self ): boxes = VGroup ( * [ Rectangle ( WHITE , 0.5 , 0.5 ) . add ( Text ( str ( i + 1 )) . scale ( 0.5 )) for i in range ( 24 ) ]) self . add ( boxes ) boxes . arrange_in_grid ( buff = ( 0.25 , 0.5 ), col_alignments = \"lccccr\" , row_alignments = \"uccd\" , col_widths = [ 1 , * [ None ] * 4 , 1 ], row_heights = [ 1 , None , None , 1 ], flow_order = \"dr\" ) class ArrangeInGrid(Scene):\n    def construct(self):\n        boxes = VGroup(*[\n            Rectangle(WHITE, 0.5, 0.5).add(Text(str(i+1)).scale(0.5))\n            for i in range(24)\n        ])\n        self.add(boxes)\n\n        boxes.arrange_in_grid(\n            buff=(0.25,0.5),\n            col_alignments=\"lccccr\",\n            row_alignments=\"uccd\",\n            col_widths=[1, *[None]*4, 1],\n            row_heights=[1, None, None, 1],\n            flow_order=\"dr\"\n        ) arrange_submobjects ( * args , ** kwargs ) [source]   Arrange the position of submobjects with a small buffer. Examples Example: ArrangeSumobjectsExample   from manim import * class ArrangeSumobjectsExample ( Scene ): def construct ( self ): s = VGroup ( * [ Dot () . shift ( i * 0.1 * RIGHT * np . random . uniform ( - 1 , 1 ) + UP * np . random . uniform ( - 1 , 1 )) for i in range ( 0 , 15 )]) s . shift ( UP ) . set_color ( BLUE ) s2 = s . copy () . set_color ( RED ) s2 . arrange_submobjects () s2 . shift ( DOWN ) self . add ( s , s2 ) class ArrangeSumobjectsExample(Scene):\n    def construct(self):\n        s= VGroup(*[Dot().shift(i*0.1*RIGHT*np.random.uniform(-1,1)+UP*np.random.uniform(-1,1)) for i in range(0,15)])\n        s.shift(UP).set_color(BLUE)\n        s2= s.copy().set_color(RED)\n        s2.arrange_submobjects()\n        s2.shift(DOWN)\n        self.add(s,s2) Return type : Self become ( mobject , match_height = False , match_width = False , match_depth = False , match_center = False , stretch = False ) [source]   Edit points, colors and submobjects to be identical\nto another Mobject Note If both match_height and match_width are True then the transformed Mobject will match the height first and then the width. Parameters : match_height ( bool ) \u2013 Whether or not to preserve the height of the original Mobject . match_width ( bool ) \u2013 Whether or not to preserve the width of the original Mobject . match_depth ( bool ) \u2013 Whether or not to preserve the depth of the original Mobject . match_center ( bool ) \u2013 Whether or not to preserve the center of the original Mobject . stretch ( bool ) \u2013 Whether or not to stretch the target mobject to match the\nthe proportions of the original Mobject . mobject ( Mobject ) Return type : Self Examples Example: BecomeScene   from manim import * class BecomeScene ( Scene ): def construct ( self ): circ = Circle ( fill_color = RED , fill_opacity = 0.8 ) square = Square ( fill_color = BLUE , fill_opacity = 0.2 ) self . add ( circ ) self . wait ( 0.5 ) circ . become ( square ) self . wait ( 0.5 ) class BecomeScene(Scene):\n    def construct(self):\n        circ = Circle(fill_color=RED, fill_opacity=0.8)\n        square = Square(fill_color=BLUE, fill_opacity=0.2)\n        self.add(circ)\n        self.wait(0.5)\n        circ.become(square)\n        self.wait(0.5) The following examples illustrate how mobject measurements\nchange when using the match_... and stretch arguments.\nWe start with a rectangle that is 2 units high and 4 units wide,\nwhich we want to turn into a circle of radius 3: >>> from manim import Rectangle , Circle >>> import numpy as np >>> rect = Rectangle ( height = 2 , width = 4 ) >>> circ = Circle ( radius = 3 ) With stretch=True , the target circle is deformed to match\nthe proportions of the rectangle, which results in the target\nmobject being an ellipse with height 2 and width 4. We can\ncheck that the resulting points satisfy the ellipse equation \\(x^2/a^2 + y^2/b^2 = 1\\) with \\(a = 4/2\\) and \\(b = 2/2\\) being the semi-axes: >>> result = rect . copy () . become ( circ , stretch = True ) >>> result . height , result . width (np.float64(2.0), np.float64(4.0)) >>> ellipse_points = np . array ( result . get_anchors ()) >>> ellipse_eq = np . sum ( ellipse_points ** 2 * [ 1 / 4 , 1 , 0 ], axis = 1 ) >>> np . allclose ( ellipse_eq , 1 ) True With match_height=True and match_width=True the circle is\nscaled such that the height or the width of the rectangle will\nbe preserved, respectively.\nThe points of the resulting mobject satisfy the circle equation \\(x^2 + y^2 = r^2\\) for the corresponding radius \\(r\\) : >>> result = rect . copy () . become ( circ , match_height = True ) >>> result . height , result . width (np.float64(2.0), np.float64(2.0)) >>> circle_points = np . array ( result . get_anchors ()) >>> circle_eq = np . sum ( circle_points ** 2 , axis = 1 ) >>> np . allclose ( circle_eq , 1 ) True >>> result = rect . copy () . become ( circ , match_width = True ) >>> result . height , result . width (np.float64(4.0), np.float64(4.0)) >>> circle_points = np . array ( result . get_anchors ()) >>> circle_eq = np . sum ( circle_points ** 2 , axis = 1 ) >>> np . allclose ( circle_eq , 2 ** 2 ) True With match_center=True , the resulting mobject is moved such that\nits center is the same as the center of the original mobject: >>> rect = rect . shift ( np . array ([ 0 , 1 , 0 ])) >>> np . allclose ( rect . get_center (), circ . get_center ()) False >>> result = rect . copy () . become ( circ , match_center = True ) >>> np . allclose ( rect . get_center (), result . get_center ()) True center ( ) [source]   Moves the center of the mobject to the center of the scene. Returns : The centered mobject. Return type : Mobject clear_updaters ( recursive = True ) [source]   Remove every updater. Parameters : recursive ( bool ) \u2013 Whether to recursively call clear_updaters on all submobjects. Returns : self Return type : Mobject See also remove_updater() , add_updater() , get_updaters() copy ( ) [source]   Create and return an identical copy of the Mobject including all submobjects . Returns : The copy. Return type : Mobject Note The clone is initially not visible in the Scene, even if the original was. property depth : float   The depth of the mobject. Return type : float See also length_over_dim() flip ( axis = array([0., 1., 0.]) , ** kwargs ) [source]   Flips/Mirrors an mobject about its center. Examples Example: FlipExample   from manim import * class FlipExample ( Scene ): def construct ( self ): s = Line ( LEFT , RIGHT + UP ) . shift ( 4 * LEFT ) self . add ( s ) s2 = s . copy () . flip () self . add ( s2 ) class FlipExample(Scene):\n    def construct(self):\n        s= Line(LEFT, RIGHT+UP).shift(4*LEFT)\n        self.add(s)\n        s2= s.copy().flip()\n        self.add(s2) Parameters : axis ( Vector3D ) Return type : Self generate_points ( ) [source]   Initializes points and therefore the shape. Gets called upon creation. This is an empty method that can be implemented by\nsubclasses. Return type : object get_all_points ( ) [source]   Return all points from this mobject and all submobjects. May contain duplicates; the order is in a depth-first (pre-order)\ntraversal of the submobjects. Return type : Point3D_Array get_bottom ( ) [source]   Get bottom Point3Ds of a box bounding the Mobject Return type : Point3D get_center ( ) [source]   Get center Point3Ds Return type : Point3D get_color ( ) [source]   Returns the color of the Mobject Examples >>> from manim import Square , RED >>> Square ( color = RED ) . get_color () == RED True Return type : ManimColor get_coord ( dim , direction = array([0., 0., 0.]) ) [source]   Meant to generalize get_x , get_y and get_z Parameters : dim ( int ) direction ( Vector3D ) get_corner ( direction ) [source]   Get corner Point3Ds for certain direction. Parameters : direction ( Vector3D ) Return type : Point3D get_critical_point ( direction ) [source]   Picture a box bounding the Mobject .  Such a box has\n9 \u2018critical points\u2019: 4 corners, 4 edge center, the\ncenter. This returns one of them, along the given direction. sample = Arc ( start_angle = PI / 7 , angle = PI / 5 ) # These are all equivalent max_y_1 = sample . get_top ()[ 1 ] max_y_2 = sample . get_critical_point ( UP )[ 1 ] max_y_3 = sample . get_extremum_along_dim ( dim = 1 , key = 1 ) Parameters : direction ( Vector3D ) Return type : Point3D get_edge_center ( direction ) [source]   Get edge Point3Ds for certain direction. Parameters : direction ( Vector3D ) Return type : Point3D get_end ( ) [source]   Returns the point, where the stroke that surrounds the Mobject ends. Return type : Point3D get_left ( ) [source]   Get left Point3Ds of a box bounding the Mobject Return type : Point3D get_merged_array ( array_attr ) [source]   Return all of a given attribute from this mobject and all submobjects. May contain duplicates; the order is in a depth-first (pre-order)\ntraversal of the submobjects. Parameters : array_attr ( str ) Return type : ndarray get_midpoint ( ) [source]   Get Point3Ds of the middle of the path that forms the Mobject . Examples Example: AngleMidPoint   from manim import * class AngleMidPoint ( Scene ): def construct ( self ): line1 = Line ( ORIGIN , 2 * RIGHT ) line2 = Line ( ORIGIN , 2 * RIGHT ) . rotate_about_origin ( 80 * DEGREES ) a = Angle ( line1 , line2 , radius = 1.5 , other_angle = False ) d = Dot ( a . get_midpoint ()) . set_color ( RED ) self . add ( line1 , line2 , a , d ) self . wait () class AngleMidPoint(Scene):\n    def construct(self):\n        line1 = Line(ORIGIN, 2*RIGHT)\n        line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)\n\n        a = Angle(line1, line2, radius=1.5, other_angle=False)\n        d = Dot(a.get_midpoint()).set_color(RED)\n\n        self.add(line1, line2, a, d)\n        self.wait() Return type : Point3D static get_mobject_type_class ( ) [source]   Return the base class of this mobject type. Return type : type[ Mobject ] get_nadir ( ) [source]   Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D Mobject . Return type : Point3D get_point_mobject ( center = None ) [source]   The simplest Mobject to be transformed to or from self.\nShould by a point of the appropriate type get_right ( ) [source]   Get right Point3Ds of a box bounding the Mobject Return type : Point3D get_start ( ) [source]   Returns the point, where the stroke that surrounds the Mobject starts. Return type : Point3D get_start_and_end ( ) [source]   Returns starting and ending point of a stroke as a tuple . Return type : tuple[ Point3D , Point3D ] get_time_based_updaters ( ) [source]   Return all updaters using the dt parameter. The updaters use this parameter as the input for difference in time. Returns : The list of time based updaters. Return type : List[ Callable ] See also get_updaters() , has_time_based_updater() get_top ( ) [source]   Get top Point3Ds of a box bounding the Mobject Return type : Point3D get_updaters ( ) [source]   Return all updaters. Returns : The list of updaters. Return type : List[ Callable ] See also add_updater() , get_time_based_updaters() get_x ( direction = array([0., 0., 0.]) ) [source]   Returns x Point3D of the center of the Mobject as float Parameters : direction ( Vector3D ) Return type : float get_y ( direction = array([0., 0., 0.]) ) [source]   Returns y Point3D of the center of the Mobject as float Parameters : direction ( Vector3D ) Return type : float get_z ( direction = array([0., 0., 0.]) ) [source]   Returns z Point3D of the center of the Mobject as float Parameters : direction ( Vector3D ) Return type : float get_zenith ( ) [source]   Get zenith Point3Ds of a box bounding a 3D Mobject . Return type : Point3D has_no_points ( ) [source]   Check if Mobject does not contains points. Return type : bool has_points ( ) [source]   Check if Mobject contains points. Return type : bool has_time_based_updater ( ) [source]   Test if self has a time based updater. Returns : True if at least one updater uses the dt parameter, False otherwise. Return type : bool See also get_time_based_updaters() property height : float   The height of the mobject. Return type : float Examples Example: HeightExample   from manim import * class HeightExample ( Scene ): def construct ( self ): decimal = DecimalNumber () . to_edge ( UP ) rect = Rectangle ( color = BLUE ) rect_copy = rect . copy () . set_stroke ( GRAY , opacity = 0.5 ) decimal . add_updater ( lambda d : d . set_value ( rect . height )) self . add ( rect_copy , rect , decimal ) self . play ( rect . animate . set ( height = 5 )) self . wait () class HeightExample(Scene):\n    def construct(self):\n        decimal = DecimalNumber().to_edge(UP)\n        rect = Rectangle(color=BLUE)\n        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)\n\n        decimal.add_updater(lambda d: d.set_value(rect.height))\n\n        self.add(rect_copy, rect, decimal)\n        self.play(rect.animate.set(height=5))\n        self.wait() See also length_over_dim() init_colors ( ) [source]   Initializes the colors. Gets called upon creation. This is an empty method that can be implemented by\nsubclasses. Return type : object insert ( index , mobject ) [source]   Inserts a mobject at a specific position into self.submobjects Effectively just calls self.submobjects.insert(index, mobject) ,\nwhere self.submobjects is a list. Highly adapted from Mobject.add . Parameters : index ( int ) \u2013 The index at which mobject ( Mobject ) \u2013 The mobject to be inserted. Return type : None interpolate ( mobject1 , mobject2 , alpha , path_func=<function interpolate> ) [source]   Turns this Mobject into an interpolation between mobject1 and mobject2 . Examples Example: DotInterpolation   from manim import * class DotInterpolation ( Scene ): def construct ( self ): dotR = Dot ( color = DARK_GREY ) dotR . shift ( 2 * RIGHT ) dotL = Dot ( color = WHITE ) dotL . shift ( 2 * LEFT ) dotMiddle = VMobject () . interpolate ( dotL , dotR , alpha = 0.3 ) self . add ( dotL , dotR , dotMiddle ) class DotInterpolation(Scene):\n    def construct(self):\n        dotR = Dot(color=DARK_GREY)\n        dotR.shift(2 * RIGHT)\n        dotL = Dot(color=WHITE)\n        dotL.shift(2 * LEFT)\n\n        dotMiddle = VMobject().interpolate(dotL, dotR, alpha=0.3)\n\n        self.add(dotL, dotR, dotMiddle) Parameters : mobject1 ( Mobject ) mobject2 ( Mobject ) alpha ( float ) path_func ( PathFuncType ) Return type : Self invert ( recursive = False ) [source]   Inverts the list of submobjects . Parameters : recursive ( bool ) \u2013 If True , all submobject lists of this mobject\u2019s family are inverted. Return type : None Examples Example: InvertSumobjectsExample   from manim import * class InvertSumobjectsExample ( Scene ): def construct ( self ): s = VGroup ( * [ Dot () . shift ( i * 0.1 * RIGHT ) for i in range ( - 20 , 20 )]) s2 = s . copy () s2 . invert () s2 . shift ( DOWN ) self . play ( Write ( s ), Write ( s2 )) class InvertSumobjectsExample(Scene):\n    def construct(self):\n        s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n        s2 = s.copy()\n        s2.invert()\n        s2.shift(DOWN)\n        self.play(Write(s), Write(s2)) length_over_dim ( dim ) [source]   Measure the length of an Mobject in a certain direction. Parameters : dim ( int ) Return type : float match_color ( mobject ) [source]   Match the color with the color of another Mobject . Parameters : mobject ( Mobject ) Return type : Self match_coord ( mobject , dim , direction = array([0., 0., 0.]) ) [source]   Match the Point3Ds with the Point3Ds of another Mobject . Parameters : mobject ( Mobject ) dim ( int ) direction ( Vector3D ) Return type : Self match_depth ( mobject , ** kwargs ) [source]   Match the depth with the depth of another Mobject . Parameters : mobject ( Mobject ) Return type : Self match_dim_size ( mobject , dim , ** kwargs ) [source]   Match the specified dimension with the dimension of another Mobject . Parameters : mobject ( Mobject ) dim ( int ) Return type : Self match_height ( mobject , ** kwargs ) [source]   Match the height with the height of another Mobject . Parameters : mobject ( Mobject ) Return type : Self match_points ( mobject , copy_submobjects = True ) [source]   Edit points, positions, and submobjects to be identical\nto another Mobject , while keeping the style unchanged. Examples Example: MatchPointsScene   from manim import * class MatchPointsScene ( Scene ): def construct ( self ): circ = Circle ( fill_color = RED , fill_opacity = 0.8 ) square = Square ( fill_color = BLUE , fill_opacity = 0.2 ) self . add ( circ ) self . wait ( 0.5 ) self . play ( circ . animate . match_points ( square )) self . wait ( 0.5 ) class MatchPointsScene(Scene):\n    def construct(self):\n        circ = Circle(fill_color=RED, fill_opacity=0.8)\n        square = Square(fill_color=BLUE, fill_opacity=0.2)\n        self.add(circ)\n        self.wait(0.5)\n        self.play(circ.animate.match_points(square))\n        self.wait(0.5) Parameters : mobject ( Mobject ) copy_submobjects ( bool ) Return type : Self match_updaters ( mobject ) [source]   Match the updaters of the given mobject. Parameters : mobject ( Mobject ) \u2013 The mobject whose updaters get matched. Returns : self Return type : Mobject Note All updaters from submobjects are removed, but only updaters of the given\nmobject are matched, not those of it\u2019s submobjects. See also add_updater() , clear_updaters() match_width ( mobject , ** kwargs ) [source]   Match the width with the width of another Mobject . Parameters : mobject ( Mobject ) Return type : Self match_x ( mobject , direction = array([0., 0., 0.]) ) [source]   Match x coord. to the x coord. of another Mobject . Parameters : mobject ( Mobject ) Return type : Self match_y ( mobject , direction = array([0., 0., 0.]) ) [source]   Match y coord. to the x coord. of another Mobject . Parameters : mobject ( Mobject ) Return type : Self match_z ( mobject , direction = array([0., 0., 0.]) ) [source]   Match z coord. to the x coord. of another Mobject . Parameters : mobject ( Mobject ) Return type : Self move_to ( point_or_mobject , aligned_edge = array([0., 0., 0.]) , coor_mask = array([1, 1, 1]) ) [source]   Move center of the Mobject to certain Point3D. Parameters : point_or_mobject ( Point3DLike | Mobject ) aligned_edge ( Vector3D ) coor_mask ( Vector3D ) Return type : Self next_to ( mobject_or_point , direction = array([1., 0., 0.]) , buff = 0.25 , aligned_edge = array([0., 0., 0.]) , submobject_to_align = None , index_of_submobject_to_align = None , coor_mask = array([1, 1, 1]) ) [source]   Move this Mobject next to another\u2019s Mobject or Point3D. Examples Example: GeometricShapes   from manim import * class GeometricShapes ( Scene ): def construct ( self ): d = Dot () c = Circle () s = Square () t = Triangle () d . next_to ( c , RIGHT ) s . next_to ( c , LEFT ) t . next_to ( c , DOWN ) self . add ( d , c , s , t ) class GeometricShapes(Scene):\n    def construct(self):\n        d = Dot()\n        c = Circle()\n        s = Square()\n        t = Triangle()\n        d.next_to(c, RIGHT)\n        s.next_to(c, LEFT)\n        t.next_to(c, DOWN)\n        self.add(d, c, s, t) Parameters : mobject_or_point ( Mobject | Point3DLike ) direction ( Vector3D ) buff ( float ) aligned_edge ( Vector3D ) submobject_to_align ( Mobject | None ) index_of_submobject_to_align ( int | None ) coor_mask ( Vector3D ) Return type : Self null_point_align ( mobject ) [source]   If a Mobject with points is being aligned to\none without, treat both as groups, and push\nthe one with points into its own submobjects\nlist. Returns : self Return type : Mobject Parameters : mobject ( Mobject ) reduce_across_dimension ( reduce_func , dim ) [source]   Find the min or max value from a dimension across all points in this and submobjects. Parameters : reduce_func ( Callable ) dim ( int ) remove ( * mobjects ) [source]   Remove submobjects . The mobjects are removed from submobjects , if they exist. Subclasses of mobject may implement - and -= dunder methods. Parameters : mobjects ( Mobject ) \u2013 The mobjects to remove. Returns : self Return type : Mobject See also add() remove_updater ( update_function ) [source]   Remove an updater. If the same updater is applied multiple times, every instance gets removed. Parameters : update_function ( Updater ) \u2013 The update function to be removed. Returns : self Return type : Mobject See also clear_updaters() , add_updater() , get_updaters() repeat ( count ) [source]   This can make transition animations nicer Parameters : count ( int ) Return type : Self reset_points ( ) [source]   Sets points to be an empty array. Return type : None restore ( ) [source]   Restores the state that was previously saved with save_state() . Return type : Self resume_updating ( recursive = True ) [source]   Enable updating from updaters and animations. Parameters : recursive ( bool ) \u2013 Whether to recursively enable updating on all submobjects. Returns : self Return type : Mobject See also suspend_updating() , add_updater() rotate ( angle , axis = array([0., 0., 1.]) , about_point = None , ** kwargs ) [source]   Rotates the Mobject about a certain point. Parameters : angle ( float ) axis ( Vector3D ) about_point ( Point3DLike | None ) Return type : Self rotate_about_origin ( angle , axis = array([0., 0., 1.]) , axes = [] ) [source]   Rotates the Mobject about the ORIGIN, which is at [0,0,0]. Parameters : angle ( float ) axis ( Vector3D ) Return type : Self save_image ( name = None ) [source]   Saves an image of only this Mobject at its position to a png\nfile. Parameters : name ( str | None ) Return type : None save_state ( ) [source]   Save the current state (position, color & size). Can be restored with restore() . Return type : Self scale ( scale_factor , ** kwargs ) [source]   Scale the size by a factor. Default behavior is to scale about the center of the mobject. Parameters : scale_factor ( float ) \u2013 The scaling factor \\(\\alpha\\) . If \\(0 < |\\alpha|\u00a0< 1\\) , the mobject\nwill shrink, and for \\(|\\alpha| > 1\\) it will grow. Furthermore,\nif \\(\\alpha < 0\\) , the mobject is also flipped. kwargs \u2013 Additional keyword arguments passed to apply_points_function_about_point() . Returns : self Return type : Mobject Examples Example: MobjectScaleExample   from manim import * class MobjectScaleExample ( Scene ): def construct ( self ): f1 = Text ( \"F\" ) f2 = Text ( \"F\" ) . scale ( 2 ) f3 = Text ( \"F\" ) . scale ( 0.5 ) f4 = Text ( \"F\" ) . scale ( - 1 ) vgroup = VGroup ( f1 , f2 , f3 , f4 ) . arrange ( 6 * RIGHT ) self . add ( vgroup ) class MobjectScaleExample(Scene):\n    def construct(self):\n        f1 = Text(\"F\")\n        f2 = Text(\"F\").scale(2)\n        f3 = Text(\"F\").scale(0.5)\n        f4 = Text(\"F\").scale(-1)\n\n        vgroup = VGroup(f1, f2, f3, f4).arrange(6 * RIGHT)\n        self.add(vgroup) See also move_to() scale_to_fit_depth ( depth , ** kwargs ) [source]   Scales the Mobject to fit a depth while keeping width/height proportional. Parameters : depth ( float ) Return type : Self scale_to_fit_height ( height , ** kwargs ) [source]   Scales the Mobject to fit a height while keeping width/depth proportional. Returns : self Return type : Mobject Parameters : height ( float ) Examples >>> from manim import * >>> sq = Square () >>> sq . width np.float64(2.0) >>> sq . scale_to_fit_height ( 5 ) Square >>> sq . height np.float64(5.0) >>> sq . width np.float64(5.0) scale_to_fit_width ( width , ** kwargs ) [source]   Scales the Mobject to fit a width while keeping height/depth proportional. Returns : self Return type : Mobject Parameters : width ( float ) Examples >>> from manim import * >>> sq = Square () >>> sq . height np.float64(2.0) >>> sq . scale_to_fit_width ( 5 ) Square >>> sq . width np.float64(5.0) >>> sq . height np.float64(5.0) set ( ** kwargs ) [source]   Sets attributes. I.e. my_mobject.set(foo=1) applies my_mobject.foo = 1 . This is a convenience to be used along with animate to\nanimate setting attributes. In addition to this method, there is a compatibility\nlayer that allows get_* and set_* methods to\nget and set generic attributes. For instance: >>> mob = Mobject () >>> mob . set_foo ( 0 ) Mobject >>> mob . get_foo () 0 >>> mob . foo 0 This compatibility layer does not interfere with any get_* or set_* methods that are explicitly\ndefined. Warning This compatibility layer is for backwards compatibility\nand is not guaranteed to stay around. Where applicable,\nplease prefer getting/setting attributes normally or with\nthe set() method. Parameters : **kwargs \u2013 The attributes and corresponding values to set. Returns : self Return type : Mobject Examples >>> mob = Mobject () >>> mob . set ( foo = 0 ) Mobject >>> mob . foo 0 set_color ( color = ManimColor('#FFFF00') , family = True ) [source]   Condition is function which takes in one arguments, (x, y, z).\nHere it just recurses to submobjects, but in subclasses this\nshould be further implemented based on the the inner workings\nof color Parameters : color ( ParsableManimColor ) family ( bool ) Return type : Self set_color_by_gradient ( * colors ) [source]   Parameters : colors ( ParsableManimColor ) \u2013 The colors to use for the gradient. Use like set_color_by_gradient(RED, BLUE, GREEN) . ManimColor.parse ( color ) ( self.color = ) self ( return ) Return type : Self classmethod set_default ( ** kwargs ) [source]   Sets the default values of keyword arguments. If this method is called without any additional keyword\narguments, the original default values of the initialization\nmethod of this class are restored. Parameters : kwargs \u2013 Passing any keyword argument will update the default\nvalues of the keyword arguments of the initialization\nfunction of this class. Return type : None Examples >>> from manim import Square , GREEN >>> Square . set_default ( color = GREEN , fill_opacity = 0.25 ) >>> s = Square (); s . color , s . fill_opacity (ManimColor('#83C167'), 0.25) >>> Square . set_default () >>> s = Square (); s . color , s . fill_opacity (ManimColor('#FFFFFF'), 0.0) Example: ChangedDefaultTextcolor   from manim import * config . background_color = WHITE class ChangedDefaultTextcolor ( Scene ): def construct ( self ): Text . set_default ( color = BLACK ) self . add ( Text ( \"Changing default values is easy!\" )) # we revert the colour back to the default to prevent a bug in the docs. Text . set_default ( color = WHITE ) config.background_color = WHITE\n\nclass ChangedDefaultTextcolor(Scene):\n    def construct(self):\n        Text.set_default(color=BLACK)\n        self.add(Text(\"Changing default values is easy!\"))\n\n        # we revert the colour back to the default to prevent a bug in the docs.\n        Text.set_default(color=WHITE) set_x ( x , direction = array([0., 0., 0.]) ) [source]   Set x value of the center of the Mobject ( int or float ) Parameters : x ( float ) direction ( Vector3D ) Return type : Self set_y ( y , direction = array([0., 0., 0.]) ) [source]   Set y value of the center of the Mobject ( int or float ) Parameters : y ( float ) direction ( Vector3D ) Return type : Self set_z ( z , direction = array([0., 0., 0.]) ) [source]   Set z value of the center of the Mobject ( int or float ) Parameters : z ( float ) direction ( Vector3D ) Return type : Self set_z_index ( z_index_value , family = True ) [source]   Sets the Mobject \u2019s z_index to the value specified in z_index_value . Parameters : z_index_value ( float ) \u2013 The new value of z_index set. family ( bool ) \u2013 If True , the z_index value of all submobjects is also set. Returns : The Mobject itself, after z_index is set. For chaining purposes. (Returns self .) Return type : Mobject Examples Example: SetZIndex   from manim import * class SetZIndex ( Scene ): def construct ( self ): text = Text ( 'z_index = 3' , color = PURE_RED ) . shift ( UP ) . set_z_index ( 3 ) square = Square ( 2 , fill_opacity = 1 ) . set_z_index ( 2 ) tex = Tex ( r 'zIndex = 1' , color = PURE_BLUE ) . shift ( DOWN ) . set_z_index ( 1 ) circle = Circle ( radius = 1.7 , color = GREEN , fill_opacity = 1 ) # z_index = 0 # Displaying order is now defined by z_index values self . add ( text ) self . add ( square ) self . add ( tex ) self . add ( circle ) class SetZIndex(Scene):\n    def construct(self):\n        text = Text('z_index = 3', color = PURE_RED).shift(UP).set_z_index(3)\n        square = Square(2, fill_opacity=1).set_z_index(2)\n        tex = Tex(r'zIndex = 1', color = PURE_BLUE).shift(DOWN).set_z_index(1)\n        circle = Circle(radius = 1.7, color = GREEN, fill_opacity = 1) # z_index = 0\n\n        # Displaying order is now defined by z_index values\n        self.add(text)\n        self.add(square)\n        self.add(tex)\n        self.add(circle) set_z_index_by_z_Point3D ( ) [source]   Sets the Mobject \u2019s z Point3D to the value of z_index . Returns : The Mobject itself, after z_index is set. (Returns self .) Return type : Mobject shift ( * vectors ) [source]   Shift by the given vectors. Parameters : vectors ( Vector3D ) \u2013 Vectors to shift by. If multiple vectors are given, they are added\ntogether. Returns : self Return type : Mobject See also move_to() shuffle ( recursive = False ) [source]   Shuffles the list of submobjects . Parameters : recursive ( bool ) Return type : None shuffle_submobjects ( * args , ** kwargs ) [source]   Shuffles the order of submobjects Examples Example: ShuffleSubmobjectsExample   from manim import * class ShuffleSubmobjectsExample ( Scene ): def construct ( self ): s = VGroup ( * [ Dot () . shift ( i * 0.1 * RIGHT ) for i in range ( - 20 , 20 )]) s2 = s . copy () s2 . shuffle_submobjects () s2 . shift ( DOWN ) self . play ( Write ( s ), Write ( s2 )) class ShuffleSubmobjectsExample(Scene):\n    def construct(self):\n        s= VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n        s2= s.copy()\n        s2.shuffle_submobjects()\n        s2.shift(DOWN)\n        self.play(Write(s), Write(s2)) Return type : None sort ( point_to_num_func=<function Mobject.<lambda>> , submob_func=None ) [source]   Sorts the list of submobjects by a function defined by submob_func . Parameters : point_to_num_func ( Callable [ [ Point3DLike ] , float ] ) submob_func ( Callable [ [ Mobject ] , Any ] | None ) Return type : Self sort_submobjects ( * args , ** kwargs ) [source]   Sort the submobjects Return type : Self stretch_to_fit_depth ( depth , ** kwargs ) [source]   Stretches the Mobject to fit a depth, not keeping width/height proportional. Parameters : depth ( float ) Return type : Self stretch_to_fit_height ( height , ** kwargs ) [source]   Stretches the Mobject to fit a height, not keeping width/depth proportional. Returns : self Return type : Mobject Parameters : height ( float ) Examples >>> from manim import * >>> sq = Square () >>> sq . width np.float64(2.0) >>> sq . stretch_to_fit_height ( 5 ) Square >>> sq . height np.float64(5.0) >>> sq . width np.float64(2.0) stretch_to_fit_width ( width , ** kwargs ) [source]   Stretches the Mobject to fit a width, not keeping height/depth proportional. Returns : self Return type : Mobject Parameters : width ( float ) Examples >>> from manim import * >>> sq = Square () >>> sq . height np.float64(2.0) >>> sq . stretch_to_fit_width ( 5 ) Square >>> sq . width np.float64(5.0) >>> sq . height np.float64(2.0) suspend_updating ( recursive = True ) [source]   Disable updating from updaters and animations. Parameters : recursive ( bool ) \u2013 Whether to recursively suspend updating on all submobjects. Returns : self Return type : Mobject See also resume_updating() , add_updater() to_corner ( corner = array([-1., -1., 0.]) , buff = 0.5 ) [source]   Moves this Mobject to the given corner of the screen. Returns : The newly positioned mobject. Return type : Mobject Parameters : corner ( Vector3D ) buff ( float ) Examples Example: ToCornerExample   from manim import * class ToCornerExample ( Scene ): def construct ( self ): c = Circle () c . to_corner ( UR ) t = Tex ( \"To the corner!\" ) t2 = MathTex ( \"x^3\" ) . shift ( DOWN ) self . add ( c , t , t2 ) t . to_corner ( DL , buff = 0 ) t2 . to_corner ( UL , buff = 1.5 ) class ToCornerExample(Scene):\n    def construct(self):\n        c = Circle()\n        c.to_corner(UR)\n        t = Tex(\"To the corner!\")\n        t2 = MathTex(\"x^3\").shift(DOWN)\n        self.add(c,t,t2)\n        t.to_corner(DL, buff=0)\n        t2.to_corner(UL, buff=1.5) to_edge ( edge = array([-1., 0., 0.]) , buff = 0.5 ) [source]   Moves this Mobject to the given edge of the screen,\nwithout affecting its position in the other dimension. Returns : The newly positioned mobject. Return type : Mobject Parameters : edge ( Vector3D ) buff ( float ) Examples Example: ToEdgeExample   from manim import * class ToEdgeExample ( Scene ): def construct ( self ): tex_top = Tex ( \"I am at the top!\" ) tex_top . to_edge ( UP ) tex_side = Tex ( \"I am moving to the side!\" ) c = Circle () . shift ( 2 * DOWN ) self . add ( tex_top , tex_side , c ) tex_side . to_edge ( LEFT ) c . to_edge ( RIGHT , buff = 0 ) class ToEdgeExample(Scene):\n    def construct(self):\n        tex_top = Tex(\"I am at the top!\")\n        tex_top.to_edge(UP)\n        tex_side = Tex(\"I am moving to the side!\")\n        c = Circle().shift(2*DOWN)\n        self.add(tex_top, tex_side, c)\n        tex_side.to_edge(LEFT)\n        c.to_edge(RIGHT, buff=0) update ( dt = 0 , recursive = True ) [source]   Apply all updaters. Does nothing if updating is suspended. Parameters : dt ( float ) \u2013 The parameter dt to pass to the update functions. Usually this is the\ntime in seconds since the last call of update . recursive ( bool ) \u2013 Whether to recursively update all submobjects. Returns : self Return type : Mobject See also add_updater() , get_updaters() property width : float   The width of the mobject. Return type : float Examples Example: WidthExample   from manim import * class WidthExample ( Scene ): def construct ( self ): decimal = DecimalNumber () . to_edge ( UP ) rect = Rectangle ( color = BLUE ) rect_copy = rect . copy () . set_stroke ( GRAY , opacity = 0.5 ) decimal . add_updater ( lambda d : d . set_value ( rect . width )) self . add ( rect_copy , rect , decimal ) self . play ( rect . animate . set ( width = 7 )) self . wait () class WidthExample(Scene):\n    def construct(self):\n        decimal = DecimalNumber().to_edge(UP)\n        rect = Rectangle(color=BLUE)\n        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)\n\n        decimal.add_updater(lambda d: d.set_value(rect.width))\n\n        self.add(rect_copy, rect, decimal)\n        self.play(rect.animate.set(width=7))\n        self.wait() See also length_over_dim()", "original_prompt": "class Mobject(color=ManimColor('#FFFFFF'), name=None, dim=3, target=None, z_index=0)"}
{"prompt": "\"Fade in a parametric spiral growing in size as it rotates around the origin with increasing speed.\"", "response": "Callable [[ 'Mobject' , float ], object ]", "original_prompt": "class TimeBasedUpdater"}
{"prompt": "\"Show the equation y = x^2, with parabola opening upwards, smoothly intersecting a red horizontal line.\"", "response": "Callable [[ 'Mobject' ], object ]", "original_prompt": "class NonTimeBasedUpdater"}
{"prompt": "\"Show a non-time-based animation updating over time with smooth transition.\"", "response": "NonTimeBasedUpdater` | TimeBasedUpdater`", "original_prompt": "class Updater"}
{"prompt": "\"Display a circle with content animation, where the content disappears smoothly.\"", "response": "Decorator for overriding method animations. This allows to specify a method (returning an Animation )\nwhich is called when the decorated method is used with the .animate syntax\nfor animating the application of a method. See also Mobject.animate Note Overridden methods cannot be combined with normal or other overridden\nmethods using method chaining with the .animate syntax. Examples Example: AnimationOverrideExample   from manim import * class CircleWithContent ( VGroup ): def __init__ ( self , content ): super () . __init__ () self . circle = Circle () self . content = content self . add ( self . circle , content ) content . move_to ( self . circle . get_center ()) def clear_content ( self ): self . remove ( self . content ) self . content = None @override_animate ( clear_content ) def _clear_content_animation ( self , anim_args = None ): if anim_args is None : anim_args = {} anim = Uncreate ( self . content , ** anim_args ) self . clear_content () return anim class AnimationOverrideExample ( Scene ): def construct ( self ): t = Text ( \"hello!\" ) my_mobject = CircleWithContent ( t ) self . play ( Create ( my_mobject )) self . play ( my_mobject . animate . clear_content ()) self . wait () class CircleWithContent(VGroup):\n    def __init__(self, content):\n        super().__init__()\n        self.circle = Circle()\n        self.content = content\n        self.add(self.circle, content)\n        content.move_to(self.circle.get_center())\n\n    def clear_content(self):\n        self.remove(self.content)\n        self.content = None\n\n    @override_animate(clear_content)\n    def _clear_content_animation(self, anim_args=None):\n        if anim_args is None:\n            anim_args = {}\n        anim = Uncreate(self.content, **anim_args)\n        self.clear_content()\n        return anim\n\nclass AnimationOverrideExample(Scene):\n    def construct(self):\n        t = Text(\"hello!\")\n        my_mobject = CircleWithContent(t)\n        self.play(Create(my_mobject))\n        self.play(my_mobject.animate.clear_content())\n        self.wait() Return type : LambdaType", "original_prompt": "override_animate(method)"}
{"prompt": "Animate a specialized Table displaying decimal entries with rounded values on an exponential curve.", "response": "Bases: Table A specialized Table mobject for use with DecimalNumber to display decimal entries. Examples Example: DecimalTableExample   from manim import * class DecimalTableExample ( Scene ): def construct ( self ): x_vals = [ - 2 , - 1 , 0 , 1 , 2 ] y_vals = np . exp ( x_vals ) t0 = DecimalTable ( [ x_vals , y_vals ], row_labels = [ MathTex ( \"x\" ), MathTex ( \"f(x)=e^ {x} \" )], h_buff = 1 , element_to_mobject_config = { \"num_decimal_places\" : 2 }) self . add ( t0 ) class DecimalTableExample(Scene):\n    def construct(self):\n        x_vals = [-2,-1,0,1,2]\n        y_vals = np.exp(x_vals)\n        t0 = DecimalTable(\n            [x_vals, y_vals],\n            row_labels=[MathTex(\"x\"), MathTex(\"f(x)=e^{x}\")],\n            h_buff=1,\n            element_to_mobject_config={\"num_decimal_places\": 2})\n        self.add(t0) Special case of Table with element_to_mobject set to DecimalNumber .\nBy default, num_decimal_places is set to 1.\nWill round/truncate the decimal places based on the provided element_to_mobject_config . Parameters : table ( Iterable [ Iterable [ float | str ] ] ) \u2013 A 2D array, or a list of lists. Content of the table must be valid input\nfor DecimalNumber . element_to_mobject ( Callable [ [ float | str ] , VMobject ] ) \u2013 The Mobject class applied to the table entries. Set as DecimalNumber . element_to_mobject_config ( dict ) \u2013 Element to mobject config, here set as {\u201cnum_decimal_places\u201d: 1}. kwargs \u2013 Additional arguments to be passed to Table . Methods Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( table , element_to_mobject=<class 'manim.mobject.text.numbers.DecimalNumber'> , element_to_mobject_config={'num_decimal_places': 1} , **kwargs )   Special case of Table with element_to_mobject set to DecimalNumber .\nBy default, num_decimal_places is set to 1.\nWill round/truncate the decimal places based on the provided element_to_mobject_config . Parameters : table ( Iterable [ Iterable [ float | str ] ] ) \u2013 A 2D array, or a list of lists. Content of the table must be valid input\nfor DecimalNumber . element_to_mobject ( Callable [ [ float | str ] , VMobject ] ) \u2013 The Mobject class applied to the table entries. Set as DecimalNumber . element_to_mobject_config ( dict ) \u2013 Element to mobject config, here set as {\u201cnum_decimal_places\u201d: 1}. kwargs \u2013 Additional arguments to be passed to Table .", "original_prompt": "class DecimalTable(table, element_to_mobject=<class 'manim.mobject.text.numbers.DecimalNumber'>, element_to_mobject_config={'num_decimal_places': 1}, **kwargs)"}
{"prompt": "\"Animate a rotating, filled integer table with trigonometric labels and rounded values.\"", "response": "Bases: Table A specialized Table mobject for use with Integer . Examples Example: IntegerTableExample   from manim import * class IntegerTableExample ( Scene ): def construct ( self ): t0 = IntegerTable ( [[ 0 , 30 , 45 , 60 , 90 ], [ 90 , 60 , 45 , 30 , 0 ]], col_labels = [ MathTex ( r \"\\frac{\\sqrt {0} } {2} \" ), MathTex ( r \"\\frac{\\sqrt {1} } {2} \" ), MathTex ( r \"\\frac{\\sqrt {2} } {2} \" ), MathTex ( r \"\\frac{\\sqrt {3} } {2} \" ), MathTex ( r \"\\frac{\\sqrt {4} } {2} \" )], row_labels = [ MathTex ( r \"\\sin\" ), MathTex ( r \"\\cos\" )], h_buff = 1 , element_to_mobject_config = { \"unit\" : r \"^{\\circ}\" }) self . add ( t0 ) class IntegerTableExample(Scene):\n    def construct(self):\n        t0 = IntegerTable(\n            [[0,30,45,60,90],\n            [90,60,45,30,0]],\n            col_labels=[\n                MathTex(r\"\\frac{\\sqrt{0}}{2}\"),\n                MathTex(r\"\\frac{\\sqrt{1}}{2}\"),\n                MathTex(r\"\\frac{\\sqrt{2}}{2}\"),\n                MathTex(r\"\\frac{\\sqrt{3}}{2}\"),\n                MathTex(r\"\\frac{\\sqrt{4}}{2}\")],\n            row_labels=[MathTex(r\"\\sin\"), MathTex(r\"\\cos\")],\n            h_buff=1,\n            element_to_mobject_config={\"unit\": r\"^{\\circ}\"})\n        self.add(t0) Special case of Table with element_to_mobject set to Integer .\nWill round if there are decimal entries in the table. Parameters : table ( Iterable [ Iterable [ float | str ] ] ) \u2013 A 2d array or list of lists. Content of the table has to be valid input\nfor Integer . element_to_mobject ( Callable [ [ float | str ] , VMobject ] ) \u2013 The Mobject class applied to the table entries. Set as Integer . kwargs \u2013 Additional arguments to be passed to Table . Methods Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( table , element_to_mobject=<class 'manim.mobject.text.numbers.Integer'> , **kwargs )   Special case of Table with element_to_mobject set to Integer .\nWill round if there are decimal entries in the table. Parameters : table ( Iterable [ Iterable [ float | str ] ] ) \u2013 A 2d array or list of lists. Content of the table has to be valid input\nfor Integer . element_to_mobject ( Callable [ [ float | str ] , VMobject ] ) \u2013 The Mobject class applied to the table entries. Set as Integer . kwargs \u2013 Additional arguments to be passed to Table .", "original_prompt": "class IntegerTable(table, element_to_mobject=<class 'manim.mobject.text.numbers.Integer'>, **kwargs)"}
{"prompt": "\"Animate a math table with values aligned in LaTeX environments, shifting rows down.\"\n\n(This prompt is under 20 words and avoids technical terms like 'class' or 'self'. It identifies key visual elements (math table), recognizes transformations (shifting rows down), and mentions no mathematical concepts.)", "response": "Bases: Table A specialized Table mobject for use with LaTeX. Examples Example: MathTableExample   from manim import * class MathTableExample ( Scene ): def construct ( self ): t0 = MathTable ( [[ \"+\" , 0 , 5 , 10 ], [ 0 , 0 , 5 , 10 ], [ 2 , 2 , 7 , 12 ], [ 4 , 4 , 9 , 14 ]], include_outer_lines = True ) self . add ( t0 ) class MathTableExample(Scene):\n    def construct(self):\n        t0 = MathTable(\n            [[\"+\", 0, 5, 10],\n            [0, 0, 5, 10],\n            [2, 2, 7, 12],\n            [4, 4, 9, 14]],\n            include_outer_lines=True)\n        self.add(t0) Special case of Table with element_to_mobject set to MathTex .\nEvery entry in table is set in a Latex align environment. Parameters : table ( Iterable [ Iterable [ float | str ] ] ) \u2013 A 2d array or list of lists. Content of the table have to be valid input\nfor MathTex . element_to_mobject ( Callable [ [ float | str ] , VMobject ] ) \u2013 The Mobject class applied to the table entries. Set as MathTex . kwargs \u2013 Additional arguments to be passed to Table . Methods Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( table , element_to_mobject=<class 'manim.mobject.text.tex_mobject.MathTex'> , **kwargs )   Special case of Table with element_to_mobject set to MathTex .\nEvery entry in table is set in a Latex align environment. Parameters : table ( Iterable [ Iterable [ float | str ] ] ) \u2013 A 2d array or list of lists. Content of the table have to be valid input\nfor MathTex . element_to_mobject ( Callable [ [ float | str ] , VMobject ] ) \u2013 The Mobject class applied to the table entries. Set as MathTex . kwargs \u2013 Additional arguments to be passed to Table .", "original_prompt": "class MathTable(table, element_to_mobject=<class 'manim.mobject.text.tex_mobject.MathTex'>, **kwargs)"}
{"prompt": "\"Animate a rotating 3D table with colored squares and lines, transforming smoothly into place.\"", "response": "Bases: Table A specialized Table mobject for use with Mobject . Examples Example: MobjectTableExample   from manim import * class MobjectTableExample ( Scene ): def construct ( self ): cross = VGroup ( Line ( UP + LEFT , DOWN + RIGHT ), Line ( UP + RIGHT , DOWN + LEFT ), ) a = Circle () . set_color ( RED ) . scale ( 0.5 ) b = cross . set_color ( BLUE ) . scale ( 0.5 ) t0 = MobjectTable ( [[ a . copy (), b . copy (), a . copy ()], [ b . copy (), a . copy (), a . copy ()], [ a . copy (), b . copy (), b . copy ()]] ) line = Line ( t0 . get_corner ( DL ), t0 . get_corner ( UR ) ) . set_color ( RED ) self . add ( t0 , line ) class MobjectTableExample(Scene):\n    def construct(self):\n        cross = VGroup(\n            Line(UP + LEFT, DOWN + RIGHT),\n            Line(UP + RIGHT, DOWN + LEFT),\n        )\n        a = Circle().set_color(RED).scale(0.5)\n        b = cross.set_color(BLUE).scale(0.5)\n        t0 = MobjectTable(\n            [[a.copy(),b.copy(),a.copy()],\n            [b.copy(),a.copy(),a.copy()],\n            [a.copy(),b.copy(),b.copy()]]\n        )\n        line = Line(\n            t0.get_corner(DL), t0.get_corner(UR)\n        ).set_color(RED)\n        self.add(t0, line) Special case of Table with element_to_mobject set to an identity function.\nHere, every item in table must already be of type Mobject . Parameters : table ( Iterable [ Iterable [ VMobject ] ] ) \u2013 A 2D array or list of lists. Content of the table must be of type Mobject . element_to_mobject ( Callable [ [ VMobject ] , VMobject ] ) \u2013 The Mobject class applied to the table entries. Set as lambda m : m to return itself. kwargs \u2013 Additional arguments to be passed to Table . Methods Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( table , element_to_mobject=<function MobjectTable.<lambda>> , **kwargs )   Special case of Table with element_to_mobject set to an identity function.\nHere, every item in table must already be of type Mobject . Parameters : table ( Iterable [ Iterable [ VMobject ] ] ) \u2013 A 2D array or list of lists. Content of the table must be of type Mobject . element_to_mobject ( Callable [ [ VMobject ] , VMobject ] ) \u2013 The Mobject class applied to the table entries. Set as lambda m : m to return itself. kwargs \u2013 Additional arguments to be passed to Table .", "original_prompt": "class MobjectTable(table, element_to_mobject=<function MobjectTable.<lambda>>, **kwargs)"}
{"prompt": "It seems like you're asking for an example of how to use the `scale()` function in Manim. \n\nHere's a simple example:\n\n```python\nfrom manim import *\n\nclass MobjectScaleExample(Scene):\n    def construct(self):\n        c1 = Circle(1, RED).set_x(-1)\n        c2 = Circle(1, GREEN).set_x(1)\n\n        vg = VGroup(c1, c2)\n        vg.set_stroke(width=50)\n\n        self.add(vg)\n\n        # Scale the group by a factor of 0.25\n        self.play(\n            vg.animate.scale(.25),\n            run_time=3,\n        )\n```\n\nThis example creates two circles, each with different colors and positions on the screen. It then adds these circles to a VGroup (a collection of objects). After that, it uses the `animate` function to scale this group by a factor of 0.25 over a period of three seconds.\n\nNote: The `run_time` parameter is used to specify how long the animation should last in seconds.", "response": "Bases: VGroup A mobject that displays a table on the screen. Parameters : table ( Iterable [ Iterable [ float | str | VMobject ] ] ) \u2013 A 2D array or list of lists. Content of the table has to be a valid input\nfor the callable set in element_to_mobject . row_labels ( Iterable [ VMobject ] | None ) \u2013 List of VMobject representing the labels of each row. col_labels ( Iterable [ VMobject ] | None ) \u2013 List of VMobject representing the labels of each column. top_left_entry ( VMobject | None ) \u2013 The top-left entry of the table, can only be specified if row and\ncolumn labels are given. v_buff ( float ) \u2013 Vertical buffer passed to arrange_in_grid() , by default 0.8. h_buff ( float ) \u2013 Horizontal buffer passed to arrange_in_grid() , by default 1.3. include_outer_lines ( bool ) \u2013 True if the table should include outer lines, by default False. add_background_rectangles_to_entries ( bool ) \u2013 True if background rectangles should be added to entries, by default False . entries_background_color ( ParsableManimColor ) \u2013 Background color of entries if add_background_rectangles_to_entries is True . include_background_rectangle ( bool ) \u2013 True if the table should have a background rectangle, by default False . background_rectangle_color ( ParsableManimColor ) \u2013 Background color of table if include_background_rectangle is True . element_to_mobject ( Callable [ [ float | str | VMobject ] , VMobject ] ) \u2013 The Mobject class applied to the table entries. by default Paragraph . For common choices, see text_mobject / tex_mobject . element_to_mobject_config ( dict ) \u2013 Custom configuration passed to element_to_mobject , by default {}. arrange_in_grid_config ( dict ) \u2013 Dict passed to arrange_in_grid() , customizes the arrangement of the table. line_config ( dict ) \u2013 Dict passed to Line , customizes the lines of the table. kwargs \u2013 Additional arguments to be passed to VGroup . Examples Example: TableExamples   from manim import * class TableExamples ( Scene ): def construct ( self ): t0 = Table ( [[ \"This\" , \"is a\" ], [ \"simple\" , \"Table in \\\\ n Manim.\" ]]) t1 = Table ( [[ \"This\" , \"is a\" ], [ \"simple\" , \"Table.\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) t1 . add_highlighted_cell (( 2 , 2 ), color = YELLOW ) t2 = Table ( [[ \"This\" , \"is a\" ], [ \"simple\" , \"Table.\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )], top_left_entry = Star () . scale ( 0.3 ), include_outer_lines = True , arrange_in_grid_config = { \"cell_alignment\" : RIGHT }) t2 . add ( t2 . get_cell (( 2 , 2 ), color = RED )) t3 = Table ( [[ \"This\" , \"is a\" ], [ \"simple\" , \"Table.\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )], top_left_entry = Star () . scale ( 0.3 ), include_outer_lines = True , line_config = { \"stroke_width\" : 1 , \"color\" : YELLOW }) t3 . remove ( * t3 . get_vertical_lines ()) g = Group ( t0 , t1 , t2 , t3 ) . scale ( 0.7 ) . arrange_in_grid ( buff = 1 ) self . add ( g ) class TableExamples(Scene):\n    def construct(self):\n        t0 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table in \\\\n Manim.\"]])\n        t1 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        t1.add_highlighted_cell((2,2), color=YELLOW)\n        t2 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")],\n            top_left_entry=Star().scale(0.3),\n            include_outer_lines=True,\n            arrange_in_grid_config={\"cell_alignment\": RIGHT})\n        t2.add(t2.get_cell((2,2), color=RED))\n        t3 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")],\n            top_left_entry=Star().scale(0.3),\n            include_outer_lines=True,\n            line_config={\"stroke_width\": 1, \"color\": YELLOW})\n        t3.remove(*t3.get_vertical_lines())\n        g = Group(\n            t0,t1,t2,t3\n        ).scale(0.7).arrange_in_grid(buff=1)\n        self.add(g) Example: BackgroundRectanglesExample   from manim import * class BackgroundRectanglesExample ( Scene ): def construct ( self ): background = Rectangle ( height = 6.5 , width = 13 ) background . set_fill ( opacity = .5 ) background . set_color ([ TEAL , RED , YELLOW ]) self . add ( background ) t0 = Table ( [[ \"This\" , \"is a\" ], [ \"simple\" , \"Table.\" ]], add_background_rectangles_to_entries = True ) t1 = Table ( [[ \"This\" , \"is a\" ], [ \"simple\" , \"Table.\" ]], include_background_rectangle = True ) g = Group ( t0 , t1 ) . scale ( 0.7 ) . arrange ( buff = 0.5 ) self . add ( g ) class BackgroundRectanglesExample(Scene):\n    def construct(self):\n        background = Rectangle(height=6.5, width=13)\n        background.set_fill(opacity=.5)\n        background.set_color([TEAL, RED, YELLOW])\n        self.add(background)\n        t0 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            add_background_rectangles_to_entries=True)\n        t1 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            include_background_rectangle=True)\n        g = Group(t0, t1).scale(0.7).arrange(buff=0.5)\n        self.add(g) Methods add_background_to_entries Adds a black BackgroundRectangle to each entry of the table. add_highlighted_cell Highlights one cell at a specific position on the table by adding a BackgroundRectangle . create Customized create-type function for tables. get_cell Returns one specific cell as a rectangular Polygon without the entry. get_col_labels Return the column labels of the table. get_columns Return columns of the table as a VGroup of VGroup . get_entries Return the individual entries of the table (including labels) or one specific entry if the parameter, pos ,  is set. get_entries_without_labels Return the individual entries of the table (without labels) or one specific entry if the parameter, pos , is set. get_highlighted_cell Returns a BackgroundRectangle of the cell at the given position. get_horizontal_lines Return the horizontal lines of the table. get_labels Returns the labels of the table. get_row_labels Return the row labels of the table. get_rows Return the rows of the table as a VGroup of VGroup . get_vertical_lines Return the vertical lines of the table. scale Scale the size by a factor. set_column_colors Set individual colors for each column of the table. set_row_colors Set individual colors for each row of the table. Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _add_horizontal_lines ( ) [source]   Adds the horizontal lines to the table. Return type : Table _add_labels ( mob_table ) [source]   Adds labels to an in a grid arranged VGroup . Parameters : mob_table ( VGroup ) \u2013 An in a grid organized class: ~.VGroup . Returns : Returns the mob_table with added labels. Return type : VGroup _add_vertical_lines ( ) [source]   Adds the vertical lines to the table Return type : Table _organize_mob_table ( table ) [source]   Arranges the VMobject of table in a grid. Parameters : table ( Iterable [ Iterable [ VMobject ] ] ) \u2013 A 2D iterable object with VMobject entries. Returns : The VMobject of the table in a VGroup already\narranged in a table-like grid. Return type : VGroup _original__init__ ( table , row_labels=None , col_labels=None , top_left_entry=None , v_buff=0.8 , h_buff=1.3 , include_outer_lines=False , add_background_rectangles_to_entries=False , entries_background_color=ManimColor('#000000') , include_background_rectangle=False , background_rectangle_color=ManimColor('#000000') , element_to_mobject=<class 'manim.mobject.text.text_mobject.Paragraph'> , element_to_mobject_config={} , arrange_in_grid_config={} , line_config={} , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : table ( Iterable [ Iterable [ float | str | VMobject ] ] ) row_labels ( Iterable [ VMobject ] | None ) col_labels ( Iterable [ VMobject ] | None ) top_left_entry ( VMobject | None ) v_buff ( float ) h_buff ( float ) include_outer_lines ( bool ) add_background_rectangles_to_entries ( bool ) entries_background_color ( ParsableManimColor ) include_background_rectangle ( bool ) background_rectangle_color ( ParsableManimColor ) element_to_mobject ( Callable [ [ float | str | VMobject ] , VMobject ] ) element_to_mobject_config ( dict ) arrange_in_grid_config ( dict ) line_config ( dict ) _table_to_mob_table ( table ) [source]   Initilaizes the entries of table as VMobject . Parameters : table ( Iterable [ Iterable [ float | str | VMobject ] ] ) \u2013 A 2D array or list of lists. Content of the table has to be a valid input\nfor the callable set in element_to_mobject . Returns : List of VMobject from the entries of table . Return type : List add_background_to_entries ( color = ManimColor('#000000') ) [source]   Adds a black BackgroundRectangle to each entry of the table. Parameters : color ( ParsableManimColor ) Return type : Table add_highlighted_cell ( pos = (1, 1) , color = ManimColor('#FFFF00') , ** kwargs ) [source]   Highlights one cell at a specific position on the table by adding a BackgroundRectangle . Parameters : pos ( Sequence [ int ] ) \u2013 The position of a specific entry on the table. (1,1) being the top left entry\nof the table. color ( ParsableManimColor ) \u2013 The color used to highlight the cell. kwargs \u2013 Additional arguments to be passed to BackgroundRectangle . Return type : Table Examples Example: AddHighlightedCellExample   from manim import * class AddHighlightedCellExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) table . add_highlighted_cell (( 2 , 2 ), color = GREEN ) self . add ( table ) class AddHighlightedCellExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.add_highlighted_cell((2,2), color=GREEN)\n        self.add(table) create ( lag_ratio=1 , line_animation=<class 'manim.animation.creation.Create'> , label_animation=<class 'manim.animation.creation.Write'> , element_animation=<class 'manim.animation.creation.Create'> , entry_animation=<class 'manim.animation.fading.FadeIn'> , **kwargs ) [source]   Customized create-type function for tables. Parameters : lag_ratio ( float ) \u2013 The lag ratio of the animation. line_animation ( Callable [ [ VMobject | VGroup ] , Animation ] ) \u2013 The animation style of the table lines, see creation for examples. label_animation ( Callable [ [ VMobject | VGroup ] , Animation ] ) \u2013 The animation style of the table labels, see creation for examples. element_animation ( Callable [ [ VMobject | VGroup ] , Animation ] ) \u2013 The animation style of the table elements, see creation for examples. entry_animation ( Callable [ [ VMobject | VGroup ] , Animation ] ) \u2013 The entry animation of the table background, see creation for examples. kwargs \u2013 Further arguments passed to the creation animations. Returns : AnimationGroup containing creation of the lines and of the elements. Return type : AnimationGroup Examples Example: CreateTableExample   from manim import * class CreateTableExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )], include_outer_lines = True ) self . play ( table . create ()) self . wait () class CreateTableExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")],\n            include_outer_lines=True)\n        self.play(table.create())\n        self.wait() get_cell ( pos = (1, 1) , ** kwargs ) [source]   Returns one specific cell as a rectangular Polygon without the entry. Parameters : pos ( Sequence [ int ] ) \u2013 The position of a specific entry on the table. (1,1) being the top left entry\nof the table. kwargs \u2013 Additional arguments to be passed to Polygon . Returns : Polygon mimicking one specific cell of the Table. Return type : Polygon Examples Example: GetCellExample   from manim import * class GetCellExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) cell = table . get_cell (( 2 , 2 ), color = RED ) self . add ( table , cell ) class GetCellExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        cell = table.get_cell((2,2), color=RED)\n        self.add(table, cell) get_col_labels ( ) [source]   Return the column labels of the table. Returns : VGroup containing the column labels of the table. Return type : VGroup Examples Example: GetColLabelsExample   from manim import * class GetColLabelsExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) lab = table . get_col_labels () for item in lab : item . set_color ( random_bright_color ()) self . add ( table ) class GetColLabelsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        lab = table.get_col_labels()\n        for item in lab:\n            item.set_color(random_bright_color())\n        self.add(table) get_columns ( ) [source]   Return columns of the table as a VGroup of VGroup . Returns : VGroup containing each column in a VGroup . Return type : VGroup Examples Example: GetColumnsExample   from manim import * class GetColumnsExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) table . add ( SurroundingRectangle ( table . get_columns ()[ 1 ])) self . add ( table ) class GetColumnsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.add(SurroundingRectangle(table.get_columns()[1]))\n        self.add(table) get_entries ( pos = None ) [source]   Return the individual entries of the table (including labels) or one specific entry\nif the parameter, pos ,  is set. Parameters : pos ( Sequence [ int ] | None ) \u2013 The position of a specific entry on the table. (1,1) being the top left entry\nof the table. Returns : VGroup containing all entries of the table (including labels)\nor the VMobject at the given position if pos is set. Return type : Union[ VMobject , VGroup ] Examples Example: GetEntriesExample   from manim import * class GetEntriesExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) ent = table . get_entries () for item in ent : item . set_color ( random_bright_color ()) table . get_entries (( 2 , 2 )) . rotate ( PI ) self . add ( table ) class GetEntriesExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        ent = table.get_entries()\n        for item in ent:\n            item.set_color(random_bright_color())\n        table.get_entries((2,2)).rotate(PI)\n        self.add(table) get_entries_without_labels ( pos = None ) [source]   Return the individual entries of the table (without labels) or one specific entry\nif the parameter, pos , is set. Parameters : pos ( Sequence [ int ] | None ) \u2013 The position of a specific entry on the table. (1,1) being the top left entry\nof the table (without labels). Returns : VGroup containing all entries of the table (without labels)\nor the VMobject at the given position if pos is set. Return type : Union[ VMobject , VGroup ] Examples Example: GetEntriesWithoutLabelsExample   from manim import * class GetEntriesWithoutLabelsExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) ent = table . get_entries_without_labels () colors = [ BLUE , GREEN , YELLOW , RED ] for k in range ( len ( colors )): ent [ k ] . set_color ( colors [ k ]) table . get_entries_without_labels (( 2 , 2 )) . rotate ( PI ) self . add ( table ) class GetEntriesWithoutLabelsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        ent = table.get_entries_without_labels()\n        colors = [BLUE, GREEN, YELLOW, RED]\n        for k in range(len(colors)):\n            ent[k].set_color(colors[k])\n        table.get_entries_without_labels((2,2)).rotate(PI)\n        self.add(table) get_highlighted_cell ( pos = (1, 1) , color = ManimColor('#FFFF00') , ** kwargs ) [source]   Returns a BackgroundRectangle of the cell at the given position. Parameters : pos ( Sequence [ int ] ) \u2013 The position of a specific entry on the table. (1,1) being the top left entry\nof the table. color ( ParsableManimColor ) \u2013 The color used to highlight the cell. kwargs \u2013 Additional arguments to be passed to BackgroundRectangle . Return type : BackgroundRectangle Examples Example: GetHighlightedCellExample   from manim import * class GetHighlightedCellExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) highlight = table . get_highlighted_cell (( 2 , 2 ), color = GREEN ) table . add_to_back ( highlight ) self . add ( table ) class GetHighlightedCellExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        highlight = table.get_highlighted_cell((2,2), color=GREEN)\n        table.add_to_back(highlight)\n        self.add(table) get_horizontal_lines ( ) [source]   Return the horizontal lines of the table. Returns : VGroup containing all the horizontal lines of the table. Return type : VGroup Examples Example: GetHorizontalLinesExample   from manim import * class GetHorizontalLinesExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) table . get_horizontal_lines () . set_color ( RED ) self . add ( table ) class GetHorizontalLinesExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.get_horizontal_lines().set_color(RED)\n        self.add(table) get_labels ( ) [source]   Returns the labels of the table. Returns : VGroup containing all the labels of the table. Return type : VGroup Examples Example: GetLabelsExample   from manim import * class GetLabelsExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) lab = table . get_labels () colors = [ BLUE , GREEN , YELLOW , RED ] for k in range ( len ( colors )): lab [ k ] . set_color ( colors [ k ]) self . add ( table ) class GetLabelsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        lab = table.get_labels()\n        colors = [BLUE, GREEN, YELLOW, RED]\n        for k in range(len(colors)):\n            lab[k].set_color(colors[k])\n        self.add(table) get_row_labels ( ) [source]   Return the row labels of the table. Returns : VGroup containing the row labels of the table. Return type : VGroup Examples Example: GetRowLabelsExample   from manim import * class GetRowLabelsExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) lab = table . get_row_labels () for item in lab : item . set_color ( random_bright_color ()) self . add ( table ) class GetRowLabelsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        lab = table.get_row_labels()\n        for item in lab:\n            item.set_color(random_bright_color())\n        self.add(table) get_rows ( ) [source]   Return the rows of the table as a VGroup of VGroup . Returns : VGroup containing each row in a VGroup . Return type : VGroup Examples Example: GetRowsExample   from manim import * class GetRowsExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) table . add ( SurroundingRectangle ( table . get_rows ()[ 1 ])) self . add ( table ) class GetRowsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.add(SurroundingRectangle(table.get_rows()[1]))\n        self.add(table) get_vertical_lines ( ) [source]   Return the vertical lines of the table. Returns : VGroup containing all the vertical lines of the table. Return type : VGroup Examples Example: GetVerticalLinesExample   from manim import * class GetVerticalLinesExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) table . get_vertical_lines ()[ 0 ] . set_color ( RED ) self . add ( table ) class GetVerticalLinesExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.get_vertical_lines()[0].set_color(RED)\n        self.add(table) scale ( scale_factor , ** kwargs ) [source]   Scale the size by a factor. Default behavior is to scale about the center of the vmobject. Parameters : scale_factor ( float ) \u2013 The scaling factor \\(\\alpha\\) . If \\(0 < |\\alpha|\u00a0< 1\\) , the mobject\nwill shrink, and for \\(|\\alpha| > 1\\) it will grow. Furthermore,\nif \\(\\alpha < 0\\) , the mobject is also flipped. scale_stroke \u2013 Boolean determining if the object\u2019s outline is scaled when the object is scaled.\nIf enabled, and object with 2px outline is scaled by a factor of .5, it will have an outline of 1px. kwargs \u2013 Additional keyword arguments passed to scale() . Returns : self Return type : VMobject Examples Example: MobjectScaleExample   from manim import * class MobjectScaleExample ( Scene ): def construct ( self ): c1 = Circle ( 1 , RED ) . set_x ( - 1 ) c2 = Circle ( 1 , GREEN ) . set_x ( 1 ) vg = VGroup ( c1 , c2 ) vg . set_stroke ( width = 50 ) self . add ( vg ) self . play ( c1 . animate . scale ( .25 ), c2 . animate . scale ( .25 , scale_stroke = True ) ) class MobjectScaleExample(Scene):\n    def construct(self):\n        c1 = Circle(1, RED).set_x(-1)\n        c2 = Circle(1, GREEN).set_x(1)\n\n        vg = VGroup(c1, c2)\n        vg.set_stroke(width=50)\n        self.add(vg)\n\n        self.play(\n            c1.animate.scale(.25),\n            c2.animate.scale(.25,\n                scale_stroke=True)\n        ) See also move_to() set_column_colors ( * colors ) [source]   Set individual colors for each column of the table. Parameters : colors ( Iterable [ ParsableManimColor ] ) \u2013 An iterable of colors; each color corresponds to a column. Return type : Table Examples Example: SetColumnColorsExample   from manim import * class SetColumnColorsExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )] ) . set_column_colors ([ RED , BLUE ], GREEN ) self . add ( table ) class SetColumnColorsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")]\n        ).set_column_colors([RED,BLUE], GREEN)\n        self.add(table) set_row_colors ( * colors ) [source]   Set individual colors for each row of the table. Parameters : colors ( Iterable [ ParsableManimColor ] ) \u2013 An iterable of colors; each color corresponds to a row. Return type : Table Examples Example: SetRowColorsExample   from manim import * class SetRowColorsExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )] ) . set_row_colors ([ RED , BLUE ], GREEN ) self . add ( table ) class SetRowColorsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")]\n        ).set_row_colors([RED,BLUE], GREEN)\n        self.add(table)", "original_prompt": "class Table(table, row_labels=None, col_labels=None, top_left_entry=None, v_buff=0.8, h_buff=1.3, include_outer_lines=False, add_background_rectangles_to_entries=False, entries_background_color=ManimColor('#000000'), include_background_rectangle=False, background_rectangle_color=ManimColor('#000000'), element_to_mobject=<class 'manim.mobject.text.text_mobject.Paragraph'>, element_to_mobject_config={}, arrange_in_grid_config={}, line_config={}, **kwargs)"}
{"prompt": "\"Render a 3D object using OpenGL and show its base Mobject class when switching renderers.\"", "response": "Gets the base mobject class, depending on the currently active renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_mobject_class >>> get_mobject_class () . __name__ in [ 'Mobject' , 'OpenGLMobject' ] True Return type : type", "original_prompt": "get_mobject_class()"}
{"prompt": "Animate a rotating point cloud to demonstrate rendering variations on different renderers.", "response": "Gets the point cloud mobject class, depending on the currently\nactive renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_point_mobject_class >>> get_point_mobject_class () . __name__ in [ 'PMobject' , 'OpenGLPMobject' ] True Return type : type", "original_prompt": "get_point_mobject_class()"}
{"prompt": "\"Animate a vectorized shape's transformation into view with changing renderer.\"", "response": "Gets the vectorized mobject class, depending on the currently\nactive renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_vectorized_mobject_class >>> get_vectorized_mobject_class () . __name__ in [ 'VMobject' , 'OpenGLVMobject' ] True Return type : type", "original_prompt": "get_vectorized_mobject_class()"}
{"prompt": "Animate a rendering engine switching between Mobject and OpenGLMobject with a fade effect.", "response": "Gets the base mobject class, depending on the currently active renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_mobject_class >>> get_mobject_class () . __name__ in [ 'Mobject' , 'OpenGLMobject' ] True Return type : type", "original_prompt": "get_mobject_class()"}
{"prompt": "Animate a point cloud object transforming into different 3D shapes based on the active renderer.", "response": "Gets the point cloud mobject class, depending on the currently\nactive renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_point_mobject_class >>> get_point_mobject_class () . __name__ in [ 'PMobject' , 'OpenGLPMobject' ] True Return type : type", "original_prompt": "get_point_mobject_class()"}
{"prompt": "Animate a vectorized mobject that transforms into an active renderer's version with mathematical precision.", "response": "Gets the vectorized mobject class, depending on the currently\nactive renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_vectorized_mobject_class >>> get_vectorized_mobject_class () . __name__ in [ 'VMobject' , 'OpenGLVMobject' ] True Return type : type", "original_prompt": "get_vectorized_mobject_class()"}
{"prompt": "\"Animate a 3D cube being displayed as part of the base Mobject class, with dynamic renderer changes.\"", "response": "Gets the base mobject class, depending on the currently active renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_mobject_class >>> get_mobject_class () . __name__ in [ 'Mobject' , 'OpenGLMobject' ] True Return type : type", "original_prompt": "get_mobject_class()"}
{"prompt": "\"Show a point cloud with dynamic rendering, switching between two shapes depending on the active renderer.\"", "response": "Gets the point cloud mobject class, depending on the currently\nactive renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_point_mobject_class >>> get_point_mobject_class () . __name__ in [ 'PMobject' , 'OpenGLPMobject' ] True Return type : type", "original_prompt": "get_point_mobject_class()"}
{"prompt": "\"Animate a vector's magnitude over time on a coordinate grid with varying renderer styles.\"", "response": "Gets the vectorized mobject class, depending on the currently\nactive renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_vectorized_mobject_class >>> get_vectorized_mobject_class () . __name__ in [ 'VMobject' , 'OpenGLVMobject' ] True Return type : type", "original_prompt": "get_vectorized_mobject_class()"}
{"prompt": "\"Reveal the base shape class with a changing renderer, showcasing various mobject styles.\"", "response": "Gets the base mobject class, depending on the currently active renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_mobject_class >>> get_mobject_class () . __name__ in [ 'Mobject' , 'OpenGLMobject' ] True Return type : type", "original_prompt": "get_mobject_class()"}
{"prompt": "\"Render a point cloud object that adapts to the selected 3D renderer style.\"", "response": "Gets the point cloud mobject class, depending on the currently\nactive renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_point_mobject_class >>> get_point_mobject_class () . __name__ in [ 'PMobject' , 'OpenGLPMobject' ] True Return type : type", "original_prompt": "get_point_mobject_class()"}
{"prompt": "Animate a vectorized VMobject rotating with its 3D axes displayed.", "response": "Gets the vectorized mobject class, depending on the currently\nactive renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_vectorized_mobject_class >>> get_vectorized_mobject_class () . __name__ in [ 'VMobject' , 'OpenGLVMobject' ] True Return type : type", "original_prompt": "get_vectorized_mobject_class()"}
{"prompt": "\"Animate a dot moving in a straight line along a parameter track with multiple updates, transforming and scaling its position.\"", "response": "Bases: ValueTracker Tracks a complex-valued parameter. When the value is set through animate , the value will take a straight path from the\nsource point to the destination point. Examples Example: ComplexValueTrackerExample   from manim import * class ComplexValueTrackerExample ( Scene ): def construct ( self ): tracker = ComplexValueTracker ( - 2 + 1 j ) dot = Dot () . add_updater ( lambda x : x . move_to ( tracker . points ) ) self . add ( NumberPlane (), dot ) self . play ( tracker . animate . set_value ( 3 + 2 j )) self . play ( tracker . animate . set_value ( tracker . get_value () * 1 j )) self . play ( tracker . animate . set_value ( tracker . get_value () - 2 j )) self . play ( tracker . animate . set_value ( tracker . get_value () / ( - 2 + 3 j ))) class ComplexValueTrackerExample(Scene):\n    def construct(self):\n        tracker = ComplexValueTracker(-2+1j)\n        dot = Dot().add_updater(\n            lambda x: x.move_to(tracker.points)\n        )\n\n        self.add(NumberPlane(), dot)\n\n        self.play(tracker.animate.set_value(3+2j))\n        self.play(tracker.animate.set_value(tracker.get_value() * 1j))\n        self.play(tracker.animate.set_value(tracker.get_value() - 2j))\n        self.play(tracker.animate.set_value(tracker.get_value() / (-2 + 3j))) Methods get_value Get the current value of this value tracker as a complex number. set_value Sets a new complex value to the ComplexValueTracker Attributes animate Used to animate the application of any method of self . animation_overrides depth The depth of the mobject. height The height of the mobject. width The width of the mobject. _original__init__ ( value = 0 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. get_value ( ) [source]   Get the current value of this value tracker as a complex number. The value is internally stored as a points array [a, b, 0]. This can be accessed directly\nto represent the value geometrically, see the usage example. set_value ( z ) [source]   Sets a new complex value to the ComplexValueTracker", "original_prompt": "class ComplexValueTracker(value=0, **kwargs)"}
{"prompt": "Animate a moving dot that follows the continuous increase of a number tracker, creating a visualization of numerical growth.", "response": "Bases: Mobject A mobject that can be used for tracking (real-valued) parameters.\nUseful for animating parameter changes. Not meant to be displayed.  Instead the position encodes some\nnumber, often one which another animation or continual_animation\nuses for its update function, and by treating it as a mobject it can\nstill be animated and manipulated just like anything else. This value changes continuously when animated using the animate syntax. Examples Example: ValueTrackerExample   from manim import * class ValueTrackerExample ( Scene ): def construct ( self ): number_line = NumberLine () pointer = Vector ( DOWN ) label = MathTex ( \"x\" ) . add_updater ( lambda m : m . next_to ( pointer , UP )) tracker = ValueTracker ( 0 ) pointer . add_updater ( lambda m : m . next_to ( number_line . n2p ( tracker . get_value ()), UP ) ) self . add ( number_line , pointer , label ) tracker += 1.5 self . wait ( 1 ) tracker -= 4 self . wait ( 0.5 ) self . play ( tracker . animate . set_value ( 5 )) self . wait ( 0.5 ) self . play ( tracker . animate . set_value ( 3 )) self . play ( tracker . animate . increment_value ( - 2 )) self . wait ( 0.5 ) class ValueTrackerExample(Scene):\n    def construct(self):\n        number_line = NumberLine()\n        pointer = Vector(DOWN)\n        label = MathTex(\"x\").add_updater(lambda m: m.next_to(pointer, UP))\n\n        tracker = ValueTracker(0)\n        pointer.add_updater(\n            lambda m: m.next_to(\n                        number_line.n2p(tracker.get_value()),\n                        UP\n                    )\n        )\n        self.add(number_line, pointer,label)\n        tracker += 1.5\n        self.wait(1)\n        tracker -= 4\n        self.wait(0.5)\n        self.play(tracker.animate.set_value(5))\n        self.wait(0.5)\n        self.play(tracker.animate.set_value(3))\n        self.play(tracker.animate.increment_value(-2))\n        self.wait(0.5) Note You can also link ValueTrackers to updaters. In this case, you have to make sure that the\nValueTracker is added to the scene by add Example: ValueTrackerExample   from manim import * class ValueTrackerExample ( Scene ): def construct ( self ): tracker = ValueTracker ( 0 ) label = Dot ( radius = 3 ) . add_updater ( lambda x : x . set_x ( tracker . get_value ())) self . add ( label ) self . add ( tracker ) tracker . add_updater ( lambda mobject , dt : mobject . increment_value ( dt )) self . wait ( 2 ) class ValueTrackerExample(Scene):\n    def construct(self):\n        tracker = ValueTracker(0)\n        label = Dot(radius=3).add_updater(lambda x : x.set_x(tracker.get_value()))\n        self.add(label)\n        self.add(tracker)\n        tracker.add_updater(lambda mobject, dt: mobject.increment_value(dt))\n        self.wait(2) Methods get_value Get the current value of this ValueTracker. increment_value Increments (adds) a scalar value  to the ValueTracker interpolate Turns self into an interpolation between mobject1 and mobject2. set_value Sets a new scalar value to the ValueTracker Attributes animate Used to animate the application of any method of self . animation_overrides depth The depth of the mobject. height The height of the mobject. width The width of the mobject. _original__init__ ( value = 0 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. get_value ( ) [source]   Get the current value of this ValueTracker. Return type : float increment_value ( d_value ) [source]   Increments (adds) a scalar value  to the ValueTracker Parameters : d_value ( float ) interpolate ( mobject1 , mobject2 , alpha , path_func=<function interpolate> ) [source]   Turns self into an interpolation between mobject1\nand mobject2. set_value ( value ) [source]   Sets a new scalar value to the ValueTracker Parameters : value ( float )", "original_prompt": "class ValueTracker(value=0, **kwargs)"}
{"prompt": "\"Display a grid of vectors with color gradients, rotating and scaling over time.\"", "response": "Bases: VectorField A VectorField represented by a set of change vectors. Vector fields are always based on a function defining the Vector at every position.\nThe values of this functions is displayed as a grid of vectors.\nBy default the color of each vector is determined by it\u2019s magnitude.\nOther color schemes can be used however. Parameters : func ( Callable [ [ np.ndarray ] , np.ndarray ] ) \u2013 The function defining the rate of change at every position of the vector field. color ( ParsableManimColor | None ) \u2013 The color of the vector field. If set, position-specific coloring is disabled. color_scheme ( Callable [ [ np.ndarray ] , float ] | None ) \u2013 A function mapping a vector to a single value. This value gives the position in the color gradient defined using min_color_scheme_value , max_color_scheme_value and colors . min_color_scheme_value ( float ) \u2013 The value of the color_scheme function to be mapped to the first color in colors . Lower values also result in the first color of the gradient. max_color_scheme_value ( float ) \u2013 The value of the color_scheme function to be mapped to the last color in colors . Higher values also result in the last color of the gradient. colors ( Sequence [ ParsableManimColor ] ) \u2013 The colors defining the color gradient of the vector field. x_range ( Sequence [ float ] ) \u2013 A sequence of x_min, x_max, delta_x y_range ( Sequence [ float ] ) \u2013 A sequence of y_min, y_max, delta_y z_range ( Sequence [ float ] ) \u2013 A sequence of z_min, z_max, delta_z three_dimensions ( bool ) \u2013 Enables three_dimensions. Default set to False, automatically turns True if\nz_range is not None. length_func ( Callable [ [ float ] , float ] ) \u2013 The function determining the displayed size of the vectors. The actual size\nof the vector is passed, the returned value will be used as display size for the\nvector. By default this is used to cap the displayed size of vectors to reduce the clutter. opacity ( float ) \u2013 The opacity of the arrows. vector_config ( dict | None ) \u2013 Additional arguments to be passed to the Vector constructor kwargs \u2013 Additional arguments to be passed to the VGroup constructor Examples Example: BasicUsage   from manim import * class BasicUsage ( Scene ): def construct ( self ): func = lambda pos : (( pos [ 0 ] * UR + pos [ 1 ] * LEFT ) - pos ) / 3 self . add ( ArrowVectorField ( func )) class BasicUsage(Scene):\n    def construct(self):\n        func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3\n        self.add(ArrowVectorField(func)) Example: SizingAndSpacing   from manim import * class SizingAndSpacing ( Scene ): def construct ( self ): func = lambda pos : np . sin ( pos [ 0 ] / 2 ) * UR + np . cos ( pos [ 1 ] / 2 ) * LEFT vf = ArrowVectorField ( func , x_range = [ - 7 , 7 , 1 ]) self . add ( vf ) self . wait () length_func = lambda x : x / 3 vf2 = ArrowVectorField ( func , x_range = [ - 7 , 7 , 1 ], length_func = length_func ) self . play ( vf . animate . become ( vf2 )) self . wait () class SizingAndSpacing(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n        vf = ArrowVectorField(func, x_range=[-7, 7, 1])\n        self.add(vf)\n        self.wait()\n\n        length_func = lambda x: x / 3\n        vf2 = ArrowVectorField(func, x_range=[-7, 7, 1], length_func=length_func)\n        self.play(vf.animate.become(vf2))\n        self.wait() Example: Coloring   from manim import * class Coloring ( Scene ): def construct ( self ): func = lambda pos : pos - LEFT * 5 colors = [ RED , YELLOW , BLUE , DARK_GRAY ] min_radius = Circle ( radius = 2 , color = colors [ 0 ]) . shift ( LEFT * 5 ) max_radius = Circle ( radius = 10 , color = colors [ - 1 ]) . shift ( LEFT * 5 ) vf = ArrowVectorField ( func , min_color_scheme_value = 2 , max_color_scheme_value = 10 , colors = colors ) self . add ( vf , min_radius , max_radius ) class Coloring(Scene):\n    def construct(self):\n        func = lambda pos: pos - LEFT * 5\n        colors = [RED, YELLOW, BLUE, DARK_GRAY]\n        min_radius = Circle(radius=2, color=colors[0]).shift(LEFT * 5)\n        max_radius = Circle(radius=10, color=colors[-1]).shift(LEFT * 5)\n        vf = ArrowVectorField(\n            func, min_color_scheme_value=2, max_color_scheme_value=10, colors=colors\n        )\n        self.add(vf, min_radius, max_radius) Methods get_vector Creates a vector in the vector field. Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( func, color=None, color_scheme=None, min_color_scheme_value=0, max_color_scheme_value=2, colors=[ManimColor('#236B8E'), ManimColor('#83C167'), ManimColor('#FFFF00'), ManimColor('#FC6255')], x_range=None, y_range=None, z_range=None, three_dimensions=False, length_func=<function ArrowVectorField.<lambda>>, opacity=1.0, vector_config=None, **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : func ( Callable [ [ np.ndarray ] , np.ndarray ] ) color ( ParsableManimColor | None ) color_scheme ( Callable [ [ np.ndarray ] , float ] | None ) min_color_scheme_value ( float ) max_color_scheme_value ( float ) colors ( Sequence [ ParsableManimColor ] ) x_range ( Sequence [ float ] ) y_range ( Sequence [ float ] ) z_range ( Sequence [ float ] ) three_dimensions ( bool ) length_func ( Callable [ [ float ] , float ] ) opacity ( float ) vector_config ( dict | None ) get_vector ( point ) [source]   Creates a vector in the vector field. The created vector is based on the function of the vector field and is\nrooted in the given point. Color and length fit the specifications of\nthis vector field. Parameters : point ( ndarray ) \u2013 The root point of the vector.", "original_prompt": "class ArrowVectorField(func, color=None, color_scheme=None, min_color_scheme_value=0, max_color_scheme_value=2, colors="}
{"prompt": "I don't see a specific prompt or question in your message for me to answer. It appears you are providing an overview of the `StreamLines` class from the Manim animation library, listing its methods and examples.\n\nIf you could provide a specific question or prompt related to these classes, I would be happy to try and assist you further!", "response": "Bases: VectorField StreamLines represent the flow of a VectorField using the trace of moving agents. Vector fields are always based on a function defining the vector at every position.\nThe values of this functions is displayed by moving many agents along the vector field\nand showing their trace. Parameters : func ( Callable [ [ np.ndarray ] , np.ndarray ] ) \u2013 The function defining the rate of change at every position of the vector field. color ( ParsableManimColor | None ) \u2013 The color of the vector field. If set, position-specific coloring is disabled. color_scheme ( Callable [ [ np.ndarray ] , float ] | None ) \u2013 A function mapping a vector to a single value. This value gives the position in the color gradient defined using min_color_scheme_value , max_color_scheme_value and colors . min_color_scheme_value ( float ) \u2013 The value of the color_scheme function to be mapped to the first color in colors . Lower values also result in the first color of the gradient. max_color_scheme_value ( float ) \u2013 The value of the color_scheme function to be mapped to the last color in colors . Higher values also result in the last color of the gradient. colors ( Sequence [ ParsableManimColor ] ) \u2013 The colors defining the color gradient of the vector field. x_range ( Sequence [ float ] ) \u2013 A sequence of x_min, x_max, delta_x y_range ( Sequence [ float ] ) \u2013 A sequence of y_min, y_max, delta_y z_range ( Sequence [ float ] ) \u2013 A sequence of z_min, z_max, delta_z three_dimensions ( bool ) \u2013 Enables three_dimensions. Default set to False, automatically turns True if\nz_range is not None. noise_factor ( float | None ) \u2013 The amount by which the starting position of each agent is altered along each axis. Defaults to delta_y / 2 if not defined. n_repeats \u2013 The number of agents generated at each starting point. dt \u2013 The factor by which the distance an agent moves per step is stretched. Lower values result in a better approximation of the trajectories in the vector field. virtual_time \u2013 The time the agents get to move in the vector field. Higher values therefore result in longer stream lines. However, this whole time gets simulated upon creation. max_anchors_per_line \u2013 The maximum number of anchors per line. Lines with more anchors get reduced in complexity, not in length. padding \u2013 The distance agents can move out of the generation area before being terminated. stroke_width \u2013 The stroke with of the stream lines. opacity \u2013 The opacity of the stream lines. Examples Example: BasicUsage   from manim import * class BasicUsage ( Scene ): def construct ( self ): func = lambda pos : (( pos [ 0 ] * UR + pos [ 1 ] * LEFT ) - pos ) / 3 self . add ( StreamLines ( func )) class BasicUsage(Scene):\n    def construct(self):\n        func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3\n        self.add(StreamLines(func)) Example: SpawningAndFlowingArea   from manim import * class SpawningAndFlowingArea ( Scene ): def construct ( self ): func = lambda pos : np . sin ( pos [ 0 ]) * UR + np . cos ( pos [ 1 ]) * LEFT + pos / 5 stream_lines = StreamLines ( func , x_range = [ - 3 , 3 , 0.2 ], y_range = [ - 2 , 2 , 0.2 ], padding = 1 ) spawning_area = Rectangle ( width = 6 , height = 4 ) flowing_area = Rectangle ( width = 8 , height = 6 ) labels = [ Tex ( \"Spawning Area\" ), Tex ( \"Flowing Area\" ) . shift ( DOWN * 2.5 )] for lbl in labels : lbl . add_background_rectangle ( opacity = 0.6 , buff = 0.05 ) self . add ( stream_lines , spawning_area , flowing_area , * labels ) class SpawningAndFlowingArea(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[0]) * UR + np.cos(pos[1]) * LEFT + pos / 5\n        stream_lines = StreamLines(\n            func, x_range=[-3, 3, 0.2], y_range=[-2, 2, 0.2], padding=1\n        )\n\n        spawning_area = Rectangle(width=6, height=4)\n        flowing_area = Rectangle(width=8, height=6)\n        labels = [Tex(\"Spawning Area\"), Tex(\"Flowing Area\").shift(DOWN * 2.5)]\n        for lbl in labels:\n            lbl.add_background_rectangle(opacity=0.6, buff=0.05)\n\n        self.add(stream_lines, spawning_area, flowing_area, *labels) Methods create The creation animation of the stream lines. end_animation End the stream line animation smoothly. start_animation Animates the stream lines using an updater. Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( func , color = None , color_scheme = None , min_color_scheme_value = 0 , max_color_scheme_value = 2 , colors = [ManimColor('#236B8E'), ManimColor('#83C167'), ManimColor('#FFFF00'), ManimColor('#FC6255')] , x_range = None , y_range = None , z_range = None , three_dimensions = False , noise_factor = None , n_repeats = 1 , dt = 0.05 , virtual_time = 3 , max_anchors_per_line = 100 , padding = 3 , stroke_width = 1 , opacity = 1 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : func ( Callable [ [ np.ndarray ] , np.ndarray ] ) color ( ParsableManimColor | None ) color_scheme ( Callable [ [ np.ndarray ] , float ] | None ) min_color_scheme_value ( float ) max_color_scheme_value ( float ) colors ( Sequence [ ParsableManimColor ] ) x_range ( Sequence [ float ] ) y_range ( Sequence [ float ] ) z_range ( Sequence [ float ] ) three_dimensions ( bool ) noise_factor ( float | None ) create ( lag_ratio = None , run_time = None , ** kwargs ) [source]   The creation animation of the stream lines. The stream lines appear in random order. Parameters : lag_ratio ( float | None ) \u2013 The lag ratio of the animation.\nIf undefined, it will be selected so that the total animation length is 1.5 times the run time of each stream line creation. run_time ( Callable [ [ float ] , float ] | None ) \u2013 The run time of every single stream line creation. The runtime of the whole animation might be longer due to the lag_ratio .\nIf undefined, the virtual time of the stream lines is used as run time. Returns : The creation animation of the stream lines. Return type : AnimationGroup Examples Example: StreamLineCreation   from manim import * class StreamLineCreation ( Scene ): def construct ( self ): func = lambda pos : ( pos [ 0 ] * UR + pos [ 1 ] * LEFT ) - pos stream_lines = StreamLines ( func , color = YELLOW , x_range = [ - 7 , 7 , 1 ], y_range = [ - 4 , 4 , 1 ], stroke_width = 3 , virtual_time = 1 , # use shorter lines max_anchors_per_line = 5 , # better performance with fewer anchors ) self . play ( stream_lines . create ()) # uses virtual_time as run_time self . wait () class StreamLineCreation(Scene):\n    def construct(self):\n        func = lambda pos: (pos[0] * UR + pos[1] * LEFT) - pos\n        stream_lines = StreamLines(\n            func,\n            color=YELLOW,\n            x_range=[-7, 7, 1],\n            y_range=[-4, 4, 1],\n            stroke_width=3,\n            virtual_time=1,  # use shorter lines\n            max_anchors_per_line=5,  # better performance with fewer anchors\n        )\n        self.play(stream_lines.create())  # uses virtual_time as run_time\n        self.wait() end_animation ( ) [source]   End the stream line animation smoothly. Returns an animation resulting in fully displayed stream lines without a noticeable cut. Returns : The animation fading out the running stream animation. Return type : AnimationGroup Raises : ValueError \u2013 if no stream line animation is running Examples Example: EndAnimation   from manim import * class EndAnimation ( Scene ): def construct ( self ): func = lambda pos : np . sin ( pos [ 0 ] / 2 ) * UR + np . cos ( pos [ 1 ] / 2 ) * LEFT stream_lines = StreamLines ( func , stroke_width = 3 , max_anchors_per_line = 5 , virtual_time = 1 , color = BLUE ) self . add ( stream_lines ) stream_lines . start_animation ( warm_up = False , flow_speed = 1.5 , time_width = 0.5 ) self . wait ( 1 ) self . play ( stream_lines . end_animation ()) class EndAnimation(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n        stream_lines = StreamLines(\n            func, stroke_width=3, max_anchors_per_line=5, virtual_time=1, color=BLUE\n        )\n        self.add(stream_lines)\n        stream_lines.start_animation(warm_up=False, flow_speed=1.5, time_width=0.5)\n        self.wait(1)\n        self.play(stream_lines.end_animation()) start_animation ( warm_up=True , flow_speed=1 , time_width=0.3 , rate_func=<function linear> , line_animation_class=<class 'manim.animation.indication.ShowPassingFlash'> , **kwargs ) [source]   Animates the stream lines using an updater. The stream lines will continuously flow Parameters : warm_up ( bool ) \u2013 If True the animation is initialized line by line. Otherwise it starts with all lines shown. flow_speed ( float ) \u2013 At flow_speed=1 the distance the flow moves per second is equal to the magnitude of the vector field along its path. The speed value scales the speed of this flow. time_width ( float ) \u2013 The proportion of the stream line shown while being animated rate_func ( Callable [ [ float ] , float ] ) \u2013 The rate function of each stream line flashing line_animation_class ( type [ ShowPassingFlash ] ) \u2013 The animation class being used Return type : None Examples Example: ContinuousMotion   from manim import * class ContinuousMotion ( Scene ): def construct ( self ): func = lambda pos : np . sin ( pos [ 0 ] / 2 ) * UR + np . cos ( pos [ 1 ] / 2 ) * LEFT stream_lines = StreamLines ( func , stroke_width = 3 , max_anchors_per_line = 30 ) self . add ( stream_lines ) stream_lines . start_animation ( warm_up = False , flow_speed = 1.5 ) self . wait ( stream_lines . virtual_time / stream_lines . flow_speed ) class ContinuousMotion(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n        stream_lines = StreamLines(func, stroke_width=3, max_anchors_per_line=30)\n        self.add(stream_lines)\n        stream_lines.start_animation(warm_up=False, flow_speed=1.5)\n        self.wait(stream_lines.virtual_time / stream_lines.flow_speed)", "original_prompt": "class StreamLines(func, color=None, color_scheme=None, min_color_scheme_value=0, max_color_scheme_value=2, colors="}
{"prompt": "I don't see a specific prompt to answer. However, I can provide some general information about the `nudge` method in Manim.\n\nThe `nudge` method is used to nudge a submobject along a vector field by a specified distance and direction. The syntax for this method is:\n```\nvector_field.nudge(submobject, distance, angle, pointwise)\n```\nWhere:\n\n* `submobject`: the submobject to be nudged\n* `distance`: the distance to nudge the submobject (in units of the vector field's length)\n* `angle`: the angle in radians at which to nudge the submobject (optional, default is 0)\n* `pointwise`: a boolean indicating whether to nudge the submobject pointwise (along its own direction) or not (default is False)\n\nIf you have a specific question about how to use this method or would like more information on how to create vector fields in Manim, feel free to ask!", "response": "Bases: VGroup A vector field. Vector fields are based on a function defining a vector at every position.\nThis class does by default not include any visible elements but provides\nmethods to move other Mobject s along the vector field. Parameters : func ( Callable [ [ np.ndarray ] , np.ndarray ] ) \u2013 The function defining the rate of change at every position of the VectorField . color ( ParsableManimColor | None ) \u2013 The color of the vector field. If set, position-specific coloring is disabled. color_scheme ( Callable [ [ np.ndarray ] , float ] | None ) \u2013 A function mapping a vector to a single value. This value gives the position in the color gradient defined using min_color_scheme_value , max_color_scheme_value and colors . min_color_scheme_value ( float ) \u2013 The value of the color_scheme function to be mapped to the first color in colors . Lower values also result in the first color of the gradient. max_color_scheme_value ( float ) \u2013 The value of the color_scheme function to be mapped to the last color in colors . Higher values also result in the last color of the gradient. colors ( Sequence [ ParsableManimColor ] ) \u2013 The colors defining the color gradient of the vector field. kwargs \u2013 Additional arguments to be passed to the VGroup constructor Methods fit_to_coordinate_system Scale the vector field to fit a coordinate system. get_colored_background_image Generate an image that displays the vector field. get_nudge_updater Get an update function to move a Mobject along the vector field. get_vectorized_rgba_gradient_function Generates a gradient of rgbas as a numpy array nudge Nudge a Mobject along the vector field. nudge_submobjects Apply a nudge along the vector field to all submobjects. scale_func Scale a vector field function. shift_func Shift a vector field function. start_submobject_movement Start continuously moving all submobjects along the vector field. stop_submobject_movement Stops the continuous movement started using start_submobject_movement() . Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( func , color = None , color_scheme = None , min_color_scheme_value = 0 , max_color_scheme_value = 2 , colors = [ManimColor('#236B8E'), ManimColor('#83C167'), ManimColor('#FFFF00'), ManimColor('#FC6255')] , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : func ( Callable [ [ np.ndarray ] , np.ndarray ] ) color ( ParsableManimColor | None ) color_scheme ( Callable [ [ np.ndarray ] , float ] | None ) min_color_scheme_value ( float ) max_color_scheme_value ( float ) colors ( Sequence [ ParsableManimColor ] ) fit_to_coordinate_system ( coordinate_system ) [source]   Scale the vector field to fit a coordinate system. This method is useful when the vector field is defined in a coordinate system\ndifferent from the one used to display the vector field. This method can only be used once because it transforms the origin of each vector. Parameters : coordinate_system ( CoordinateSystem ) \u2013 The coordinate system to fit the vector field to. get_colored_background_image ( sampling_rate = 5 ) [source]   Generate an image that displays the vector field. The color at each position is calculated by passing the positing through a\nseries of steps:\nCalculate the vector field function at that position, map that vector to a\nsingle value using self.color_scheme and finally generate a color from\nthat value using the color gradient. Parameters : sampling_rate ( int ) \u2013 The stepsize at which pixels get included in the image. Lower values give\nmore accurate results, but may take a long time to compute. Returns : The vector field image. Return type : Image.Imgae get_nudge_updater ( speed = 1 , pointwise = False ) [source]   Get an update function to move a Mobject along the vector field. When used with add_updater() , the mobject will move along the vector field, where its speed is determined by the magnitude of the vector field. Parameters : speed ( float ) \u2013 At speed=1 the distance a mobject moves per second is equal to the magnitude of the vector field along its path. The speed value scales the speed of such a mobject. pointwise ( bool ) \u2013 Whether to move the mobject along the vector field. See nudge() for details. Returns : The update function. Return type : Callable[[ Mobject , float], Mobject ] get_vectorized_rgba_gradient_function ( start , end , colors ) [source]   Generates a gradient of rgbas as a numpy array Parameters : start ( float ) \u2013 start value used for inverse interpolation at inverse_interpolate() end ( float ) \u2013 end value used for inverse interpolation at inverse_interpolate() colors ( Iterable [ ParsableManimColor ] ) \u2013 list of colors to generate the gradient Return type : function to generate the gradients as numpy arrays representing rgba values nudge ( mob , dt = 1 , substeps = 1 , pointwise = False ) [source]   Nudge a Mobject along the vector field. Parameters : mob ( Mobject ) \u2013 The mobject to move along the vector field dt ( float ) \u2013 A scalar to the amount the mobject is moved along the vector field.\nThe actual distance is based on the magnitude of the vector field. substeps ( int ) \u2013 The amount of steps the whole nudge is divided into. Higher values\ngive more accurate approximations. pointwise ( bool ) \u2013 Whether to move the mobject along the vector field. If False the\nvector field takes effect on the center of the given Mobject . If True the vector field takes effect on the\npoints of the individual points of the Mobject ,\npotentially distorting it. Returns : This vector field. Return type : VectorField Examples Example: Nudging   from manim import * class Nudging ( Scene ): def construct ( self ): func = lambda pos : np . sin ( pos [ 1 ] / 2 ) * RIGHT + np . cos ( pos [ 0 ] / 2 ) * UP vector_field = ArrowVectorField ( func , x_range = [ - 7 , 7 , 1 ], y_range = [ - 4 , 4 , 1 ], length_func = lambda x : x / 2 ) self . add ( vector_field ) circle = Circle ( radius = 2 ) . shift ( LEFT ) self . add ( circle . copy () . set_color ( GRAY )) dot = Dot () . move_to ( circle ) vector_field . nudge ( circle , - 2 , 60 , True ) vector_field . nudge ( dot , - 2 , 60 ) circle . add_updater ( vector_field . get_nudge_updater ( pointwise = True )) dot . add_updater ( vector_field . get_nudge_updater ()) self . add ( circle , dot ) self . wait ( 6 ) class Nudging(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[1] / 2) * RIGHT + np.cos(pos[0] / 2) * UP\n        vector_field = ArrowVectorField(\n            func, x_range=[-7, 7, 1], y_range=[-4, 4, 1], length_func=lambda x: x / 2\n        )\n        self.add(vector_field)\n        circle = Circle(radius=2).shift(LEFT)\n        self.add(circle.copy().set_color(GRAY))\n        dot = Dot().move_to(circle)\n\n        vector_field.nudge(circle, -2, 60, True)\n        vector_field.nudge(dot, -2, 60)\n\n        circle.add_updater(vector_field.get_nudge_updater(pointwise=True))\n        dot.add_updater(vector_field.get_nudge_updater())\n        self.add(circle, dot)\n        self.wait(6) nudge_submobjects ( dt = 1 , substeps = 1 , pointwise = False ) [source]   Apply a nudge along the vector field to all submobjects. Parameters : dt ( float ) \u2013 A scalar to the amount the mobject is moved along the vector field.\nThe actual distance is based on the magnitude of the vector field. substeps ( int ) \u2013 The amount of steps the whole nudge is divided into. Higher values\ngive more accurate approximations. pointwise ( bool ) \u2013 Whether to move the mobject along the vector field. See nudge() for details. Returns : This vector field. Return type : VectorField static scale_func ( func , scalar ) [source]   Scale a vector field function. Parameters : func ( Callable [ [ ndarray ] , ndarray ] ) \u2013 The function defining a vector field. scalar ( float ) \u2013 The scalar to be applied to the vector field. Return type : Callable [[ ndarray ], ndarray ] Examples Example: ScaleVectorFieldFunction   from manim import * class ScaleVectorFieldFunction ( Scene ): def construct ( self ): func = lambda pos : np . sin ( pos [ 1 ]) * RIGHT + np . cos ( pos [ 0 ]) * UP vector_field = ArrowVectorField ( func ) self . add ( vector_field ) self . wait () func = VectorField . scale_func ( func , 0.5 ) self . play ( vector_field . animate . become ( ArrowVectorField ( func ))) self . wait () class ScaleVectorFieldFunction(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[1]) * RIGHT + np.cos(pos[0]) * UP\n        vector_field = ArrowVectorField(func)\n        self.add(vector_field)\n        self.wait()\n\n        func = VectorField.scale_func(func, 0.5)\n        self.play(vector_field.animate.become(ArrowVectorField(func)))\n        self.wait() Returns : The scaled vector field function. Return type : Callable[[np.ndarray], np.ndarray] Parameters : func ( Callable [ [ ndarray ] , ndarray ] ) scalar ( float ) static shift_func ( func , shift_vector ) [source]   Shift a vector field function. Parameters : func ( Callable [ [ ndarray ] , ndarray ] ) \u2013 The function defining a vector field. shift_vector ( ndarray ) \u2013 The shift to be applied to the vector field. Returns : The shifted vector field function. Return type : Callable[[np.ndarray], np.ndarray] start_submobject_movement ( speed = 1 , pointwise = False ) [source]   Start continuously moving all submobjects along the vector field. Calling this method multiple times will result in removing the previous updater created by this method. Parameters : speed ( float ) \u2013 The speed at which to move the submobjects. See get_nudge_updater() for details. pointwise ( bool ) \u2013 Whether to move the mobject along the vector field. See nudge() for details. Returns : This vector field. Return type : VectorField stop_submobject_movement ( ) [source]   Stops the continuous movement started using start_submobject_movement() . Returns : This vector field. Return type : VectorField", "original_prompt": "class VectorField(func, color=None, color_scheme=None, min_color_scheme_value=0, max_color_scheme_value=2, colors="}
{"prompt": "Animate a camera panning over a rotating graph of sine function with smoothly fading point annotations.", "response": "Bases: Scene This is a Scene, with special configurations and properties that\nmake it suitable for cases where the camera must be moved around. Note: Examples are included in the moving_camera_scene module\ndocumentation, see below in the \u2018see also\u2019 section. See also moving_camera_scene MovingCamera Methods get_moving_mobjects This method returns a list of all of the Mobjects in the Scene that are moving, that are also in the animations passed. Attributes camera time The time since the start of the scene. get_moving_mobjects ( * animations ) [source]   This method returns a list of all of the Mobjects in the Scene that\nare moving, that are also in the animations passed. Parameters : *animations ( Animation ) \u2013 The Animations whose mobjects will be checked.", "original_prompt": "class MovingCameraScene(camera_class=<class 'manim.camera.moving_camera.MovingCamera'>, **kwargs)"}
{"prompt": "Animate a menu with different presentation types appearing and disappearing.", "response": "Bases: str , Enum The type of a section can be used for third party applications.\nA presentation system could for example use the types to created loops. Examples This class can be reimplemented for more types: class PresentationSectionType ( str , Enum ): # start, end, wait for continuation by user NORMAL = \"presentation.normal\" # start, end, immediately continue to next section SKIP = \"presentation.skip\" # start, end, restart, immediately continue to next section when continued by user LOOP = \"presentation.loop\" # start, end, restart, finish animation first when user continues COMPLETE_LOOP = \"presentation.complete_loop\" Methods Attributes NORMAL", "original_prompt": "class DefaultSectionType(value, names=<not given>, *values, module=None, qualname=None, type=None, start=1, boundary=None)"}
{"prompt": "\"Show a 3D cube rotating smoothly with coordinate axes appearing from a partially rendered video file.\"", "response": "Bases: object A Scene can be segmented into multiple Sections.\nRefer to the documentation for more info.\nIt consists of multiple animations. Parameters : type_ ( str ) video ( str | None ) name ( str ) skip_animations ( bool ) type\\_ Can be used by a third party applications to classify different types of sections. video   Path to video file with animations belonging to section relative to sections directory.\nIf None , then the section will not be saved. name   Human readable, non-unique name for this section. skip_animations   Skip rendering the animations in this section when True . partial_movie_files   Animations belonging to this section. See also DefaultSectionType , CairoRenderer.update_skipping_status() , OpenGLRenderer.update_skipping_status() Methods get_clean_partial_movie_files Return all partial movie files that are not None . get_dict Get dictionary representation with metadata of output video. is_empty Check whether this section is empty. get_clean_partial_movie_files ( ) [source]   Return all partial movie files that are not None . Return type : list[str] get_dict ( sections_dir ) [source]   Get dictionary representation with metadata of output video. The output from this function is used from every section to build the sections index file.\nThe output video must have been created in the sections_dir before executing this method.\nThis is the main part of the Segmented Video API. Parameters : sections_dir ( Path ) Return type : dict[str, Any ] is_empty ( ) [source]   Check whether this section is empty. Note that animations represented by None are also counted. Return type : bool", "original_prompt": "class Section(type_, video, name, skip_animations)"}
{"prompt": "\"Show a 3D coordinate system transforming as a file modifies, updating the scene instantly.\"", "response": "Bases: FileSystemEventHandler A class to handle rerunning a Scene after the input file is modified. Methods on_modified Called when a file or directory is modified. on_modified ( event ) [source]   Called when a file or directory is modified. Parameters : event ( DirModifiedEvent or FileModifiedEvent ) \u2013 Event representing file/directory modification.", "original_prompt": "class RerunSceneHandler(queue)"}
{"prompt": "Unfortunately, this text appears to be documentation for a Python library related to animation and graphics, but it does not contain any specific code or prompt that can be executed directly. It seems to be more of an explanation of the library's functionality and classes.\n\nIf you could provide more context or clarify what you are trying to accomplish, I would be happy to try and help you further.", "response": "Bases: object A Scene is the canvas of your animation. The primary role of Scene is to provide the user with tools to manage\nmobjects and animations.  Generally speaking, a manim script consists of a class\nthat derives from Scene whose Scene.construct() method is overridden\nby the user\u2019s code. Mobjects are displayed on screen by calling Scene.add() and removed from\nscreen by calling Scene.remove() .  All mobjects currently on screen are kept\nin Scene.mobjects .  Animations are played by calling Scene.play() . A Scene is rendered internally by calling Scene.render() .  This in\nturn calls Scene.setup() , Scene.construct() , and Scene.tear_down() , in that order. It is not recommended to override the __init__ method in user Scenes.  For code\nthat should be ran before a Scene is rendered, use Scene.setup() instead. Examples Override the Scene.construct() method with your code. class MyScene ( Scene ): def construct ( self ): self . play ( Write ( Text ( \"Hello World!\" ))) Methods add Mobjects will be displayed, from background to foreground in the order with which they are added. add_foreground_mobject Adds a single mobject to the foreground, and internally to the list foreground_mobjects, and mobjects. add_foreground_mobjects Adds mobjects to the foreground, and internally to the list foreground_mobjects, and mobjects. add_mobjects_from_animations add_sound This method is used to add a sound to the animation. add_subcaption Adds an entry in the corresponding subcaption file at the current time stamp. add_updater Add an update function to the scene. begin_animations Start the animations of the scene. bring_to_back Removes the mobject from the scene and adds them to the back of the scene. bring_to_front Adds the passed mobjects to the scene again, pushing them to he front of the scene. check_interactive_embed_is_valid clear Removes all mobjects present in self.mobjects and self.foreground_mobjects from the scene. compile_animation_data Given a list of animations, compile the corresponding static and moving mobjects, and gather the animation durations. compile_animations Creates _MethodAnimations from any _AnimationBuilders and updates animation kwargs with kwargs passed to play(). construct Add content to the Scene. embed get_attrs Gets attributes of a scene given the attribute's identifier/name. get_mobject_family_members Returns list of family-members of all mobjects in scene. get_moving_and_static_mobjects get_moving_mobjects Gets all moving mobjects in the passed animation(s). get_restructured_mobject_list Given a list of mobjects and a list of mobjects to be removed, this filters out the removable mobjects from the list of mobjects. get_run_time Gets the total run time for a list of animations. get_time_progression You will hardly use this when making your own animations. get_top_level_mobjects Returns all mobjects which are not submobjects. interact interactive_embed Like embed(), but allows for screen interaction. is_current_animation_frozen_frame Returns whether the current animation produces a static frame (generally a Wait). mouse_drag_orbit_controls mouse_scroll_orbit_controls next_section Create separation here; the last section gets finished and a new one gets created. on_key_press on_key_release on_mouse_drag on_mouse_motion on_mouse_press on_mouse_scroll pause Pauses the scene (i.e., displays a frozen frame). play Plays an animation in this scene. play_internal This method is used to prep the animations for rendering, apply the arguments and parameters required to them, render them, and write them to the video file. remove Removes mobjects in the passed list of mobjects from the scene and the foreground, by removing them from \"mobjects\" and \"foreground_mobjects\" remove_foreground_mobject Removes a single mobject from the foreground, and internally from the list foreground_mobjects. remove_foreground_mobjects Removes mobjects from the foreground, and internally from the list foreground_mobjects. remove_updater Remove an update function from the scene. render Renders this Scene. replace Replace one mobject in the scene with another, preserving draw order. restructure_mobjects tl:wr set_key_function setup This is meant to be implemented by any scenes which are commonly subclassed, and have some common setup involved before the construct method is called. should_update_mobjects Returns True if the mobjects of this scene should be updated. tear_down This is meant to be implemented by any scenes which are commonly subclassed, and have some common method to be invoked before the scene ends. update_meshes update_mobjects Begins updating all mobjects in the Scene. update_self Run all scene updater functions. update_to_time validate_run_time wait Plays a \"no operation\" animation. wait_until Wait until a condition is satisfied, up to a given maximum duration. Attributes camera time The time since the start of the scene. Parameters : renderer ( CairoRenderer | OpenGLRenderer | None ) camera_class ( type [ Camera ] ) always_update_mobjects ( bool ) random_seed ( int | None ) skip_animations ( bool ) _get_animation_time_progression ( animations , duration ) [source]   You will hardly use this when making your own animations.\nThis method is for Manim\u2019s internal use. Uses get_time_progression() to obtain a\nCommandLine ProgressBar whose fill_time is\ndependent on the qualities of the passed Animation, Parameters : animations ( list [ Animation ] ) \u2013 The list of animations to get\nthe time progression for. duration ( float ) \u2013 duration of wait time Returns : The CommandLine Progress Bar. Return type : time_progression add ( * mobjects ) [source]   Mobjects will be displayed, from background to\nforeground in the order with which they are added. Parameters : *mobjects ( Mobject ) \u2013 Mobjects to add. Returns : The same scene after adding the Mobjects in. Return type : Scene add_foreground_mobject ( mobject ) [source]   Adds a single mobject to the foreground, and internally to the list\nforeground_mobjects, and mobjects. Parameters : mobject ( Mobject ) \u2013 The Mobject to add to the foreground. Returns : The Scene, with the foreground mobject added. Return type : Scene add_foreground_mobjects ( * mobjects ) [source]   Adds mobjects to the foreground, and internally to the list\nforeground_mobjects, and mobjects. Parameters : *mobjects ( Mobject ) \u2013 The Mobjects to add to the foreground. Returns : The Scene, with the foreground mobjects added. Return type : Scene add_sound ( sound_file , time_offset = 0 , gain = None , ** kwargs ) [source]   This method is used to add a sound to the animation. Parameters : sound_file ( str ) \u2013 The path to the sound file. time_offset ( float ) \u2013 The offset in the sound file after which\nthe sound can be played. gain ( float | None ) \u2013 Amplification of the sound. Examples Example: SoundExample   from manim import * class SoundExample ( Scene ): # Source of sound under Creative Commons 0 License. https://freesound.org/people/Druminfected/sounds/250551/ def construct ( self ): dot = Dot () . set_color ( GREEN ) self . add_sound ( \"click.wav\" ) self . add ( dot ) self . wait () self . add_sound ( \"click.wav\" ) dot . set_color ( BLUE ) self . wait () self . add_sound ( \"click.wav\" ) dot . set_color ( RED ) self . wait () class SoundExample(Scene):\n    # Source of sound under Creative Commons 0 License. https://freesound.org/people/Druminfected/sounds/250551/\n    def construct(self):\n        dot = Dot().set_color(GREEN)\n        self.add_sound(\"click.wav\")\n        self.add(dot)\n        self.wait()\n        self.add_sound(\"click.wav\")\n        dot.set_color(BLUE)\n        self.wait()\n        self.add_sound(\"click.wav\")\n        dot.set_color(RED)\n        self.wait() Download the resource for the previous example here . add_subcaption ( content , duration = 1 , offset = 0 ) [source]   Adds an entry in the corresponding subcaption file\nat the current time stamp. The current time stamp is obtained from Scene.time . Parameters : content ( str ) \u2013 The subcaption content. duration ( float ) \u2013 The duration (in seconds) for which the subcaption is shown. offset ( float ) \u2013 This offset (in seconds) is added to the starting time stamp\nof the subcaption. Return type : None Examples This example illustrates both possibilities for adding\nsubcaptions to Manimations: class SubcaptionExample ( Scene ): def construct ( self ): square = Square () circle = Circle () # first option: via the add_subcaption method self . add_subcaption ( \"Hello square!\" , duration = 1 ) self . play ( Create ( square )) # second option: within the call to Scene.play self . play ( Transform ( square , circle ), subcaption = \"The square transforms.\" ) add_updater ( func ) [source]   Add an update function to the scene. The scene updater functions are run every frame,\nand they are the last type of updaters to run. Warning When using the Cairo renderer, scene updaters that\nmodify mobjects are not detected in the same way\nthat mobject updaters are. To be more concrete,\na mobject only modified via a scene updater will\nnot necessarily be added to the list of moving\nmobjects and thus might not be updated every frame. TL;DR: Use mobject updaters to update mobjects. Parameters : func ( Callable [ [ float ] , None ] ) \u2013 The updater function. It takes a float, which is the\ntime difference since the last update (usually equal\nto the frame rate). Return type : None See also Scene.remove_updater() , Scene.update_self() begin_animations ( ) [source]   Start the animations of the scene. Return type : None bring_to_back ( * mobjects ) [source]   Removes the mobject from the scene and\nadds them to the back of the scene. Parameters : *mobjects ( Mobject ) \u2013 The mobject(s) to push to the back of the scene. Returns : The Scene, with the mobjects pushed to the back\nof the scene. Return type : Scene bring_to_front ( * mobjects ) [source]   Adds the passed mobjects to the scene again,\npushing them to he front of the scene. Parameters : *mobjects ( Mobject ) \u2013 The mobject(s) to bring to the front of the scene. Returns : The Scene, with the mobjects brought to the front\nof the scene. Return type : Scene clear ( ) [source]   Removes all mobjects present in self.mobjects\nand self.foreground_mobjects from the scene. Returns : The Scene, with all of its mobjects in\nself.mobjects and self.foreground_mobjects\nremoved. Return type : Scene compile_animation_data ( * animations , ** play_kwargs ) [source]   Given a list of animations, compile the corresponding\nstatic and moving mobjects, and gather the animation durations. This also begins the animations. Parameters : animations ( Animation | Mobject | _AnimationBuilder ) \u2013 Animation or mobject with mobject method and params play_kwargs \u2013 Named parameters affecting what was passed in animations ,\ne.g. run_time , lag_ratio and so on. Returns : None if there is nothing to play, or self otherwise. Return type : self, None compile_animations ( * args , ** kwargs ) [source]   Creates _MethodAnimations from any _AnimationBuilders and updates animation\nkwargs with kwargs passed to play(). Parameters : *args ( Animation | Mobject | _AnimationBuilder ) \u2013 Animations to be played. **kwargs \u2013 Configuration for the call to play(). Returns : Animations to be played. Return type : Tuple[ Animation ] construct ( ) [source]   Add content to the Scene. From within Scene.construct() , display mobjects on screen by calling Scene.add() and remove them from screen by calling Scene.remove() .\nAll mobjects currently on screen are kept in Scene.mobjects .  Play\nanimations by calling Scene.play() . Notes Initialization code should go in Scene.setup() .  Termination code should\ngo in Scene.tear_down() . Examples A typical manim script includes a class derived from Scene with an\noverridden Scene.construct() method: class MyScene ( Scene ): def construct ( self ): self . play ( Write ( Text ( \"Hello World!\" ))) See also Scene.setup() , Scene.render() , Scene.tear_down() get_attrs ( * keys ) [source]   Gets attributes of a scene given the attribute\u2019s identifier/name. Parameters : *keys ( str ) \u2013 Name(s) of the argument(s) to return the attribute of. Returns : List of attributes of the passed identifiers. Return type : list get_mobject_family_members ( ) [source]   Returns list of family-members of all mobjects in scene.\nIf a Circle() and a VGroup(Rectangle(),Triangle()) were added,\nit returns not only the Circle(), Rectangle() and Triangle(), but\nalso the VGroup() object. Returns : List of mobject family members. Return type : list get_moving_mobjects ( * animations ) [source]   Gets all moving mobjects in the passed animation(s). Parameters : *animations ( Animation ) \u2013 The animations to check for moving mobjects. Returns : The list of mobjects that could be moving in\nthe Animation(s) Return type : list get_restructured_mobject_list ( mobjects , to_remove ) [source]   Given a list of mobjects and a list of mobjects to be removed, this\nfilters out the removable mobjects from the list of mobjects. Parameters : mobjects ( list ) \u2013 The Mobjects to check. to_remove ( list ) \u2013 The list of mobjects to remove. Returns : The list of mobjects with the mobjects to remove removed. Return type : list get_run_time ( animations ) [source]   Gets the total run time for a list of animations. Parameters : animations ( list [ Animation ] ) \u2013 A list of the animations whose total run_time is to be calculated. Returns : The total run_time of all of the animations in the list. Return type : float get_time_progression ( run_time , description , n_iterations = None , override_skip_animations = False ) [source]   You will hardly use this when making your own animations.\nThis method is for Manim\u2019s internal use. Returns a CommandLine ProgressBar whose fill_time is dependent on the run_time of an animation,\nthe iterations to perform in that animation\nand a bool saying whether or not to consider\nthe skipped animations. Parameters : run_time ( float ) \u2013 The run_time of the animation. n_iterations ( int | None ) \u2013 The number of iterations in the animation. override_skip_animations ( bool ) \u2013 Whether or not to show skipped animations in the progress bar. Returns : The CommandLine Progress Bar. Return type : time_progression get_top_level_mobjects ( ) [source]   Returns all mobjects which are not submobjects. Returns : List of top level mobjects. Return type : list interactive_embed ( ) [source]   Like embed(), but allows for screen interaction. is_current_animation_frozen_frame ( ) [source]   Returns whether the current animation produces a static frame (generally a Wait). Return type : bool next_section ( name = 'unnamed' , section_type = DefaultSectionType.NORMAL , skip_animations = False ) [source]   Create separation here; the last section gets finished and a new one gets created. skip_animations skips the rendering of all animations in this section.\nRefer to the documentation on how to use sections. Parameters : name ( str ) section_type ( str ) skip_animations ( bool ) Return type : None pause ( duration = 1.0 ) [source]   Pauses the scene (i.e., displays a frozen frame). This is an alias for wait() with frozen_frame set to True . Parameters : duration ( float ) \u2013 The duration of the pause. See also wait() , Wait play ( * args , subcaption = None , subcaption_duration = None , subcaption_offset = 0 , ** kwargs ) [source]   Plays an animation in this scene. Parameters : args ( Animation | Mobject | _AnimationBuilder ) \u2013 Animations to be played. subcaption \u2013 The content of the external subcaption that should\nbe added during the animation. subcaption_duration \u2013 The duration for which the specified subcaption is\nadded. If None (the default), the run time of the\nanimation is taken. subcaption_offset \u2013 An offset (in seconds) for the start time of the\nadded subcaption. kwargs \u2013 All other keywords are passed to the renderer. play_internal ( skip_rendering = False ) [source]   This method is used to prep the animations for rendering,\napply the arguments and parameters required to them,\nrender them, and write them to the video file. Parameters : skip_rendering ( bool ) \u2013 Whether the rendering should be skipped, by default False remove ( * mobjects ) [source]   Removes mobjects in the passed list of mobjects\nfrom the scene and the foreground, by removing them\nfrom \u201cmobjects\u201d and \u201cforeground_mobjects\u201d Parameters : *mobjects ( Mobject ) \u2013 The mobjects to remove. remove_foreground_mobject ( mobject ) [source]   Removes a single mobject from the foreground, and internally from the list\nforeground_mobjects. Parameters : mobject ( Mobject ) \u2013 The mobject to remove from the foreground. Returns : The Scene, with the foreground mobject removed. Return type : Scene remove_foreground_mobjects ( * to_remove ) [source]   Removes mobjects from the foreground, and internally from the list\nforeground_mobjects. Parameters : *to_remove ( Mobject ) \u2013 The mobject(s) to remove from the foreground. Returns : The Scene, with the foreground mobjects removed. Return type : Scene remove_updater ( func ) [source]   Remove an update function from the scene. Parameters : func ( Callable [ [ float ] , None ] ) \u2013 The updater function to be removed. Return type : None See also Scene.add_updater() , Scene.update_self() render ( preview = False ) [source]   Renders this Scene. Parameters : preview ( bool ) \u2013 If true, opens scene in a file viewer. replace ( old_mobject , new_mobject ) [source]   Replace one mobject in the scene with another, preserving draw order. If old_mobject is a submobject of some other Mobject (e.g. a Group ), the new_mobject will replace it inside the group,\nwithout otherwise changing the parent mobject. Parameters : old_mobject ( Mobject ) \u2013 The mobject to be replaced. Must be present in the scene. new_mobject ( Mobject ) \u2013 A mobject which must not already be in the scene. Return type : None restructure_mobjects ( to_remove , mobject_list_name = 'mobjects' , extract_families = True ) [source]   tl:wr If your scene has a Group(), and you removed a mobject from the Group,\nthis dissolves the group and puts the rest of the mobjects directly\nin self.mobjects or self.foreground_mobjects. In cases where the scene contains a group, e.g. Group(m1, m2, m3), but one\nof its submobjects is removed, e.g. scene.remove(m1), the list of mobjects\nwill be edited to contain other submobjects, but not m1, e.g. it will now\ninsert m2 and m3 to where the group once was. Parameters : to_remove ( Sequence [ Mobject ] ) \u2013 The Mobject to remove. mobject_list_name ( str ) \u2013 The list of mobjects (\u201cmobjects\u201d, \u201cforeground_mobjects\u201d etc) to remove from. extract_families ( bool ) \u2013 Whether the mobject\u2019s families should be recursively extracted. Returns : The Scene mobject with restructured Mobjects. Return type : Scene setup ( ) [source]   This is meant to be implemented by any scenes which\nare commonly subclassed, and have some common setup\ninvolved before the construct method is called. should_update_mobjects ( ) [source]   Returns True if the mobjects of this scene should be updated. In particular, this checks whether the always_update_mobjects attribute of Scene is set to True , the Scene itself has time-based updaters attached, any mobject in this Scene has time-based updaters attached. This is only called when a single Wait animation is played. Return type : bool tear_down ( ) [source]   This is meant to be implemented by any scenes which\nare commonly subclassed, and have some common method\nto be invoked before the scene ends. property time : float   The time since the start of the scene. update_mobjects ( dt ) [source]   Begins updating all mobjects in the Scene. Parameters : dt ( float ) \u2013 Change in time between updates. Defaults (mostly) to 1/frames_per_second update_self ( dt ) [source]   Run all scene updater functions. Among all types of update functions (mobject updaters, mesh updaters,\nscene updaters), scene update functions are called last. Parameters : dt ( float ) \u2013 Scene time since last update. See also Scene.add_updater() , Scene.remove_updater() wait ( duration = 1.0 , stop_condition = None , frozen_frame = None ) [source]   Plays a \u201cno operation\u201d animation. Parameters : duration ( float ) \u2013 The run time of the animation. stop_condition ( Callable [ [ ] , bool ] | None ) \u2013 A function without positional arguments that is evaluated every time\na frame is rendered. The animation only stops when the return value\nof the function is truthy, or when the time specified in duration passes. frozen_frame ( bool | None ) \u2013 If True, updater functions are not evaluated, and the animation outputs\na frozen frame. If False, updater functions are called and frames\nare rendered as usual. If None (the default), the scene tries to\ndetermine whether or not the frame is frozen on its own. See also Wait , should_mobjects_update() wait_until ( stop_condition , max_time = 60 ) [source]   Wait until a condition is satisfied, up to a given maximum duration. Parameters : stop_condition ( Callable [ [ ] , bool ] ) \u2013 A function with no arguments that determines whether or not the\nscene should keep waiting. max_time ( float ) \u2013 The maximum wait time in seconds.", "original_prompt": "class Scene(renderer=None, camera_class=<class 'manim.camera.camera.Camera'>, always_update_mobjects=False, random_seed=None, skip_animations=False)"}
{"prompt": "\"Render a function graph from an input file to an output file with specified codec.\"", "response": "Parameters : input_path ( Path ) output_path ( Path ) codec_name ( str )", "original_prompt": "convert_audio(input_path, output_path, codec_name)"}
{"prompt": "Animate a 3D model rotating around the x-axis, with the y and z axes fading in and out.", "response": "Bases: object SceneFileWriter is the object that actually writes the animations\nplayed, into video files, using FFMPEG.\nThis is mostly for Manim\u2019s internal use. You will rarely, if ever,\nhave to use the methods for this class, unless tinkering with the very\nfabric of Manim\u2019s reality. Parameters : renderer ( CairoRenderer | OpenGLRenderer ) scene_name ( StrPath ) kwargs ( Any ) sections   used to segment scene Type : list of Section sections_output_dir   where are section videos stored Type : pathlib.Path output_name   name of movie without extension and basis for section video names Type : str Some useful attributes are: \u201cwrite_to_movie\u201d (bool=False) Whether or not to write the animations into a video file. \u201cmovie_file_extension\u201d (str=\u201d.mp4\u201d) The file-type extension of the outputted video. \u201cpartial_movie_files\u201d List of all the partial-movie files. Methods add_audio_segment This method adds an audio segment from an AudioSegment type object and suitable parameters. add_partial_movie_file Adds a new partial movie file path to scene.partial_movie_files and current section from a hash. add_sound This method adds an audio segment from a sound file. begin_animation Used internally by manim to stream the animation to FFMPEG for displaying or writing to a file. clean_cache Will clean the cache by removing the oldest partial_movie_files. close_partial_movie_stream Close the currently opened video container. combine_files combine_to_movie Used internally by Manim to combine the separate partial movie files that make up a Scene into a single video file for that Scene. combine_to_section_videos Concatenate partial movie files for each section. create_audio_segment Creates an empty, silent, Audio Segment. encode_and_write_frame For internal use only: takes a given frame in np.ndarray format and write it to the stream end_animation Internally used by Manim to stop streaming to FFMPEG gracefully. finish Finishes writing to the FFMPEG buffer or writing images to output directory. finish_last_section Delete current section if it is empty. flush_cache_directory Delete all the cached partial movie files get_resolution_directory Get the name of the resolution directory directly containing the video file. init_audio Preps the writer for adding audio to the movie. init_output_directories Initialise output directories. is_already_cached Will check if a file named with hash_invocation exists. listen_and_write For internal use only: blocks until new frame is available on the queue. next_section Create segmentation cut here. open_partial_movie_stream Open a container holding a video stream. output_image print_file_ready_message Prints the \"File Ready\" message to STDOUT. save_final_image The name is a misnomer. write_frame Used internally by Manim to write a frame to the FFMPEG input buffer. write_subcaption_file Writes the subcaption file. Attributes force_output_as_scene_name add_audio_segment ( new_segment , time = None , gain_to_background = None ) [source]   This method adds an audio segment from an\nAudioSegment type object and suitable parameters. Parameters : new_segment ( AudioSegment ) \u2013 The audio segment to add time ( float | None ) \u2013 the timestamp at which the\nsound should be added. gain_to_background ( float | None ) \u2013 The gain of the segment from the background. add_partial_movie_file ( hash_animation ) [source]   Adds a new partial movie file path to scene.partial_movie_files and current section from a hash.\nThis method will compute the path from the hash. In addition to that it adds the new animation to the current section. Parameters : hash_animation ( str ) \u2013 Hash of the animation. add_sound ( sound_file , time = None , gain = None , ** kwargs ) [source]   This method adds an audio segment from a sound file. Parameters : sound_file ( str ) \u2013 The path to the sound file. time ( float | None ) \u2013 The timestamp at which the audio should be added. gain ( float | None ) \u2013 The gain of the given audio segment. **kwargs \u2013 This method uses add_audio_segment, so any keyword arguments\nused there can be referenced here. begin_animation ( allow_write = False , file_path = None ) [source]   Used internally by manim to stream the animation to FFMPEG for\ndisplaying or writing to a file. Parameters : allow_write ( bool ) \u2013 Whether or not to write to a video file. file_path ( StrPath | None ) Return type : None clean_cache ( ) [source]   Will clean the cache by removing the oldest partial_movie_files. close_partial_movie_stream ( ) [source]   Close the currently opened video container. Used internally by Manim to first flush the remaining packages\nin the video stream holding a partial file, and then close\nthe corresponding container. Return type : None combine_to_movie ( ) [source]   Used internally by Manim to combine the separate\npartial movie files that make up a Scene into a single\nvideo file for that Scene. combine_to_section_videos ( ) [source]   Concatenate partial movie files for each section. Return type : None create_audio_segment ( ) [source]   Creates an empty, silent, Audio Segment. encode_and_write_frame ( frame , num_frames ) [source]   For internal use only: takes a given frame in np.ndarray format and\nwrite it to the stream Parameters : frame ( PixelArray ) num_frames ( int ) Return type : None end_animation ( allow_write = False ) [source]   Internally used by Manim to stop streaming to\nFFMPEG gracefully. Parameters : allow_write ( bool ) \u2013 Whether or not to write to a video file. Return type : None finish ( ) [source]   Finishes writing to the FFMPEG buffer or writing images\nto output directory.\nCombines the partial movie files into the\nwhole scene.\nIf save_last_frame is True, saves the last\nframe in the default image directory. Return type : None finish_last_section ( ) [source]   Delete current section if it is empty. Return type : None flush_cache_directory ( ) [source]   Delete all the cached partial movie files get_resolution_directory ( ) [source]   Get the name of the resolution directory directly containing\nthe video file. This method gets the name of the directory that immediately contains the\nvideo file. This name is <height_in_pixels_of_video>p<frame_rate> .\nFor example, if you are rendering an 854x480 px animation at 15fps,\nthe name of the directory that immediately contains the video,  file\nwill be 480p15 . The file structure should look something like: MEDIA_DIR |-- Tex |-- texts |-- videos |--< name_of_file_containing_scene > |--< height_in_pixels_of_video > p < frame_rate > |--< scene_name >. mp4 Returns : The name of the directory. Return type : str init_audio ( ) [source]   Preps the writer for adding audio to the movie. init_output_directories ( scene_name ) [source]   Initialise output directories. Notes The directories are read from config , for example config['media_dir'] .  If the target directories don\u2019t already\nexist, they will be created. Parameters : scene_name ( StrPath ) Return type : None is_already_cached ( hash_invocation ) [source]   Will check if a file named with hash_invocation exists. Parameters : hash_invocation ( str ) \u2013 The hash corresponding to an invocation to either scene.play or scene.wait . Returns : Whether the file exists. Return type : bool listen_and_write ( ) [source]   For internal use only: blocks until new frame is available on the queue. next_section ( name , type_ , skip_animations ) [source]   Create segmentation cut here. Parameters : name ( str ) type_ ( str ) skip_animations ( bool ) Return type : None open_partial_movie_stream ( file_path = None ) [source]   Open a container holding a video stream. This is used internally by Manim initialize the container holding\nthe video stream of a partial movie file. Return type : None print_file_ready_message ( file_path ) [source]   Prints the \u201cFile Ready\u201d message to STDOUT. save_final_image ( image ) [source]   The name is a misnomer. This method saves the image\npassed to it as an in the default image directory. Parameters : image ( ndarray ) \u2013 The pixel array of the image to save. write_frame ( frame_or_renderer , num_frames = 1 ) [source]   Used internally by Manim to write a frame to\nthe FFMPEG input buffer. Parameters : frame_or_renderer ( np.ndarray | OpenGLRenderer ) \u2013 Pixel array of the frame. num_frames ( int ) \u2013 The number of times to write frame. write_subcaption_file ( ) [source]   Writes the subcaption file.", "original_prompt": "class SceneFileWriter(renderer, scene_name, **kwargs)"}
{"prompt": "\"Draw parametric helix onto canvas with specified input path.\"\n\nNote: The provided Manim code snippet does not include any visual elements, transformations, mathematical concepts, or animation sequence. It only defines parameters for drawing a curve. If you'd like to add more details, please provide the actual code snippet.", "response": "Parameters : input_path ( Path ) output_path ( Path ) codec_name ( str )", "original_prompt": "convert_audio(input_path, output_path, codec_name)"}
{"prompt": "\"Draw an ellipse on the screen with variable x-coordinates using parametric equations, centered at the origin.\"\n\nOr, if you'd like a more Manim-specific prompt:\n\n\"Animate a curve tracing out an elliptical path along the x-axis from the left edge to the right.\"", "response": "Parameters : input_path ( Path ) output_path ( Path ) codec_name ( str )", "original_prompt": "convert_audio(input_path, output_path, codec_name)"}
{"prompt": "\"Animate a 3D scene rotating from axes into a default camera view, showing spheres and axes transformations.\"", "response": "Bases: ThreeDScene An extension of ThreeDScene with more settings. It has some extra configuration for axes, spheres,\nand an override for low quality rendering. Further key differences\nare: The camera shades applicable 3DMobjects by default,\nexcept if rendering in low quality. Some default params for Spheres and Axes have been added. Methods get_axes Return a set of 3D axes. get_default_camera_position Returns the default_angled_camera position. get_sphere Returns a sphere with the passed keyword arguments as properties. set_camera_to_default_position Sets the camera to its default position. Attributes camera time The time since the start of the scene. get_axes ( ) [source]   Return a set of 3D axes. Returns : A set of 3D axes. Return type : ThreeDAxes get_default_camera_position ( ) [source]   Returns the default_angled_camera position. Returns : Dictionary of phi, theta, focal_distance, and gamma. Return type : dict get_sphere ( ** kwargs ) [source]   Returns a sphere with the passed keyword arguments as properties. Parameters : **kwargs \u2013 Any valid parameter of Sphere or Surface . Returns : The sphere object. Return type : Sphere set_camera_to_default_position ( ) [source]   Sets the camera to its default position.", "original_prompt": "class SpecialThreeDScene(cut_axes_at_radius=True, camera_config={'exponential_projection': True, 'should_apply_shading': True}, three_d_axes_config={'axis_config': {'numbers_with_elongated_ticks':"}
{"prompt": "\"Animate a 3D rotating sphere with a fixed orientation, transitioning from an unrotated state while displaying coordinate axes.\"", "response": "Bases: Scene This is a Scene, with special configurations and properties that\nmake it suitable for Three Dimensional Scenes. Methods add_fixed_in_frame_mobjects This method is used to prevent the rotation and movement of mobjects as the camera moves around. add_fixed_orientation_mobjects This method is used to prevent the rotation and tilting of mobjects as the camera moves around. begin_3dillusion_camera_rotation This method creates a 3D camera rotation illusion around the current camera orientation. begin_ambient_camera_rotation This method begins an ambient rotation of the camera about the Z_AXIS, in the anticlockwise direction get_moving_mobjects This method returns a list of all of the Mobjects in the Scene that are moving, that are also in the animations passed. move_camera This method animates the movement of the camera to the given spherical coordinates. remove_fixed_in_frame_mobjects This method undoes what add_fixed_in_frame_mobjects does. remove_fixed_orientation_mobjects This method \"unfixes\" the orientation of the mobjects passed, meaning they will no longer be at the same angle relative to the camera. set_camera_orientation This method sets the orientation of the camera in the scene. set_to_default_angled_camera_orientation This method sets the default_angled_camera_orientation to the keyword arguments passed, and sets the camera to that orientation. stop_3dillusion_camera_rotation This method stops all illusion camera rotations. stop_ambient_camera_rotation This method stops all ambient camera rotation. Attributes camera time The time since the start of the scene. add_fixed_in_frame_mobjects ( * mobjects ) [source]   This method is used to prevent the rotation and movement\nof mobjects as the camera moves around. The mobject is\nessentially overlaid, and is not impacted by the camera\u2019s\nmovement in any way. Parameters : *mobjects ( Mobject ) \u2013 The Mobjects whose orientation must be fixed. add_fixed_orientation_mobjects ( * mobjects , ** kwargs ) [source]   This method is used to prevent the rotation and tilting\nof mobjects as the camera moves around. The mobject can\nstill move in the x,y,z directions, but will always be\nat the angle (relative to the camera) that it was at\nwhen it was passed through this method.) Parameters : *mobjects ( Mobject ) \u2013 The Mobject(s) whose orientation must be fixed. **kwargs \u2013 Some valid kwargs are use_static_center_func : bool\ncenter_func : function begin_3dillusion_camera_rotation ( rate = 1 , origin_phi = None , origin_theta = None ) [source]   This method creates a 3D camera rotation illusion around\nthe current camera orientation. Parameters : rate ( float ) \u2013 The rate at which the camera rotation illusion should operate. origin_phi ( float | None ) \u2013 The polar angle the camera should move around. Defaults\nto the current phi angle. origin_theta ( float | None ) \u2013 The azimutal angle the camera should move around. Defaults\nto the current theta angle. begin_ambient_camera_rotation ( rate = 0.02 , about = 'theta' ) [source]   This method begins an ambient rotation of the camera about the Z_AXIS,\nin the anticlockwise direction Parameters : rate ( float ) \u2013 The rate at which the camera should rotate about the Z_AXIS.\nNegative rate means clockwise rotation. about ( str ) \u2013 one of 3 options: [\u201ctheta\u201d, \u201cphi\u201d, \u201cgamma\u201d]. defaults to theta. get_moving_mobjects ( * animations ) [source]   This method returns a list of all of the Mobjects in the Scene that\nare moving, that are also in the animations passed. Parameters : *animations ( Animation ) \u2013 The animations whose mobjects will be checked. move_camera ( phi = None , theta = None , gamma = None , zoom = None , focal_distance = None , frame_center = None , added_anims = [] , ** kwargs ) [source]   This method animates the movement of the camera\nto the given spherical coordinates. Parameters : phi ( float | None ) \u2013 The polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians. theta ( float | None ) \u2013 The azimuthal angle i.e the angle that spins the camera around the Z_AXIS. focal_distance ( float | None ) \u2013 The radial focal_distance between ORIGIN and Camera. gamma ( float | None ) \u2013 The rotation of the camera about the vector from the ORIGIN to the Camera. zoom ( float | None ) \u2013 The zoom factor of the camera. frame_center ( Mobject | Sequence [ float ] | None ) \u2013 The new center of the camera frame in cartesian coordinates. added_anims ( Iterable [ Animation ] ) \u2013 Any other animations to be played at the same time. remove_fixed_in_frame_mobjects ( * mobjects ) [source]   This method undoes what add_fixed_in_frame_mobjects does.\nIt allows the mobject to be affected by the movement of\nthe camera. Parameters : *mobjects ( Mobject ) \u2013 The Mobjects whose position and orientation must be unfixed. remove_fixed_orientation_mobjects ( * mobjects ) [source]   This method \u201cunfixes\u201d the orientation of the mobjects\npassed, meaning they will no longer be at the same angle\nrelative to the camera. This only makes sense if the\nmobject was passed through add_fixed_orientation_mobjects first. Parameters : *mobjects ( Mobject ) \u2013 The Mobjects whose orientation must be unfixed. set_camera_orientation ( phi = None , theta = None , gamma = None , zoom = None , focal_distance = None , frame_center = None , ** kwargs ) [source]   This method sets the orientation of the camera in the scene. Parameters : phi ( float | None ) \u2013 The polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians. theta ( float | None ) \u2013 The azimuthal angle i.e the angle that spins the camera around the Z_AXIS. focal_distance ( float | None ) \u2013 The focal_distance of the Camera. gamma ( float | None ) \u2013 The rotation of the camera about the vector from the ORIGIN to the Camera. zoom ( float | None ) \u2013 The zoom factor of the scene. frame_center ( Mobject | Sequence [ float ] | None ) \u2013 The new center of the camera frame in cartesian coordinates. set_to_default_angled_camera_orientation ( ** kwargs ) [source]   This method sets the default_angled_camera_orientation to the\nkeyword arguments passed, and sets the camera to that orientation. Parameters : **kwargs \u2013 Some recognised kwargs are phi, theta, focal_distance, gamma,\nwhich have the same meaning as the parameters in set_camera_orientation. stop_3dillusion_camera_rotation ( ) [source]   This method stops all illusion camera rotations. stop_ambient_camera_rotation ( about = 'theta' ) [source]   This method stops all ambient camera rotation.", "original_prompt": "class ThreeDScene(camera_class=<class 'manim.camera.three_d_camera.ThreeDCamera'>, ambient_camera_rotation=None, default_angled_camera_orientation_kwargs=None, **kwargs)"}
{"prompt": "It appears that you are asking me to write a code snippet or function in Python based on the provided documentation for the Manim animation library. However, I don't see any specific request or problem to solve.\n\nIf you could provide more context or clarify what you would like me to do, I'll be happy to help.\n\nThat being said, I can provide some examples of functions that are commonly used in Manim scenes:\n\n**Example 1: Applying a transformation**\n```python\nmatrix = np.array([[2, 0], [0, 3]])  # rotation matrix\nscene.apply_matrix(matrix)\n```\n\n**Example 2: Writing vector coordinates to the screen**\n```python\nvector = Vector([4, 5])\ncoordinates = scene.write_vector_coordinates(vector)\nprint(coordinates)  # prints the coordinates as a column matrix\n```\n\n**Example 3: Applying an inverse transformation**\n```python\nmatrix = np.array([[2, 0], [0, 3]])  # rotation matrix\ninverse_matrix = np.linalg.inv(matrix)\nscene.apply_inverse(inverse_matrix)\n```\n\nPlease let me know if you have any specific questions or requests, and I'll be happy to help!", "response": "Bases: VectorScene This scene contains special methods that make it\nespecially suitable for showing linear transformations. Parameters : include_background_plane ( bool ) \u2013 Whether or not to include the background plane in the scene. include_foreground_plane ( bool ) \u2013 Whether or not to include the foreground plane in the scene. background_plane_kwargs ( dict | None ) \u2013 Parameters to be passed to NumberPlane to adjust the background plane. foreground_plane_kwargs ( dict | None ) \u2013 Parameters to be passed to NumberPlane to adjust the foreground plane. show_coordinates ( bool ) \u2013 Whether or not to include the coordinates for the background plane. show_basis_vectors ( bool ) \u2013 Whether to show the basis x_axis -> i_hat and y_axis -> j_hat vectors. basis_vector_stroke_width ( float ) \u2013 The stroke_width of the basis vectors. i_hat_color ( ParsableManimColor ) \u2013 The color of the i_hat vector. j_hat_color ( ParsableManimColor ) \u2013 The color of the j_hat vector. leave_ghost_vectors ( bool ) \u2013 Indicates the previous position of the basis vectors following a transformation. Examples Example: LinearTransformationSceneExample   from manim import * class LinearTransformationSceneExample ( LinearTransformationScene ): def __init__ ( self , ** kwargs ): LinearTransformationScene . __init__ ( self , show_coordinates = True , leave_ghost_vectors = True , ** kwargs ) def construct ( self ): matrix = [[ 1 , 1 ], [ 0 , 1 ]] self . apply_matrix ( matrix ) self . wait () class LinearTransformationSceneExample(LinearTransformationScene):\n    def __init__(self, **kwargs):\n        LinearTransformationScene.__init__(\n            self,\n            show_coordinates=True,\n            leave_ghost_vectors=True,\n            **kwargs\n        )\n\n    def construct(self):\n        matrix = [[1, 1], [0, 1]]\n        self.apply_matrix(matrix)\n        self.wait() Methods add_background_mobject Adds the mobjects to the special list self.background_mobjects. add_foreground_mobject Adds the mobjects to the special list self.foreground_mobjects. add_moving_mobject Adds the mobject to the special list self.moving_mobject, and adds a property to the mobject called mobject.target, which keeps track of what the mobject will move to or become etc. add_special_mobjects Adds mobjects to a separate list that can be tracked, if these mobjects have some extra importance. add_title Adds a title, after scaling it, adding a background rectangle, moving it to the top and adding it to foreground_mobjects adding it as a local variable of self. add_transformable_label Method for creating, and animating the addition of a transformable label for the vector. add_transformable_mobject Adds the mobjects to the special list self.transformable_mobjects. add_unit_square Adds a unit square to the scene via self.get_unit_square. add_vector Adds a vector to the scene, and puts it in the special list self.moving_vectors. apply_function Applies the given function to each of the mobjects in self.transformable_mobjects, and plays the animation showing this. apply_inverse This method applies the linear transformation represented by the inverse of the passed matrix to the number plane, and each vector/similar mobject on it. apply_inverse_transpose Applies the inverse of the transformation represented by the given transposed matrix to the number plane and each vector/similar mobject on it. apply_matrix Applies the transformation represented by the given matrix to the number plane, and each vector/similar mobject on it. apply_nonlinear_transformation Applies the non-linear transformation represented by the given function to the number plane and each vector/similar mobject on it. apply_transposed_matrix Applies the transformation represented by the given transposed matrix to the number plane, and each vector/similar mobject on it. get_ghost_vectors Returns all ghost vectors ever added to self . get_matrix_transformation Returns a function corresponding to the linear transformation represented by the matrix passed. get_moving_mobject_movement This method returns an animation that moves a mobject in \"self.moving_mobjects\"  to its corresponding .target value. get_piece_movement This method returns an animation that moves an arbitrary mobject in \"pieces\" to its corresponding .target value. get_transformable_label_movement This method returns an animation that moves all labels in \"self.transformable_labels\" to its corresponding .target . get_transposed_matrix_transformation Returns a function corresponding to the linear transformation represented by the transposed matrix passed. get_unit_square Returns a unit square for the current NumberPlane. get_vector_movement This method returns an animation that moves a mobject in \"self.moving_vectors\"  to its corresponding .target value. setup This is meant to be implemented by any scenes which are commonly subclassed, and have some common setup involved before the construct method is called. update_default_configs write_vector_coordinates Returns a column matrix indicating the vector coordinates, after writing them to the screen, and adding them to the special list self.foreground_mobjects Attributes camera time The time since the start of the scene. add_background_mobject ( * mobjects ) [source]   Adds the mobjects to the special list\nself.background_mobjects. Parameters : *mobjects ( Mobject ) \u2013 The mobjects to add to the list. add_foreground_mobject ( * mobjects ) [source]   Adds the mobjects to the special list\nself.foreground_mobjects. Parameters : *mobjects ( Mobject ) \u2013 The mobjects to add to the list add_moving_mobject ( mobject , target_mobject = None ) [source]   Adds the mobject to the special list\nself.moving_mobject, and adds a property\nto the mobject called mobject.target, which\nkeeps track of what the mobject will move to\nor become etc. Parameters : mobject ( Mobject ) \u2013 The mobjects to add to the list target_mobject ( Mobject | None ) \u2013 What the moving_mobject goes to, etc. add_special_mobjects ( mob_list , * mobs_to_add ) [source]   Adds mobjects to a separate list that can be tracked,\nif these mobjects have some extra importance. Parameters : mob_list ( list ) \u2013 The special list to which you want to add\nthese mobjects. *mobs_to_add ( Mobject ) \u2013 The mobjects to add. add_title ( title , scale_factor = 1.5 , animate = False ) [source]   Adds a title, after scaling it, adding a background rectangle,\nmoving it to the top and adding it to foreground_mobjects adding\nit as a local variable of self. Returns the Scene. Parameters : title ( str | MathTex | Tex ) \u2013 What the title should be. scale_factor ( float ) \u2013 How much the title should be scaled by. animate ( bool ) \u2013 Whether or not to animate the addition. Returns : The scene with the title added to it. Return type : LinearTransformationScene add_transformable_label ( vector , label , transformation_name = 'L' , new_label = None , ** kwargs ) [source]   Method for creating, and animating the addition of\na transformable label for the vector. Parameters : vector ( Vector ) \u2013 The vector for which the label must be added. label ( MathTex | str ) \u2013 The MathTex/string of the label. transformation_name ( str | MathTex ) \u2013 The name to give the transformation as a label. new_label ( str | MathTex | None ) \u2013 What the label should display after a Linear Transformation **kwargs \u2013 Any valid keyword argument of get_vector_label Returns : The MathTex of the label. Return type : MathTex add_transformable_mobject ( * mobjects ) [source]   Adds the mobjects to the special list\nself.transformable_mobjects. Parameters : *mobjects ( Mobject ) \u2013 The mobjects to add to the list. add_unit_square ( animate = False , ** kwargs ) [source]   Adds a unit square to the scene via\nself.get_unit_square. Parameters : animate ( bool ) \u2013 Whether or not to animate the addition\nwith DrawBorderThenFill. **kwargs \u2013 Any valid keyword arguments of\nself.get_unit_square() Returns : The unit square. Return type : Square add_vector ( vector , color = ManimColor('#FFFF00') , ** kwargs ) [source]   Adds a vector to the scene, and puts it in the special\nlist self.moving_vectors. Parameters : vector ( Arrow | list | tuple | ndarray ) \u2013 It can be a pre-made graphical vector, or the\ncoordinates of one. color ( str ) \u2013 The string of the hex color of the vector.\nThis is only taken into consideration if\n\u2018vector\u2019 is not an Arrow. Defaults to YELLOW. **kwargs \u2013 Any valid keyword argument of VectorScene.add_vector. Returns : The arrow representing the vector. Return type : Arrow apply_function ( function , added_anims = [] , ** kwargs ) [source]   Applies the given function to each of the mobjects in\nself.transformable_mobjects, and plays the animation showing\nthis. Parameters : function ( Callable [ [ ndarray ] , ndarray ] ) \u2013 The function that affects each point\nof each mobject in self.transformable_mobjects. added_anims ( list ) \u2013 Any other animations that need to be played\nsimultaneously with this. **kwargs \u2013 Any valid keyword argument of a self.play() call. apply_inverse ( matrix , ** kwargs ) [source]   This method applies the linear transformation\nrepresented by the inverse of the passed matrix\nto the number plane, and each vector/similar mobject on it. Parameters : matrix ( ndarray | list | tuple ) \u2013 The matrix whose inverse is to be applied. **kwargs \u2013 Any valid keyword argument of self.apply_matrix() apply_inverse_transpose ( t_matrix , ** kwargs ) [source]   Applies the inverse of the transformation represented\nby the given transposed matrix to the number plane and each\nvector/similar mobject on it. Parameters : t_matrix ( ndarray | list | tuple ) \u2013 The matrix. **kwargs \u2013 Any valid keyword argument of self.apply_transposed_matrix() apply_matrix ( matrix , ** kwargs ) [source]   Applies the transformation represented by the\ngiven matrix to the number plane, and each vector/similar\nmobject on it. Parameters : matrix ( ndarray | list | tuple ) \u2013 The matrix. **kwargs \u2013 Any valid keyword argument of self.apply_transposed_matrix() apply_nonlinear_transformation ( function , ** kwargs ) [source]   Applies the non-linear transformation represented\nby the given function to the number plane and each\nvector/similar mobject on it. Parameters : function ( Callable [ [ ndarray ] , ndarray ] ) \u2013 The function. **kwargs \u2013 Any valid keyword argument of self.apply_function() apply_transposed_matrix ( transposed_matrix , ** kwargs ) [source]   Applies the transformation represented by the\ngiven transposed matrix to the number plane,\nand each vector/similar mobject on it. Parameters : transposed_matrix ( ndarray | list | tuple ) \u2013 The matrix. **kwargs \u2013 Any valid keyword argument of self.apply_function() get_ghost_vectors ( ) [source]   Returns all ghost vectors ever added to self . Each element is a VGroup of\ntwo ghost vectors. Return type : VGroup get_matrix_transformation ( matrix ) [source]   Returns a function corresponding to the linear\ntransformation represented by the matrix passed. Parameters : matrix ( ndarray | list | tuple ) \u2013 The matrix. get_moving_mobject_movement ( func ) [source]   This method returns an animation that moves a mobject\nin \u201cself.moving_mobjects\u201d  to its corresponding .target value.\nfunc is a function that determines where the .target goes. Parameters : func ( Callable [ [ ndarray ] , ndarray ] ) \u2013 The function that determines where the .target of\nthe moving mobject goes. Returns : The animation of the movement. Return type : Animation get_piece_movement ( pieces ) [source]   This method returns an animation that moves an arbitrary\nmobject in \u201cpieces\u201d to its corresponding .target value.\nIf self.leave_ghost_vectors is True, ghosts of the original\npositions/mobjects are left on screen Parameters : pieces ( list | tuple | ndarray ) \u2013 The pieces for which the movement must be shown. Returns : The animation of the movement. Return type : Animation get_transformable_label_movement ( ) [source]   This method returns an animation that moves all labels\nin \u201cself.transformable_labels\u201d to its corresponding .target . Returns : The animation of the movement. Return type : Animation get_transposed_matrix_transformation ( transposed_matrix ) [source]   Returns a function corresponding to the linear\ntransformation represented by the transposed\nmatrix passed. Parameters : transposed_matrix ( ndarray | list | tuple ) \u2013 The matrix. get_unit_square ( color = ManimColor('#FFFF00') , opacity = 0.3 , stroke_width = 3 ) [source]   Returns a unit square for the current NumberPlane. Parameters : color ( str ) \u2013 The string of the hex color code of the color wanted. opacity ( float ) \u2013 The opacity of the square stroke_width ( float ) \u2013 The stroke_width in pixels of the border of the square Return type : Square get_vector_movement ( func ) [source]   This method returns an animation that moves a mobject\nin \u201cself.moving_vectors\u201d  to its corresponding .target value.\nfunc is a function that determines where the .target goes. Parameters : func ( Callable [ [ ndarray ] , ndarray ] ) \u2013 The function that determines where the .target of\nthe moving mobject goes. Returns : The animation of the movement. Return type : Animation setup ( ) [source]   This is meant to be implemented by any scenes which\nare commonly subclassed, and have some common setup\ninvolved before the construct method is called. write_vector_coordinates ( vector , ** kwargs ) [source]   Returns a column matrix indicating the vector coordinates,\nafter writing them to the screen, and adding them to the\nspecial list self.foreground_mobjects Parameters : vector ( Arrow ) \u2013 The arrow representing the vector. **kwargs \u2013 Any valid keyword arguments of VectorScene.write_vector_coordinates Returns : The column matrix representing the vector. Return type : Matrix", "original_prompt": "class LinearTransformationScene(include_background_plane=True, include_foreground_plane=True, background_plane_kwargs=None, foreground_plane_kwargs=None, show_coordinates=False, show_basis_vectors=True, basis_vector_stroke_width=6, i_hat_color=ManimColor('#83C167'), j_hat_color=ManimColor('#FC6255'), leave_ghost_vectors=False, **kwargs)"}
{"prompt": "Animate an arrow that transforms into a number plane while showing coordinates on a grid.", "response": "Bases: Scene Methods add_axes Adds a pair of Axes to the Scene. add_plane Adds a NumberPlane object to the background. add_vector Returns the Vector after adding it to the Plane. coords_to_vector This method writes the vector as a column matrix (henceforth called the label), takes the values in it one by one, and form the corresponding lines that make up the x and y components of the vector. get_basis_vector_labels Returns naming labels for the basis vectors. get_basis_vectors Returns a VGroup of the Basis Vectors (1,0) and (0,1) get_vector Returns an arrow on the Plane given an input numerical vector. get_vector_label Returns naming labels for the passed vector. label_vector Shortcut method for creating, and animating the addition of a label for the vector. lock_in_faded_grid This method freezes the NumberPlane and Axes that were already in the background, and adds new, manipulatable ones to the foreground. position_x_coordinate position_y_coordinate show_ghost_movement This method plays an animation that partially shows the entire plane moving in the direction of a particular vector. vector_to_coords This method displays vector as a Vector() based vector, and then shows the corresponding lines that make up the x and y components of the vector. write_vector_coordinates Returns a column matrix indicating the vector coordinates, after writing them to the screen. Attributes camera time The time since the start of the scene. add_axes ( animate = False , color = ManimColor('#FFFFFF') , ** kwargs ) [source]   Adds a pair of Axes to the Scene. Parameters : animate ( bool ) \u2013 Whether or not to animate the addition of the axes through Create. color ( bool ) \u2013 The color of the axes. Defaults to WHITE. add_plane ( animate = False , ** kwargs ) [source]   Adds a NumberPlane object to the background. Parameters : animate ( bool ) \u2013 Whether or not to animate the addition of the plane via Create. **kwargs \u2013 Any valid keyword arguments accepted by NumberPlane. Returns : The NumberPlane object. Return type : NumberPlane add_vector ( vector , color = ManimColor('#FFFF00') , animate = True , ** kwargs ) [source]   Returns the Vector after adding it to the Plane. Parameters : vector ( Arrow | list | tuple | ndarray ) \u2013 It can be a pre-made graphical vector, or the\ncoordinates of one. color ( str ) \u2013 The string of the hex color of the vector.\nThis is only taken into consideration if\n\u2018vector\u2019 is not an Arrow. Defaults to YELLOW. animate ( bool ) \u2013 Whether or not to animate the addition of the vector\nby using GrowArrow **kwargs \u2013 Any valid keyword argument of Arrow.\nThese are only considered if vector is not\nan Arrow. Returns : The arrow representing the vector. Return type : Arrow coords_to_vector ( vector , coords_start = array([2., 2., 0.]) , clean_up = True ) [source]   This method writes the vector as a column matrix (henceforth called the label),\ntakes the values in it one by one, and form the corresponding\nlines that make up the x and y components of the vector. Then, an\nVector() based vector is created between the lines on the Screen. Parameters : vector ( ndarray | list | tuple ) \u2013 The vector to show. coords_start ( ndarray | list | tuple ) \u2013 The starting point of the location of\nthe label of the vector that shows it\nnumerically.\nDefaults to 2 * RIGHT + 2 * UP or (2,2) clean_up ( bool ) \u2013 Whether or not to remove whatever\nthis method did after it\u2019s done. get_basis_vector_labels ( ** kwargs ) [source]   Returns naming labels for the basis vectors. Parameters : **kwargs \u2013 Any valid keyword arguments of get_vector_label: vector,\nlabel (str,MathTex)\nat_tip (bool=False),\ndirection (str=\u201dleft\u201d),\nrotate (bool),\ncolor (str),\nlabel_scale_factor=VECTOR_LABEL_SCALE_FACTOR (int, float), get_basis_vectors ( i_hat_color = ManimColor('#83C167') , j_hat_color = ManimColor('#FC6255') ) [source]   Returns a VGroup of the Basis Vectors (1,0) and (0,1) Parameters : i_hat_color ( str ) \u2013 The hex colour to use for the basis vector in the x direction j_hat_color ( str ) \u2013 The hex colour to use for the basis vector in the y direction Returns : VGroup of the Vector Mobjects representing the basis vectors. Return type : VGroup get_vector ( numerical_vector , ** kwargs ) [source]   Returns an arrow on the Plane given an input numerical vector. Parameters : numerical_vector ( ndarray | list | tuple ) \u2013 The Vector to plot. **kwargs \u2013 Any valid keyword argument of Arrow. Returns : The Arrow representing the Vector. Return type : Arrow get_vector_label ( vector , label , at_tip = False , direction = 'left' , rotate = False , color = None , label_scale_factor = 0.8 ) [source]   Returns naming labels for the passed vector. Parameters : vector ( Vector ) \u2013 Vector Object for which to get the label. at_tip ( bool ) \u2013 Whether or not to place the label at the tip of the vector. direction ( str ) \u2013 If the label should be on the \u201cleft\u201d or right of the vector. rotate ( bool ) \u2013 Whether or not to rotate it to align it with the vector. color ( str | None ) \u2013 The color to give the label. label_scale_factor ( float ) \u2013 How much to scale the label by. Returns : The MathTex of the label. Return type : MathTex label_vector ( vector , label , animate = True , ** kwargs ) [source]   Shortcut method for creating, and animating the addition of\na label for the vector. Parameters : vector ( Vector ) \u2013 The vector for which the label must be added. label ( MathTex | str ) \u2013 The MathTex/string of the label. animate ( bool ) \u2013 Whether or not to animate the labelling w/ Write **kwargs \u2013 Any valid keyword argument of get_vector_label Returns : The MathTex of the label. Return type : MathTex lock_in_faded_grid ( dimness = 0.7 , axes_dimness = 0.5 ) [source]   This method freezes the NumberPlane and Axes that were already\nin the background, and adds new, manipulatable ones to the foreground. Parameters : dimness ( float ) \u2013 The required dimness of the NumberPlane axes_dimness ( float ) \u2013 The required dimness of the Axes. show_ghost_movement ( vector ) [source]   This method plays an animation that partially shows the entire plane moving\nin the direction of a particular vector. This is useful when you wish to\nconvey the idea of mentally moving the entire plane in a direction, without\nactually moving the plane. Parameters : vector ( Arrow | list | tuple | ndarray ) \u2013 The vector which indicates the direction of movement. vector_to_coords ( vector , integer_labels = True , clean_up = True ) [source]   This method displays vector as a Vector() based vector, and then shows\nthe corresponding lines that make up the x and y components of the vector.\nThen, a column matrix (henceforth called the label) is created near the\nhead of the Vector. Parameters : vector ( ndarray | list | tuple ) \u2013 The vector to show. integer_labels ( bool ) \u2013 Whether or not to round the value displayed.\nin the vector\u2019s label to the nearest integer clean_up ( bool ) \u2013 Whether or not to remove whatever\nthis method did after it\u2019s done. write_vector_coordinates ( vector , ** kwargs ) [source]   Returns a column matrix indicating the vector coordinates,\nafter writing them to the screen. Parameters : vector ( Arrow ) \u2013 The arrow representing the vector. **kwargs \u2013 Any valid keyword arguments of coordinate_label() : Returns : The column matrix representing the vector. Return type : Matrix", "original_prompt": "class VectorScene(basis_vector_stroke_width=6, **kwargs)"}
{"prompt": "\"Zoom in on a moving camera with a dynamic mini-display that pops out and fades away.\"", "response": "Bases: MovingCameraScene This is a Scene with special configurations made for when\na particular part of the scene must be zoomed in on and displayed\nseparately. Methods activate_zooming This method is used to activate the zooming for the zoomed_camera. get_zoom_factor Returns the Zoom factor of the Zoomed camera. get_zoom_in_animation Returns the animation of camera zooming in. get_zoomed_display_pop_out_animation This is the animation of the popping out of the mini-display that shows the content of the zoomed camera. setup This method is used internally by Manim to setup the scene for proper use. Attributes camera time The time since the start of the scene. activate_zooming ( animate = False ) [source]   This method is used to activate the zooming for\nthe zoomed_camera. Parameters : animate ( bool ) \u2013 Whether or not to animate the activation\nof the zoomed camera. get_zoom_factor ( ) [source]   Returns the Zoom factor of the Zoomed camera.\nDefined as the ratio between the height of the\nzoomed camera and the height of the zoomed mini\ndisplay.\n:returns: The zoom factor.\n:rtype: float get_zoom_in_animation ( run_time = 2 , ** kwargs ) [source]   Returns the animation of camera zooming in. Parameters : run_time ( float ) \u2013 The run_time of the animation of the camera zooming in. **kwargs \u2013 Any valid keyword arguments of ApplyMethod() Returns : The animation of the camera zooming in. Return type : ApplyMethod get_zoomed_display_pop_out_animation ( ** kwargs ) [source]   This is the animation of the popping out of the\nmini-display that shows the content of the zoomed\ncamera. Returns : The Animation of the Zoomed Display popping out. Return type : ApplyMethod setup ( ) [source]   This method is used internally by Manim to\nsetup the scene for proper use.", "original_prompt": "class ZoomedScene(camera_class=<class 'manim.camera.multi_camera.MultiCamera'>, zoomed_display_height=3, zoomed_display_width=3, zoomed_display_center=None, zoomed_display_corner=array("}
{"prompt": "Animate a curve with variable control points being evaluated along its length.", "response": "Classic implementation of a B\u00e9zier curve. Parameters : points \u2013 \\((d+1, 3)\\) -shaped array of \\(d+1\\) control points defining a single B\u00e9zier\ncurve of degree \\(d\\) . Alternatively, for vectorization purposes, points can\nalso be a \\((d+1, M, 3)\\) -shaped sequence of \\(d+1\\) arrays of \\(M\\) control points each, which define M B\u00e9zier curves instead. Returns : bezier_func \u2013 Function describing the B\u00e9zier curve. The behaviour of this function depends on\nthe shape of points : If points was a \\((d+1, 3)\\) array representing a single B\u00e9zier curve,\nthen bezier_func can receive either: a float t , in which case it returns a\nsingle \\((1, 3)\\) -shaped Point3D representing the evaluation\nof the B\u00e9zier at t , or an \\((n, 1)\\) -shaped ColVector containing \\(n\\) values to evaluate the B\u00e9zier curve at, returning instead\nan \\((n, 3)\\) -shaped Point3D_Array containing the points\nresulting from evaluating the B\u00e9zier at each of the \\(n\\) values. Warning If passing a vector of \\(t\\) -values to bezier_func , it must be a column vector/matrix of shape \\((n, 1)\\) . Passing an 1D array of\nshape \\((n,)\\) is not supported and will result in undefined behaviour . If points was a \\((d+1, M, 3)\\) array describing \\(M\\) B\u00e9zier curves,\nthen bezier_func can receive either: a float t , in which case it returns an \\((M, 3)\\) -shaped Point3D_Array representing the evaluation\nof the \\(M\\) B\u00e9zier curves at the same value t , or an \\((M, 1)\\) -shaped ColVector containing \\(M\\) values, such that the \\(i\\) -th\nB\u00e9zier curve defined by points is evaluated at the corresponding \\(i\\) -th\nvalue in t , returning again an \\((M, 3)\\) -shaped Point3D_Array containing those \\(M\\) evaluations. Warning Unlike the previous case, if you pass a ColVector to bezier_func ,\nit must contain exactly \\(M\\) values, each value for each of the \\(M\\) B\u00e9zier curves defined by points . Any array of shape other than \\((M, 1)\\) will result in undefined behaviour . Return type : typing.Callable [[ float | ColVector ], Point3D | Point3D_Array ]", "original_prompt": "bezier(points: BezierPointsLike) \u2192 Callable"}
{"prompt": "\"Subdivide each Bezier curve into more segments until it reaches a desired number.\"", "response": "Subdivides each curve in bezier_tuples into as many parts as necessary, until the final number of\ncurves reaches a desired amount, new_number_of_curves . Parameters : bezier_tuples ( BezierPointsLike_Array ) \u2013 An array of multiple B\u00e9zier curves of degree \\(d\\) to be remapped. The shape of this array\nmust be (current_number_of_curves, nppc, dim) , where: current_number_of_curves is the current amount of curves in the array bezier_tuples , nppc is the amount of points per curve, such that their degree is nppc-1 , and dim is the dimension of the points, usually \\(3\\) . new_number_of_curves ( int ) \u2013 The number of curves that the output will contain. This needs to be higher than the current number. Returns : The new array of shape (new_number_of_curves, nppc, dim) ,\ncontaining the new B\u00e9zier curves after the remap. Return type : BezierPoints_Array", "original_prompt": "bezier_remap(bezier_tuples, new_number_of_curves)"}
{"prompt": "\"Generate a smooth quadratic B\u00e9zier curve from a given cubic B\u00e9zier curve's control points by finding intermediate handles.\"", "response": "If a0 , h0 , h1 and a1 are the control points of a cubic\nB\u00e9zier curve, approximate the curve with two quadratic B\u00e9zier curves and\nreturn an array of 6 points, where the first 3 points represent the first\nquadratic curve and the last 3 represent the second one. Otherwise, if a0 , h0 , h1 and a1 are _arrays_ of \\(N\\) points representing \\(N\\) cubic B\u00e9zier curves, return an array of \\(6N\\) points where each group of \\(6\\) consecutive points\napproximates each of the \\(N\\) curves in a similar way as above. Note If the cubic spline given by the original cubic B\u00e9zier curves is\nsmooth, this algorithm will generate a quadratic spline which is also\nsmooth. If a cubic B\u00e9zier is given by \\[C(t) = (1-t)^3 A_0 + 3(1-t)^2 t H_0 + 3(1-t)t^2 H_1 + t^3 A_1\\] where \\(A_0\\) , \\(H_0\\) , \\(H_1\\) and \\(A_1\\) are its\ncontrol points, then this algorithm should generate two quadratic\nB\u00e9ziers given by \\[\\begin{split}Q_0(t) &= (1-t)^2 A_0 + 2(1-t)t M_0 + t^2 K \\\\\nQ_1(t) &= (1-t)^2 K + 2(1-t)t M_1 + t^2 A_1\\end{split}\\] where \\(M_0\\) and \\(M_1\\) are the respective handles to be\nfound for both curves, and \\(K\\) is the end anchor of the 1st curve\nand the start anchor of the 2nd, which must also be found. To solve for \\(M_0\\) , \\(M_1\\) and \\(K\\) , three conditions\ncan be imposed: \\(Q_0'(0) = \\frac{1}{2}C'(0)\\) . The derivative of the first\nquadratic curve at \\(t = 0\\) should be proportional to that of\nthe original cubic curve, also at \\(t = 0\\) . Because the cubic\ncurve is split into two parts, it is necessary to divide this by\ntwo: the speed of a point travelling through the curve should be\nhalf of the original. This gives: \\[\\begin{split}Q_0'(0) &= \\frac{1}{2}C'(0) \\\\\n2(M_0 - A_0) &= \\frac{3}{2}(H_0 - A_0) \\\\\n2M_0 - 2A_0 &= \\frac{3}{2}H_0 - \\frac{3}{2}A_0 \\\\\n2M_0 &= \\frac{3}{2}H_0 + \\frac{1}{2}A_0 \\\\\nM_0 &= \\frac{1}{4}(3H_0 + A_0)\\end{split}\\] \\(Q_1'(1) = \\frac{1}{2}C'(1)\\) . The derivative of the second\nquadratic curve at \\(t = 1\\) should be half of that of the\noriginal cubic curve for the same reasons as above, also at \\(t = 1\\) . This gives: \\[\\begin{split}Q_1'(1) &= \\frac{1}{2}C'(1) \\\\\n2(A_1 - M_1) &= \\frac{3}{2}(A_1 - H_1) \\\\\n2A_1 - 2M_1 &= \\frac{3}{2}A_1 - \\frac{3}{2}H_1 \\\\\n-2M_1 &= -\\frac{1}{2}A_1 - \\frac{3}{2}H_1 \\\\\nM_1 &= \\frac{1}{4}(3H_1 + A_1)\\end{split}\\] \\(Q_0'(1) = Q_1'(0)\\) . The derivatives of both quadratic curves\nshould match at the point \\(K\\) , in order for the final spline\nto be smooth. This gives: \\[\\begin{split}Q_0'(1) &= Q_1'(0) \\\\\n2(K - M_0) &= 2(M_1 - K) \\\\\n2K - 2M_0 &= 2M_1 - 2K \\\\\n4K &= 2M_0 + 2M_1 \\\\\nK &= \\frac{1}{2}(M_0 + M_1)\\end{split}\\] This is sufficient to find proper control points for the quadratic\nB\u00e9zier curves. Parameters : a0 \u2013 The start anchor of a single cubic B\u00e9zier curve, or an array of \\(N\\) start anchors for \\(N\\) curves. h0 \u2013 The first handle of a single cubic B\u00e9zier curve, or an array of \\(N\\) first handles for \\(N\\) curves. h1 \u2013 The second handle of a single cubic B\u00e9zier curve, or an array of \\(N\\) second handles for \\(N\\) curves. a1 \u2013 The end anchor of a single cubic B\u00e9zier curve, or an array of \\(N\\) end anchors for \\(N\\) curves. Returns : An array containing either 6 points for 2 quadratic B\u00e9zier curves\napproximating the original cubic curve, or \\(6N\\) points for \\(2N\\) quadratic curves approximating \\(N\\) cubic curves. Return type : result Raises : ValueError \u2013 If a0 , h0 , h1 and a1 have different dimensions, or\n    if their number of dimensions is not 1 or 2.", "original_prompt": "get_quadratic_approximation_of_cubic(a0: Point3DLike, h0: Point3DLike, h1: Point3DLike, a1: Point3DLike) \u2192 QuadraticSpline"}
{"prompt": "I can help you with that! However, I notice that the code snippet you provided is a C++ implementation of a closed cubic spline solver. It appears to be a part of a larger library or framework.\n\nIf you'd like, I can try to assist you with understanding the code and providing guidance on how to use it. Alternatively, if you have specific questions about the code or would like me to explain certain sections in more detail, please feel free to ask!\n\nHere is an example of how you might use this function:\n```cpp\n#include <cmath>\n\n// Define anchors ( Point3DLike_Array )\nPoint3DLike_Array anchors;\n\n// Create a closed cubic spline solver\nClosedCubicSplineSolver solver(anchors);\n\n// Get the 1st handle for every curve in the closed cubic spline\nPoint3D_Array firstHandles = solver.getFirstHandle();\n\n// Get the 2nd handles for every curve in the closed cubic spline\nPoint3D_Array secondHandles = solver.getSecondHandle();\n```\nPlease note that this is just an example, and you will need to consult the documentation for the `ClosedCubicSplineSolver` class and its methods to understand how to use them correctly.\n\nIf you have any specific questions or would like further assistance, please don't hesitate to ask!", "response": "Special case of get_smooth_cubic_bezier_handle_points() ,\nwhen the anchors form a closed loop. Note A system of equations must be solved to get the first handles of\nevery B\u00e9zier curve (referred to as \\(H_1\\) ).\nThen \\(H_2\\) (the second handles) can be obtained separately. See also The equations were obtained from: Conditions on control points for continuous curvature. (2016). Jaco Stuifbergen. In general, if there are \\(N+1\\) anchors, there will be \\(N\\) B\u00e9zier curves\nand thus \\(N\\) pairs of handles to find. We must solve the following\nsystem of equations for the 1st handles (example for \\(N = 5\\) ): \\[\\begin{split}\\begin{pmatrix}\n    4 & 1 & 0 & 0 & 1 \\\\\n    1 & 4 & 1 & 0 & 0 \\\\\n    0 & 1 & 4 & 1 & 0 \\\\\n    0 & 0 & 1 & 4 & 1 \\\\\n    1 & 0 & 0 & 1 & 4\n\\end{pmatrix}\n\\begin{pmatrix}\n    H_{1,0} \\\\\n    H_{1,1} \\\\\n    H_{1,2} \\\\\n    H_{1,3} \\\\\n    H_{1,4}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n    4A_0 + 2A_1 \\\\\n    4A_1 + 2A_2 \\\\\n    4A_2 + 2A_3 \\\\\n    4A_3 + 2A_4 \\\\\n    4A_4 + 2A_5\n\\end{pmatrix}\\end{split}\\] which will be expressed as \\(RH_1 = D\\) . \\(R\\) is almost a tridiagonal matrix, so we could use Thomas\u2019 algorithm. See also Tridiagonal matrix algorithm. Wikipedia. However, \\(R\\) has ones at the opposite corners. A solution to this is\nthe first decomposition proposed in the link below, with \\(\\alpha = 1\\) : See also Tridiagonal matrix algorithm # Variants. Wikipedia. \\[\\begin{split}R\n=\n\\begin{pmatrix}\n    4 & 1 & 0 & 0 & 1 \\\\\n    1 & 4 & 1 & 0 & 0 \\\\\n    0 & 1 & 4 & 1 & 0 \\\\\n    0 & 0 & 1 & 4 & 1 \\\\\n    1 & 0 & 0 & 1 & 4\n\\end{pmatrix}\n&=\n\\begin{pmatrix}\n    3 & 1 & 0 & 0 & 0 \\\\\n    1 & 4 & 1 & 0 & 0 \\\\\n    0 & 1 & 4 & 1 & 0 \\\\\n    0 & 0 & 1 & 4 & 1 \\\\\n    0 & 0 & 0 & 1 & 3\n\\end{pmatrix}\n+\n\\begin{pmatrix}\n    1 & 0 & 0 & 0 & 1 \\\\\n    0 & 0 & 0 & 0 & 0 \\\\\n    0 & 0 & 0 & 0 & 0 \\\\\n    0 & 0 & 0 & 0 & 0 \\\\\n    1 & 0 & 0 & 0 & 1\n\\end{pmatrix}\n\\\\\n&\n\\\\\n&=\n\\begin{pmatrix}\n    3 & 1 & 0 & 0 & 0 \\\\\n    1 & 4 & 1 & 0 & 0 \\\\\n    0 & 1 & 4 & 1 & 0 \\\\\n    0 & 0 & 1 & 4 & 1 \\\\\n    0 & 0 & 0 & 1 & 3\n\\end{pmatrix}\n+\n\\begin{pmatrix}\n    1 \\\\\n    0 \\\\\n    0 \\\\\n    0 \\\\\n    1\n\\end{pmatrix}\n\\begin{pmatrix}\n    1 & 0 & 0 & 0 & 1\n\\end{pmatrix}\n\\\\\n&\n\\\\\n&=\nT + uv^t\\end{split}\\] We decompose \\(R = T + uv^t\\) , where \\(T\\) is a tridiagonal matrix, and \\(u, v\\) are \\(N\\) -D vectors such that \\(u_0 = u_{N-1} = v_0 = v_{N-1} = 1\\) ,\nand \\(u_i = v_i = 0, \\forall i \\in \\{1, ..., N-2\\}\\) . Thus: \\[\\begin{split}RH_1 &= D \\\\\n\\Rightarrow (T + uv^t)H_1 &= D\\end{split}\\] If we find a vector \\(q\\) such that \\(Tq = u\\) : \\[\\begin{split}\\Rightarrow (T + Tqv^t)H_1 &= D \\\\\n\\Rightarrow T(I + qv^t)H_1 &= D \\\\\n\\Rightarrow H_1 &= (I + qv^t)^{-1} T^{-1} D\\end{split}\\] According to Sherman-Morrison\u2019s formula: See also Sherman-Morrison\u2019s formula. Wikipedia. \\[(I + qv^t)^{-1} = I - \\frac{1}{1 + v^tq} qv^t\\] If we find \\(Y = T^{-1} D\\) , or in other words, if we solve for \\(Y\\) in \\(TY = D\\) : \\[\\begin{split}H_1 &= (I + qv^t)^{-1} T^{-1} D \\\\\n&= (I + qv^t)^{-1} Y \\\\\n&= (I - \\frac{1}{1 + v^tq} qv^t) Y \\\\\n&= Y - \\frac{1}{1 + v^tq} qv^tY\\end{split}\\] Therefore, we must solve for \\(q\\) and \\(Y\\) in \\(Tq = u\\) and \\(TY = D\\) .\nAs \\(T\\) is now tridiagonal, we shall use Thomas\u2019 algorithm. Define: \\(a = [a_0, \\ a_1, \\ ..., \\ a_{N-2}]\\) as \\(T\\) \u2019s lower diagonal of \\(N-1\\) elements,\nsuch that \\(a_0 = a_1 = ... = a_{N-2} = 1\\) , so this diagonal is filled with ones; \\(b = [b_0, \\ b_1, \\ ..., \\ b_{N-2}, \\ b_{N-1}]\\) as \\(T\\) \u2019s main diagonal of \\(N\\) elements,\nsuch that \\(b_0 = b_{N-1} = 3\\) , and \\(b_1 = b_2 = ... = b_{N-2} = 4\\) ; \\(c = [c_0, \\ c_1, \\ ..., \\ c_{N-2}]\\) as \\(T\\) \u2019s upper diagonal of \\(N-1\\) elements,\nsuch that \\(c_0 = c_1 = ... = c_{N-2} = 1\\) : this diagonal is also filled with ones. If, according to Thomas\u2019 algorithm, we define: \\[\\begin{split}c'_0 &= \\frac{c_0}{b_0} & \\\\\nc'_i &= \\frac{c_i}{b_i - a_{i-1} c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n& & \\\\\nu'_0 &= \\frac{u_0}{b_0} & \\\\\nu'_i &= \\frac{u_i - a_{i-1} u'_{i-1}}{b_i - a_{i-1} c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-1\\} \\\\\n& & \\\\\nD'_0 &= \\frac{1}{b_0} D_0 & \\\\\nD'_i &= \\frac{1}{b_i - a_{i-1} c'_{i-1}} (D_i - a_{i-1} D'_{i-1}), & \\quad \\forall i \\in \\{1, ..., N-1\\}\\end{split}\\] Then: \\[\\begin{split}c'_0     &= \\frac{1}{3} & \\\\\nc'_i     &= \\frac{1}{4 - c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n& & \\\\\nu'_0     &= \\frac{1}{3} & \\\\\nu'_i     &= \\frac{-u'_{i-1}}{4 - c'_{i-1}} = -c'_i u'_{i-1}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\nu'_{N-1} &= \\frac{1 - u'_{N-2}}{3 - c'_{N-2}} & \\\\\n& & \\\\\nD'_0     &= \\frac{1}{3} (4A_0 + 2A_1) & \\\\\nD'_i     &= \\frac{1}{4 - c'_{i-1}} (4A_i + 2A_{i+1} - D'_{i-1}) & \\\\\n&= c_i (4A_i + 2A_{i+1} - D'_{i-1}), & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\nD'_{N-1} &= \\frac{1}{3 - c'_{N-2}} (4A_{N-1} + 2A_N - D'_{N-2}) &\\end{split}\\] Finally, we can do Backward Substitution to find \\(q\\) and \\(Y\\) : \\[\\begin{split}q_{N-1} &= u'_{N-1} & \\\\\nq_i     &= u'_{i} - c'_i q_{i+1}, & \\quad \\forall i \\in \\{0, ..., N-2\\} \\\\\n& & \\\\\nY_{N-1} &= D'_{N-1} & \\\\\nY_i     &= D'_i - c'_i Y_{i+1},   & \\quad \\forall i \\in \\{0, ..., N-2\\}\\end{split}\\] With those values, we can finally calculate \\(H_1 = Y - \\frac{1}{1 + v^tq} qv^tY\\) .\nGiven that \\(v_0 = v_{N-1} = 1\\) , and \\(v_1 = v_2 = ... = v_{N-2} = 0\\) , its dot products\nwith \\(q\\) and \\(Y\\) are respectively \\(v^tq = q_0 + q_{N-1}\\) and \\(v^tY = Y_0 + Y_{N-1}\\) . Thus: \\[H_1 = Y - \\frac{1}{1 + q_0 + q_{N-1}} q(Y_0 + Y_{N-1})\\] Once we have \\(H_1\\) , we can get \\(H_2\\) (the array of second handles) as follows: \\[\\begin{split}H_{2, i}   &= 2A_{i+1} - H_{1, i+1}, & \\quad \\forall i \\in \\{0, ..., N-2\\} \\\\\nH_{2, N-1} &= 2A_0 - H_{1, 0} &\\end{split}\\] Because the matrix \\(R\\) always follows the same pattern (and thus \\(T, u, v\\) as well),\nwe can define a memo list for \\(c'\\) and \\(u'\\) to avoid recalculation. We cannot\nmemoize \\(D\\) and \\(Y\\) , however, because they are always different matrices. We\ncannot make a memo for \\(q\\) either, but we can calculate it faster because \\(u'\\) can be memoized. Parameters : anchors ( Point3DLike_Array ) \u2013 Anchors of a closed cubic spline. Returns : A tuple of two arrays: one containing the 1st handle for every curve in\nthe closed cubic spline, and the other containing the 2nd handles. Return type : tuple [ Point3D_Array , Point3D_Array ]", "original_prompt": "get_smooth_closed_cubic_bezier_handle_points(anchors)"}
{"prompt": "\"Show handles for each connected cubic B\u00e9zier curve while smoothly connecting the curves.\"", "response": "Given an array of anchors for a cubic spline (array of connected cubic\nB\u00e9zier curves), compute the 1st and 2nd handle for every curve, so that\nthe resulting spline is smooth. Parameters : anchors ( Point3DLike_Array ) \u2013 Anchors of a cubic spline. Returns : A tuple of two arrays: one containing the 1st handle for every curve in\nthe cubic spline, and the other containing the 2nd handles. Return type : tuple [ Point3D_Array , Point3D_Array ]", "original_prompt": "get_smooth_cubic_bezier_handle_points(anchors)"}
{"prompt": "Animate a system of linear equations being solved using Thomas' algorithm to find B\u00e9zier curve handles.", "response": "Special case of get_smooth_cubic_bezier_handle_points() ,\nwhen the anchors do not form a closed loop. Note A system of equations must be solved to get the first handles of\nevery B\u00e8zier curve (referred to as \\(H_1\\) ).\nThen \\(H_2\\) (the second handles) can be obtained separately. See also The equations were obtained from: Smooth B\u00e9zier Spline Through Prescribed Points. (2012). Particle in Cell Consulting LLC. Conditions on control points for continuous curvature. (2016). Jaco Stuifbergen. Warning The equations in the first webpage have some typos which were corrected in the comments. In general, if there are \\(N+1\\) anchors, there will be \\(N\\) B\u00e9zier curves\nand thus \\(N\\) pairs of handles to find. We must solve the following\nsystem of equations for the 1st handles (example for \\(N = 5\\) ): \\[\\begin{split}\\begin{pmatrix}\n    2 & 1 & 0 & 0 & 0 \\\\\n    1 & 4 & 1 & 0 & 0 \\\\\n    0 & 1 & 4 & 1 & 0 \\\\\n    0 & 0 & 1 & 4 & 1 \\\\\n    0 & 0 & 0 & 2 & 7\n\\end{pmatrix}\n\\begin{pmatrix}\n    H_{1,0} \\\\\n    H_{1,1} \\\\\n    H_{1,2} \\\\\n    H_{1,3} \\\\\n    H_{1,4}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n    A_0 + 2A_1 \\\\\n    4A_1 + 2A_2 \\\\\n    4A_2 + 2A_3 \\\\\n    4A_3 + 2A_4 \\\\\n    8A_4 + A_5\n\\end{pmatrix}\\end{split}\\] which will be expressed as \\(TH_1 = D\\) . \\(T\\) is a tridiagonal matrix, so the system can be solved in \\(O(N)\\) operations. Here we shall use Thomas\u2019 algorithm or the tridiagonal matrix\nalgorithm. See also Tridiagonal matrix algorithm. Wikipedia. Define: \\(a = [a_0, \\ a_1, \\ ..., \\ a_{N-2}]\\) as \\(T\\) \u2019s lower diagonal of \\(N-1\\) elements,\nsuch that \\(a_0 = a_1 = ... = a_{N-3} = 1\\) , and \\(a_{N-2} = 2\\) ; \\(b = [b_0, \\ b_1, \\ ..., \\ b_{N-2}, \\ b_{N-1}]\\) as \\(T\\) \u2019s main diagonal of \\(N\\) elements,\nsuch that \\(b_0 = 2\\) , \\(b_1 = b_2 = ... = b_{N-2} = 4\\) , and \\(b_{N-1} = 7\\) ; \\(c = [c_0, \\ c_1, \\ ..., \\ c_{N-2}]\\) as \\(T\\) \u2019s upper diagonal of \\({N-1}\\) elements,\nsuch that \\(c_0 = c_1 = ... = c_{N-2} = 1\\) : this diagonal is filled with ones. If, according to Thomas\u2019 algorithm, we define: \\[\\begin{split}c'_0 &= \\frac{c_0}{b_0} & \\\\\nc'_i &= \\frac{c_i}{b_i - a_{i-1} c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n& & \\\\\nD'_0 &= \\frac{1}{b_0} D_0 & \\\\\nD'_i &= \\frac{1}{b_i - a_{i-1} c'{i-1}} (D_i - a_{i-1} D'_{i-1}), & \\quad \\forall i \\in \\{1, ..., N-1\\}\\end{split}\\] Then: \\[\\begin{split}c'_0     &= 0.5 & \\\\\nc'_i     &= \\frac{1}{4 - c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n& & \\\\\nD'_0     &= 0.5A_0 + A_1 & \\\\\nD'_i     &= \\frac{1}{4 - c'_{i-1}} (4A_i + 2A_{i+1} - D'_{i-1}) & \\\\\n&= c_i (4A_i + 2A_{i+1} - D'_{i-1}), & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\nD'_{N-1} &= \\frac{1}{7 - 2c'_{N-2}} (8A_{N-1} + A_N - 2D'_{N-2}) &\\end{split}\\] Finally, we can do Backward Substitution to find \\(H_1\\) : \\[\\begin{split}H_{1, N-1} &= D'_{N-1} & \\\\\nH_{1, i}   &= D'_i - c'_i H_{1, i+1}, & \\quad \\forall i \\in \\{0, ..., N-2\\}\\end{split}\\] Once we have \\(H_1\\) , we can get \\(H_2\\) (the array of second handles) as follows: \\[\\begin{split}H_{2, i}   &= 2A_{i+1} - H_{1, i+1}, & \\quad \\forall i \\in \\{0, ..., N-2\\} \\\\\nH_{2, N-1} &= 0.5A_N   + 0.5H_{1, N-1} &\\end{split}\\] As the matrix \\(T\\) always follows the same pattern, we can define a memo list\nfor \\(c'\\) to avoid recalculation. We cannot do the same for \\(D\\) , however,\nbecause it is always a different matrix. Parameters : anchors ( Point3DLike_Array ) \u2013 Anchors of an open cubic spline. Returns : A tuple of two arrays: one containing the 1st handle for every curve in\nthe open cubic spline, and the other containing the 2nd handles. Return type : tuple [ Point3D_Array , Point3D_Array ]", "original_prompt": "get_smooth_open_cubic_bezier_handle_points(anchors)"}
{"prompt": "Animate an interpolation between two numbers with a decreasing residual, showing the range and proportion values.", "response": "This is a variant of interpolate that returns an integer and the residual Parameters : start ( float ) \u2013 The start of the range end ( float ) \u2013 The end of the range alpha ( float ) \u2013 a float between 0 and 1. Returns : This returns an integer between start and end (inclusive) representing\nappropriate interpolation between them, along with a\n\u201cresidue\u201d representing a new proportion between the\nreturned integer and the next one of the\nlist. Return type : tuple[int, float] Example >>> integer , residue = integer_interpolate ( start = 0 , end = 10 , alpha = 0.46 ) >>> np . allclose (( integer , residue ), ( 4 , 0.6 )) True", "original_prompt": "integer_interpolate(start, end, alpha)"}
{"prompt": "Animate a line segment smoothly transitioning between two points along a 2D axis.", "response": "Linearly interpolates between two values start and end . Parameters : start \u2013 The start of the range. end \u2013 The end of the range. alpha \u2013 A float between 0 and 1, or an \\((n, 1)\\) column vector containing \\(n\\) floats between 0 and 1 to interpolate in a vectorized fashion. Returns : The result of the linear interpolation. If start and end are of type float , and: alpha is also a float , the return is simply another float . alpha is a ColVector , the return is another ColVector . If start and end are of type Point3D , and: alpha is a float , the return is another Point3D . alpha is a ColVector , the return is a Point3D_Array . Return type : float | ColVector | Point3D | Point3D_Array", "original_prompt": "interpolate(start: float, end: float, alpha: float) \u2192 float"}
{"prompt": "Animate a smooth fade between two points, with interpolation curves for each axis.", "response": "Perform inverse interpolation to determine the alpha\nvalues that would produce the specified value given the start and end values or points. Parameters : start \u2013 The start value or point of the interpolation. end \u2013 The end value or point of the interpolation. value \u2013 The value or point for which the alpha value\nshould be determined. Returns : The alpha values producing the given input when interpolating between start and end . Example >>> inverse_interpolate ( start = 2 , end = 6 , value = 4 ) np.float64(0.5) >>> start = np . array ([ 1 , 2 , 1 ]) >>> end = np . array ([ 7 , 8 , 11 ]) >>> value = np . array ([ 4 , 5 , 5 ]) >>> inverse_interpolate ( start , end , value ) array([0.5, 0.5, 0.4])", "original_prompt": "inverse_interpolate(start: float, end: float, value: float) \u2192 float"}
{"prompt": "Animate a closed spline that transforms into an open one with varying point distances.", "response": "Returns True if the spline given by points is closed, by\nchecking if its first and last points are close to each other, or``False``\notherwise. Note This function reimplements np.allclose() , because repeated\ncalling of np.allclose() for only 2 points is inefficient. Parameters : points ( Point3D_Array ) \u2013 An array of points defining a spline. Returns : Whether the first and last points of the array are close enough or not\nto be considered the same, thus considering the defined spline as\nclosed. Return type : bool Examples >>> import numpy as np >>> from manim import is_closed >>> is_closed ( ... np . array ( ... [ ... [ 0 , 0 , 0 ], ... [ 1 , 2 , 3 ], ... [ 3 , 2 , 1 ], ... [ 0 , 0 , 0 ], ... ] ... ) ... ) True >>> is_closed ( ... np . array ( ... [ ... [ 0 , 0 , 0 ], ... [ 1 , 2 , 3 ], ... [ 3 , 2 , 1 ], ... [ 1e-10 , 1e-10 , 1e-10 ], ... ] ... ) ... ) True >>> is_closed ( ... np . array ( ... [ ... [ 0 , 0 , 0 ], ... [ 1 , 2 , 3 ], ... [ 3 , 2 , 1 ], ... [ 1e-2 , 1e-2 , 1e-2 ], ... ] ... ) ... ) False", "original_prompt": "is_closed(points)"}
{"prompt": "\" smoothly map an old value to a new range, illustrating proportional scaling with color and transparency.\"", "response": "Interpolate a value from an old range to a new range. Parameters : new_start \u2013 The start of the new range. new_end \u2013 The end of the new range. old_start \u2013 The start of the old range. old_end \u2013 The end of the old range. old_value \u2013 The value within the old range whose corresponding\nvalue in the new range (with the same alpha value)\nis desired. Return type : The interpolated value within the new range. Examples >>> match_interpolate ( 0 , 100 , 10 , 20 , 15 ) np.float64(50.0)", "original_prompt": "match_interpolate(new_start: float, new_end: float, old_start: float, old_end: float, old_value: float) \u2192 float"}
{"prompt": "\"Show a line connecting two points, illustrating the concept of a midpoint with simple geometric animation\"", "response": "Returns the midpoint between two values. Parameters : start \u2013 The first value end \u2013 The second value Return type : The midpoint between the two values", "original_prompt": "mid(start: float, end: float) \u2192 float"}
{"prompt": "Animate a linear transformation applying a cubic matrix to points along a curve, showing its effect on Bezier curve segments.", "response": "Given an array of points which define a B\u00e9zier curve, and two numbers \\(a, b\\) such that \\(0 \\le a < b \\le 1\\) , return an array of the same size, which describes the\nportion of the original B\u00e9zier curve on the interval \\([a, b]\\) . partial_bezier_points() is conceptually equivalent to calling split_bezier() twice and discarding unused B\u00e9zier curves, but this is more efficient and doesn\u2019t waste\ncomputations. See also See split_bezier() for an explanation on how to split B\u00e9zier curves. Note To find the portion of a B\u00e9zier curve with \\(t\\) between \\(a\\) and \\(b\\) : Split the curve at \\(t = a\\) and extract its 2nd subcurve. We cannot evaluate the new subcurve at \\(t = b\\) because its range of values for \\(t\\) is different.\nTo find the correct value, we need to transform the interval \\([a, 1]\\) into \\([0, 1]\\) by first subtracting \\(a\\) to get \\([0, 1-a]\\) and then dividing by \\(1-a\\) . Thus, our new\nvalue must be \\(t = \\frac{b - a}{1 - a}\\) . Define \\(u = \\frac{b - a}{1 - a}\\) . Split the subcurve at \\(t = u\\) and extract its 1st subcurve. The final portion is a linear combination of points, and thus the process can be\nsummarized as a linear transformation by some matrix in terms of \\(a\\) and \\(b\\) .\nThis matrix is given explicitly for B\u00e9zier curves up to degree 3, which are often used in Manim.\nFor higher degrees, the algorithm described previously is used. For the case of a quadratic B\u00e9zier curve: Step 1: \\[\\begin{split}H'_1\n=\n\\begin{pmatrix}\n    (1-a)^2 & 2(1-a)a & a^2 \\\\\n    0 & (1-a) & a \\\\\n    0 & 0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n    p_0 \\\\\n    p_1 \\\\\n    p_2\n\\end{pmatrix}\\end{split}\\] Step 2: \\[\\begin{split}H''_0\n&=\n\\begin{pmatrix}\n    1 & 0 & 0 \\\\\n    (1-u) & u & 0\\\\\n    (1-u)^2 & 2(1-u)u & u^2\n\\end{pmatrix}\nH'_1\n\\\\\n&\n\\\\\n&=\n\\begin{pmatrix}\n    1 & 0 & 0 \\\\\n    (1-u) & u & 0\\\\\n    (1-u)^2 & 2(1-u)u & u^2\n\\end{pmatrix}\n\\begin{pmatrix}\n    (1-a)^2 & 2(1-a)a & a^2 \\\\\n    0 & (1-a) & a \\\\\n    0 & 0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n    p_0 \\\\\n    p_1 \\\\\n    p_2\n\\end{pmatrix}\n\\\\\n&\n\\\\\n&=\n\\begin{pmatrix}\n    (1-a)^2 & 2(1-a)a & a^2 \\\\\n    (1-a)(1-b) & a(1-b) + (1-a)b & ab \\\\\n    (1-b)^2 & 2(1-b)b & b^2\n\\end{pmatrix}\n\\begin{pmatrix}\n    p_0 \\\\\n    p_1 \\\\\n    p_2\n\\end{pmatrix}\\end{split}\\] from where one can define a \\((3, 3)\\) matrix \\(P_2\\) which, when applied over\nthe array of points , will return the desired partial quadratic B\u00e9zier curve: \\[\\begin{split}P_2\n=\n\\begin{pmatrix}\n    (1-a)^2 & 2(1-a)a & a^2 \\\\\n    (1-a)(1-b) & a(1-b) + (1-a)b & ab \\\\\n    (1-b)^2 & 2(1-b)b & b^2\n\\end{pmatrix}\\end{split}\\] Similarly, for the cubic B\u00e9zier curve case, one can define the following \\((4, 4)\\) matrix \\(P_3\\) : \\[\\begin{split}P_3\n=\n\\begin{pmatrix}\n    (1-a)^3 & 3(1-a)^2a & 3(1-a)a^2 & a^3 \\\\\n    (1-a)^2(1-b) & 2(1-a)a(1-b) + (1-a)^2b & a^2(1-b) + 2(1-a)ab & a^2b \\\\\n    (1-a)(1-b)^2 & a(1-b)^2 + 2(1-a)(1-b)b & 2a(1-b)b + (1-a)b^2 & ab^2 \\\\\n    (1-b)^3 & 3(1-b)^2b & 3(1-b)b^2 & b^3\n\\end{pmatrix}\\end{split}\\] Parameters : points ( BezierPointsLike ) \u2013 set of points defining the bezier curve. a ( float ) \u2013 lower bound of the desired partial bezier curve. b ( float ) \u2013 upper bound of the desired partial bezier curve. Returns : An array containing the control points defining the partial B\u00e9zier curve. Return type : BezierPoints", "original_prompt": "partial_bezier_points(points, a, b)"}
{"prompt": "\"Verify if a given point intersects with a Bezier curve defined by control points.\"", "response": "Checks if a given point lies on the bezier curves with the given control points. This is done by solving the bezier polynomial with the point as the constant term; if\nany real roots exist, the point lies on the bezier curve. Parameters : point ( Point3DLike ) \u2013 The Cartesian Coordinates of the point to check. control_points ( BezierPointsLike ) \u2013 The Cartesian Coordinates of the ordered control\npoints of the bezier curve on which the point may\nor may not lie. round_to ( float ) \u2013 A float whose number of decimal places all values\nsuch as coordinates of points will be rounded. Returns : Whether the point lies on the curve. Return type : bool", "original_prompt": "point_lies_on_bezier(point, control_points, round_to=1e-06)"}
{"prompt": "\"Find the proportion along a B\u00e9zier curve for a given point's coordinates.\"", "response": "Obtains the proportion along the bezier curve corresponding to a given point\ngiven the bezier curve\u2019s control points. The bezier polynomial is constructed using the coordinates of the given point\nas well as the bezier curve\u2019s control points. On solving the polynomial for each dimension,\nif there are roots common to every dimension, those roots give the proportion along the\ncurve the point is at. If there are no real roots, the point does not lie on the curve. Parameters : point ( Point3DLike ) \u2013 The Cartesian Coordinates of the point whose parameter\nshould be obtained. control_points ( BezierPointsLike ) \u2013 The Cartesian Coordinates of the ordered control\npoints of the bezier curve on which the point may\nor may not lie. round_to ( float ) \u2013 A float whose number of decimal places all values\nsuch as coordinates of points will be rounded. Returns : List containing possible parameters (the proportions along the bezier curve)\nfor the given point on the given bezier curve.\nThis usually only contains one or zero elements, but if the\npoint is, say, at the beginning/end of a closed loop, may return\na list with more than 1 value, corresponding to the beginning and\nend etc. of the loop. Return type : np.ndarray[float] Raises : ValueError \u2013 When point and the control points have different shapes.", "original_prompt": "proportions_along_bezier_curve_for_point(point, control_points, round_to=1e-06)"}
{"prompt": "Based on the provided code, it appears that the function `splitBezierCurve` is used to split a cubic Bezier curve into two smaller Bezier curves at a specified t-value.\n\nTo use this function, you would call it with an array of points representing the control points of the cubic Bezier curve and a float value for t. The function would then return an array containing the control points defining the two resulting Bezier curves.\n\nHere is an example:\n```python\nimport math\n\n# Define the control points of the cubic Bezier curve\npoints = [math.cos(0), 1, math.sin(0), 0]\n\n# Split the Bezier curve at t=0.5\nt = 0.5\nresult = splitBezierCurve(points, t)\n\nprint(result)\n```\nThis would output the control points defining the two resulting Bezier curves.\n\nPlease note that this is just an example and you may need to modify it to fit your specific use case. Additionally, the `splitBezierCurve` function is not implemented in this code snippet, so you will need to provide its implementation for this to work.", "response": "Split a B\u00e9zier curve at argument t into two curves. Note See also A Primer on B\u00e9zier Curves #10: Splitting curves. Pomax. As an example for a cubic B\u00e9zier curve, let \\(p_0, p_1, p_2, p_3\\) be the points\nneeded for the curve \\(C_0 = [p_0, \\ p_1, \\ p_2, \\ p_3]\\) . Define the 3 linear B\u00e9ziers \\(L_0, L_1, L_2\\) as interpolations of \\(p_0, p_1, p_2, p_3\\) : \\[\\begin{split}L_0(t) &= p_0 + t(p_1 - p_0) \\\\\nL_1(t) &= p_1 + t(p_2 - p_1) \\\\\nL_2(t) &= p_2 + t(p_3 - p_2)\\end{split}\\] Define the 2 quadratic B\u00e9ziers \\(Q_0, Q_1\\) as interpolations of \\(L_0, L_1, L_2\\) : \\[\\begin{split}Q_0(t) &= L_0(t) + t(L_1(t) - L_0(t)) \\\\\nQ_1(t) &= L_1(t) + t(L_2(t) - L_1(t))\\end{split}\\] Then \\(C_0\\) is the following interpolation of \\(Q_0\\) and \\(Q_1\\) : \\[C_0(t) = Q_0(t) + t(Q_1(t) - Q_0(t))\\] Evaluating \\(C_0\\) at a value \\(t=t'\\) splits \\(C_0\\) into two cubic B\u00e9ziers \\(H_0\\) and \\(H_1\\) , defined by some of the points we calculated earlier: \\[\\begin{split}H_0 &= [p_0, &\\ L_0(t'), &\\ Q_0(t'), &\\ C_0(t') &] \\\\\nH_1 &= [p_0(t'), &\\ Q_1(t'), &\\ L_2(t'), &\\ p_3 &]\\end{split}\\] As the resulting curves are obtained from linear combinations of points , everything can\nbe encoded into a matrix for efficiency, which is done for B\u00e9zier curves of degree up to 3. See also A Primer on B\u00e9zier Curves #11: Splitting curves using matrices. Pomax. For the simpler case of a quadratic B\u00e9zier curve: \\[\\begin{split}H_0\n&=\n\\begin{pmatrix}\n    p_0 \\\\\n    (1-t) p_0 + t p_1 \\\\\n    (1-t)^2 p_0 + 2(1-t)t p_1 + t^2 p_2 \\\\\n\\end{pmatrix}\n&=\n\\begin{pmatrix}\n    1 & 0 & 0 \\\\\n    (1-t) & t & 0\\\\\n    (1-t)^2 & 2(1-t)t & t^2\n\\end{pmatrix}\n\\begin{pmatrix}\n    p_0 \\\\\n    p_1 \\\\\n    p_2\n\\end{pmatrix}\n\\\\\n&\n\\\\\nH_1\n&=\n\\begin{pmatrix}\n    (1-t)^2 p_0 + 2(1-t)t p_1 + t^2 p_2 \\\\\n    (1-t) p_1 + t p_2 \\\\\n    p_2\n\\end{pmatrix}\n&=\n\\begin{pmatrix}\n    (1-t)^2 & 2(1-t)t & t^2 \\\\\n    0 & (1-t) & t \\\\\n    0 & 0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n    p_0 \\\\\n    p_1 \\\\\n    p_2\n\\end{pmatrix}\\end{split}\\] from where one can define a \\((6, 3)\\) split matrix \\(S_2\\) which can multiply\nthe array of points to compute the return value: \\[\\begin{split}S_2\n&=\n\\begin{pmatrix}\n    1 & 0 & 0 \\\\\n    (1-t) & t & 0 \\\\\n    (1-t)^2 & 2(1-t)t & t^2 \\\\\n    (1-t)^2 & 2(1-t)t & t^2 \\\\\n    0 & (1-t) & t \\\\\n    0 & 0 & 1\n\\end{pmatrix}\n\\\\\n&\n\\\\\nS_2 P\n&=\n\\begin{pmatrix}\n    1 & 0 & 0 \\\\\n    (1-t) & t & 0 \\\\\n    (1-t)^2 & 2(1-t)t & t^2 \\\\\n    (1-t)^2 & 2(1-t)t & t^2 \\\\\n    0 & (1-t) & t \\\\\n    0 & 0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n    p_0 \\\\\n    p_1 \\\\\n    p_2\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n    \\vert \\\\\n    H_0 \\\\\n    \\vert \\\\\n    \\vert \\\\\n    H_1 \\\\\n    \\vert\n\\end{pmatrix}\\end{split}\\] For the previous example with a cubic B\u00e9zier curve: \\[\\begin{split}H_0\n&=\n\\begin{pmatrix}\n    p_0 \\\\\n    (1-t) p_0 + t p_1 \\\\\n    (1-t)^2 p_0 + 2(1-t)t p_1 + t^2 p_2 \\\\\n    (1-t)^3 p_0 + 3(1-t)^2 t p_1 + 3(1-t)t^2 p_2 + t^3 p_3\n\\end{pmatrix}\n&=\n\\begin{pmatrix}\n    1 & 0 & 0 & 0 \\\\\n    (1-t) & t & 0 & 0 \\\\\n    (1-t)^2 & 2(1-t)t & t^2 & 0 \\\\\n    (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3\n\\end{pmatrix}\n\\begin{pmatrix}\n    p_0 \\\\\n    p_1 \\\\\n    p_2 \\\\\n    p_3\n\\end{pmatrix}\n\\\\\n&\n\\\\\nH_1\n&=\n\\begin{pmatrix}\n    (1-t)^3 p_0 + 3(1-t)^2 t p_1 + 3(1-t)t^2 p_2 + t^3 p_3 \\\\\n    (1-t)^2 p_1 + 2(1-t)t p_2 + t^2 p_3 \\\\\n    (1-t) p_2 + t p_3 \\\\\n    p_3\n\\end{pmatrix}\n&=\n\\begin{pmatrix}\n    (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n    0 & (1-t)^2 & 2(1-t)t & t^2 \\\\\n    0 & 0 & (1-t) & t \\\\\n    0 & 0 & 0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n    p_0 \\\\\n    p_1 \\\\\n    p_2 \\\\\n    p_3\n\\end{pmatrix}\\end{split}\\] from where one can define a \\((8, 4)\\) split matrix \\(S_3\\) which can multiply\nthe array of points to compute the return value: \\[\\begin{split}S_3\n&=\n\\begin{pmatrix}\n    1 & 0 & 0 & 0 \\\\\n    (1-t) & t & 0 & 0 \\\\\n    (1-t)^2 & 2(1-t)t & t^2 & 0 \\\\\n    (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n    (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n    0 & (1-t)^2 & 2(1-t)t & t^2 \\\\\n    0 & 0 & (1-t) & t \\\\\n    0 & 0 & 0 & 1\n\\end{pmatrix}\n\\\\\n&\n\\\\\nS_3 P\n&=\n\\begin{pmatrix}\n    1 & 0 & 0 & 0 \\\\\n    (1-t) & t & 0 & 0 \\\\\n    (1-t)^2 & 2(1-t)t & t^2 & 0 \\\\\n    (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n    (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n    0 & (1-t)^2 & 2(1-t)t & t^2 \\\\\n    0 & 0 & (1-t) & t \\\\\n    0 & 0 & 0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n    p_0 \\\\\n    p_1 \\\\\n    p_2 \\\\\n    p_3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n    \\vert \\\\\n    H_0 \\\\\n    \\vert \\\\\n    \\vert \\\\\n    H_1 \\\\\n    \\vert\n\\end{pmatrix}\\end{split}\\] Parameters : points ( BezierPointsLike ) \u2013 The control points of the B\u00e9zier curve. t ( float ) \u2013 The t -value at which to split the B\u00e9zier curve. Returns : An array containing the control points defining the two B\u00e9zier curves. Return type : Point3D_Array", "original_prompt": "split_bezier(points, t)"}
{"prompt": "\"Subdivide a quadratic B\u00e9zier curve into two equal parts with precalculated subdivision matrix.\"", "response": "Subdivide a B\u00e9zier curve into \\(n\\) subcurves which have the same shape. The points at which the curve is split are located at the\narguments \\(t = \\frac{i}{n}\\) , for \\(i \\in \\{1, ..., n-1\\}\\) . See also See split_bezier() for an explanation on how to split B\u00e9zier curves. See partial_bezier_points() for an extra understanding of this function. Note The resulting subcurves can be expressed as linear combinations of points , which can be encoded in a single matrix that is precalculated\nfor 2nd and 3rd degree B\u00e9zier curves. As an example for a quadratic B\u00e9zier curve: taking inspiration from the\nexplanation in partial_bezier_points() , where the following matrix \\(P_2\\) was defined to extract the portion of a quadratic B\u00e9zier\ncurve for \\(t \\in [a, b]\\) : \\[\\begin{split}P_2\n=\n\\begin{pmatrix}\n    (1-a)^2 & 2(1-a)a & a^2 \\\\\n    (1-a)(1-b) & a(1-b) + (1-a)b & ab \\\\\n    (1-b)^2 & 2(1-b)b & b^2\n\\end{pmatrix}\\end{split}\\] the plan is to replace \\([a, b]\\) with \\(\\left[ \\frac{i-1}{n}, \\frac{i}{n} \\right], \\ \\forall i \\in \\{1, ..., n\\}\\) . As an example for \\(n = 2\\) divisions, construct \\(P_1\\) for\nthe interval \\(\\left[ 0, \\frac{1}{2} \\right]\\) , and \\(P_2\\) for the\ninterval \\(\\left[ \\frac{1}{2}, 1 \\right]\\) : \\[\\begin{split}P_1\n=\n\\begin{pmatrix}\n    1 & 0 & 0 \\\\\n    0.5 & 0.5 & 0 \\\\\n    0.25 & 0.5 & 0.25\n\\end{pmatrix}\n,\n\\quad\nP_2\n=\n\\begin{pmatrix}\n    0.25 & 0.5 & 0.25 \\\\\n    0 & 0.5 & 0.5 \\\\\n    0 & 0 & 1\n\\end{pmatrix}\\end{split}\\] Therefore, the following \\((6, 3)\\) subdivision matrix \\(D_2\\) can be\nconstructed, which will subdivide an array of points into 2 parts: \\[\\begin{split}D_2\n=\n\\begin{pmatrix}\n    M_1 \\\\\n    M_2\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n    1 & 0 & 0 \\\\\n    0.5 & 0.5 & 0 \\\\\n    0.25 & 0.5 & 0.25 \\\\\n    0.25 & 0.5 & 0.25 \\\\\n    0 & 0.5 & 0.5 \\\\\n    0 & 0 & 1\n\\end{pmatrix}\\end{split}\\] For quadratic and cubic B\u00e9zier curves, the subdivision matrices are memoized for\nefficiency. For higher degree curves, an iterative algorithm inspired by the\none from split_bezier() is used instead. Parameters : points ( BezierPointsLike ) \u2013 The control points of the B\u00e9zier curve. n_divisions ( int ) \u2013 The number of curves to subdivide the B\u00e9zier curve into Returns : An array containing the points defining the new \\(n\\) subcurves. Return type : Spline", "original_prompt": "subdivide_bezier(points, n_divisions)"}
{"prompt": "Animate a parametric line graph updating its equation with input commands.", "response": "Parameters : command ( str ) cwd ( StrOrBytesPath | None ) command_input ( str | None ) Return type : tuple[str, str, int]", "original_prompt": "capture(command, cwd=None, command_input=None)"}
{"prompt": "\"Generate a tree diagram showing file system directory hierarchy with path names.\"", "response": "Get list of paths relative to dirpath of all files in dir and subdirs recursively. Parameters : dirpath ( Path ) Return type : Generator [str, None, None]", "original_prompt": "get_dir_layout(dirpath)"}
{"prompt": "\"Fade in an animated graph displaying exponential growth, then rotate it around the origin with axis labels.\"", "response": "Parameters : path_to_video ( str | PathLike ) Return type : VideoMetadata", "original_prompt": "get_video_metadata(path_to_video)"}
{"prompt": "\"Merge multiple dictionaries into one with highest-priority keys and recursive value merging.\"", "response": "Creates a dict whose keyset is the union of all the\ninput dictionaries.  The value for each key is based\non the first dict in the list with that key. dicts later in the list have higher priority When values are dictionaries, it is applied recursively Parameters : dicts ( dict [ Any , Any ] ) Return type : dict[ Any , Any ]", "original_prompt": "merge_dicts_recursively(*dicts)"}
{"prompt": "\"Move a graph to the center of the screen, rotating around the y-axis while highlighting nearby points with color changes.\"", "response": "Parameters : current_dict ( dict [ Any , Any ] ) others ( dict [ Any , Any ] ) Return type : None", "original_prompt": "update_dict_recursively(current_dict, *others)"}
{"prompt": "Animate a mathematical expression with labeled subterms.", "response": "Returns a VGroup of Integer mobjects\nthat shows the index of each submobject. Useful for working with parts of complicated mobjects. Parameters : mobject ( Mobject ) \u2013 The mobject that will have its submobjects labelled. label_height ( float ) \u2013 The height of the labels, by default 0.15. background_stroke_width ( float ) \u2013 The stroke width of the outline of the labels, by default 5. background_stroke_color ( ManimColor ) \u2013 The stroke color of the outline of labels. kwargs ( Any ) \u2013 Additional parameters to be passed into the :class`~.Integer`\nmobjects used to construct the labels. Return type : VGroup Examples Example: IndexLabelsExample   from manim import * class IndexLabelsExample ( Scene ): def construct ( self ): text = MathTex ( \" \\\\ frac {d}{dx} f(x)g(x)=\" , \"f(x) \\\\ frac {d}{dx} g(x)\" , \"+\" , \"g(x) \\\\ frac {d}{dx} f(x)\" , ) #index the fist term in the MathTex mob indices = index_labels ( text [ 0 ]) text [ 0 ][ 1 ] . set_color ( PURPLE_B ) text [ 0 ][ 8 : 12 ] . set_color ( DARK_BLUE ) self . add ( text , indices ) class IndexLabelsExample(Scene):\n    def construct(self):\n        text = MathTex(\n            \"\\\\frac{d}{dx}f(x)g(x)=\",\n            \"f(x)\\\\frac{d}{dx}g(x)\",\n            \"+\",\n            \"g(x)\\\\frac{d}{dx}f(x)\",\n        )\n\n        #index the fist term in the MathTex mob\n        indices = index_labels(text[0])\n\n        text[0][1].set_color(PURPLE_B)\n        text[0][8:12].set_color(DARK_BLUE)\n\n        self.add(text, indices)", "original_prompt": "index_labels(mobject, label_height=0.15, background_stroke_width=5, background_stroke_color=ManimColor('#000000'), **kwargs)"}
{"prompt": "\"Rotate a circle on the screen, creating a tabbed layout with five rectangular tabs.\"", "response": "For debugging purposes Parameters : mobject ( Mobject ) n_tabs ( int ) Return type : None", "original_prompt": "print_family(mobject, n_tabs=0)"}
{"prompt": "\"Fade in and rotate a circle with increasing radius, illustrating exponential growth.\"", "response": "TypeVar ( 'T' )", "original_prompt": "class T"}
{"prompt": "Animate a warning message that deprecates a function.", "response": "Decorator to mark a callable as deprecated. The decorated callable will cause a warning when used. The docstring of the\ndeprecated callable is adjusted to indicate that this callable is deprecated. Parameters : func \u2013 The function to be decorated. Should not be set by the user. since \u2013 The version or date since deprecation. until \u2013 The version or date until removal of the deprecated callable. replacement \u2013 The identifier of the callable replacing the deprecated one. message \u2013 The reason for why the callable has been deprecated. Returns : The decorated callable. Return type : Callable Examples Basic usage: from manim.utils.deprecation import deprecated @deprecated def foo ( ** kwargs ): pass @deprecated class Bar : def __init__ ( self ): pass @deprecated def baz ( self ): pass foo () # WARNING  The function foo has been deprecated and may be removed in a later version. a = Bar () # WARNING  The class Bar has been deprecated and may be removed in a later version. a . baz () # WARNING  The method Bar.baz has been deprecated and may be removed in a later version. You can specify additional information for a more precise warning: from manim.utils.deprecation import deprecated @deprecated ( since = \"v0.2\" , until = \"v0.4\" , replacement = \"bar\" , message = \"It is cooler.\" ) def foo (): pass foo () # WARNING  The function foo has been deprecated since v0.2 and is expected to be removed after v0.4. Use bar instead. It is cooler. You may also use dates instead of versions: from manim.utils.deprecation import deprecated @deprecated ( since = \"05/01/2021\" , until = \"06/01/2021\" ) def foo (): pass foo () # WARNING  The function foo has been deprecated since 05/01/2021 and is expected to be removed after 06/01/2021.", "original_prompt": "deprecated(func: Callable"}
{"prompt": "Animate a warning message with deprecation parameters displayed over a white background with fading effect.", "response": "Decorator to mark parameters of a callable as deprecated. It can also be used to automatically redirect deprecated parameter values to their\nreplacements. Parameters : params ( str | Iterable [ str ] | None ) \u2013 The parameters to be deprecated. Can consist of: An iterable of strings, with each element representing a parameter to deprecate A single string, with parameter names separated by commas or spaces. since ( str | None ) \u2013 The version or date since deprecation. until ( str | None ) \u2013 The version or date until removal of the deprecated callable. message ( str ) \u2013 The reason for why the callable has been deprecated. redirections ( None | Iterable [ tuple [ str , str ] | Callable [ [ ... ] , dict [ str , Any ] ] ] ) \u2013 A list of parameter redirections. Each redirection can be one of the following: A tuple of two strings. The first string defines the name of the deprecated\nparameter; the second string defines the name of the parameter to redirect to,\nwhen attempting to use the first string. A function performing the mapping operation. The parameter names of the\nfunction determine which parameters are used as input. The function must\nreturn a dictionary which contains the redirected arguments. Redirected parameters are also implicitly deprecated. Returns : The decorated callable. Return type : Callable Raises : ValueError \u2013 If no parameters are defined (neither explicitly nor implicitly). ValueError \u2013 If defined parameters are invalid python identifiers. Examples Basic usage: from manim.utils.deprecation import deprecated_params @deprecated_params ( params = \"a, b, c\" ) def foo ( ** kwargs ): pass foo ( x = 2 , y = 3 , z = 4 ) # No warning foo ( a = 2 , b = 3 , z = 4 ) # WARNING  The parameters a and b of method foo have been deprecated and may be removed in a later version. You can also specify additional information for a more precise warning: from manim.utils.deprecation import deprecated_params @deprecated_params ( params = \"a, b, c\" , since = \"v0.2\" , until = \"v0.4\" , message = \"The letters x, y, z are cooler.\" , ) def foo ( ** kwargs ): pass foo ( a = 2 ) # WARNING  The parameter a of method foo has been deprecated since v0.2 and is expected to be removed after v0.4. The letters x, y, z are cooler. Basic parameter redirection: from manim.utils.deprecation import deprecated_params @deprecated_params ( redirections = [ # Two ways to redirect one parameter to another: ( \"old_param\" , \"new_param\" ), lambda old_param2 : { \"new_param22\" : old_param2 }, ] ) def foo ( ** kwargs ): return kwargs foo ( x = 1 , old_param = 2 ) # WARNING  The parameter old_param of method foo has been deprecated and may be removed in a later version. # returns {\"x\": 1, \"new_param\": 2} Redirecting using a calculated value: from manim.utils.deprecation import deprecated_params @deprecated_params ( redirections = [ lambda runtime_in_ms : { \"run_time\" : runtime_in_ms / 1000 }] ) def foo ( ** kwargs ): return kwargs foo ( runtime_in_ms = 500 ) # WARNING  The parameter runtime_in_ms of method foo has been deprecated and may be removed in a later version. # returns {\"run_time\": 0.5} Redirecting multiple parameter values to one: from manim.utils.deprecation import deprecated_params @deprecated_params ( redirections = [ lambda buff_x = 1 , buff_y = 1 : { \"buff\" : ( buff_x , buff_y )}] ) def foo ( ** kwargs ): return kwargs foo ( buff_x = 2 ) # WARNING  The parameter buff_x of method foo has been deprecated and may be removed in a later version. # returns {\"buff\": (2, 1)} Redirect one parameter to multiple: from manim.utils.deprecation import deprecated_params @deprecated_params ( redirections = [ lambda buff = 1 : { \"buff_x\" : buff [ 0 ], \"buff_y\" : buff [ 1 ]} if isinstance ( buff , tuple ) else { \"buff_x\" : buff , \"buff_y\" : buff } ] ) def foo ( ** kwargs ): return kwargs foo ( buff = 0 ) # WARNING  The parameter buff of method foo has been deprecated and may be removed in a later version. # returns {\"buff_x\": 0, buff_y: 0} foo ( buff = ( 1 , 2 )) # WARNING  The parameter buff of method foo has been deprecated and may be removed in a later version. # returns {\"buff_x\": 1, buff_y: 2}", "original_prompt": "deprecated_params(params=None, since=None, until=None, message='', redirections=None)"}
{"prompt": "\"Output animation and scene hash values together, with camera position as a prefix.\"", "response": "Take the list of animations and a list of mobjects and output their hashes. This is meant to be used for scene.play function. Parameters : scene_object ( Scene ) \u2013 The scene object. camera_object ( Camera | OpenGLCamera ) \u2013 The camera object used in the scene. animations_list ( Iterable [ Animation ] ) \u2013 The list of animations. current_mobjects_list ( Iterable [ Mobject ] ) \u2013 The list of mobjects. Returns : A string concatenation of the respective hashes of camera_object , animations_list and current_mobjects_list , separated by _ . Return type : str", "original_prompt": "get_hash_from_play_call(scene_object, camera_object, animations_list, current_mobjects_list)"}
{"prompt": "\"Display a dictionary transforming into a flat JSON string with custom encoding details\"", "response": "Recursively serialize object to JSON using the CustomEncoder class. Parameters : obj ( dict ) \u2013 The dict to flatten Returns : The flattened object Return type : str", "original_prompt": "get_json(obj)"}
{"prompt": "\"Add opaque white border to an RGB image with varying opacity.\"", "response": "Converts an RGB array into RGBA with the alpha value opacity maxed. Parameters : image ( RGBPixelArray ) dtype ( str ) Return type : RGBPixelArray", "original_prompt": "change_to_rgba_array(image, dtype='uint8')"}
{"prompt": "\"Fade in a graph over multiple frames with exponential growth.\"", "response": "Parameters : frames ( list [ array ] ) Return type : list[ array ]", "original_prompt": "drag_pixels(frames)"}
{"prompt": "\"Display an image file on screen.\"", "response": "Parameters : image_file_name ( str | PurePath ) Return type : Path", "original_prompt": "get_full_raster_image_path(image_file_name)"}
{"prompt": "\"Generate an animated graph that moves horizontally along the x-axis.\" \n\n(Note: The provided Manim code snippet doesn't explicitly show a graph, so I made an assumption. If you provide more context or details about the code, I can create a more accurate prompt.)", "response": "Parameters : image_file_name ( str | PurePath ) Return type : Path", "original_prompt": "get_full_vector_image_path(image_file_name)"}
{"prompt": "\"Rotate and zoom a graph of a sine wave, with axes scaling in sync.\"", "response": "Parameters : image ( array ) Return type : <module \u2018PIL.Image\u2019 from \u2018/home/docs/checkouts/readthedocs.org/user_builds/manimce/envs/stable/lib/python3.13/site-packages/PIL/Image.py\u2019>", "original_prompt": "invert_image(image)"}
{"prompt": "\"Show how sine wave graph rises with increasing values in a colorful animated curve.\"", "response": "TypeVar ( 'T' )", "original_prompt": "class T"}
{"prompt": "\"Animate a sine wave with amplitude changes, oscillating within a square frame.\"", "response": "TypeVar ( 'U' )", "original_prompt": "class U"}
{"prompt": "\"Fade in a parabola with variable y-value oscillating between positive and negative values\"", "response": "TypeVar('F', np.float64, np.int_)", "original_prompt": "class F"}
{"prompt": "\"Fade in a colorful hexagon over a circular graph, with X values increasing along the circle.\"", "response": "TypeVar ( 'H' , bound = Hashable )", "original_prompt": "class H"}
{"prompt": "\"Rotate and split a sequence of numbers into cyclic groups of length n.\"", "response": "Returns the Sequence objects cyclically split into n length tuples. See also adjacent_pairs alias with n=2 Examples >>> list ( adjacent_n_tuples ([ 1 , 2 , 3 , 4 ], 2 )) [(1, 2), (2, 3), (3, 4), (4, 1)] >>> list ( adjacent_n_tuples ([ 1 , 2 , 3 , 4 ], 3 )) [(1, 2, 3), (2, 3, 4), (3, 4, 1), (4, 1, 2)] Parameters : objects ( Sequence [ T ] ) n ( int ) Return type : zip[tuple[ T , \u2026]]", "original_prompt": "adjacent_n_tuples(objects, n)"}
{"prompt": "Animate a sequence of adjacent pairs that shift and repeat with changing line colors.", "response": "Alias for adjacent_n_tuples(objects, 2) . See also adjacent_n_tuples Examples >>> list ( adjacent_pairs ([ 1 , 2 , 3 , 4 ])) [(1, 2), (2, 3), (3, 4), (4, 1)] Parameters : objects ( Sequence [ T ] ) Return type : zip[tuple[ T , \u2026]]", "original_prompt": "adjacent_pairs(objects)"}
{"prompt": "\"Animate a series of colored dots moving into place, demonstrating membership testing with different shapes.\"", "response": "Returns True if all elements of iterable are instances of Class.\nFalse otherwise. Parameters : iterable ( Iterable [ object ] ) Class ( type [ object ] ) Return type : bool", "original_prompt": "all_elements_are_instances(iterable, Class)"}
{"prompt": "Animate a sequence of batches grouped by function output, preserving original order.", "response": "Takes in a Sequence, and returns a list of tuples, (batch, prop)\nsuch that all items in a batch have the same output when\nput into the Callable property_func, and such that chaining all these\nbatches together would give the original Sequence (i.e. order is\npreserved). Examples >>> batch_by_property ([( 1 , 2 ), ( 3 , 4 ), ( 5 , 6 , 7 ), ( 8 , 9 )], len ) [([(1, 2), (3, 4)], 2), ([(5, 6, 7)], 3), ([(8, 9)], 2)] Parameters : items ( Iterable [ T ] ) property_func ( Callable [ [ T ] , U ] ) Return type : list[tuple[list[ T ], U | None]]", "original_prompt": "batch_by_property(items, property_func)"}
{"prompt": "\"Merge and display lists of numbers side-by-side into a single list.\"", "response": "Combines the Iterables provided as arguments into one list. Examples >>> concatenate_lists ([ 1 , 2 ], [ 3 , 4 ], [ 5 ]) [1, 2, 3, 4, 5] Parameters : list_of_lists ( Iterable [ T ] ) Return type : list[ T ]", "original_prompt": "concatenate_lists(*list_of_lists)"}
{"prompt": "\"Show an integer value being calculated from the hash of a given object, with changing colors.\"", "response": "Determines a hash, even of potentially mutable objects. Parameters : obj ( object ) Return type : int", "original_prompt": "hash_obj(obj)"}
{"prompt": "\"Show difference between two sets, updating one with the other, using a bouncing ball visualization.\"", "response": "Returns a list containing all the elements of l1 not in l2. Examples >>> list_difference_update ([ 1 , 2 , 3 , 4 ], [ 2 , 4 ]) [1, 3] Parameters : l1 ( Iterable [ T ] ) l2 ( Iterable [ T ] ) Return type : list[ T ]", "original_prompt": "list_difference_update(l1, l2)"}
{"prompt": "\"Sort and merge two lists without duplicates, removing overlap, while preserving original order\"", "response": "Used instead of set.update() to maintain order, making sure duplicates are removed from l1, not l2.\nRemoves overlap of l1 and l2 and then concatenates l2 unchanged. Examples >>> list_update ([ 1 , 2 , 3 ], [ 2 , 4 , 4 ]) [1, 3, 2, 4, 4] Parameters : l1 ( Iterable [ T ] ) l2 ( Iterable [ T ] ) Return type : list[ T ]", "original_prompt": "list_update(l1, l2)"}
{"prompt": "Animate a text input box displaying mathematical functions and objects as lists.", "response": "Converts obj to a list intelligently. Examples >>> listify ( \"str\" ) ['str'] >>> listify (( 1 , 2 )) [1, 2] >>> listify ( len ) [<built-in function len>]", "original_prompt": "listify(obj: str) \u2192 list"}
{"prompt": "\"Extend two lists to equal length by cycling elements, showing original iterables and resulting even sequences.\"", "response": "Extends the shorter of the two iterables with duplicate values until its length is equal to the longer iterable (favours earlier elements). See also make_even_by_cycling cycles elements instead of favouring earlier ones Examples >>> make_even ([ 1 , 2 ], [ 3 , 4 , 5 , 6 ]) ([1, 1, 2, 2], [3, 4, 5, 6]) >>> make_even ([ 1 , 2 ], [ 3 , 4 , 5 , 6 , 7 ]) ([1, 1, 1, 2, 2], [3, 4, 5, 6, 7]) Parameters : iterable_1 ( Iterable [ T ] ) iterable_2 ( Iterable [ U ] ) Return type : tuple[list[ T ], list[ U ]]", "original_prompt": "make_even(iterable_1, iterable_2)"}
{"prompt": "\"Fill in gaps with repeating values between two sequences.\"", "response": "Extends the shorter of the two iterables with duplicate values until its length is equal to the longer iterable (cycles over shorter iterable). See also make_even favours earlier elements instead of cycling them Examples >>> make_even_by_cycling ([ 1 , 2 ], [ 3 , 4 , 5 , 6 ]) ([1, 2, 1, 2], [3, 4, 5, 6]) >>> make_even_by_cycling ([ 1 , 2 ], [ 3 , 4 , 5 , 6 , 7 ]) ([1, 2, 1, 2, 1], [3, 4, 5, 6, 7]) Parameters : iterable_1 ( Collection [ T ] ) iterable_2 ( Collection [ U ] ) Return type : tuple[list[ T ], list[ U ]]", "original_prompt": "make_even_by_cycling(iterable_1, iterable_2)"}
{"prompt": "\"Sort a list of elements in ascending order with maintained order for identical values\"", "response": "Used instead of list(set(l)) to maintain order.\nKeeps the last occurrence of each element. Parameters : lst ( Reversible [ H ] ) Return type : list[ H ]", "original_prompt": "remove_list_redundancies(lst)"}
{"prompt": "Animate a graph removing non-elementary elements.\n\n(Note: This prompt is concise and focuses on the key visual element, without referencing technical terms like class or self.)", "response": "Removes elements where bool(x) evaluates to False. Examples >>> remove_nones ([ \"m\" , \"\" , \"l\" , 0 , 42 , False , True ]) ['m', 'l', 42, True] Parameters : sequence ( Iterable [ T | None ] ) Return type : list[ T ]", "original_prompt": "remove_nones(sequence)"}
{"prompt": "\"Repeat and truncate an array of coordinates to fit a fixed length by cycling its elements.\"", "response": "Extends/truncates nparray so that len(result) == length . The elements of nparray are cycled to achieve the desired length. See also resize_preserving_order favours earlier elements instead of cycling them make_even_by_cycling similar cycling behaviour for balancing 2 iterables Examples >>> points = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> resize_array ( points , 1 ) array([[1, 2]]) >>> resize_array ( points , 3 ) array([[1, 2], [3, 4], [1, 2]]) >>> resize_array ( points , 2 ) array([[1, 2], [3, 4]]) Parameters : nparray ( npt.NDArray [ F ] ) length ( int ) Return type : npt.NDArray[ F ]", "original_prompt": "resize_array(nparray, length)"}
{"prompt": "\"Duplicate and align numpy arrays to desired lengths with optional preservation of original order.\"", "response": "Extends/truncates nparray so that len(result) == length . The elements of nparray are duplicated to achieve the desired length\n(favours earlier elements). Constructs a zeroes array of length if nparray is empty. See also resize_array cycles elements instead of favouring earlier ones make_even similar earlier-favouring behaviour for balancing 2 iterables Examples >>> resize_preserving_order ( np . array ([]), 5 ) array([0., 0., 0., 0., 0.]) >>> nparray = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> resize_preserving_order ( nparray , 1 ) array([[1, 2]]) >>> resize_preserving_order ( nparray , 3 ) array([[1, 2], [1, 2], [3, 4]]) Parameters : nparray ( npt.NDArray [ np.float64 ] ) length ( int ) Return type : npt.NDArray[np.float64]", "original_prompt": "resize_preserving_order(nparray, length)"}
{"prompt": "\"Interpolate missing array elements to match desired length while preserving data type\"", "response": "Extends/truncates nparray so that len(result) == length . New elements are interpolated to achieve the desired length. Note that if nparray\u2019s length changes, its dtype may too\n(e.g. int -> float: see Examples) See also resize_array cycles elements instead of interpolating resize_preserving_order favours earlier elements instead of interpolating Examples >>> nparray = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> resize_with_interpolation ( nparray , 1 ) array([[1., 2.]]) >>> resize_with_interpolation ( nparray , 4 ) array([[1.        , 2.        ], [1.66666667, 2.66666667], [2.33333333, 3.33333333], [3.        , 4.        ]]) >>> nparray = np . array ([[[ 1 , 2 ], [ 3 , 4 ]]]) >>> nparray = np . array ([[ 1 , 2 ], [ 3 , 4 ], [ 5 , 6 ]]) >>> resize_with_interpolation ( nparray , 4 ) array([[1.        , 2.        ], [2.33333333, 3.33333333], [3.66666667, 4.66666667], [5.        , 6.        ]]) >>> nparray = np . array ([[ 1 , 2 ], [ 3 , 4 ], [ 1 , 2 ]]) >>> resize_with_interpolation ( nparray , 4 ) array([[1.        , 2.        ], [2.33333333, 3.33333333], [2.33333333, 3.33333333], [1.        , 2.        ]]) Parameters : nparray ( npt.NDArray [ F ] ) length ( int ) Return type : npt.NDArray[ F ]", "original_prompt": "resize_with_interpolation(nparray, length)"}
{"prompt": "\"Rotate a red square in the x-y plane, scaling its size with distance from the origin.\"", "response": "Parameters : nparray ( npt.NDArray [ F ] ) length ( int ) Return type : npt.NDArray[ F ]", "original_prompt": "stretch_array_to_length(nparray, length)"}
{"prompt": "\"Display conversion of objects into tuples with fade effect and precise formatting.\"", "response": "Converts obj to a tuple intelligently. Examples >>> tuplify ( \"str\" ) ('str',) >>> tuplify ([ 1 , 2 ]) (1, 2) >>> tuplify ( len ) (<built-in function len>,)", "original_prompt": "tuplify(obj: str) \u2192 tuple"}
{"prompt": "\"Show the elements of each iterable in sequence, one by one.\"\n\n(Note: This prompt focuses on the visual aspect of the animation, describing what is being shown, without referencing technical details like iterables or generators)", "response": "Returns a generator that yields all unique elements of the Iterables provided via args in the order provided. Examples >>> gen = uniq_chain ([ 1 , 2 ], [ 2 , 3 ], [ 1 , 4 , 4 ]) >>> from collections.abc import Generator >>> isinstance ( gen , Generator ) True >>> tuple ( gen ) (1, 2, 3, 4) Parameters : args ( Iterable [ T ] ) Return type : Generator [ T , None, None]", "original_prompt": "uniq_chain(*args)"}
{"prompt": "\"Animate a VGroup moving clockwise around a half circle, transforming into another VGroup.\"", "response": "This function transforms each point by moving clockwise around a half circle. Examples Example: ClockwisePathExample   from manim import * class ClockwisePathExample ( Scene ): def construct ( self ): colors = [ RED , GREEN , BLUE ] starting_points = VGroup ( * [ Dot ( LEFT + pos , color = color ) for pos , color in zip ([ UP , DOWN , LEFT ], colors ) ] ) finish_points = VGroup ( * [ Dot ( RIGHT + pos , color = color ) for pos , color in zip ([ ORIGIN , UP , DOWN ], colors ) ] ) self . add ( starting_points ) self . add ( finish_points ) for dot in starting_points : self . add ( TracedPath ( dot . get_center , stroke_color = dot . get_color ())) self . wait () self . play ( Transform ( starting_points , finish_points , path_func = utils . paths . clockwise_path (), run_time = 2 , ) ) self . wait () class ClockwisePathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.clockwise_path(),\n                run_time=2,\n            )\n        )\n        self.wait() Return type : PathFuncType", "original_prompt": "clockwise_path()"}
{"prompt": "\"Animate a red, green, and blue dot group tracing counterclockwise paths around the circle while rotating to its final position.\"", "response": "This function transforms each point by moving counterclockwise around a half circle. Examples Example: CounterclockwisePathExample   from manim import * class CounterclockwisePathExample ( Scene ): def construct ( self ): colors = [ RED , GREEN , BLUE ] starting_points = VGroup ( * [ Dot ( LEFT + pos , color = color ) for pos , color in zip ([ UP , DOWN , LEFT ], colors ) ] ) finish_points = VGroup ( * [ Dot ( RIGHT + pos , color = color ) for pos , color in zip ([ ORIGIN , UP , DOWN ], colors ) ] ) self . add ( starting_points ) self . add ( finish_points ) for dot in starting_points : self . add ( TracedPath ( dot . get_center , stroke_color = dot . get_color ())) self . wait () self . play ( Transform ( starting_points , finish_points , path_func = utils . paths . counterclockwise_path (), run_time = 2 , ) ) self . wait () class CounterclockwisePathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.counterclockwise_path(),\n                run_time=2,\n            )\n        )\n        self.wait() Return type : PathFuncType", "original_prompt": "counterclockwise_path()"}
{"prompt": "Animate a rotating Dot along a circular arc to its mirror image.", "response": "This function transforms each point by moving it along a circular arc. Parameters : arc_angle ( float ) \u2013 The angle each point traverses around a circular arc. axis ( Vector3D ) \u2013 The axis of rotation. Return type : PathFuncType Examples Example: PathAlongArcExample   from manim import * class PathAlongArcExample ( Scene ): def construct ( self ): colors = [ RED , GREEN , BLUE ] starting_points = VGroup ( * [ Dot ( LEFT + pos , color = color ) for pos , color in zip ([ UP , DOWN , LEFT ], colors ) ] ) finish_points = VGroup ( * [ Dot ( RIGHT + pos , color = color ) for pos , color in zip ([ ORIGIN , UP , DOWN ], colors ) ] ) self . add ( starting_points ) self . add ( finish_points ) for dot in starting_points : self . add ( TracedPath ( dot . get_center , stroke_color = dot . get_color ())) self . wait () self . play ( Transform ( starting_points , finish_points , path_func = utils . paths . path_along_arc ( TAU * 2 / 3 ), run_time = 3 , ) ) self . wait () class PathAlongArcExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.path_along_arc(TAU * 2 / 3),\n                run_time=3,\n            )\n        )\n        self.wait()", "original_prompt": "path_along_arc(arc_angle, axis=array("}
{"prompt": "Animate a group of dots tracing curved paths around circles that rotate along the x-axis.", "response": "This function transforms each point by moving it roughly along a circle, each with its own specified center. The path may be seen as each point smoothly changing its orbit from its starting position to its destination. Parameters : arc_angle ( float ) \u2013 The angle each point traverses around the quasicircle. circles_centers ( ndarray ) \u2013 The centers of each point\u2019s quasicircle to rotate around. axis ( Vector3D ) \u2013 The axis of rotation. Return type : PathFuncType Examples Example: PathAlongCirclesExample   from manim import * class PathAlongCirclesExample ( Scene ): def construct ( self ): colors = [ RED , GREEN , BLUE ] starting_points = VGroup ( * [ Dot ( LEFT + pos , color = color ) for pos , color in zip ([ UP , DOWN , LEFT ], colors ) ] ) finish_points = VGroup ( * [ Dot ( RIGHT + pos , color = color ) for pos , color in zip ([ ORIGIN , UP , DOWN ], colors ) ] ) self . add ( starting_points ) self . add ( finish_points ) for dot in starting_points : self . add ( TracedPath ( dot . get_center , stroke_color = dot . get_color ())) circle_center = Dot ( 3 * LEFT ) self . add ( circle_center ) self . wait () self . play ( Transform ( starting_points , finish_points , path_func = utils . paths . path_along_circles ( 2 * PI , circle_center . get_center () ), run_time = 3 , ) ) self . wait () class PathAlongCirclesExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        circle_center = Dot(3 * LEFT)\n        self.add(circle_center)\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.path_along_circles(\n                    2 * PI, circle_center.get_center()\n                ),\n                run_time=3,\n            )\n        )\n        self.wait()", "original_prompt": "path_along_circles(arc_angle, circles_centers, axis=array("}
{"prompt": "\"Animate a spiral transformation from colorful dots to paths, rotating around each axis.\"", "response": "This function transforms each point by moving along a spiral to its destination. Parameters : angle ( float ) \u2013 The angle each point traverses around a spiral. axis ( Vector3D ) \u2013 The axis of rotation. Return type : PathFuncType Examples Example: SpiralPathExample   from manim import * class SpiralPathExample ( Scene ): def construct ( self ): colors = [ RED , GREEN , BLUE ] starting_points = VGroup ( * [ Dot ( LEFT + pos , color = color ) for pos , color in zip ([ UP , DOWN , LEFT ], colors ) ] ) finish_points = VGroup ( * [ Dot ( RIGHT + pos , color = color ) for pos , color in zip ([ ORIGIN , UP , DOWN ], colors ) ] ) self . add ( starting_points ) self . add ( finish_points ) for dot in starting_points : self . add ( TracedPath ( dot . get_center , stroke_color = dot . get_color ())) self . wait () self . play ( Transform ( starting_points , finish_points , path_func = utils . paths . spiral_path ( 2 * TAU ), run_time = 5 , ) ) self . wait () class SpiralPathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.spiral_path(2 * TAU),\n                run_time=5,\n            )\n        )\n        self.wait()", "original_prompt": "spiral_path(angle, axis=array("}
{"prompt": "Animate red, green, and blue dots moving in straight paths towards their colored destinations.", "response": "Simplest path function. Each point in a set goes in a straight path toward its destination. Examples Example: StraightPathExample   from manim import * class StraightPathExample ( Scene ): def construct ( self ): colors = [ RED , GREEN , BLUE ] starting_points = VGroup ( * [ Dot ( LEFT + pos , color = color ) for pos , color in zip ([ UP , DOWN , LEFT ], colors ) ] ) finish_points = VGroup ( * [ Dot ( RIGHT + pos , color = color ) for pos , color in zip ([ ORIGIN , UP , DOWN ], colors ) ] ) self . add ( starting_points ) self . add ( finish_points ) for dot in starting_points : self . add ( TracedPath ( dot . get_center , stroke_color = dot . get_color ())) self . wait () self . play ( Transform ( starting_points , finish_points , path_func = utils . paths . straight_path (), run_time = 2 , ) ) self . wait () class StraightPathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.straight_path(),\n                run_time=2,\n            )\n        )\n        self.wait() Return type : PathFuncType", "original_prompt": "straight_path()"}
{"prompt": "\"Graphically illustrate the sine function oscillating over time, with amplitude visualized as wave height.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "double_smooth(t)"}
{"prompt": "\"Show the sine wave with oscillating amplitude and frequency over time, animated vertically.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_back(t)"}
{"prompt": "\"Show sine wave graph with parameterized oscillations over time, smoothly increasing in amplitude.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_bounce(t)"}
{"prompt": "\"Show a parabola opening upwards with its equation being shown as it rises to the right.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_circ(t)"}
{"prompt": "\"Smoothly oscillate the sine function along the x-axis as it approaches a stable value.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_cubic(t)"}
{"prompt": "\"Smoothly interpolate between values of x as time progresses on the number line.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_elastic(t)"}
{"prompt": "\"Show the parabola y = x^2, reflected across the x-axis, as it opens.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_expo(t)"}
{"prompt": "\"Show a parabola's opening width narrowing from both sides with changing speed over time.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_out_back(t)"}
{"prompt": "\"Graph oscillating sinusoid with amplitude and frequency changing over time, smoothly shifting up/down the x-axis.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_out_bounce(t)"}
{"prompt": "\"Generate a sine wave graph with oscillating amplitude over time.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_out_circ(t)"}
{"prompt": "Animate sine wave oscillating within square boundaries over time interval from 0 to \u03c0.", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_out_cubic(t)"}
{"prompt": "\"Rotate a blue circle around the origin, tracing a sine wave path with x-coordinate increasing.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_out_elastic(t)"}
{"prompt": "\"Rotate a graph around the origin with time t to illustrate parametric equation behavior.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_out_expo(t)"}
{"prompt": "\"Rotate and smooth out x-coordinates of points on a parabola over time\"\n\n(No shapes/graphs/3D objects mentioned in the provided Python code snippet.)", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_out_quad(t)"}
{"prompt": "\"Graphically display sine wave with variable amplitude over time, animated from left to right.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_out_quart(t)"}
{"prompt": "Animate a sine wave graph oscillating with increasing amplitude.", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_out_quint(t)"}
{"prompt": "\"Show the graph of a sine function with x-axis labeled 't', rotating around the origin.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_out_sine(t)"}
{"prompt": "\"Fade in a sine wave graph with increasing amplitude over time, illustrating the relationship between frequency and amplitude.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_quad(t)"}
{"prompt": "\"Graphically illustrate the sine function oscillating between y=0 and y=1 with smooth transitions\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_quart(t)"}
{"prompt": "\"Draw a parabola on the screen\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_quint(t)"}
{"prompt": "Animate a parabola curve unfolding from a point on the x-axis.", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_in_sine(t)"}
{"prompt": "\"Show sine wave oscillating along x-axis, gradually increasing in amplitude.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_out_back(t)"}
{"prompt": "\"Show a sine wave oscillating with increasing frequency, smoothly transitioning to a step function over time.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_out_bounce(t)"}
{"prompt": "\"Show an increasing sine wave with time, smoothly zooming in on its vertex.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_out_circ(t)"}
{"prompt": "\"Rotate a sine wave graph along the x-axis, smoothly increasing in amplitude.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_out_cubic(t)"}
{"prompt": "\"Animate x^2 trajectory of a particle moving along the parabola with time-dependent velocity\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_out_elastic(t)"}
{"prompt": "\"Show the sine function oscillating between two lines, highlighting its smooth wave pattern.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_out_expo(t)"}
{"prompt": "\"Rotate and scale a sine wave graph over time\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_out_quad(t)"}
{"prompt": "\"Fade in a graph with variable y-values over time, oscillating between two values.\"\n\nNote: The provided code snippet is incomplete. However, the prompt above attempts to capture the essence of an animation that might involve a graph with oscillating y-values, which could be related to the missing code.", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_out_quart(t)"}
{"prompt": "Analyze Manim code to create prompt:\n\n\"Show sine wave oscillating vertically on screen\"\n\nThis prompt is concise, descriptive of key visual elements (sine wave), and doesn't require technical terms.", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_out_quint(t)"}
{"prompt": "\"Fade in a parabola as its y-value increases with time, starting at the origin.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "ease_out_sine(t)"}
{"prompt": "\"Graph a decay function with exponential decrease, smoothly animating towards zero over time.\"", "response": "Parameters : t ( float ) half_life ( float ) Return type : float", "original_prompt": "exponential_decay(t, half_life=0.1)"}
{"prompt": "\"Graphically illustrate sine wave function, oscillating between two points, with increasing amplitude over time.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "linear(t)"}
{"prompt": "However, I don't see any Manim code provided. Please share the code, and I'll analyze it to create a concise prompt for you!", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "lingering(t)"}
{"prompt": "\"Smoothly increase speed with growing size of a moving object.\"", "response": "Parameters : func ( RateFunction ) proportion ( float ) Return type : RateFunction", "original_prompt": "not_quite_there(func=<function smooth>, proportion=0.7)"}
{"prompt": "\"Pull inwards on a line graph with variable distance and speed, illustrating acceleration due to gravity.\"", "response": "Parameters : t ( float ) pull_factor ( float ) Return type : float", "original_prompt": "running_start(t, pull_factor=-0.5)"}
{"prompt": "\"Show a function graphing an inflection point at y = f(t) with a smooth, curved motion around it\"", "response": "Parameters : t ( float ) inflection ( float ) Return type : float", "original_prompt": "rush_from(t, inflection=10.0)"}
{"prompt": "\"Graph a parabola with variable curvature, smoothly changing from inflection point to smooth curve.\"", "response": "Parameters : t ( float ) inflection ( float ) Return type : float", "original_prompt": "rush_into(t, inflection=10.0)"}
{"prompt": "\"Animate sine wave graph increasing in amplitude with time, synchronized to parameter 't'.\"", "response": "Parameters : t ( float ) Return type : float", "original_prompt": "slow_into(t)"}
{"prompt": "\"Show the graph of y = x^2 with an inflection point, smoothly moving towards a horizontal line over time.\"", "response": "Parameters : t ( float ) inflection ( float ) Return type : float", "original_prompt": "smooth(t, inflection=10.0)"}
{"prompt": "Animate a curve showing the 3rd order SmoothStep sigmoid function's derivative over time, from 0 to 1.", "response": "Implementation of the 3rd order SmoothStep sigmoid function.\nThe 1st, 2nd and 3rd derivatives (speed, acceleration and jerk) are zero at the endpoints. https://en.wikipedia.org/wiki/Smoothstep Parameters : t ( float ) Return type : float", "original_prompt": "smoothererstep(t)"}
{"prompt": "Animate a smooth sigmoid curve to show its 1st and 2nd derivatives over time, highlighting endpoint properties.", "response": "Implementation of the 2nd order SmoothStep sigmoid function.\nThe 1st and 2nd derivatives (speed and acceleration) are zero at the endpoints. https://en.wikipedia.org/wiki/Smoothstep Parameters : t ( float ) Return type : float", "original_prompt": "smootherstep(t)"}
{"prompt": "Animate a graph showing the first-order derivative of the smoothstep sigmoid function.", "response": "Implementation of the 1st order SmoothStep sigmoid function.\nThe 1st derivative (speed) is zero at the endpoints. https://en.wikipedia.org/wiki/Smoothstep Parameters : t ( float ) Return type : float", "original_prompt": "smoothstep(t)"}
{"prompt": "\"Show rate of change graph with linear equation, highlighting a and b values over time.\"", "response": "Parameters : func ( RateFunction ) a ( float ) b ( float ) Return type : RateFunction", "original_prompt": "squish_rate_func(func, a=0.4, b=0.6)"}
{"prompt": "\"Show graph of parabola inflicting on y-axis with parameter t controlling its shape.\"\n\nNote: The provided Manim code appears to define a function that takes two parameters, `t` and `inflection`, and returns the value of a parabola at a given point. However, without more context or information about what's being animated, I couldn't create a more detailed prompt.", "response": "Parameters : t ( float ) inflection ( float ) Return type : float", "original_prompt": "there_and_back(t, inflection=10.0)"}
{"prompt": "\"Show a graph oscillating sinusoidally with time, smoothly fading in and out over time.\"\n\nThis prompt highlights the key visual element of a graph, the transformation of amplitude (fade-in/fade-out), and the mathematical concept of a sinusoidal function. The use of \"smoothly\" emphasizes the pause ratio parameter controlling the animation's pace.", "response": "Parameters : t ( float ) pause_ratio ( float ) Return type : float", "original_prompt": "there_and_back_with_pause(t, pause_ratio=0.3333333333333333)"}
{"prompt": "\"Visualize rate of change with animated exponential curves.\"\n\n(Note: The provided Python code does not seem to be related to the given prompt, as it defines a mathematical function without any visual elements. If you provide more context or the actual code, I'd be happy to help create a new prompt.)", "response": "Parameters : function ( RateFunction ) Return type : RateFunction", "original_prompt": "unit_interval(function)"}
{"prompt": "Animate sine wave oscillations with time-dependent amplitude, showcasing smooth sinusoidal motion over time.", "response": "Parameters : t ( float ) wiggles ( float ) Return type : float", "original_prompt": "wiggle(t, wiggles=2)"}
{"prompt": "\"Fade in a graph with an exponential increase, then smoothly scale its height with time.\"\n\nNote: The provided Manim code snippet does not appear to contain any visual elements, transformations, or mathematical concepts. It defines a rate function for animation purposes only. If you provide more context or the actual code snippet, I'd be happy to assist you in creating a descriptive prompt.", "response": "Parameters : function ( RateFunction ) Return type : RateFunction", "original_prompt": "zero(function)"}
{"prompt": "\"Show a parabola opening upwards, with x-axis labeled as x and y-axis labeled as y, zooming in on the vertex.\"", "response": "TypeVar ( 'ComparableT' , bound = Comparable )", "original_prompt": "class ComparableT"}
{"prompt": "\"Graphically illustrate numerical binary search finding roots of a quadratic equation within specified bounds.\"", "response": "Searches for a value in a range by repeatedly dividing the range in half. To be more precise, performs numerical binary search to determine the\ninput to function , between the bounds given, that outputs target to within tolerance (default of 0.0001).\nReturns None if no input can be found within the bounds. Examples Consider the polynomial \\(x^2 + 3x + 1\\) where we search for\na target value of \\(11\\) . An exact solution is \\(x = 2\\) . >>> solution = binary_search ( lambda x : x ** 2 + 3 * x + 1 , 11 , 0 , 5 ) >>> bool ( abs ( solution - 2 ) < 1e-4 ) True >>> solution = binary_search ( lambda x : x ** 2 + 3 * x + 1 , 11 , 0 , 5 , tolerance = 0.01 ) >>> bool ( abs ( solution - 2 ) < 0.01 ) True Searching in the interval \\([0, 5]\\) for a target value of \\(71\\) does not yield a solution: >>> binary_search ( lambda x : x ** 2 + 3 * x + 1 , 71 , 0 , 5 ) is None True Parameters : function ( Callable [ [ float ] , float ] ) target ( float ) lower_bound ( float ) upper_bound ( float ) tolerance ( float ) Return type : float | None", "original_prompt": "binary_search(function, target, lower_bound, upper_bound, tolerance=0.0001)"}
{"prompt": "\"Visualize the binomial coefficient n choose k with a changing 'hands-on' selection process.\"", "response": "The binomial coefficient n choose k. \\(\\binom{n}{k}\\) describes the number of possible choices of \\(k\\) elements from a set of \\(n\\) elements. References https://en.wikipedia.org/wiki/Combination https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.comb.html Parameters : n ( int ) k ( int ) Return type : int", "original_prompt": "choose(n, k)"}
{"prompt": "\"Fade in and out of bounds, returning closest value between min_a and max_a.\"", "response": "Clips a to the interval [ min_a , max_a ]. Accepts any comparable objects (i.e. those that support <, >).\nReturns a if it is between min_a and max_a .\nOtherwise, whichever of min_a and max_a is closest. Examples >>> clip ( 15 , 11 , 20 ) 15 >>> clip ( 'a' , 'h' , 'k' ) 'h' Parameters : a ( ComparableT ) min_a ( ComparableT ) max_a ( ComparableT ) Return type : ComparableT", "original_prompt": "clip(a, min_a, max_a)"}
{"prompt": "Animate the logistic function, showing how it maps input values to output probabilities.", "response": "Returns the output of the logistic function. The logistic function, a common example of a sigmoid function, is defined\nas \\(\\frac{1}{1 + e^{-x}}\\) . References https://en.wikipedia.org/wiki/Sigmoid_function https://en.wikipedia.org/wiki/Logistic_function Parameters : x ( float ) Return type : float", "original_prompt": "sigmoid(x)"}
{"prompt": "\"Play an audio file\" \n\n(Note: The provided Manim code snippet doesn't specify the visual elements, transformations, or mathematical concepts being used. To create a more descriptive prompt, additional information about the animation is required.)", "response": "Parameters : sound_file_name ( StrPath ) Return type : Path", "original_prompt": "get_full_sound_file_path(sound_file_name)"}
{"prompt": "Animate points on a graph moving along an arbitrary path.", "response": "Parameters : point ( Sequence [ float ] ) Return type : ndarray", "original_prompt": "R3_to_complex(point)"}
{"prompt": "\"Visualize the direction of rotation with an axis based on a given quaternion's angle and axis.\"", "response": "Gets angle and axis from a quaternion. Parameters : quaternion ( Sequence [ float ] ) \u2013 The quaternion from which we get the angle and axis. Returns : Gives the angle and axis Return type : Sequence[float]", "original_prompt": "angle_axis_from_quaternion(quaternion)"}
{"prompt": "Animate a dot product calculation, displaying unit vectors on an axis, with rotation of vectors to show angle between them.", "response": "Returns the angle between two vectors.\nThis angle will always be between 0 and pi Parameters : v1 ( ndarray ) \u2013 The first vector. v2 ( ndarray ) \u2013 The second vector. Returns : The angle between the vectors. Return type : float", "original_prompt": "angle_between_vectors(v1, v2)"}
{"prompt": "\"Show a vector's projection on the XY plane and calculate its polar angle with a 3D coordinate system.\"", "response": "Returns polar coordinate theta when vector is projected on xy plane. Parameters : vector ( Sequence [ float ] | ndarray ) \u2013 The vector to find the angle for. Returns : The angle of the vector projected. Return type : float", "original_prompt": "angle_of_vector(vector)"}
{"prompt": "\"Generate a 3D sphere from polar coordinates and visualize its radius and angle values.\"", "response": "Returns an array of numbers corresponding to each\npolar coordinate value (distance, phi, theta). Parameters : vec ( Sequence [ float ] ) \u2013 A numpy array [x, y, z] . Return type : ndarray", "original_prompt": "cartesian_to_spherical(vec)"}
{"prompt": "\"Visualize the center of mass calculation for a set of points, illustrating vector addition and centroid determination.\"", "response": "Gets the center of mass of the points in space. Parameters : points ( PointNDLike_Array ) \u2013 The points to find the center of mass from. Returns : The center of mass of the points. Return type : np.ndarray", "original_prompt": "center_of_mass(points)"}
{"prompt": "Rotate an arrow representing cardinal directions by 0, 90, and 180 degrees around a fixed point with tau units.", "response": "Finds the cardinal directions using tau. Parameters : n ( int ) \u2013 The amount to be rotated, by default 4 start_vect ( ndarray ) \u2013 The direction for the angle to start with, by default RIGHT Returns : The angle which has been rotated. Return type : np.ndarray", "original_prompt": "compass_directions(n=4, start_vect=array("}
{"prompt": "Animate a point moving along a complex-valued curve defined by the given function.", "response": "Parameters : complex_func ( Callable [ [ complex ] , complex ] ) Return type : Callable [[ Point3DLike ], Point3D ]", "original_prompt": "complex_func_to_R3_func(complex_func)"}
{"prompt": "\"Display the magnitude of a complex number as a color gradient.\"", "response": "Parameters : complex_num ( complex ) Return type : ndarray", "original_prompt": "complex_to_R3(complex_num)"}
{"prompt": "\"Rotate vectors V1 and V2 around the origin while showing unit vector visualizations.\"", "response": "Parameters : v1 ( Vector3D ) v2 ( Vector3D ) Return type : Vector3D", "original_prompt": "cross(v1, v2)"}
{"prompt": "\"Show the cross product of two vectors in 2D space with their components highlighted.\"", "response": "Compute the determinant(s) of the passed\nvector (sequences). Parameters : a ( Vector2D | Vector2D_Array ) \u2013 A vector or a sequence of vectors. b ( Vector2D | Vector2D_Array ) \u2013 A vector or a sequence of vectors. Returns : The determinant or sequence of determinants\nof the first two components of the specified\nvectors. Return type : Sequence[float] | float Examples >>> cross2d ( np . array ([ 1 , 2 ]), np . array ([ 3 , 4 ])) np.int64(-2) >>> cross2d ( ... np . array ([[ 1 , 2 , 0 ], [ 1 , 0 , 0 ]]), ... np . array ([[ 3 , 4 , 0 ], [ 0 , 1 , 0 ]]), ... ) array([-2,  1])", "original_prompt": "cross2d(a, b)"}
{"prompt": "\"Show a polygon's triangulation with holes and highlighted end points over time, displaying updated shapes.\"", "response": "Returns a list of indices giving a triangulation\nof a polygon, potentially with holes. Parameters : verts ( ndarray ) \u2013 verts is a numpy array of points. ring_ends ( list ) \u2013 ring_ends is a list of indices indicating where\nthe ends of new paths are. Returns : A list of indices giving a triangulation of a polygon. Return type : list", "original_prompt": "earclip_triangulation(verts, ring_ends)"}
{"prompt": "Animate the intersection points between two lines in 3D space, revealing closest distance.", "response": "Return the intersection of a line passing through p0 in direction v0\nwith one passing through p1 in direction v1 (or array of intersections\nfrom arrays of such points/directions).\nFor 3d values, it returns the point on the ray p0 + v0 * t closest to the\nray p1 + v1 * t Parameters : p0s ( Point3DLike_Array ) v0s ( Vector3D_Array ) p1s ( Point3DLike_Array ) v1s ( Vector3D_Array ) threshold ( float ) Return type : list[ Point3D ]", "original_prompt": "find_intersection(p0s, v0s, p1s, v1s, threshold=1e-05)"}
{"prompt": "\"Highlight unit normals of two vectors as arrows, with color representing magnitude.\"", "response": "Gets the unit normal of the vectors. Parameters : v1 ( Vector3D ) \u2013 The first vector. v2 ( Vector3D ) \u2013 The second vector tol ( float ) \u2013 [description], by default 1e-6 Returns : The normal of the two vectors. Return type : np.ndarray", "original_prompt": "get_unit_normal(v1, v2, tol=1e-06)"}
{"prompt": "Animate a square representing a polygon winding around the origin, with its orientation changing after shifting up.", "response": "Determine the number of times a polygon winds around the origin. The orientation is measured mathematically positively, i.e.,\ncounterclockwise. Parameters : points ( Sequence [ ndarray ] ) \u2013 The vertices of the polygon being queried. Return type : float Examples >>> from manim import Square , get_winding_number >>> polygon = Square () >>> get_winding_number ( polygon . get_vertices ()) np.float64(1.0) >>> polygon . shift ( 2 * UP ) Square >>> get_winding_number ( polygon . get_vertices ()) np.float64(0.0)", "original_prompt": "get_winding_number(points)"}
{"prompt": "Animate two lines intersecting in 2D space, highlighting an error message when they don't cross.", "response": "Returns the intersection point of two lines, each defined by\na pair of distinct points lying on the line. Parameters : line1 ( Sequence [ ndarray ] ) \u2013 A list of two points that determine the first line. line2 ( Sequence [ ndarray ] ) \u2013 A list of two points that determine the second line. Returns : The intersection points of the two lines which are intersecting. Return type : np.ndarray Raises : ValueError \u2013 Error is produced if the two lines don\u2019t intersect with each other\n    or if the coordinates don\u2019t lie on the xy-plane.", "original_prompt": "line_intersection(line1, line2)"}
{"prompt": "\"Draw a line segment connecting two points and display its midpoint.\"", "response": "Gets the midpoint of two points. Parameters : point1 ( Sequence [ float ] ) \u2013 The first point. point2 ( Sequence [ float ] ) \u2013 The second point. Returns : The midpoint of the points Return type : Union [float, np.ndarray]", "original_prompt": "midpoint(point1, point2)"}
{"prompt": "\"Graphically illustrate the relationship between velocity and distance traveled.\"", "response": "Parameters : v ( float ) Return type : float", "original_prompt": "norm_squared(v)"}
{"prompt": "\"Draw a vector from a given point with optional fall-back, returning the resulting vector.\"", "response": "Parameters : vect ( ndarray | tuple [ float ] ) fall_back ( ndarray | None ) Return type : ndarray", "original_prompt": "normalize(vect, fall_back=None)"}
{"prompt": "\"Normalize a 2D array along its X-axis to have unit values, smoothly with color fade.\"", "response": "Normalizes an array with the provided axis. Parameters : array ( ndarray ) \u2013 The array which has to be normalized. axis ( ndarray ) \u2013 The axis to be normalized to. Returns : Array which has been normalized according to the axis. Return type : np.ndarray", "original_prompt": "normalize_along_axis(array, axis)"}
{"prompt": "\"Draw a line segment between two points and show its perpendicular bisector as a dotted blue line.\"", "response": "Returns a list of two points that correspond\nto the ends of the perpendicular bisector of the\ntwo points given. Parameters : line ( Sequence [ ndarray ] ) \u2013 a list of two numpy array points (corresponding\nto the ends of a line). norm_vector ( Vector3D ) \u2013 the vector perpendicular to both the line given\nand the perpendicular bisector. Returns : A list of two numpy array points that correspond\nto the ends of the perpendicular bisector Return type : list", "original_prompt": "perpendicular_bisector(line, norm_vector=array("}
{"prompt": "\"Rotate a 3D quaternions around each axis and visualize its conjugate.\"", "response": "Used for finding the conjugate of the quaternion Parameters : quaternion ( Sequence [ float ] ) \u2013 The quaternion for which you want to find the conjugate for. Returns : The conjugate of the quaternion. Return type : np.ndarray", "original_prompt": "quaternion_conjugate(quaternion)"}
{"prompt": "\"Generate a 3D sphere with arrows representing quaternions rotating along an axis.\"", "response": "Gets a quaternion from an angle and an axis.\nFor more information, check this Wikipedia page . Parameters : angle ( float ) \u2013 The angle for the quaternion. axis ( ndarray ) \u2013 The axis for the quaternion axis_normalized ( bool ) \u2013 Checks whether the axis is normalized, by default False Returns : Gives back a quaternion from the angle and axis Return type : list[float]", "original_prompt": "quaternion_from_angle_axis(angle, axis, axis_normalized=False)"}
{"prompt": "\"Rotate two quaternions together to find their Hamilton product.\"", "response": "Gets the Hamilton product of the quaternions provided.\nFor more information, check this Wikipedia page . Returns : Returns a list of product of two quaternions. Return type : Union [np.ndarray, List[ Union [float, np.ndarray]]] Parameters : quats ( Sequence [ float ] )", "original_prompt": "quaternion_mult(*quats)"}
{"prompt": "\"Create a circular pattern of evenly spaced points rotating around a central axis.\"", "response": "Generates regularly spaced vertices around a circle centered at the origin. Parameters : n ( int ) \u2013 The number of vertices radius ( float ) \u2013 The radius of the circle that the vertices are placed on. start_angle ( float | None ) \u2013 The angle the vertices start at. If unspecified, for even n values, 0 will be used.\nFor odd n values, 90 degrees is used. Returns : vertices ( numpy.ndarray ) \u2013 The regularly spaced vertices. start_angle ( float ) \u2013 The angle the vertices start at. Return type : tuple[ ndarray , float]", "original_prompt": "regular_vertices(n, *, radius=1, start_angle=None)"}
{"prompt": "\"Rotate a 3D vector around an arbitrary axis.\"\n\nNote: I've kept the prompt concise while still conveying the key visual element (a 3D vector) and transformation (rotation). The \"arbitrary axis\" detail implies that the user can specify their own axis of rotation, without requiring additional context or parameters.", "response": "Function for rotating a vector. Parameters : vector ( ndarray ) \u2013 The vector to be rotated. angle ( float ) \u2013 The angle to be rotated by. axis ( ndarray ) \u2013 The axis to be rotated, by default OUT Returns : The rotated vector with provided angle and axis. Return type : np.ndarray Raises : ValueError \u2013 If vector is not of dimension 2 or 3.", "original_prompt": "rotate_vector(vector, angle, axis=array("}
{"prompt": "\"Rotate a 2D point around the origin with increasing angle of [angle] degrees.\"", "response": "Returns a rotation matrix for a given angle. Parameters : angle ( float ) \u2013 Angle for the rotation matrix. Returns : Gives back the rotated matrix. Return type : np.ndarray", "original_prompt": "rotation_about_z(angle)"}
{"prompt": "Rotate a point in 3D space around an axis while showing its homogeneity.", "response": "Rotation in R^3 about a specified axis of rotation. Parameters : angle ( float ) axis ( ndarray ) homogeneous ( bool ) Return type : ndarray", "original_prompt": "rotation_matrix(angle, axis, homogeneous=False)"}
{"prompt": "\"Rotate quaternions to change 3D orientation.\"\n\n(Note: The provided Python code is specifically related to quaternions, a mathematical concept used in 3D transformations. This prompt captures the essence of the animation being created.)", "response": "Parameters : quat ( ndarray ) Return type : ndarray", "original_prompt": "rotation_matrix_from_quaternion(quat)"}
{"prompt": "\"Rotate an arrow along the x-axis by an increasing angle.\"\n\n(Note: The code seems to involve rotating an arrow in 2D space, but it's not explicitly stated. However, without more context or visual elements mentioned, this is the most concise and accurate prompt I could create.)", "response": "Parameters : angle ( float ) axis ( ndarray ) Return type : ndarray", "original_prompt": "rotation_matrix_transpose(angle, axis)"}
{"prompt": "Animate a rotating cube that transforms into a sphere with coordinate axes display", "response": "Converts the quaternion, quat, to an equivalent rotation matrix representation.\nFor more information, check this page . Parameters : quat ( ndarray ) \u2013 The quaternion which is to be converted. Returns : Gives back the Rotation matrix representation, returned as a 3-by-3\nmatrix or 3-by-3-by-N multidimensional array. Return type : List[np.ndarray]", "original_prompt": "rotation_matrix_transpose_from_quaternion(quat)"}
{"prompt": "\"Graph a curve tracing the shoelace formula, moving along an array of points with coordinates.\"", "response": "2D implementation of the shoelace formula. Returns : Returns signed area. Return type : float Parameters : x_y ( Point2D_Array )", "original_prompt": "shoelace(x_y)"}
{"prompt": "\"Graph a random point set, then apply the shoelace method to determine direction.\"", "response": "Uses the area determined by the shoelace method to determine whether\nthe input set of points is directed clockwise or counterclockwise. Returns : Either \"CW\" or \"CCW\" . Return type : str Parameters : x_y ( Point2D_Array )", "original_prompt": "shoelace_direction(x_y)"}
{"prompt": "\"Convert spherical coordinates into 3D points with a gradual zoom.\"", "response": "Returns a numpy array [x, y, z] based on the spherical\ncoordinates given. Parameters : spherical ( Sequence [ float ] ) \u2013 A list of three floats that correspond to the following: r - The distance between the point and the origin. theta - The azimuthal angle of the point to the positive x-axis. phi - The vertical angle of the point to the positive z-axis. Return type : ndarray", "original_prompt": "spherical_to_cartesian(spherical)"}
{"prompt": "\"Create a square matrix with specified dimension and thickness, dynamically generated.\"", "response": "Parameters : dim ( int ) thickness ( int ) Return type : MatrixMN", "original_prompt": "thick_diagonal(dim, thickness=2)"}
{"prompt": "\"Display a line segment along a rotating axis that stabilizes at a new direction with each rotation.\"", "response": "Returns some matrix in SO(3) which takes the z-axis to the\n(normalized) vector provided as an argument Parameters : vector ( ndarray ) Return type : ndarray", "original_prompt": "z_to_vector(vector)"}
{"prompt": "\"Render a compiled TeX document into a high-quality PDF with specified formatting options.\"", "response": "Compiles a tex_file into a .dvi or a .xdv or a .pdf Parameters : tex_file ( Path ) \u2013 File name of TeX file to be typeset. tex_compiler ( str ) \u2013 String containing the compiler to be used, e.g. pdflatex or lualatex output_format ( str ) \u2013 String containing the output format generated by the compiler, e.g. .dvi or .pdf Returns : Path to generated output file in desired format (DVI, XDV or PDF). Return type : Path", "original_prompt": "compile_tex(tex_file, tex_compiler, output_format)"}
{"prompt": "\"Convert a .dvi document into an SVG image with specified file extension and page number.\"", "response": "Converts a .dvi, .xdv, or .pdf file into an svg using dvisvgm. Parameters : dvi_file ( Path ) \u2013 File name of the input file to be converted. extension ( str ) \u2013 String containing the file extension and thus indicating the file type, e.g. .dvi or .pdf page ( int ) \u2013 Page to be converted if input file is multi-page. Returns : Path to generated SVG file. Return type : Path", "original_prompt": "convert_to_svg(dvi_file, extension, page=1)"}
{"prompt": "Delete all files without specified extensions, preserving only those ending in \".svg\" and \".tex\".", "response": "Deletes every file that does not have a suffix in (\".svg\", \".tex\", *additional_endings) Parameters : additional_endings ( Iterable [ str ] ) \u2013 Additional endings to whitelist Return type : None", "original_prompt": "delete_nonsvg_files(additional_endings=())"}
{"prompt": "Animate a square that smoothly changes size and rotates around its center with an equation displayed below it.", "response": "Takes a tex expression (and an optional tex environment),\nand returns a fully formed tex file ready for compilation. Parameters : expression ( str ) \u2013 String containing the TeX expression to be rendered, e.g. \\\\sqrt{2} or foo environment ( str | None ) \u2013 The string containing the environment in which the expression should be typeset, e.g. align* tex_template ( TexTemplate | None ) \u2013 Template class used to typesetting. If not set, use default template set via config[\u201ctex_template\u201d] Returns : Path to generated TeX file Return type : Path", "original_prompt": "generate_tex_file(expression, environment=None, tex_template=None)"}
{"prompt": "\"Show a match sequence with words aligning vertically.\"\n\n(Note: The provided Manim code snippet does not explicitly define any shapes, 3D objects, transformations, mathematical concepts, or animation sequences. Therefore, the prompt is concise and simple.)", "response": "Parameters : matching ( Match [ str ] ) Return type : Generator [str]", "original_prompt": "insight_inputenc_error(matching)"}
{"prompt": "\"Show a line graph with x-axis labels, then animate it moving horizontally across the screen.\"", "response": "Parameters : matching ( Match [ str ] ) Return type : Generator [str]", "original_prompt": "insight_package_not_found_error(matching)"}
{"prompt": "\"Compile a LaTeX document with specified text processor and output format, saving files in a designated directory.\"", "response": "Prepares the TeX compilation command, i.e. the TeX compiler name\nand all necessary CLI flags. Parameters : tex_compiler ( str ) \u2013 String containing the compiler to be used, e.g. pdflatex or lualatex output_format ( str ) \u2013 String containing the output format generated by the compiler, e.g. .dvi or .pdf tex_file ( Path ) \u2013 File name of TeX file to be typeset. tex_dir ( Path ) \u2013 Path to the directory where compiler output will be stored. Returns : Compilation command according to given parameters Return type : list[str]", "original_prompt": "make_tex_compilation_command(tex_compiler, output_format, tex_file, tex_dir)"}
{"prompt": "\"Render a mathematical equation from a LaTeX file using a specified TeX compiler for display in a log file.\"", "response": "Parameters : log_file ( Path ) tex_compiler ( str ) tex_file ( Path ) Return type : None", "original_prompt": "print_all_tex_errors(log_file, tex_compiler, tex_file)"}
{"prompt": "\"Animate a graph's y-axis values increasing over time with error bars.\"", "response": "Parameters : tex_compilation_log ( Sequence [ str ] ) error_start_index ( int ) tex_source ( Sequence [ str ] ) Return type : None", "original_prompt": "print_tex_error(tex_compilation_log, error_start_index, tex_source)"}
{"prompt": "\"Draw an evolving spiral equation on a graph, tracing its path over time.\" \n\nHowever, the prompt is incomplete as it doesn't specify any transformations or animations. To create a more descriptive prompt, here's a revised version:\n\n\"Animate a rotating spiral that morphs into a helix, revealing a parametric curve in motion.\"\n\nThis revised prompt includes key visual elements (spiral and helix), recognizes transformations (rotation), and notes mathematical concepts (parametric curve).", "response": "Parameters : expression ( Any ) Return type : str", "original_prompt": "tex_hash(expression)"}
{"prompt": "\"Render a TeX expression as an animated SVG diagram.\"", "response": "Takes a tex expression and returns the svg version of the compiled tex Parameters : expression ( str ) \u2013 String containing the TeX expression to be rendered, e.g. \\\\sqrt{2} or foo environment ( str | None ) \u2013 The string containing the environment in which the expression should be typeset, e.g. align* tex_template ( TexTemplate | None ) \u2013 Template class used to typesetting. If not set, use default template set via config[\u201ctex_template\u201d] Returns : Path to generated SVG file. Return type : Path", "original_prompt": "tex_to_svg_file(expression, environment=None, tex_template=None)"}
{"prompt": "\"Visualize x^2 + y^2 as a circle on a coordinate plane with points moving along it in an oscillating path.\"", "response": "np . float64 A double-precision floating-point value (64 bits, or 8 bytes),\naccording to the IEEE 754 standard.", "original_prompt": "class ManimFloat"}
{"prompt": "\"Animate an integer A growing from -9.2e18 to +9.2e18 on the x-axis with exponential growth.\"", "response": "np . int64 A long integer (64 bits, or 8 bytes). It can take values between \\(-2^{63}\\) and \\(+2^{63} - 1\\) ,\nwhich expressed in base 10 is a range between around \\(-9.223 \\cdot 10^{18}\\) and \\(+9.223 \\cdot 10^{18}\\) .", "original_prompt": "class ManimInt"}
{"prompt": "\"Fade in a colorful sine wave graph that oscillates vertically within the screen with variable amplitude.\"", "response": "ManimFloat Data type used in ManimColorInternal : a\ndouble-precision float between 0 and 1.", "original_prompt": "class ManimColorDType"}
{"prompt": "Animate a circle that smoothly fades from red to green with oscillating blue intensity over time.", "response": "NDArray[ ManimColorDType ] shape: (3,) A numpy.ndarray of 3 floats between 0 and 1, representing a\ncolor in RGB format. Its components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.", "original_prompt": "class RGB_Array_Float"}
{"prompt": "\"Create a color gradient animating from red to green, transitioning smoothly through shades.\"", "response": "tuple [ float , float , float ] shape: (3,) A tuple of 3 floats between 0 and 1, representing a color in RGB\nformat. Its components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.", "original_prompt": "class RGB_Tuple_Float"}
{"prompt": "\"Fade an arrow into place, with color changing from red to green over time.\"\n\nHere's why:\n\n* Key visual element: An arrow.\n* Transformation: Fade into place.\n* With/of: Color changes from red (RGB 255,0,0) to green (RGB 0,255,0).\n \nNote that this prompt does not include a specific mathematical concept or animation sequence. The Manim code does not use shapes, graphs, or 3D objects in the provided snippet, so these details are omitted.", "response": "NDArray[ ManimInt ] shape: (3,) A numpy.ndarray of 3 integers between 0 and 255,\nrepresenting a color in RGB format. Its components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.", "original_prompt": "class RGB_Array_Int"}
{"prompt": "\"Showcase an evolving rainbow spectrum with increasing brightness, transitioning from red to green to blue.\"", "response": "tuple [ int , int , int ] shape: (3,) A tuple of 3 integers between 0 and 255, representing a color in RGB\nformat. Its components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.", "original_prompt": "class RGB_Tuple_Int"}
{"prompt": "\"Fade a transparent square into a filled rectangle with animated RGB values over a 5-second duration.\"", "response": "NDArray[ ManimColorDType ] shape: (4,) A numpy.ndarray of 4 floats between 0 and 1, representing a\ncolor in RGBA format. Its components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.", "original_prompt": "class RGBA_Array_Float"}
{"prompt": "Animate a changing RGBA color over time with smooth transitions.", "response": "tuple [ float , float , float , float ] shape: (4,) A tuple of 4 floats between 0 and 1, representing a color in RGBA\nformat. Its components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.", "original_prompt": "class RGBA_Tuple_Float"}
{"prompt": "\"Create an animated RGBA color transition from black to white.\"", "response": "NDArray[ ManimInt ] shape: (4,) A numpy.ndarray of 4 integers between 0 and 255,\nrepresenting a color in RGBA format. Its components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.", "original_prompt": "class RGBA_Array_Int"}
{"prompt": "Animate a circle with changing RGBA colors over time with fade-in effect slowly.", "response": "tuple [ int , int , int , int ] shape: (4,) A tuple of 4 integers between 0 and 255, representing a color in RGBA\nformat. Its components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.", "original_prompt": "class RGBA_Tuple_Int"}
{"prompt": "\"Gradually fill a RGB array with colors, transforming from HSV to RGB.\"", "response": "RGB_Array_Float shape: (3,) A numpy.ndarray of 3 floats between 0 and 1, representing a\ncolor in HSV (or HSB) format. Its components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.", "original_prompt": "class HSV_Array_Float"}
{"prompt": "\"Fade in an RGB color tuple over time.\"", "response": "RGB_Tuple_Float shape: (3,) A tuple of 3 floats between 0 and 1, representing a color in HSV (or\nHSB) format. Its components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.", "original_prompt": "class HSV_Tuple_Float"}
{"prompt": "Animate a pulsating RGBA array that changes with time, revealing a gradient of colors over the hue axis.", "response": "RGBA_Array_Float shape: (4,) A numpy.ndarray of 4 floats between 0 and 1, representing a\ncolor in HSVA (or HSBA) format. Its components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.", "original_prompt": "class HSVA_Array_Float"}
{"prompt": "Animate an RGBA color tuple that gradually changes its hue value while keeping saturation and brightness constant.", "response": "RGBA_Tuple_Float shape: (4,) A tuple of 4 floats between 0 and 1, representing a color in HSVA (or\nHSBA) format. Its components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.", "original_prompt": "class HSVA_Tuple_Float"}
{"prompt": "Animate an RGB color bar that smoothly fades from Red to Blue with fading and rotation effects.", "response": "RGB_Array_Float shape: (3,) A numpy.ndarray of 3 floats between 0 and 1, representing a\ncolor in HSL format. Its components describe, in order, the Hue, Saturation and Lightness\nin the represented color.", "original_prompt": "class HSL_Array_Float"}
{"prompt": "\"Fade a square into an ellipse with RGB values changing over time, illustrating HSL color transitions.\"", "response": "RGB_Tuple_Float shape: (3,) A numpy.ndarray of 3 floats between 0 and 1, representing a\ncolor in HSL format. Its components describe, in order, the Hue, Saturation and Lightness\nin the represented color.", "original_prompt": "class HSL_Tuple_Float"}
{"prompt": "Animate a red dot that fades from full opacity to zero along a horizontal line.", "response": "RGBA_Array_Float shape: (4,) Internal color representation used by ManimColor ,\nfollowing the RGBA format. It is a numpy.ndarray consisting of 4 floats between 0 and\n1, describing respectively the intensities of Red, Green, Blue and\nAlpha (opacity) in the represented color.", "original_prompt": "class ManimColorInternal"}
{"prompt": "\"Draw a red circle moving horizontally across the screen with changing radius.\"", "response": "ManimFloat Default type for arrays representing points: a double-precision\nfloating point value.", "original_prompt": "class PointDType"}
{"prompt": "Animate a blue dot that moves along the x-axis from 0 to 10 with smooth linear motion.", "response": "NDArray[ PointDType ] shape: (2,) A NumPy array representing a 2-dimensional point: [float, float] .", "original_prompt": "class Point2D"}
{"prompt": "Animate a circle that moves along a straight line with constantly changing speed and direction.", "response": "Point2D | tuple[float, float] shape: (2,) A 2-dimensional point: [float, float] . This represents anything which can be converted to a :class: Point2D NumPy\narray. Normally, a function or method which expects a Point2D as a\nparameter can handle being passed a Point3D instead.", "original_prompt": "class Point2DLike"}
{"prompt": "\"Rotate a series of connected dots around the origin.\"", "response": "NDArray[ PointDType ] shape: (M, 2) A NumPy array representing a sequence of Point2D objects: [[float, float], ...] .", "original_prompt": "class Point2D_Array"}
{"prompt": "\"Animate a grid of points moving along straight lines with variable speeds.\"", "response": "Point2D_Array | Sequence[ Point2DLike ] shape: (M, 2) An array of Point2DLike objects: [[float, float], ...] . This represents anything which can be converted to a :class: Point2D_Array NumPy array. Normally, a function or method which expects a Point2D_Array as a\nparameter can handle being passed a Point3D_Array instead. Please refer to the documentation of the function you are using for\nfurther type information.", "original_prompt": "class Point2DLike_Array"}
{"prompt": "Animate a 3D point moving along a parabola in space while showing its coordinates.", "response": "NDArray[ PointDType ] shape: (3,) A NumPy array representing a 3-dimensional point: [float, float, float] .", "original_prompt": "class Point3D"}
{"prompt": "\"Rotate and orbit a glowing blue point around the origin in 3D space.\"", "response": "Point3D | tuple[float, float, float] shape: (3,) A 3-dimensional point: [float, float, float] . This represents anything which can be converted to a :class: Point3D NumPy\narray.", "original_prompt": "class Point3DLike"}
{"prompt": "\"Show M points moving in 3D space as an array transforms.\"\n\nThis prompt is concise and accurately describes the animation being created. It identifies key visual elements (points), transformations (an array transforming) and does not include any unnecessary mathematical concepts or details.", "response": "NDArray[ PointDType ] shape: (M, 3) A NumPy array representing a sequence of Point3D objects: [[float, float, float], ...] .", "original_prompt": "class Point3D_Array"}
{"prompt": "Animate a 3D plot showing an orbit around a central point with curved trajectories, gradually slowing down over time.", "response": "Point3D_Array | Sequence[ Point3DLike ] shape: (M, 3) An array of Point3D objects: [[float, float, float], ...] . This represents anything which can be converted to a :class: Point3D_Array NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "original_prompt": "class Point3DLike_Array"}
{"prompt": "\"Animate a line segment's length along the x-axis over time, with continuous movement.\"", "response": "NDArray[ PointDType ] shape: (N,) A NumPy array representing an N-dimensional point: [float, ...] .", "original_prompt": "class PointND"}
{"prompt": "Animate an N-dimensional point's position and size changing smoothly over time.", "response": "PointND | Sequence[float] shape: (N,) An N-dimensional point: [float, ...] . This represents anything which can be converted to a :class: PointND NumPy\narray.", "original_prompt": "class PointNDLike"}
{"prompt": "\"Render a parabola graph along with arrows that fade out from a point.\"\n\n(Note: This prompt assumes the Manim code is rendering a simple graph, but without more context or code, it's hard to determine what exactly is being animated. The provided code snippet was missing)", "response": "NDArray[ PointDType ] shape: (M, N) A NumPy array representing a sequence of PointND objects: [[float, ...], ...] .", "original_prompt": "class PointND_Array"}
{"prompt": "Animate a 2D grid of points in motion along an MxN trajectory with smooth color changes and fading.", "response": "PointND_Array | Sequence[ PointNDLike ] shape: (M, N) An array of PointND objects: [[float, ...], ...] . This represents anything which can be converted to a :class: PointND_Array NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "original_prompt": "class PointNDLike_Array"}
{"prompt": "\"Move a dot along a straight line, illustrating addition of two vectors.\"", "response": "NDArray[ PointDType ] shape: (2,) A 2-dimensional vector: [float, float] . Normally, a function or method which expects a Vector2D as a\nparameter can handle being passed a Vector3D instead. Caution Do not confuse with the Vector or Arrow VMobjects!", "original_prompt": "class Vector2D"}
{"prompt": "\"Show a moving line graph with points on a coordinate plane, smoothly changing colors.\"", "response": "NDArray[ PointDType ] shape: (M, 2) An array of Vector2D objects: [[float, float], ...] . Normally, a function or method which expects a Vector2D_Array as a\nparameter can handle being passed a Vector3D_Array instead.", "original_prompt": "class Vector2D_Array"}
{"prompt": "Animate a 3D line segment moving in a circular path around the origin.", "response": "NDArray[ PointDType ] shape: (3,) A 3-dimensional vector: [float, float, float] . Caution Do not confuse with the Vector or Arrow3D VMobjects!", "original_prompt": "class Vector3D"}
{"prompt": "\"Draw a trajectory of points on a 2D plane, with each point's x and y coordinates changing sinusoidally.\"", "response": "NDArray[ PointDType ] shape: (M, 3) An array of Vector3D objects: [[float, float, float], ...] .", "original_prompt": "class Vector3D_Array"}
{"prompt": "\"Rotate a 3D vector in space around each axis separately.\"", "response": "NDArray[ PointDType ] shape (N,) An \\(N\\) -dimensional vector: [float, ...] . Caution Do not confuse with the Vector VMobject! This type alias\nis named \u201cVectorND\u201d instead of \u201cVector\u201d to avoid potential name\ncollisions.", "original_prompt": "class VectorND"}
{"prompt": "Animate a grid of vectors oscillating about the origin.\n\n(Note: This prompt is based on the fact that `shape` is an array of `VectorND` objects, and without further context, it's difficult to provide a more specific description. The mention of \"oscillating about the origin\" suggests movement around a central point, but more information would be needed for a more detailed prompt.)", "response": "NDArray[ PointDType ] shape (M, N) An array of VectorND objects: [[float, ...], ...] .", "original_prompt": "class VectorND_Array"}
{"prompt": "\"Fade in a row vector of coordinates with each point moving towards the origin.\"", "response": "NDArray[ PointDType ] shape: (1, N) A row vector: [[float, ...]] .", "original_prompt": "class RowVector"}
{"prompt": "Animate a series of arrows moving along the x and y axes with point labels, fading out after one second.", "response": "NDArray[ PointDType ] shape: (N, 1) A column vector: [[float], [float], ...] .", "original_prompt": "class ColVector"}
{"prompt": "\"Rotate a 2D matrix of points around the origin while displaying its elements.\"", "response": "NDArray[ PointDType ] shape: (M, N) A matrix: [[float, ...], [float, ...], ...] .", "original_prompt": "class MatrixMN"}
{"prompt": "\"Draw a 2x2 matrix with zeros, then fill it in one square at a time.\"", "response": "MatrixMN shape: (M, N) A MatrixMN filled with zeros, typically created with numpy.zeros((M, N)) .", "original_prompt": "class Zeros"}
{"prompt": "\"Rotate and animate a curve defined by three 3D points along the x, y, z axes.\"", "response": "Point3D_Array shape: (3, 3) A Point3D_Array of three 3D control points for a single quadratic B\u00e9zier\ncurve: [[float, float, float], [float, float, float], [float, float, float]] .", "original_prompt": "class QuadraticBezierPoints"}
{"prompt": "Animate three 3D control points moving along a single quadratic Bezier curve.", "response": "QuadraticBezierPoints | tuple[ Point3DLike , Point3DLike , Point3DLike ] shape: (3, 3) A Point3DLike_Array of three 3D control points for a single quadratic B\u00e9zier\ncurve: [[float, float, float], [float, float, float], [float, float, float]] . This represents anything which can be converted to a\n:class: QuadraticBezierPoints NumPy array.", "original_prompt": "class QuadraticBezierPointsLike"}
{"prompt": "Animate a growing grid of connected points along curved paths with smooth rotations around each point.", "response": "NDArray[ PointDType ] shape: (N, 3, 3) A NumPy array containing \\(N\\) QuadraticBezierPoints objects: [[[float, float, float], [float, float, float], [float, float, float]], ...] .", "original_prompt": "class QuadraticBezierPoints_Array"}
{"prompt": "\"Draw N equally spaced points on a 3D plane with smooth, curved paths.\"", "response": "QuadraticBezierPoints_Array | Sequence[ QuadraticBezierPointsLike ] shape: (N, 3, 3) A sequence of \\(N\\) QuadraticBezierPointsLike objects: [[[float, float, float], [float, float, float], [float, float, float]], ...] . This represents anything which can be converted to a\n:class: QuadraticBezierPoints_Array NumPy array.", "original_prompt": "class QuadraticBezierPointsLike_Array"}
{"prompt": "\"Draw N Bezier curves with Point3D arrays as control points.\"\n\nThis prompt is short and concise, focusing on the key visual element (Bezier curves) and the subject (Point3D arrays). It avoids technical terms like 'class' or 'self'.", "response": "Point3D_Array shape: (3*N, 3) A Point3D_Array of \\(3N\\) points, where each one of the \\(N\\) consecutive blocks of 3 points represents a quadratic\nB\u00e9zier curve: [[float, float, float], ...], ...] . Please refer to the documentation of the function you are using for\nfurther type information.", "original_prompt": "class QuadraticBezierPath"}
{"prompt": "\"Create a 3D graph with N quadratic B\u00e9zier curves, rotating smoothly over time with axis labels.\"", "response": "Point3DLike_Array shape: (3*N, 3) A Point3DLike_Array of \\(3N\\) points, where each one of the \\(N\\) consecutive blocks of 3 points represents a quadratic\nB\u00e9zier curve: [[float, float, float], ...], ...] . This represents anything which can be converted to a\n:class: QuadraticBezierPath NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "original_prompt": "class QuadraticBezierPathLike"}
{"prompt": "\"Create a smooth curve from multiple connected quadratic B\u00e9zier paths.\"", "response": "QuadraticBezierPath shape: (3*N, 3) A special case of QuadraticBezierPath where all the \\(N\\) quadratic B\u00e9zier curves are connected, forming a quadratic spline: [[float, float, float], ...], ...] . Please refer to the documentation of the function you are using for\nfurther type information.", "original_prompt": "class QuadraticSpline"}
{"prompt": "\"Draw a smooth curve formed by connecting multiple quadratic B\u00e9zier curves.\"", "response": "QuadraticBezierPathLike shape: (3*N, 3) A special case of QuadraticBezierPathLike where all the \\(N\\) quadratic B\u00e9zier curves are connected, forming a quadratic spline: [[float, float, float], ...], ...] . This represents anything which can be converted to a :class: QuadraticSpline NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "original_prompt": "class QuadraticSplineLike"}
{"prompt": "\"Draw a smooth cubic Bezier curve with 4 control points moving along each axis.\"\n\nLet me know if you need any modifications.", "response": "Point3D_Array shape: (4, 3) A Point3D_Array of four 3D control points for a single cubic B\u00e9zier curve: [[float, float, float], [float, float, float], [float, float, float], [float, float, float]] .", "original_prompt": "class CubicBezierPoints"}
{"prompt": "Animate a curve with four control points to create a smooth cubic B\u00e9zier shape.", "response": "CubicBezierPoints | tuple[ Point3DLike , Point3DLike , Point3DLike , Point3DLike ] shape: (4, 3) A Point3DLike_Array of 4 control points for a single cubic B\u00e9zier curve: [[float, float, float], [float, float, float], [float, float, float], [float, float, float]] . This represents anything which can be converted to a :class: CubicBezierPoints NumPy array.", "original_prompt": "class CubicBezierPointsLike"}
{"prompt": "Animate a cubic Bezier curve that morphs into another in three-dimensional space with N points.", "response": "NDArray[ PointDType ] shape: (N, 4, 3) A NumPy array containing \\(N\\) CubicBezierPoints objects: [[[float, float, float], [float, float, float], [float, float, float], [float, float, float]], ...] .", "original_prompt": "class CubicBezierPoints_Array"}
{"prompt": "\"Draw N connected CubicBezierPoints in sequence with smooth curves\"", "response": "CubicBezierPoints_Array | Sequence[ CubicBezierPointsLike ] shape: (N, 4, 3) A sequence of \\(N\\) CubicBezierPointsLike objects: [[[float, float, float], [float, float, float], [float, float, float], [float, float, float]], ...] . This represents anything which can be converted to a\n:class: CubicBezierPoints_Array NumPy array.", "original_prompt": "class CubicBezierPointsLike_Array"}
{"prompt": "Animate a cubic B\u00e9zier curve that evolves through multiple positions along its shape.", "response": "Point3D_Array shape: (4*N, 3) A Point3D_Array of \\(4N\\) points, where each one of the \\(N\\) consecutive blocks of 4 points represents a cubic B\u00e9zier\ncurve: [[float, float, float], ...], ...] . Please refer to the documentation of the function you are using for\nfurther type information.", "original_prompt": "class CubicBezierPath"}
{"prompt": "\"Draw N cubic B\u00e9zier curves connecting 4 points each, creating a smooth cubic curve with repeating pattern.\"", "response": "Point3DLike_Array shape: (4*N, 3) A Point3DLike_Array of \\(4N\\) points, where each one of the \\(N\\) consecutive blocks of 4 points represents a cubic B\u00e9zier\ncurve: [[float, float, float], ...], ...] . This represents anything which can be converted to a\n:class: CubicBezierPath NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "original_prompt": "class CubicBezierPathLike"}
{"prompt": "\"Show a smooth curve formed by connecting cubic B\u00e9zier curves.\"", "response": "CubicBezierPath shape: (4*N, 3) A special case of CubicBezierPath where all the \\(N\\) cubic\nB\u00e9zier curves are connected, forming a quadratic spline: [[float, float, float], ...], ...] . Please refer to the documentation of the function you are using for\nfurther type information.", "original_prompt": "class CubicSpline"}
{"prompt": "\"Create a Bezier spline that smoothly connects multiple cubic curves, forming a single quadratic path\"", "response": "CubicBezierPathLike shape: (4*N, 3) A special case of CubicBezierPath where all the \\(N\\) cubic\nB\u00e9zier curves are connected, forming a quadratic spline: [[float, float, float], ...], ...] . This represents anything which can be converted to a\n:class: CubicSpline NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "original_prompt": "class CubicSplineLike"}
{"prompt": "\"Create a sequence of smooth Bezier curves, rotating each one around its center point along the x-axis.\"", "response": "Point3D_Array shape: (PPC, 3) A Point3D_Array of \\(\\text{PPC}\\) control points\n( \\(\\text{PPC: Points Per Curve} = n + 1\\) ) for a single \\(n\\) -th degree B\u00e9zier curve: [[float, float, float], ...] . Please refer to the documentation of the function you are using for\nfurther type information.", "original_prompt": "class BezierPoints"}
{"prompt": "Animate a 3D Bezier curve with PPC control points rotating around its center, smoothly easing into place.", "response": "Point3DLike_Array shape: (PPC, 3) A Point3DLike_Array of \\(\\text{PPC}\\) control points\n( \\(\\text{PPC: Points Per Curve} = n + 1\\) ) for a single \\(n\\) -th degree B\u00e9zier curve: [[float, float, float], ...] . This represents anything which can be converted to a\n:class: BezierPoints NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "original_prompt": "class BezierPointsLike"}
{"prompt": "\"Display N Bezier curves with points that smoothly change shape over time.\"", "response": "NDArray[ PointDType ] shape: (N, PPC, 3) A NumPy array of \\(N\\) BezierPoints objects containing \\(\\text{PPC}\\) Point3D objects each\n( \\(\\text{PPC: Points Per Curve} = n + 1\\) ): [[[float, float, float], ...], ...] . Please refer to the documentation of the function you are using for\nfurther type information.", "original_prompt": "class BezierPoints_Array"}
{"prompt": "Animate a series of Bezier curves with varying points per curve, transitioning smoothly between them.", "response": "BezierPoints_Array | Sequence[ BezierPointsLike ] shape: (N, PPC, 3) A sequence of \\(N\\) BezierPointsLike objects containing \\(\\text{PPC}\\) Point3DLike objects each\n( \\(\\text{PPC: Points Per Curve} = n + 1\\) ): [[[float, float, float], ...], ...] . This represents anything which can be converted to a\n:class: BezierPoints_Array NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "original_prompt": "class BezierPointsLike_Array"}
{"prompt": "\"Show a Bezier curve of degree n that morphs into another curve with varying control points.\"", "response": "Point3D_Array shape: (PPC*N, 3) A Point3D_Array of \\(\\text{PPC} \\cdot N\\) points, where each\none of the \\(N\\) consecutive blocks of \\(\\text{PPC}\\) control\npoints ( \\(\\text{PPC: Points Per Curve} = n + 1\\) ) represents a\nB\u00e9zier curve of \\(n\\) -th degree: [[float, float, float], ...], ...] . Please refer to the documentation of the function you are using for\nfurther type information.", "original_prompt": "class BezierPath"}
{"prompt": "Animate a B\u00e9zier curve that smoothly fades in and rotates around its axis over time.", "response": "Point3DLike_Array shape: (PPC*N, 3) A Point3DLike_Array of \\(\\text{PPC} \\cdot N\\) points, where each\none of the \\(N\\) consecutive blocks of \\(\\text{PPC}\\) control\npoints ( \\(\\text{PPC: Points Per Curve} = n + 1\\) ) represents a\nB\u00e9zier curve of \\(n\\) -th degree: [[float, float, float], ...], ...] . This represents anything which can be converted to a\n:class: BezierPath NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "original_prompt": "class BezierPathLike"}
{"prompt": "\"Create a Bezier spline curve with N curves connecting at PPC points.\"", "response": "BezierPath shape: (PPC*N, 3) A special case of BezierPath where all the \\(N\\) B\u00e9zier curves\nconsisting of \\(\\text{PPC}\\) Point3D objects\n( \\(\\text{PPC: Points Per Curve} = n + 1\\) ) are connected, forming\nan \\(n\\) -th degree spline: [[float, float, float], ...], ...] . Please refer to the documentation of the function you are using for\nfurther type information.", "original_prompt": "class Spline"}
{"prompt": "\"Draw a Bezier spline with N curve segments, forming an n-th degree surface.\"", "response": "BezierPathLike shape: (PPC*N, 3) A special case of BezierPathLike where all the \\(N\\) B\u00e9zier curves\nconsisting of \\(\\text{PPC}\\) Point3D objects\n( \\(\\text{PPC: Points Per Curve} = n + 1\\) ) are connected, forming\nan \\(n\\) -th degree spline: [[float, float, float], ...], ...] . This represents anything which can be converted to a\n:class: Spline NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "original_prompt": "class SplineLike"}
{"prompt": "Animate a curve defined by B\u00e9zier control points to show its shape and properties.", "response": "NDArray[ PointDType ] | tuple[float, ...] shape: (3*PPC*N,) A flattened array of B\u00e9zier control points: [float, ...] .", "original_prompt": "class FlatBezierPoints"}
{"prompt": "\"Fade in a circle, then rotate it around the origin, revealing its parametric equation.\"", "response": "Callable Function type returning an Animation for the specified Mobject .", "original_prompt": "class FunctionOverride"}
{"prompt": "\"Fade in a circle centered at the origin, with lines radiating from its center.\"", "response": "Callable[[ Point3DLike , Point3DLike , float], Point3DLike ] Function mapping two :class: Point3D objects and an alpha value to a new\n:class: Point3D .", "original_prompt": "class PathFuncType"}
{"prompt": "Animate points along parabola with velocity changes, visualizing vector projection.", "response": "Callable[[ Point3D ], Point3D ] A function mapping a :class: Point3D to another :class: Point3D .", "original_prompt": "class MappingFunction"}
{"prompt": "\"Rotate a 2D array of points around the origin while displaying their coordinates.\"", "response": "Callable[[ Point3D_Array ], Point3D_Array ] A function mapping a :class: Point3D_Array to another\n:class: Point3D_Array .", "original_prompt": "class MultiMappingFunction"}
{"prompt": "\"Render a series of greyscale images of a digital image, gradually fading in.\"\n\nAlternatively:\n\"Display a sequence of greyscale rasterized images with gradual intensity changes.\"", "response": "NDArray[ ManimInt ] shape: (height, width) | (height, width, 3) | (height, width, 4) A rasterized image with a height of height pixels and a width of width pixels. Every value in the array is an integer from 0 to 255. Every pixel is represented either by a single integer indicating its\nlightness (for greyscale images), an RGB_Array_Int or an RGBA_Array_Int .", "original_prompt": "class PixelArray"}
{"prompt": "Animate a grayscale grid of increasing brightness as it grows from darkness to light with ManimInt values.", "response": "PixelArray shape: (height, width) A 100% opaque grayscale PixelArray , where every pixel value is a ManimInt indicating its lightness (black -> gray -> white).", "original_prompt": "class GrayscalePixelArray"}
{"prompt": "\"Display a bright, opaque square that transitions into a 3D rotating prism with changing colors.\"", "response": "PixelArray shape: (height, width, 3) A 100% opaque PixelArray in color, where every pixel value is an RGB_Array_Int object.", "original_prompt": "class RGBPixelArray"}
{"prompt": "\"Fade a green square into a red circle on a black background with smooth radius growth\"", "response": "PixelArray shape: (height, width, 4) A PixelArray in color where pixels can be transparent. Every pixel\nvalue is an RGBA_Array_Int object.", "original_prompt": "class RGBAPixelArray"}
{"prompt": "\"Draw a sine wave graph that smoothly fades into itself with oscillating amplitude.\"", "response": "str | PathLike [ str ] A string or os.PathLike representing a path to a\ndirectory or file.", "original_prompt": "class StrPath"}
{"prompt": "\"Display equations on a graph that animate and transform into 3D shapes with fading.\"", "response": "str | bytes | PathLike [ str ] | PathLike [ bytes ] A string, bytes or os.PathLike object representing a path\nto a directory or file.", "original_prompt": "class StrOrBytesPath"}
