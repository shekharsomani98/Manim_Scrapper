{"prompt": "override_animation(animation_class)", "response": "Decorator used to mark methods as overrides for specific Animation types. Should only be used to decorate methods of classes derived from Mobject . Animation overrides get inherited to subclasses of the Mobject who defined\nthem. They don\u2019t override subclasses of the Animation they override. See also add_animation_override() Parameters : animation_class ( type [ Animation ] ) \u2013 The animation to be overridden. Returns : The actual decorator. This marks the method as overriding an animation. Return type : Callable[[Callable], Callable] Examples Example: OverrideAnimationExample   from manim import * class MySquare ( Square ): @override_animation ( FadeIn ) def _fade_in_override ( self , ** kwargs ): return Create ( self , ** kwargs ) class OverrideAnimationExample ( Scene ): def construct ( self ): self . play ( FadeIn ( MySquare ())) class MySquare(Square):\n    @override_animation(FadeIn)\n    def _fade_in_override(self, **kwargs):\n        return Create(self, **kwargs)\n\nclass OverrideAnimationExample(Scene):\n    def construct(self):\n        self.play(FadeIn(MySquare()))", "source": "https://docs.manim.community/en/stable/reference/manim.animation.animation.html"}
{"prompt": "prepare_animation(anim)", "response": "Returns either an unchanged animation, or the animation built\nfrom a passed animation factory. Examples >>> from manim import Square , FadeIn >>> s = Square () >>> prepare_animation ( FadeIn ( s )) FadeIn(Square) >>> prepare_animation ( s . animate . scale ( 2 ) . rotate ( 42 )) _MethodAnimation(Square) >>> prepare_animation ( 42 ) Traceback (most recent call last): ... TypeError : Object 42 cannot be converted to an animation Parameters : anim ( Animation | _AnimationBuilder ) Return type : Animation", "source": "https://docs.manim.community/en/stable/reference/manim.animation.animation.html"}
{"prompt": "class Add(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Animation Add Mobjects to a scene, without animating them in any other way. This\nis similar to the Scene.add() method, but Add is an\nanimation which can be grouped into other animations. Parameters : mobjects ( Mobject ) \u2013 One Mobject or more to add to a scene. run_time ( float ) \u2013 The duration of the animation after adding the mobjects . Defaults\nto 0, which means this is an instant animation without extra wait time\nafter adding them. **kwargs ( Any ) \u2013 Additional arguments to pass to the parent Animation class. Examples Example: DefaultAddScene   from manim import * class DefaultAddScene ( Scene ): def construct ( self ): text_1 = Text ( \"I was added with Add!\" ) text_2 = Text ( \"Me too!\" ) text_3 = Text ( \"And me!\" ) texts = VGroup ( text_1 , text_2 , text_3 ) . arrange ( DOWN ) rect = SurroundingRectangle ( texts , buff = 0.5 ) self . play ( Create ( rect , run_time = 3.0 ), Succession ( Wait ( 1.0 ), # You can Add a Mobject in the middle of an animation... Add ( text_1 ), Wait ( 1.0 ), # ...or multiple Mobjects at once! Add ( text_2 , text_3 ), ), ) self . wait () class DefaultAddScene(Scene):\n    def construct(self):\n        text_1 = Text(\"I was added with Add!\")\n        text_2 = Text(\"Me too!\")\n        text_3 = Text(\"And me!\")\n        texts = VGroup(text_1, text_2, text_3).arrange(DOWN)\n        rect = SurroundingRectangle(texts, buff=0.5)\n\n        self.play(\n            Create(rect, run_time=3.0),\n            Succession(\n                Wait(1.0),\n                # You can Add a Mobject in the middle of an animation...\n                Add(text_1),\n                Wait(1.0),\n                # ...or multiple Mobjects at once!\n                Add(text_2, text_3),\n            ),\n        )\n        self.wait() Example: AddWithRunTimeScene   from manim import * class AddWithRunTimeScene ( Scene ): def construct ( self ): # A 5x5 grid of circles circles = VGroup ( * [ Circle ( radius = 0.5 ) for _ in range ( 25 )] ) . arrange_in_grid ( 5 , 5 ) self . play ( Succession ( # Add a run_time of 0.2 to wait for 0.2 seconds after # adding the circle, instead of using Wait(0.2) after Add! * [ Add ( circle , run_time = 0.2 ) for circle in circles ], rate_func = smooth , ) ) self . wait () class AddWithRunTimeScene(Scene):\n    def construct(self):\n        # A 5x5 grid of circles\n        circles = VGroup(\n            *[Circle(radius=0.5) for _ in range(25)]\n        ).arrange_in_grid(5, 5)\n\n        self.play(\n            Succession(\n                # Add a run_time of 0.2 to wait for 0.2 seconds after\n                # adding the circle, instead of using Wait(0.2) after Add!\n                *[Add(circle, run_time=0.2) for circle in circles],\n                rate_func=smooth,\n            )\n        )\n        self.wait() Methods begin Begin the animation. clean_up_from_scene Clean up the Scene after finishing the animation. finish Finish the animation. interpolate Set the animation progress. update_mobjects Updates things like starting_mobject, and (for Transforms) target_mobject. Attributes run_time _original__init__ ( * mobjects , run_time = 0.0 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobjects ( Mobject ) run_time ( float ) kwargs ( Any ) Return type : None begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None finish ( ) [source]   Finish the animation. This method gets called when the animation is over. Return type : None interpolate ( alpha ) [source]   Set the animation progress. This method gets called for every frame during an animation. Parameters : alpha ( float ) \u2013 The relative time to set the animation to, 0 meaning the start, 1 meaning\nthe end. Return type : None update_mobjects ( dt ) [source]   Updates things like starting_mobject, and (for\nTransforms) target_mobject.  Note, since typically\n(always?) self.mobject will have its updating\nsuspended during the animation, this will do\nnothing to self.mobject. Parameters : dt ( float ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.animation.Add.html"}
{"prompt": "class Animation(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: object An animation. Animations have a fixed time span. Parameters : mobject \u2013 The mobject to be animated. This is not required for all types of animations. lag_ratio \u2013 Defines the delay after which the animation is applied to submobjects. This lag\nis relative to the duration of the animation. This does not influence the total\nruntime of the animation. Instead the runtime of individual animations is\nadjusted so that the complete animation has the defined run time. run_time \u2013 The duration of the animation in seconds. rate_func \u2013 The function defining the animation progress based on the relative runtime (see rate_functions ) . For example rate_func(0.5) is the proportion of the animation that is done\nafter half of the animations run time. Return type : Self reverse_rate_function Reverses the rate function of the animation. Setting reverse_rate_function does not have any effect on remover or introducer . These need to be\nset explicitly if an introducer-animation should be turned into a remover one\nand vice versa. name The name of the animation. This gets displayed while rendering the animation.\nDefaults to <class-name>(<Mobject-name>). remover Whether the given mobject should be removed from the scene after this animation. suspend_mobject_updating Whether updaters of the mobject should be suspended during the animation. Note In the current implementation of this class, the specified rate function is applied\nwithin Animation.interpolate_mobject() call as part of the call to Animation.interpolate_submobject() . For subclasses of Animation that are implemented by overriding interpolate_mobject() , the rate function\nhas to be applied manually (e.g., by passing self.rate_func(alpha) instead\nof just alpha ). Examples Example: LagRatios   from manim import * class LagRatios ( Scene ): def construct ( self ): ratios = [ 0 , 0.1 , 0.5 , 1 , 2 ] # demonstrated lag_ratios # Create dot groups group = VGroup ( * [ Dot () for _ in range ( 4 )]) . arrange_submobjects () groups = VGroup ( * [ group . copy () for _ in ratios ]) . arrange_submobjects ( buff = 1 ) self . add ( groups ) # Label groups self . add ( Text ( \"lag_ratio = \" , font_size = 36 ) . next_to ( groups , UP , buff = 1.5 )) for group , ratio in zip ( groups , ratios ): self . add ( Text ( str ( ratio ), font_size = 36 ) . next_to ( group , UP )) #Animate groups with different lag_ratios self . play ( AnimationGroup ( * [ group . animate ( lag_ratio = ratio , run_time = 1.5 ) . shift ( DOWN * 2 ) for group , ratio in zip ( groups , ratios ) ])) # lag_ratio also works recursively on nested submobjects: self . play ( groups . animate ( run_time = 1 , lag_ratio = 0.1 ) . shift ( UP * 2 )) class LagRatios(Scene):\n    def construct(self):\n        ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios\n\n        # Create dot groups\n        group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()\n        groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)\n        self.add(groups)\n\n        # Label groups\n        self.add(Text(\"lag_ratio = \", font_size=36).next_to(groups, UP, buff=1.5))\n        for group, ratio in zip(groups, ratios):\n            self.add(Text(str(ratio), font_size=36).next_to(group, UP))\n\n        #Animate groups with different lag_ratios\n        self.play(AnimationGroup(*[\n            group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)\n            for group, ratio in zip(groups, ratios)\n        ]))\n\n        # lag_ratio also works recursively on nested submobjects:\n        self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2)) Methods begin Begin the animation. clean_up_from_scene Clean up the Scene after finishing the animation. copy Create a copy of the animation. create_starting_mobject finish Finish the animation. get_all_families_zipped get_all_mobjects Get all mobjects involved in the animation. get_all_mobjects_to_update Get all mobjects to be updated during the animation. get_rate_func Get the rate function of the animation. get_run_time Get the run time of the animation. get_sub_alpha Get the animation progress of any submobjects subanimation. interpolate Set the animation progress. interpolate_mobject Interpolates the mobject of the Animation based on alpha value. interpolate_submobject is_introducer Test if the animation is an introducer. is_remover Test if the animation is a remover. set_default Sets the default values of keyword arguments. set_name Set the name of the animation. set_rate_func Set the rate function of the animation. set_run_time Set the run time of the animation. update_mobjects Updates things like starting_mobject, and (for Transforms) target_mobject. Attributes run_time _setup_scene ( scene ) [source]   Setup up the Scene before starting the animation. This includes to add() the Animation\u2019s Mobject if the animation is an introducer. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None copy ( ) [source]   Create a copy of the animation. Returns : A copy of self Return type : Animation finish ( ) [source]   Finish the animation. This method gets called when the animation is over. Return type : None get_all_mobjects ( ) [source]   Get all mobjects involved in the animation. Ordering must match the ordering of arguments to interpolate_submobject Returns : The sequence of mobjects. Return type : Sequence[ Mobject ] get_all_mobjects_to_update ( ) [source]   Get all mobjects to be updated during the animation. Returns : The list of mobjects to be updated during the animation. Return type : List[ Mobject ] get_rate_func ( ) [source]   Get the rate function of the animation. Returns : The rate function of the animation. Return type : Callable[[float], float] get_run_time ( ) [source]   Get the run time of the animation. Returns : The time the animation takes in seconds. Return type : float get_sub_alpha ( alpha , index , num_submobjects ) [source]   Get the animation progress of any submobjects subanimation. Parameters : alpha ( float ) \u2013 The overall animation progress index ( int ) \u2013 The index of the subanimation. num_submobjects ( int ) \u2013 The total count of subanimations. Returns : The progress of the subanimation. Return type : float interpolate ( alpha ) [source]   Set the animation progress. This method gets called for every frame during an animation. Parameters : alpha ( float ) \u2013 The relative time to set the animation to, 0 meaning the start, 1 meaning\nthe end. Return type : None interpolate_mobject ( alpha ) [source]   Interpolates the mobject of the Animation based on alpha value. Parameters : alpha ( float ) \u2013 A float between 0 and 1 expressing the ratio to which the animation\nis completed. For example, alpha-values of 0, 0.5, and 1 correspond\nto the animation being completed 0%, 50%, and 100%, respectively. Return type : None is_introducer ( ) [source]   Test if the animation is an introducer. Returns : True if the animation is an introducer, False otherwise. Return type : bool is_remover ( ) [source]   Test if the animation is a remover. Returns : True if the animation is a remover, False otherwise. Return type : bool classmethod set_default ( ** kwargs ) [source]   Sets the default values of keyword arguments. If this method is called without any additional keyword\narguments, the original default values of the initialization\nmethod of this class are restored. Parameters : kwargs \u2013 Passing any keyword argument will update the default\nvalues of the keyword arguments of the initialization\nfunction of this class. Return type : None Examples Example: ChangeDefaultAnimation   from manim import * class ChangeDefaultAnimation ( Scene ): def construct ( self ): Rotate . set_default ( run_time = 2 , rate_func = rate_functions . linear ) Indicate . set_default ( color = None ) S = Square ( color = BLUE , fill_color = BLUE , fill_opacity = 0.25 ) self . add ( S ) self . play ( Rotate ( S , PI )) self . play ( Indicate ( S )) Rotate . set_default () Indicate . set_default () class ChangeDefaultAnimation(Scene):\n    def construct(self):\n        Rotate.set_default(run_time=2, rate_func=rate_functions.linear)\n        Indicate.set_default(color=None)\n\n        S = Square(color=BLUE, fill_color=BLUE, fill_opacity=0.25)\n        self.add(S)\n        self.play(Rotate(S, PI))\n        self.play(Indicate(S))\n\n        Rotate.set_default()\n        Indicate.set_default() set_name ( name ) [source]   Set the name of the animation. Parameters : name ( str ) \u2013 The new name of the animation. Returns : self Return type : Animation set_rate_func ( rate_func ) [source]   Set the rate function of the animation. Parameters : rate_func ( Callable [ [ float ] , float ] ) \u2013 The new function defining the animation progress based on the\nrelative runtime (see rate_functions ). Returns : self Return type : Animation set_run_time ( run_time ) [source]   Set the run time of the animation. Parameters : run_time ( float ) \u2013 The new time the animation should take in seconds. note:: ( .. ) \u2013 The run_time of an animation should not be changed while it is already\nrunning. Returns : self Return type : Animation update_mobjects ( dt ) [source]   Updates things like starting_mobject, and (for\nTransforms) target_mobject.  Note, since typically\n(always?) self.mobject will have its updating\nsuspended during the animation, this will do\nnothing to self.mobject. Parameters : dt ( float ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.animation.Animation.html"}
{"prompt": "class Wait(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Animation A \u201cno operation\u201d animation. Parameters : run_time ( float ) \u2013 The amount of time that should pass. stop_condition ( Callable [ [ ] , bool ] | None ) \u2013 A function without positional arguments that evaluates to a boolean.\nThe function is evaluated after every new frame has been rendered.\nPlaying the animation stops after the return value is truthy, or\nafter the specified run_time has passed. frozen_frame ( bool | None ) \u2013 Controls whether or not the wait animation is static, i.e., corresponds\nto a frozen frame. If False is passed, the render loop still\nprogresses through the animation as usual and (among other things)\ncontinues to call updater functions. If None (the default value),\nthe Scene.play() call tries to determine whether the Wait call\ncan be static or not itself via Scene.should_mobjects_update() . kwargs \u2013 Keyword arguments to be passed to the parent class, Animation . rate_func ( Callable [ [ float ] , float ] ) Methods begin Begin the animation. clean_up_from_scene Clean up the Scene after finishing the animation. finish Finish the animation. interpolate Set the animation progress. update_mobjects Updates things like starting_mobject, and (for Transforms) target_mobject. Attributes run_time _original__init__ ( run_time=1 , stop_condition=None , frozen_frame=None , rate_func=<function linear> , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : run_time ( float ) stop_condition ( Callable [ [ ] , bool ] | None ) frozen_frame ( bool | None ) rate_func ( Callable [ [ float ] , float ] ) begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None finish ( ) [source]   Finish the animation. This method gets called when the animation is over. Return type : None interpolate ( alpha ) [source]   Set the animation progress. This method gets called for every frame during an animation. Parameters : alpha ( float ) \u2013 The relative time to set the animation to, 0 meaning the start, 1 meaning\nthe end. Return type : None update_mobjects ( dt ) [source]   Updates things like starting_mobject, and (for\nTransforms) target_mobject.  Note, since typically\n(always?) self.mobject will have its updating\nsuspended during the animation, this will do\nnothing to self.mobject. Parameters : dt ( float ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.animation.Wait.html"}
{"prompt": "override_animation(animation_class)", "response": "Decorator used to mark methods as overrides for specific Animation types. Should only be used to decorate methods of classes derived from Mobject . Animation overrides get inherited to subclasses of the Mobject who defined\nthem. They don\u2019t override subclasses of the Animation they override. See also add_animation_override() Parameters : animation_class ( type [ Animation ] ) \u2013 The animation to be overridden. Returns : The actual decorator. This marks the method as overriding an animation. Return type : Callable[[Callable], Callable] Examples Example: OverrideAnimationExample   from manim import * class MySquare ( Square ): @override_animation ( FadeIn ) def _fade_in_override ( self , ** kwargs ): return Create ( self , ** kwargs ) class OverrideAnimationExample ( Scene ): def construct ( self ): self . play ( FadeIn ( MySquare ())) class MySquare(Square):\n    @override_animation(FadeIn)\n    def _fade_in_override(self, **kwargs):\n        return Create(self, **kwargs)\n\nclass OverrideAnimationExample(Scene):\n    def construct(self):\n        self.play(FadeIn(MySquare()))", "source": "https://docs.manim.community/en/stable/reference/manim.animation.animation.html#manim.animation.animation.override_animation"}
{"prompt": "prepare_animation(anim)", "response": "Returns either an unchanged animation, or the animation built\nfrom a passed animation factory. Examples >>> from manim import Square , FadeIn >>> s = Square () >>> prepare_animation ( FadeIn ( s )) FadeIn(Square) >>> prepare_animation ( s . animate . scale ( 2 ) . rotate ( 42 )) _MethodAnimation(Square) >>> prepare_animation ( 42 ) Traceback (most recent call last): ... TypeError : Object 42 cannot be converted to an animation Parameters : anim ( Animation | _AnimationBuilder ) Return type : Animation", "source": "https://docs.manim.community/en/stable/reference/manim.animation.animation.html#manim.animation.animation.override_animation"}
{"prompt": "override_animation(animation_class)", "response": "Decorator used to mark methods as overrides for specific Animation types. Should only be used to decorate methods of classes derived from Mobject . Animation overrides get inherited to subclasses of the Mobject who defined\nthem. They don\u2019t override subclasses of the Animation they override. See also add_animation_override() Parameters : animation_class ( type [ Animation ] ) \u2013 The animation to be overridden. Returns : The actual decorator. This marks the method as overriding an animation. Return type : Callable[[Callable], Callable] Examples Example: OverrideAnimationExample   from manim import * class MySquare ( Square ): @override_animation ( FadeIn ) def _fade_in_override ( self , ** kwargs ): return Create ( self , ** kwargs ) class OverrideAnimationExample ( Scene ): def construct ( self ): self . play ( FadeIn ( MySquare ())) class MySquare(Square):\n    @override_animation(FadeIn)\n    def _fade_in_override(self, **kwargs):\n        return Create(self, **kwargs)\n\nclass OverrideAnimationExample(Scene):\n    def construct(self):\n        self.play(FadeIn(MySquare()))", "source": "https://docs.manim.community/en/stable/reference/manim.animation.animation.html#manim.animation.animation.prepare_animation"}
{"prompt": "prepare_animation(anim)", "response": "Returns either an unchanged animation, or the animation built\nfrom a passed animation factory. Examples >>> from manim import Square , FadeIn >>> s = Square () >>> prepare_animation ( FadeIn ( s )) FadeIn(Square) >>> prepare_animation ( s . animate . scale ( 2 ) . rotate ( 42 )) _MethodAnimation(Square) >>> prepare_animation ( 42 ) Traceback (most recent call last): ... TypeError : Object 42 cannot be converted to an animation Parameters : anim ( Animation | _AnimationBuilder ) Return type : Animation", "source": "https://docs.manim.community/en/stable/reference/manim.animation.animation.html#manim.animation.animation.prepare_animation"}
{"prompt": "class AnimatedBoundary(vmobject, colors=", "response": "Bases: VGroup Boundary of a VMobject with animated color change. Examples Example: AnimatedBoundaryExample   from manim import * class AnimatedBoundaryExample ( Scene ): def construct ( self ): text = Text ( \"So shiny!\" ) boundary = AnimatedBoundary ( text , colors = [ RED , GREEN , BLUE ], cycle_rate = 3 ) self . add ( text , boundary ) self . wait ( 2 ) class AnimatedBoundaryExample(Scene):\n    def construct(self):\n        text = Text(\"So shiny!\")\n        boundary = AnimatedBoundary(text, colors=[RED, GREEN, BLUE],\n                                    cycle_rate=3)\n        self.add(text, boundary)\n        self.wait(2) Methods full_family_become_partial update_boundary_copies Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( vmobject, colors=[ManimColor('#29ABCA'), ManimColor('#9CDCEB'), ManimColor('#236B8E'), ManimColor('#736357')], max_stroke_width=3, cycle_rate=0.5, back_and_forth=True, draw_rate_func=<function smooth>, fade_rate_func=<function smooth>, **kwargs )   Initialize self.  See help(type(self)) for accurate signature.", "source": "https://docs.manim.community/en/stable/reference/manim.animation.changing.AnimatedBoundary.html"}
{"prompt": "class TracedPath(traced_point_func, stroke_width=2, stroke_color=ManimColor('#FFFFFF'), dissipating_time=None, **kwargs)", "response": "Bases: VMobject Traces the path of a point returned by a function call. Parameters : traced_point_func ( Callable ) \u2013 The function to be traced. stroke_width ( float ) \u2013 The width of the trace. stroke_color ( ParsableManimColor | None ) \u2013 The color of the trace. dissipating_time ( float | None ) \u2013 The time taken for the path to dissipate. Default set to None which disables dissipation. Examples Example: TracedPathExample   from manim import * class TracedPathExample ( Scene ): def construct ( self ): circ = Circle ( color = RED ) . shift ( 4 * LEFT ) dot = Dot ( color = RED ) . move_to ( circ . get_start ()) rolling_circle = VGroup ( circ , dot ) trace = TracedPath ( circ . get_start ) rolling_circle . add_updater ( lambda m : m . rotate ( - 0.3 )) self . add ( trace , rolling_circle ) self . play ( rolling_circle . animate . shift ( 8 * RIGHT ), run_time = 4 , rate_func = linear ) class TracedPathExample(Scene):\n    def construct(self):\n        circ = Circle(color=RED).shift(4*LEFT)\n        dot = Dot(color=RED).move_to(circ.get_start())\n        rolling_circle = VGroup(circ, dot)\n        trace = TracedPath(circ.get_start)\n        rolling_circle.add_updater(lambda m: m.rotate(-0.3))\n        self.add(trace, rolling_circle)\n        self.play(rolling_circle.animate.shift(8*RIGHT), run_time=4, rate_func=linear) Example: DissipatingPathExample   from manim import * class DissipatingPathExample ( Scene ): def construct ( self ): a = Dot ( RIGHT * 2 ) b = TracedPath ( a . get_center , dissipating_time = 0.5 , stroke_opacity = [ 0 , 1 ]) self . add ( a , b ) self . play ( a . animate ( path_arc = PI / 4 ) . shift ( LEFT * 2 )) self . play ( a . animate ( path_arc =- PI / 4 ) . shift ( LEFT * 2 )) self . wait () class DissipatingPathExample(Scene):\n    def construct(self):\n        a = Dot(RIGHT * 2)\n        b = TracedPath(a.get_center, dissipating_time=0.5, stroke_opacity=[0, 1])\n        self.add(a, b)\n        self.play(a.animate(path_arc=PI / 4).shift(LEFT * 2))\n        self.play(a.animate(path_arc=-PI / 4).shift(LEFT * 2))\n        self.wait() Methods update_path Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( traced_point_func , stroke_width = 2 , stroke_color = ManimColor('#FFFFFF') , dissipating_time = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : traced_point_func ( Callable ) stroke_width ( float ) stroke_color ( ParsableManimColor | None ) dissipating_time ( float | None )", "source": "https://docs.manim.community/en/stable/reference/manim.animation.changing.TracedPath.html"}
{"prompt": "class AnimationGroup(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Animation Plays a group or series of Animation . Parameters : animations ( Animation | Iterable [ Animation ] | types.GeneratorType [ Animation ] ) \u2013 Sequence of Animation objects to be played. group ( Group | VGroup | OpenGLGroup | OpenGLVGroup ) \u2013 A group of multiple Mobject . run_time ( float | None ) \u2013 The duration of the animation in seconds. rate_func ( Callable [ [ float ] , float ] ) \u2013 The function defining the animation progress based on the relative\nruntime (see rate_functions ) . lag_ratio ( float ) \u2013 Defines the delay after which the animation is applied to submobjects. A lag_ratio of n.nn means the next animation will play when nnn% of the current animation has played.\nDefaults to 0.0, meaning that all animations will be played together. This does not influence the total runtime of the animation. Instead the runtime\nof individual animations is adjusted so that the complete animation has the defined\nrun time. Methods begin Begin the animation. build_animations_with_timings Creates a list of triplets of the form (anim, start_time, end_time). clean_up_from_scene Clean up the Scene after finishing the animation. finish Finish the animation. get_all_mobjects Get all mobjects involved in the animation. init_run_time Calculates the run time of the animation, if different from run_time . interpolate Set the animation progress. update_mobjects Updates things like starting_mobject, and (for Transforms) target_mobject. Attributes run_time _original__init__ ( *animations , group=None , run_time=None , rate_func=<function linear> , lag_ratio=0 , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : animations ( Animation | Iterable [ Animation ] | types.GeneratorType [ Animation ] ) group ( Group | VGroup | OpenGLGroup | OpenGLVGroup ) run_time ( float | None ) rate_func ( Callable [ [ float ] , float ] ) lag_ratio ( float ) Return type : None _setup_scene ( scene ) [source]   Setup up the Scene before starting the animation. This includes to add() the Animation\u2019s Mobject if the animation is an introducer. Parameters : scene \u2013 The scene the animation should be cleaned up from. Return type : None begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None build_animations_with_timings ( ) [source]   Creates a list of triplets of the form (anim, start_time, end_time). Return type : None clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None finish ( ) [source]   Finish the animation. This method gets called when the animation is over. Return type : None get_all_mobjects ( ) [source]   Get all mobjects involved in the animation. Ordering must match the ordering of arguments to interpolate_submobject Returns : The sequence of mobjects. Return type : Sequence[ Mobject ] init_run_time ( run_time ) [source]   Calculates the run time of the animation, if different from run_time . Parameters : run_time \u2013 The duration of the animation in seconds. Returns : The duration of the animation in seconds. Return type : run_time interpolate ( alpha ) [source]   Set the animation progress. This method gets called for every frame during an animation. Parameters : alpha ( float ) \u2013 The relative time to set the animation to, 0 meaning the start, 1 meaning\nthe end. Return type : None update_mobjects ( dt ) [source]   Updates things like starting_mobject, and (for\nTransforms) target_mobject.  Note, since typically\n(always?) self.mobject will have its updating\nsuspended during the animation, this will do\nnothing to self.mobject. Parameters : dt ( float ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.composition.AnimationGroup.html"}
{"prompt": "class LaggedStart(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: AnimationGroup Adjusts the timing of a series of Animation according to lag_ratio . Parameters : animations ( Animation ) \u2013 Sequence of Animation objects to be played. lag_ratio ( float ) \u2013 Defines the delay after which the animation is applied to submobjects. A lag_ratio of n.nn means the next animation will play when nnn% of the current animation has played.\nDefaults to 0.05, meaning that the next animation will begin when 5% of the current\nanimation has played. This does not influence the total runtime of the animation. Instead the runtime\nof individual animations is adjusted so that the complete animation has the defined\nrun time. Examples Example: LaggedStartExample   from manim import * class LaggedStartExample ( Scene ): def construct ( self ): title = Text ( \"lag_ratio = 0.25\" ) . to_edge ( UP ) dot1 = Dot ( point = LEFT * 2 + UP , radius = 0.16 ) dot2 = Dot ( point = LEFT * 2 , radius = 0.16 ) dot3 = Dot ( point = LEFT * 2 + DOWN , radius = 0.16 ) line_25 = DashedLine ( start = LEFT + UP * 2 , end = LEFT + DOWN * 2 , color = RED ) label = Text ( \"25%\" , font_size = 24 ) . next_to ( line_25 , UP ) self . add ( title , dot1 , dot2 , dot3 , line_25 , label ) self . play ( LaggedStart ( dot1 . animate . shift ( RIGHT * 4 ), dot2 . animate . shift ( RIGHT * 4 ), dot3 . animate . shift ( RIGHT * 4 ), lag_ratio = 0.25 , run_time = 4 )) class LaggedStartExample(Scene):\n    def construct(self):\n        title = Text(\"lag_ratio = 0.25\").to_edge(UP)\n\n        dot1 = Dot(point=LEFT * 2 + UP, radius=0.16)\n        dot2 = Dot(point=LEFT * 2, radius=0.16)\n        dot3 = Dot(point=LEFT * 2 + DOWN, radius=0.16)\n        line_25 = DashedLine(\n            start=LEFT + UP * 2,\n            end=LEFT + DOWN * 2,\n            color=RED\n        )\n        label = Text(\"25%\", font_size=24).next_to(line_25, UP)\n        self.add(title, dot1, dot2, dot3, line_25, label)\n\n        self.play(LaggedStart(\n            dot1.animate.shift(RIGHT * 4),\n            dot2.animate.shift(RIGHT * 4),\n            dot3.animate.shift(RIGHT * 4),\n            lag_ratio=0.25,\n            run_time=4\n        )) Methods Attributes run_time _original__init__ ( * animations , lag_ratio = 0.05 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : animations ( Animation ) lag_ratio ( float )", "source": "https://docs.manim.community/en/stable/reference/manim.animation.composition.LaggedStart.html"}
{"prompt": "class LaggedStartMap(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: LaggedStart Plays a series of Animation while mapping a function to submobjects. Parameters : AnimationClass ( Callable [ ... , Animation ] ) \u2013 Animation to apply to mobject. mobject ( Mobject ) \u2013 Mobject whose submobjects the animation, and optionally the function,\nare to be applied. arg_creator ( Callable [ [ Mobject ] , str ] ) \u2013 Function which will be applied to Mobject . run_time ( float ) \u2013 The duration of the animation in seconds. Examples Example: LaggedStartMapExample   from manim import * class LaggedStartMapExample ( Scene ): def construct ( self ): title = Tex ( \"LaggedStartMap\" ) . to_edge ( UP , buff = LARGE_BUFF ) dots = VGroup ( * [ Dot ( radius = 0.16 ) for _ in range ( 35 )] ) . arrange_in_grid ( rows = 5 , cols = 7 , buff = MED_LARGE_BUFF ) self . add ( dots , title ) # Animate yellow ripple effect for mob in dots , title : self . play ( LaggedStartMap ( ApplyMethod , mob , lambda m : ( m . set_color , YELLOW ), lag_ratio = 0.1 , rate_func = there_and_back , run_time = 2 )) class LaggedStartMapExample(Scene):\n    def construct(self):\n        title = Tex(\"LaggedStartMap\").to_edge(UP, buff=LARGE_BUFF)\n        dots = VGroup(\n            *[Dot(radius=0.16) for _ in range(35)]\n            ).arrange_in_grid(rows=5, cols=7, buff=MED_LARGE_BUFF)\n        self.add(dots, title)\n\n        # Animate yellow ripple effect\n        for mob in dots, title:\n            self.play(LaggedStartMap(\n                ApplyMethod, mob,\n                lambda m : (m.set_color, YELLOW),\n                lag_ratio = 0.1,\n                rate_func = there_and_back,\n                run_time = 2\n            )) Methods Attributes run_time _original__init__ ( AnimationClass , mobject , arg_creator = None , run_time = 2 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : AnimationClass ( Callable [ [ ... ] , Animation ] ) mobject ( Mobject ) arg_creator ( Callable [ [ Mobject ] , str ] ) run_time ( float ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.composition.LaggedStartMap.html"}
{"prompt": "class Succession(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: AnimationGroup Plays a series of animations in succession. Parameters : animations ( Animation ) \u2013 Sequence of Animation objects to be played. lag_ratio ( float ) \u2013 Defines the delay after which the animation is applied to submobjects. A lag_ratio of n.nn means the next animation will play when nnn% of the current animation has played.\nDefaults to 1.0, meaning that the next animation will begin when 100% of the current\nanimation has played. This does not influence the total runtime of the animation. Instead the runtime\nof individual animations is adjusted so that the complete animation has the defined\nrun time. Examples Example: SuccessionExample   from manim import * class SuccessionExample ( Scene ): def construct ( self ): dot1 = Dot ( point = LEFT * 2 + UP * 2 , radius = 0.16 , color = BLUE ) dot2 = Dot ( point = LEFT * 2 + DOWN * 2 , radius = 0.16 , color = MAROON ) dot3 = Dot ( point = RIGHT * 2 + DOWN * 2 , radius = 0.16 , color = GREEN ) dot4 = Dot ( point = RIGHT * 2 + UP * 2 , radius = 0.16 , color = YELLOW ) self . add ( dot1 , dot2 , dot3 , dot4 ) self . play ( Succession ( dot1 . animate . move_to ( dot2 ), dot2 . animate . move_to ( dot3 ), dot3 . animate . move_to ( dot4 ), dot4 . animate . move_to ( dot1 ) )) class SuccessionExample(Scene):\n    def construct(self):\n        dot1 = Dot(point=LEFT * 2 + UP * 2, radius=0.16, color=BLUE)\n        dot2 = Dot(point=LEFT * 2 + DOWN * 2, radius=0.16, color=MAROON)\n        dot3 = Dot(point=RIGHT * 2 + DOWN * 2, radius=0.16, color=GREEN)\n        dot4 = Dot(point=RIGHT * 2 + UP * 2, radius=0.16, color=YELLOW)\n        self.add(dot1, dot2, dot3, dot4)\n\n        self.play(Succession(\n            dot1.animate.move_to(dot2),\n            dot2.animate.move_to(dot3),\n            dot3.animate.move_to(dot4),\n            dot4.animate.move_to(dot1)\n        )) Methods begin Begin the animation. finish Finish the animation. interpolate Set the animation progress. next_animation Proceeds to the next animation. update_active_animation update_mobjects Updates things like starting_mobject, and (for Transforms) target_mobject. Attributes run_time _original__init__ ( * animations , lag_ratio = 1 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : animations ( Animation ) lag_ratio ( float ) Return type : None _setup_scene ( scene ) [source]   Setup up the Scene before starting the animation. This includes to add() the Animation\u2019s Mobject if the animation is an introducer. Parameters : scene \u2013 The scene the animation should be cleaned up from. Return type : None begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None finish ( ) [source]   Finish the animation. This method gets called when the animation is over. Return type : None interpolate ( alpha ) [source]   Set the animation progress. This method gets called for every frame during an animation. Parameters : alpha ( float ) \u2013 The relative time to set the animation to, 0 meaning the start, 1 meaning\nthe end. Return type : None next_animation ( ) [source]   Proceeds to the next animation. This method is called right when the active animation finishes. Return type : None update_mobjects ( dt ) [source]   Updates things like starting_mobject, and (for\nTransforms) target_mobject.  Note, since typically\n(always?) self.mobject will have its updating\nsuspended during the animation, this will do\nnothing to self.mobject. Parameters : dt ( float ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.composition.Succession.html"}
{"prompt": "class AddTextLetterByLetter(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: ShowIncreasingSubsets Show a Text letter by letter on the scene. Parameters : time_per_char ( float ) \u2013 Frequency of appearance of the letters. tip:: ( .. ) \u2013 This is currently only possible for class: ~.Text and not for class: ~.MathTex text ( Text ) suspend_mobject_updating ( bool ) int_func ( Callable [ [ np.ndarray ] , np.ndarray ] ) rate_func ( Callable [ [ float ] , float ] ) run_time ( float | None ) Methods Attributes run_time _original__init__ ( text , suspend_mobject_updating=False , int_func=<ufunc 'ceil'> , rate_func=<function linear> , time_per_char=0.1 , run_time=None , reverse_rate_function=False , introducer=True , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : text ( Text ) suspend_mobject_updating ( bool ) int_func ( Callable [ [ np.ndarray ] , np.ndarray ] ) rate_func ( Callable [ [ float ] , float ] ) time_per_char ( float ) run_time ( float | None ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.creation.AddTextLetterByLetter.html"}
{"prompt": "class AddTextWordByWord(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Succession Show a Text word by word on the scene. Note: currently broken. Methods Attributes run_time Parameters : text_mobject ( Text ) run_time ( float ) time_per_char ( float ) _original__init__ ( text_mobject , run_time = None , time_per_char = 0.06 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : text_mobject ( Text ) run_time ( float ) time_per_char ( float ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.creation.AddTextWordByWord.html"}
{"prompt": "class Create(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: ShowPartial Incrementally show a VMobject. Parameters : mobject ( VMobject | OpenGLVMobject | OpenGLSurface ) \u2013 The VMobject to animate. lag_ratio ( float ) introducer ( bool ) Raises : TypeError \u2013 If mobject is not an instance of VMobject . Examples Example: CreateScene   from manim import * class CreateScene ( Scene ): def construct ( self ): self . play ( Create ( Square ())) class CreateScene(Scene):\n    def construct(self):\n        self.play(Create(Square())) See also ShowPassingFlash Methods Attributes run_time _original__init__ ( mobject , lag_ratio = 1.0 , introducer = True , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( VMobject | OpenGLVMobject | OpenGLSurface ) lag_ratio ( float ) introducer ( bool ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.creation.Create.html"}
{"prompt": "class DrawBorderThenFill(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Animation Draw the border first and then show the fill. Examples Example: ShowDrawBorderThenFill   from manim import * class ShowDrawBorderThenFill ( Scene ): def construct ( self ): self . play ( DrawBorderThenFill ( Square ( fill_opacity = 1 , fill_color = ORANGE ))) class ShowDrawBorderThenFill(Scene):\n    def construct(self):\n        self.play(DrawBorderThenFill(Square(fill_opacity=1, fill_color=ORANGE))) Methods begin Begin the animation. get_all_mobjects Get all mobjects involved in the animation. get_outline get_stroke_color interpolate_submobject Attributes run_time Parameters : vmobject ( VMobject | OpenGLVMobject ) run_time ( float ) rate_func ( Callable [ [ float ] , float ] ) stroke_width ( float ) stroke_color ( str ) draw_border_animation_config ( dict ) fill_animation_config ( dict ) introducer ( bool ) _original__init__ ( vmobject , run_time=2 , rate_func=<function double_smooth> , stroke_width=2 , stroke_color=None , draw_border_animation_config={} , fill_animation_config={} , introducer=True , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : vmobject ( VMobject | OpenGLVMobject ) run_time ( float ) rate_func ( Callable [ [ float ] , float ] ) stroke_width ( float ) stroke_color ( str ) draw_border_animation_config ( dict ) fill_animation_config ( dict ) introducer ( bool ) Return type : None begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None get_all_mobjects ( ) [source]   Get all mobjects involved in the animation. Ordering must match the ordering of arguments to interpolate_submobject Returns : The sequence of mobjects. Return type : Sequence[ Mobject ]", "source": "https://docs.manim.community/en/stable/reference/manim.animation.creation.DrawBorderThenFill.html"}
{"prompt": "class RemoveTextLetterByLetter(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: AddTextLetterByLetter Remove a Text letter by letter from the scene. Parameters : time_per_char ( float ) \u2013 Frequency of appearance of the letters. tip:: ( .. ) \u2013 This is currently only possible for class: ~.Text and not for class: ~.MathTex text ( Text ) suspend_mobject_updating ( bool ) int_func ( Callable [ [ np.ndarray ] , np.ndarray ] ) rate_func ( Callable [ [ float ] , float ] ) run_time ( float | None ) Methods Attributes run_time _original__init__ ( text , suspend_mobject_updating=False , int_func=<ufunc 'ceil'> , rate_func=<function linear> , time_per_char=0.1 , run_time=None , reverse_rate_function=True , introducer=False , remover=True , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : text ( Text ) suspend_mobject_updating ( bool ) int_func ( Callable [ [ np.ndarray ] , np.ndarray ] ) rate_func ( Callable [ [ float ] , float ] ) time_per_char ( float ) run_time ( float | None ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.creation.RemoveTextLetterByLetter.html"}
{"prompt": "class ShowIncreasingSubsets(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Animation Show one submobject at a time, leaving all previous ones displayed on screen. Examples Example: ShowIncreasingSubsetsScene   from manim import * class ShowIncreasingSubsetsScene ( Scene ): def construct ( self ): p = VGroup ( Dot (), Square (), Triangle ()) self . add ( p ) self . play ( ShowIncreasingSubsets ( p )) self . wait () class ShowIncreasingSubsetsScene(Scene):\n    def construct(self):\n        p = VGroup(Dot(), Square(), Triangle())\n        self.add(p)\n        self.play(ShowIncreasingSubsets(p))\n        self.wait() Methods interpolate_mobject Interpolates the mobject of the Animation based on alpha value. update_submobject_list Attributes run_time Parameters : group ( Mobject ) suspend_mobject_updating ( bool ) int_func ( Callable [ [ np.ndarray ] , np.ndarray ] ) _original__init__ ( group , suspend_mobject_updating=False , int_func=<ufunc 'floor'> , reverse_rate_function=False , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : group ( Mobject ) suspend_mobject_updating ( bool ) int_func ( Callable [ [ ndarray ] , ndarray ] ) Return type : None interpolate_mobject ( alpha ) [source]   Interpolates the mobject of the Animation based on alpha value. Parameters : alpha ( float ) \u2013 A float between 0 and 1 expressing the ratio to which the animation\nis completed. For example, alpha-values of 0, 0.5, and 1 correspond\nto the animation being completed 0%, 50%, and 100%, respectively. Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.creation.ShowIncreasingSubsets.html"}
{"prompt": "class ShowPartial(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Animation Abstract class for Animations that show the VMobject partially. Raises : TypeError \u2013 If mobject is not an instance of VMobject . Parameters : mobject ( VMobject | OpenGLVMobject | OpenGLSurface | None ) See also Create , ShowPassingFlash Methods interpolate_submobject Attributes run_time _original__init__ ( mobject , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( VMobject | OpenGLVMobject | OpenGLSurface | None )", "source": "https://docs.manim.community/en/stable/reference/manim.animation.creation.ShowPartial.html"}
{"prompt": "class ShowSubmobjectsOneByOne(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: ShowIncreasingSubsets Show one submobject at a time, removing all previously displayed ones from screen. Methods update_submobject_list Attributes run_time Parameters : group ( Iterable [ Mobject ] ) int_func ( Callable [ [ np.ndarray ] , np.ndarray ] ) _original__init__ ( group , int_func=<ufunc 'ceil'> , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : group ( Iterable [ Mobject ] ) int_func ( Callable [ [ ndarray ] , ndarray ] ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.creation.ShowSubmobjectsOneByOne.html"}
{"prompt": "class SpiralIn(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Animation Create the Mobject with sub-Mobjects flying in on spiral trajectories. Parameters : shapes ( Mobject ) \u2013 The Mobject on which to be operated. scale_factor ( float ) \u2013 The factor used for scaling the effect. fade_in_fraction \u2013 Fractional duration of initial fade-in of sub-Mobjects as they fly inward. Examples Example: SpiralInExample   from manim import * class SpiralInExample ( Scene ): def construct ( self ): pi = MathTex ( r \"\\pi\" ) . scale ( 7 ) pi . shift ( 2.25 * LEFT + 1.5 * UP ) circle = Circle ( color = GREEN_C , fill_opacity = 1 ) . shift ( LEFT ) square = Square ( color = BLUE_D , fill_opacity = 1 ) . shift ( UP ) shapes = VGroup ( pi , circle , square ) self . play ( SpiralIn ( shapes )) class SpiralInExample(Scene):\n    def construct(self):\n        pi = MathTex(r\"\\pi\").scale(7)\n        pi.shift(2.25 * LEFT + 1.5 * UP)\n        circle = Circle(color=GREEN_C, fill_opacity=1).shift(LEFT)\n        square = Square(color=BLUE_D, fill_opacity=1).shift(UP)\n        shapes = VGroup(pi, circle, square)\n        self.play(SpiralIn(shapes)) Methods interpolate_mobject Interpolates the mobject of the Animation based on alpha value. Attributes run_time _original__init__ ( shapes , scale_factor = 8 , fade_in_fraction = 0.3 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : shapes ( Mobject ) scale_factor ( float ) Return type : None interpolate_mobject ( alpha ) [source]   Interpolates the mobject of the Animation based on alpha value. Parameters : alpha ( float ) \u2013 A float between 0 and 1 expressing the ratio to which the animation\nis completed. For example, alpha-values of 0, 0.5, and 1 correspond\nto the animation being completed 0%, 50%, and 100%, respectively. Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.creation.SpiralIn.html"}
{"prompt": "class TypeWithCursor(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: AddTextLetterByLetter Similar to AddTextLetterByLetter , but with an additional cursor mobject at the end. Parameters : time_per_char ( float ) \u2013 Frequency of appearance of the letters. cursor ( Mobject ) \u2013 Mobject shown after the last added letter. buff ( float ) \u2013 Controls how far away the cursor is to the right of the last added letter. keep_cursor_y ( bool ) \u2013 If True , the cursor\u2019s y-coordinate is set to the center of the Text and remains the same throughout the animation. Otherwise, it is set to the center of the last added letter. leave_cursor_on ( bool ) \u2013 Whether to show the cursor after the animation. tip:: ( .. ) \u2013 This is currently only possible for class: ~.Text and not for class: ~.MathTex . text ( Text ) Examples Example: InsertingTextExample   from manim import * class InsertingTextExample ( Scene ): def construct ( self ): text = Text ( \"Inserting\" , color = PURPLE ) . scale ( 1.5 ) . to_edge ( LEFT ) cursor = Rectangle ( color = GREY_A , fill_color = GREY_A , fill_opacity = 1.0 , height = 1.1 , width = 0.5 , ) . move_to ( text [ 0 ]) # Position the cursor self . play ( TypeWithCursor ( text , cursor )) self . play ( Blink ( cursor , blinks = 2 )) class InsertingTextExample(Scene):\n    def construct(self):\n        text = Text(\"Inserting\", color=PURPLE).scale(1.5).to_edge(LEFT)\n        cursor = Rectangle(\n            color = GREY_A,\n            fill_color = GREY_A,\n            fill_opacity = 1.0,\n            height = 1.1,\n            width = 0.5,\n        ).move_to(text[0]) # Position the cursor\n\n        self.play(TypeWithCursor(text, cursor))\n        self.play(Blink(cursor, blinks=2)) References: Blink Methods begin Begin the animation. clean_up_from_scene Clean up the Scene after finishing the animation. finish Finish the animation. update_submobject_list Attributes run_time _original__init__ ( text , cursor , buff = 0.1 , keep_cursor_y = True , leave_cursor_on = True , time_per_char = 0.1 , reverse_rate_function = False , introducer = True , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : text ( Text ) cursor ( Mobject ) buff ( float ) keep_cursor_y ( bool ) leave_cursor_on ( bool ) time_per_char ( float ) Return type : None begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None finish ( ) [source]   Finish the animation. This method gets called when the animation is over. Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.creation.TypeWithCursor.html"}
{"prompt": "class Uncreate(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Create Like Create but in reverse. Examples Example: ShowUncreate   from manim import * class ShowUncreate ( Scene ): def construct ( self ): self . play ( Uncreate ( Square ())) class ShowUncreate(Scene):\n    def construct(self):\n        self.play(Uncreate(Square())) See also Create Methods Attributes run_time Parameters : mobject ( VMobject | OpenGLVMobject ) reverse_rate_function ( bool ) remover ( bool ) _original__init__ ( mobject , reverse_rate_function = True , remover = True , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( VMobject | OpenGLVMobject ) reverse_rate_function ( bool ) remover ( bool ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.creation.Uncreate.html"}
{"prompt": "class UntypeWithCursor(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: TypeWithCursor Similar to RemoveTextLetterByLetter , but with an additional cursor mobject at the end. Parameters : time_per_char ( float ) \u2013 Frequency of appearance of the letters. cursor ( VMobject | None ) \u2013 Mobject shown after the last added letter. buff \u2013 Controls how far away the cursor is to the right of the last added letter. keep_cursor_y \u2013 If True , the cursor\u2019s y-coordinate is set to the center of the Text and remains the same throughout the animation. Otherwise, it is set to the center of the last added letter. leave_cursor_on \u2013 Whether to show the cursor after the animation. tip:: ( .. ) \u2013 This is currently only possible for class: ~.Text and not for class: ~.MathTex . text ( Text ) Examples Example: DeletingTextExample   from manim import * class DeletingTextExample ( Scene ): def construct ( self ): text = Text ( \"Deleting\" , color = PURPLE ) . scale ( 1.5 ) . to_edge ( LEFT ) cursor = Rectangle ( color = GREY_A , fill_color = GREY_A , fill_opacity = 1.0 , height = 1.1 , width = 0.5 , ) . move_to ( text [ 0 ]) # Position the cursor self . play ( UntypeWithCursor ( text , cursor )) self . play ( Blink ( cursor , blinks = 2 )) class DeletingTextExample(Scene):\n    def construct(self):\n        text = Text(\"Deleting\", color=PURPLE).scale(1.5).to_edge(LEFT)\n        cursor = Rectangle(\n            color = GREY_A,\n            fill_color = GREY_A,\n            fill_opacity = 1.0,\n            height = 1.1,\n            width = 0.5,\n        ).move_to(text[0]) # Position the cursor\n\n        self.play(UntypeWithCursor(text, cursor))\n        self.play(Blink(cursor, blinks=2)) References: Blink Methods Attributes run_time _original__init__ ( text , cursor = None , time_per_char = 0.1 , reverse_rate_function = True , introducer = False , remover = True , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : text ( Text ) cursor ( VMobject | None ) time_per_char ( float ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.creation.UntypeWithCursor.html"}
{"prompt": "class Unwrite(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Write Simulate erasing by hand a Text or a VMobject . Parameters : reverse ( bool ) \u2013 Set True to have the animation start erasing from the last submobject first. vmobject ( VMobject ) rate_func ( Callable [ [ float ] , float ] ) Examples Example: UnwriteReverseTrue   from manim import * class UnwriteReverseTrue ( Scene ): def construct ( self ): text = Tex ( \"Alice and Bob\" ) . scale ( 3 ) self . add ( text ) self . play ( Unwrite ( text )) class UnwriteReverseTrue(Scene):\n    def construct(self):\n        text = Tex(\"Alice and Bob\").scale(3)\n        self.add(text)\n        self.play(Unwrite(text)) Example: UnwriteReverseFalse   from manim import * class UnwriteReverseFalse ( Scene ): def construct ( self ): text = Tex ( \"Alice and Bob\" ) . scale ( 3 ) self . add ( text ) self . play ( Unwrite ( text , reverse = False )) class UnwriteReverseFalse(Scene):\n    def construct(self):\n        text = Tex(\"Alice and Bob\").scale(3)\n        self.add(text)\n        self.play(Unwrite(text, reverse=False)) Methods Attributes run_time _original__init__ ( vmobject , rate_func=<function linear> , reverse=True , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : vmobject ( VMobject ) rate_func ( Callable [ [ float ] , float ] ) reverse ( bool ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.creation.Unwrite.html"}
{"prompt": "class Write(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: DrawBorderThenFill Simulate hand-writing a Text or hand-drawing a VMobject . Examples Example: ShowWrite   from manim import * class ShowWrite ( Scene ): def construct ( self ): self . play ( Write ( Text ( \"Hello\" , font_size = 144 ))) class ShowWrite(Scene):\n    def construct(self):\n        self.play(Write(Text(\"Hello\", font_size=144))) Example: ShowWriteReversed   from manim import * class ShowWriteReversed ( Scene ): def construct ( self ): self . play ( Write ( Text ( \"Hello\" , font_size = 144 ), reverse = True , remover = False )) class ShowWriteReversed(Scene):\n    def construct(self):\n        self.play(Write(Text(\"Hello\", font_size=144), reverse=True, remover=False)) Tests Check that creating empty Write animations works: >>> from manim import Write , Text >>> Write ( Text ( '' )) Write(Text('')) Methods begin Begin the animation. finish Finish the animation. reverse_submobjects Attributes run_time Parameters : vmobject ( VMobject | OpenGLVMobject ) rate_func ( Callable [ [ float ] , float ] ) reverse ( bool ) _original__init__ ( vmobject , rate_func=<function linear> , reverse=False , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : vmobject ( VMobject | OpenGLVMobject ) rate_func ( Callable [ [ float ] , float ] ) reverse ( bool ) Return type : None begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None finish ( ) [source]   Finish the animation. This method gets called when the animation is over. Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.creation.Write.html"}
{"prompt": "class FadeIn(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: _Fade Fade in Mobject s. Parameters : mobjects ( Mobject ) \u2013 The mobjects to be faded in. shift \u2013 The vector by which the mobject shifts while being faded in. target_position \u2013 The position from which the mobject starts while being faded in. In case\nanother mobject is given as target position, its center is used. scale \u2013 The factor by which the mobject is scaled initially before being rescaling to\nits original size while being faded in. Examples Example: FadeInExample   from manim import * class FadeInExample ( Scene ): def construct ( self ): dot = Dot ( UP * 2 + LEFT ) self . add ( dot ) tex = Tex ( \"FadeIn with \" , \"shift \" , r \" or target\\_position\" , \" and scale\" ) . scale ( 1 ) animations = [ FadeIn ( tex [ 0 ]), FadeIn ( tex [ 1 ], shift = DOWN ), FadeIn ( tex [ 2 ], target_position = dot ), FadeIn ( tex [ 3 ], scale = 1.5 ), ] self . play ( AnimationGroup ( * animations , lag_ratio = 0.5 )) class FadeInExample(Scene):\n    def construct(self):\n        dot = Dot(UP * 2 + LEFT)\n        self.add(dot)\n        tex = Tex(\n            \"FadeIn with \", \"shift \", r\" or target\\_position\", \" and scale\"\n        ).scale(1)\n        animations = [\n            FadeIn(tex[0]),\n            FadeIn(tex[1], shift=DOWN),\n            FadeIn(tex[2], target_position=dot),\n            FadeIn(tex[3], scale=1.5),\n        ]\n        self.play(AnimationGroup(*animations, lag_ratio=0.5)) Methods create_starting_mobject create_target Attributes path_arc path_func run_time _original__init__ ( * mobjects , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobjects ( Mobject ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.fading.FadeIn.html"}
{"prompt": "class FadeOut(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: _Fade Fade out Mobject s. Parameters : mobjects ( Mobject ) \u2013 The mobjects to be faded out. shift \u2013 The vector by which the mobject shifts while being faded out. target_position \u2013 The position to which the mobject moves while being faded out. In case another\nmobject is given as target position, its center is used. scale \u2013 The factor by which the mobject is scaled while being faded out. Examples Example: FadeInExample   from manim import * class FadeInExample ( Scene ): def construct ( self ): dot = Dot ( UP * 2 + LEFT ) self . add ( dot ) tex = Tex ( \"FadeOut with \" , \"shift \" , r \" or target\\_position\" , \" and scale\" ) . scale ( 1 ) animations = [ FadeOut ( tex [ 0 ]), FadeOut ( tex [ 1 ], shift = DOWN ), FadeOut ( tex [ 2 ], target_position = dot ), FadeOut ( tex [ 3 ], scale = 0.5 ), ] self . play ( AnimationGroup ( * animations , lag_ratio = 0.5 )) class FadeInExample(Scene):\n    def construct(self):\n        dot = Dot(UP * 2 + LEFT)\n        self.add(dot)\n        tex = Tex(\n            \"FadeOut with \", \"shift \", r\" or target\\_position\", \" and scale\"\n        ).scale(1)\n        animations = [\n            FadeOut(tex[0]),\n            FadeOut(tex[1], shift=DOWN),\n            FadeOut(tex[2], target_position=dot),\n            FadeOut(tex[3], scale=0.5),\n        ]\n        self.play(AnimationGroup(*animations, lag_ratio=0.5)) Methods clean_up_from_scene Clean up the Scene after finishing the animation. create_target Attributes path_arc path_func run_time _original__init__ ( * mobjects , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobjects ( Mobject ) Return type : None clean_up_from_scene ( scene = None ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.fading.FadeOut.html"}
{"prompt": "class GrowArrow(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: GrowFromPoint Introduce an Arrow by growing it from its start toward its tip. Parameters : arrow ( Arrow ) \u2013 The arrow to be introduced. point_color ( str ) \u2013 Initial color of the arrow before growing to its full size. Leave empty to match arrow\u2019s color. Examples Example: GrowArrowExample   from manim import * class GrowArrowExample ( Scene ): def construct ( self ): arrows = [ Arrow ( 2 * LEFT , 2 * RIGHT ), Arrow ( 2 * DR , 2 * UL )] VGroup ( * arrows ) . set_x ( 0 ) . arrange ( buff = 2 ) self . play ( GrowArrow ( arrows [ 0 ])) self . play ( GrowArrow ( arrows [ 1 ], point_color = RED )) class GrowArrowExample(Scene):\n    def construct(self):\n        arrows = [Arrow(2 * LEFT, 2 * RIGHT), Arrow(2 * DR, 2 * UL)]\n        VGroup(*arrows).set_x(0).arrange(buff=2)\n        self.play(GrowArrow(arrows[0]))\n        self.play(GrowArrow(arrows[1], point_color=RED)) Methods create_starting_mobject Attributes path_arc path_func run_time _original__init__ ( arrow , point_color = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : arrow ( Arrow ) point_color ( str ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.growing.GrowArrow.html"}
{"prompt": "class GrowFromCenter(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: GrowFromPoint Introduce an Mobject by growing it from its center. Parameters : mobject ( Mobject ) \u2013 The mobjects to be introduced. point_color ( str ) \u2013 Initial color of the mobject before growing to its full size. Leave empty to match mobject\u2019s color. Examples Example: GrowFromCenterExample   from manim import * class GrowFromCenterExample ( Scene ): def construct ( self ): squares = [ Square () for _ in range ( 2 )] VGroup ( * squares ) . set_x ( 0 ) . arrange ( buff = 2 ) self . play ( GrowFromCenter ( squares [ 0 ])) self . play ( GrowFromCenter ( squares [ 1 ], point_color = RED )) class GrowFromCenterExample(Scene):\n    def construct(self):\n        squares = [Square() for _ in range(2)]\n        VGroup(*squares).set_x(0).arrange(buff=2)\n        self.play(GrowFromCenter(squares[0]))\n        self.play(GrowFromCenter(squares[1], point_color=RED)) Methods Attributes path_arc path_func run_time _original__init__ ( mobject , point_color = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) point_color ( str ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.growing.GrowFromCenter.html"}
{"prompt": "class GrowFromEdge(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: GrowFromPoint Introduce an Mobject by growing it from one of its bounding box edges. Parameters : mobject ( Mobject ) \u2013 The mobjects to be introduced. edge ( np.ndarray ) \u2013 The direction to seek bounding box edge of mobject. point_color ( str ) \u2013 Initial color of the mobject before growing to its full size. Leave empty to match mobject\u2019s color. Examples Example: GrowFromEdgeExample   from manim import * class GrowFromEdgeExample ( Scene ): def construct ( self ): squares = [ Square () for _ in range ( 4 )] VGroup ( * squares ) . set_x ( 0 ) . arrange ( buff = 1 ) self . play ( GrowFromEdge ( squares [ 0 ], DOWN )) self . play ( GrowFromEdge ( squares [ 1 ], RIGHT )) self . play ( GrowFromEdge ( squares [ 2 ], UR )) self . play ( GrowFromEdge ( squares [ 3 ], UP , point_color = RED )) class GrowFromEdgeExample(Scene):\n    def construct(self):\n        squares = [Square() for _ in range(4)]\n        VGroup(*squares).set_x(0).arrange(buff=1)\n        self.play(GrowFromEdge(squares[0], DOWN))\n        self.play(GrowFromEdge(squares[1], RIGHT))\n        self.play(GrowFromEdge(squares[2], UR))\n        self.play(GrowFromEdge(squares[3], UP, point_color=RED)) Methods Attributes path_arc path_func run_time _original__init__ ( mobject , edge , point_color = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) edge ( np.ndarray ) point_color ( str ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.growing.GrowFromEdge.html"}
{"prompt": "class GrowFromPoint(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Transform Introduce an Mobject by growing it from a point. Parameters : mobject ( Mobject ) \u2013 The mobjects to be introduced. point ( np.ndarray ) \u2013 The point from which the mobject grows. point_color ( str ) \u2013 Initial color of the mobject before growing to its full size. Leave empty to match mobject\u2019s color. Examples Example: GrowFromPointExample   from manim import * class GrowFromPointExample ( Scene ): def construct ( self ): dot = Dot ( 3 * UR , color = GREEN ) squares = [ Square () for _ in range ( 4 )] VGroup ( * squares ) . set_x ( 0 ) . arrange ( buff = 1 ) self . add ( dot ) self . play ( GrowFromPoint ( squares [ 0 ], ORIGIN )) self . play ( GrowFromPoint ( squares [ 1 ], [ - 2 , 2 , 0 ])) self . play ( GrowFromPoint ( squares [ 2 ], [ 3 , - 2 , 0 ], RED )) self . play ( GrowFromPoint ( squares [ 3 ], dot , dot . get_color ())) class GrowFromPointExample(Scene):\n    def construct(self):\n        dot = Dot(3 * UR, color=GREEN)\n        squares = [Square() for _ in range(4)]\n        VGroup(*squares).set_x(0).arrange(buff=1)\n        self.add(dot)\n        self.play(GrowFromPoint(squares[0], ORIGIN))\n        self.play(GrowFromPoint(squares[1], [-2, 2, 0]))\n        self.play(GrowFromPoint(squares[2], [3, -2, 0], RED))\n        self.play(GrowFromPoint(squares[3], dot, dot.get_color())) Methods create_starting_mobject create_target Attributes path_arc path_func run_time _original__init__ ( mobject , point , point_color = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) point ( np.ndarray ) point_color ( str ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.growing.GrowFromPoint.html"}
{"prompt": "class SpinInFromNothing(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: GrowFromCenter Introduce an Mobject spinning and growing it from its center. Parameters : mobject ( Mobject ) \u2013 The mobjects to be introduced. angle ( float ) \u2013 The amount of spinning before mobject reaches its full size. E.g. 2*PI means\nthat the object will do one full spin before being fully introduced. point_color ( str ) \u2013 Initial color of the mobject before growing to its full size. Leave empty to match mobject\u2019s color. Examples Example: SpinInFromNothingExample   from manim import * class SpinInFromNothingExample ( Scene ): def construct ( self ): squares = [ Square () for _ in range ( 3 )] VGroup ( * squares ) . set_x ( 0 ) . arrange ( buff = 2 ) self . play ( SpinInFromNothing ( squares [ 0 ])) self . play ( SpinInFromNothing ( squares [ 1 ], angle = 2 * PI )) self . play ( SpinInFromNothing ( squares [ 2 ], point_color = RED )) class SpinInFromNothingExample(Scene):\n    def construct(self):\n        squares = [Square() for _ in range(3)]\n        VGroup(*squares).set_x(0).arrange(buff=2)\n        self.play(SpinInFromNothing(squares[0]))\n        self.play(SpinInFromNothing(squares[1], angle=2 * PI))\n        self.play(SpinInFromNothing(squares[2], point_color=RED)) Methods Attributes path_arc path_func run_time _original__init__ ( mobject , angle = 1.5707963267948966 , point_color = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) angle ( float ) point_color ( str ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.growing.SpinInFromNothing.html"}
{"prompt": "class ApplyWave(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Homotopy Send a wave through the Mobject distorting it temporarily. Parameters : mobject ( Mobject ) \u2013 The mobject to be distorted. direction ( np.ndarray ) \u2013 The direction in which the wave nudges points of the shape amplitude ( float ) \u2013 The distance points of the shape get shifted wave_func ( Callable [ [ float ] , float ] ) \u2013 The function defining the shape of one wave flank. time_width ( float ) \u2013 The length of the wave relative to the width of the mobject. ripples ( int ) \u2013 The number of ripples of the wave run_time ( float ) \u2013 The duration of the animation. Examples Example: ApplyingWaves   from manim import * class ApplyingWaves ( Scene ): def construct ( self ): tex = Tex ( \"WaveWaveWaveWaveWave\" ) . scale ( 2 ) self . play ( ApplyWave ( tex )) self . play ( ApplyWave ( tex , direction = RIGHT , time_width = 0.5 , amplitude = 0.3 )) self . play ( ApplyWave ( tex , rate_func = linear , ripples = 4 )) class ApplyingWaves(Scene):\n    def construct(self):\n        tex = Tex(\"WaveWaveWaveWaveWave\").scale(2)\n        self.play(ApplyWave(tex))\n        self.play(ApplyWave(\n            tex,\n            direction=RIGHT,\n            time_width=0.5,\n            amplitude=0.3\n        ))\n        self.play(ApplyWave(\n            tex,\n            rate_func=linear,\n            ripples=4\n        )) Methods Attributes run_time _original__init__ ( mobject , direction=array([0. , 1. , 0.]) , amplitude=0.2 , wave_func=<function smooth> , time_width=1 , ripples=1 , run_time=2 , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) direction ( ndarray ) amplitude ( float ) wave_func ( Callable [ [ float ] , float ] ) time_width ( float ) ripples ( int ) run_time ( float ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.indication.ApplyWave.html"}
{"prompt": "class Blink(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Succession Blink the mobject. Parameters : mobject ( Mobject ) \u2013 The mobject to be blinked. time_on ( float ) \u2013 The duration that the mobject is shown for one blink. time_off ( float ) \u2013 The duration that the mobject is hidden for one blink. blinks ( int ) \u2013 The number of blinks hide_at_end ( bool ) \u2013 Whether to hide the mobject at the end of the animation. kwargs \u2013 Additional arguments to be passed to the Succession constructor. Examples Example: BlinkingExample   from manim import * class BlinkingExample ( Scene ): def construct ( self ): text = Text ( \"Blinking\" ) . scale ( 1.5 ) self . add ( text ) self . play ( Blink ( text , blinks = 3 )) class BlinkingExample(Scene):\n    def construct(self):\n        text = Text(\"Blinking\").scale(1.5)\n        self.add(text)\n        self.play(Blink(text, blinks=3)) Methods Attributes run_time _original__init__ ( mobject , time_on = 0.5 , time_off = 0.5 , blinks = 1 , hide_at_end = False , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) time_on ( float ) time_off ( float ) blinks ( int ) hide_at_end ( bool )", "source": "https://docs.manim.community/en/stable/reference/manim.animation.indication.Blink.html"}
{"prompt": "class Circumscribe(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Succession Draw a temporary line surrounding the mobject. Parameters : mobject ( Mobject ) \u2013 The mobject to be circumscribed. shape ( type ) \u2013 The shape with which to surround the given mobject. Should be either Rectangle or Circle fade_in \u2013 Whether to make the surrounding shape to fade in. It will be drawn otherwise. fade_out \u2013 Whether to make the surrounding shape to fade out. It will be undrawn otherwise. time_width \u2013 The time_width of the drawing and undrawing. Gets ignored if either fade_in or fade_out is True . buff ( float ) \u2013 The distance between the surrounding shape and the given mobject. color ( ParsableManimColor ) \u2013 The color of the surrounding shape. run_time \u2013 The duration of the entire animation. kwargs \u2013 Additional arguments to be passed to the Succession constructor Examples Example: UsingCircumscribe   from manim import * class UsingCircumscribe ( Scene ): def construct ( self ): lbl = Tex ( r \"Circum- \\\\ scribe\" ) . scale ( 2 ) self . add ( lbl ) self . play ( Circumscribe ( lbl )) self . play ( Circumscribe ( lbl , Circle )) self . play ( Circumscribe ( lbl , fade_out = True )) self . play ( Circumscribe ( lbl , time_width = 2 )) self . play ( Circumscribe ( lbl , Circle , True )) class UsingCircumscribe(Scene):\n    def construct(self):\n        lbl = Tex(r\"Circum-\\\\scribe\").scale(2)\n        self.add(lbl)\n        self.play(Circumscribe(lbl))\n        self.play(Circumscribe(lbl, Circle))\n        self.play(Circumscribe(lbl, fade_out=True))\n        self.play(Circumscribe(lbl, time_width=2))\n        self.play(Circumscribe(lbl, Circle, True)) Methods Attributes run_time _original__init__ ( mobject , shape=<class 'manim.mobject.geometry.polygram.Rectangle'> , fade_in=False , fade_out=False , time_width=0.3 , buff=0.1 , color=ManimColor('#FFFF00') , run_time=1 , stroke_width=4 , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) shape ( type ) buff ( float ) color ( ParsableManimColor )", "source": "https://docs.manim.community/en/stable/reference/manim.animation.indication.Circumscribe.html"}
{"prompt": "class Flash(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: AnimationGroup Send out lines in all directions. Parameters : point ( np.ndarray | Mobject ) \u2013 The center of the flash lines. If it is a Mobject its center will be used. line_length ( float ) \u2013 The length of the flash lines. num_lines ( int ) \u2013 The number of flash lines. flash_radius ( float ) \u2013 The distance from point at which the flash lines start. line_stroke_width ( int ) \u2013 The stroke width of the flash lines. color ( str ) \u2013 The color of the flash lines. time_width ( float ) \u2013 The time width used for the flash lines. See ShowPassingFlash for more details. run_time ( float ) \u2013 The duration of the animation. kwargs \u2013 Additional arguments to be passed to the Succession constructor Examples Example: UsingFlash   from manim import * class UsingFlash ( Scene ): def construct ( self ): dot = Dot ( color = YELLOW ) . shift ( DOWN ) self . add ( Tex ( \"Flash the dot below:\" ), dot ) self . play ( Flash ( dot )) self . wait () class UsingFlash(Scene):\n    def construct(self):\n        dot = Dot(color=YELLOW).shift(DOWN)\n        self.add(Tex(\"Flash the dot below:\"), dot)\n        self.play(Flash(dot))\n        self.wait() Example: FlashOnCircle   from manim import * class FlashOnCircle ( Scene ): def construct ( self ): radius = 2 circle = Circle ( radius ) self . add ( circle ) self . play ( Flash ( circle , line_length = 1 , num_lines = 30 , color = RED , flash_radius = radius + SMALL_BUFF , time_width = 0.3 , run_time = 2 , rate_func = rush_from )) class FlashOnCircle(Scene):\n    def construct(self):\n        radius = 2\n        circle = Circle(radius)\n        self.add(circle)\n        self.play(Flash(\n            circle, line_length=1,\n            num_lines=30, color=RED,\n            flash_radius=radius+SMALL_BUFF,\n            time_width=0.3, run_time=2,\n            rate_func = rush_from\n        )) Methods create_line_anims create_lines Attributes run_time _original__init__ ( point , line_length = 0.2 , num_lines = 12 , flash_radius = 0.1 , line_stroke_width = 3 , color = ManimColor('#FFFF00') , time_width = 1 , run_time = 1.0 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : point ( ndarray | Mobject ) line_length ( float ) num_lines ( int ) flash_radius ( float ) line_stroke_width ( int ) color ( str ) time_width ( float ) run_time ( float ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.indication.Flash.html"}
{"prompt": "class FocusOn(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Transform Shrink a spotlight to a position. Parameters : focus_point ( np.ndarray | Mobject ) \u2013 The point at which to shrink the spotlight. If it is a Mobject its center will be used. opacity ( float ) \u2013 The opacity of the spotlight. color ( str ) \u2013 The color of the spotlight. run_time ( float ) \u2013 The duration of the animation. Examples Example: UsingFocusOn   from manim import * class UsingFocusOn ( Scene ): def construct ( self ): dot = Dot ( color = YELLOW ) . shift ( DOWN ) self . add ( Tex ( \"Focusing on the dot below:\" ), dot ) self . play ( FocusOn ( dot )) self . wait () class UsingFocusOn(Scene):\n    def construct(self):\n        dot = Dot(color=YELLOW).shift(DOWN)\n        self.add(Tex(\"Focusing on the dot below:\"), dot)\n        self.play(FocusOn(dot))\n        self.wait() Methods create_target Attributes path_arc path_func run_time _original__init__ ( focus_point , opacity = 0.2 , color = ManimColor('#888888') , run_time = 2 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : focus_point ( ndarray | Mobject ) opacity ( float ) color ( str ) run_time ( float ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.indication.FocusOn.html"}
{"prompt": "class Indicate(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Transform Indicate a Mobject by temporarily resizing and recoloring it. Parameters : mobject ( Mobject ) \u2013 The mobject to indicate. scale_factor ( float ) \u2013 The factor by which the mobject will be temporally scaled color ( str ) \u2013 The color the mobject temporally takes. rate_func ( Callable [ [ float , float | None ] , np.ndarray ] ) \u2013 The function defining the animation progress at every point in time. kwargs \u2013 Additional arguments to be passed to the Succession constructor Examples Example: UsingIndicate   from manim import * class UsingIndicate ( Scene ): def construct ( self ): tex = Tex ( \"Indicate\" ) . scale ( 3 ) self . play ( Indicate ( tex )) self . wait () class UsingIndicate(Scene):\n    def construct(self):\n        tex = Tex(\"Indicate\").scale(3)\n        self.play(Indicate(tex))\n        self.wait() Methods create_target Attributes path_arc path_func run_time _original__init__ ( mobject , scale_factor=1.2 , color=ManimColor('#FFFF00') , rate_func=<function there_and_back> , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) scale_factor ( float ) color ( str ) rate_func ( Callable [ [ float , float | None ] , ndarray ] ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.indication.Indicate.html"}
{"prompt": "class ShowPassingFlash(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: ShowPartial Show only a sliver of the VMobject each frame. Parameters : mobject ( VMobject ) \u2013 The mobject whose stroke is animated. time_width ( float ) \u2013 The length of the sliver relative to the length of the stroke. Examples Example: TimeWidthValues   from manim import * class TimeWidthValues ( Scene ): def construct ( self ): p = RegularPolygon ( 5 , color = DARK_GRAY , stroke_width = 6 ) . scale ( 3 ) lbl = VMobject () self . add ( p , lbl ) p = p . copy () . set_color ( BLUE ) for time_width in [ 0.2 , 0.5 , 1 , 2 ]: lbl . become ( Tex ( r \"\\texttt{time\\_width={{ %.1f }}}\" % time_width )) self . play ( ShowPassingFlash ( p . copy () . set_color ( BLUE ), run_time = 2 , time_width = time_width )) class TimeWidthValues(Scene):\n    def construct(self):\n        p = RegularPolygon(5, color=DARK_GRAY, stroke_width=6).scale(3)\n        lbl = VMobject()\n        self.add(p, lbl)\n        p = p.copy().set_color(BLUE)\n        for time_width in [0.2, 0.5, 1, 2]:\n            lbl.become(Tex(r\"\\texttt{time\\_width={{%.1f}}}\"%time_width))\n            self.play(ShowPassingFlash(\n                p.copy().set_color(BLUE),\n                run_time=2,\n                time_width=time_width\n            )) See also Create Methods clean_up_from_scene Clean up the Scene after finishing the animation. Attributes run_time _original__init__ ( mobject , time_width = 0.1 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( VMobject ) time_width ( float ) Return type : None clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.indication.ShowPassingFlash.html"}
{"prompt": "class ShowPassingFlashWithThinningStrokeWidth(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: AnimationGroup Methods Attributes run_time _original__init__ ( vmobject , n_segments = 10 , time_width = 0.1 , remover = True , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature.", "source": "https://docs.manim.community/en/stable/reference/manim.animation.indication.ShowPassingFlashWithThinningStrokeWidth.html"}
{"prompt": "class Wiggle(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Animation Wiggle a Mobject. Parameters : mobject ( Mobject ) \u2013 The mobject to wiggle. scale_value ( float ) \u2013 The factor by which the mobject will be temporarily scaled. rotation_angle ( float ) \u2013 The wiggle angle. n_wiggles ( int ) \u2013 The number of wiggles. scale_about_point ( np.ndarray | None ) \u2013 The point about which the mobject gets scaled. rotate_about_point ( np.ndarray | None ) \u2013 The point around which the mobject gets rotated. run_time ( float ) \u2013 The duration of the animation Examples Example: ApplyingWaves   from manim import * class ApplyingWaves ( Scene ): def construct ( self ): tex = Tex ( \"Wiggle\" ) . scale ( 3 ) self . play ( Wiggle ( tex )) self . wait () class ApplyingWaves(Scene):\n    def construct(self):\n        tex = Tex(\"Wiggle\").scale(3)\n        self.play(Wiggle(tex))\n        self.wait() Methods get_rotate_about_point get_scale_about_point interpolate_submobject Attributes run_time _original__init__ ( mobject , scale_value = 1.1 , rotation_angle = 0.06283185307179587 , n_wiggles = 6 , scale_about_point = None , rotate_about_point = None , run_time = 2 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) scale_value ( float ) rotation_angle ( float ) n_wiggles ( int ) scale_about_point ( ndarray | None ) rotate_about_point ( ndarray | None ) run_time ( float ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.indication.Wiggle.html"}
{"prompt": "class ComplexHomotopy(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Homotopy Complex Homotopy a function Cx[0, 1] to C Methods Attributes run_time Parameters : complex_homotopy ( Callable [ [ complex ] , float ] ) mobject ( Mobject ) _original__init__ ( complex_homotopy , mobject , ** kwargs )   Complex Homotopy a function Cx[0, 1] to C Parameters : complex_homotopy ( Callable [ [ complex ] , float ] ) mobject ( Mobject ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.movement.ComplexHomotopy.html"}
{"prompt": "class Homotopy(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Animation A Homotopy. This is an animation transforming the points of a mobject according\nto the specified transformation function. With the parameter \\(t\\) moving from 0 to 1 throughout the animation and \\((x, y, z)\\) describing the coordinates of the point of a mobject,\nthe function passed to the homotopy keyword argument should\ntransform the tuple \\((x, y, z, t)\\) to \\((x', y', z')\\) ,\nthe coordinates the original point is transformed to at time \\(t\\) . Parameters : homotopy ( Callable [ [ float , float , float , float ] , tuple [ float , float , float ] ] ) \u2013 A function mapping \\((x, y, z, t)\\) to \\((x', y', z')\\) . mobject ( Mobject ) \u2013 The mobject transformed under the given homotopy. run_time ( float ) \u2013 The run time of the animation. apply_function_kwargs ( dict [ str , Any ] | None ) \u2013 Keyword arguments propagated to Mobject.apply_function() . kwargs \u2013 Further keyword arguments passed to the parent class. Examples Example: HomotopyExample   from manim import * class HomotopyExample ( Scene ): def construct ( self ): square = Square () def homotopy ( x , y , z , t ): if t <= 0.25 : progress = t / 0.25 return ( x , y + progress * 0.2 * np . sin ( x ), z ) else : wave_progress = ( t - 0.25 ) / 0.75 return ( x , y + 0.2 * np . sin ( x + 10 * wave_progress ), z ) self . play ( Homotopy ( homotopy , square , rate_func = linear , run_time = 2 )) class HomotopyExample(Scene):\n    def construct(self):\n        square = Square()\n\n        def homotopy(x, y, z, t):\n            if t <= 0.25:\n                progress = t / 0.25\n                return (x, y + progress * 0.2 * np.sin(x), z)\n            else:\n                wave_progress = (t - 0.25) / 0.75\n                return (x, y + 0.2 * np.sin(x + 10 * wave_progress), z)\n\n        self.play(Homotopy(homotopy, square, rate_func= linear, run_time=2)) Methods function_at_time_t interpolate_submobject Attributes run_time _original__init__ ( homotopy , mobject , run_time = 3 , apply_function_kwargs = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : homotopy ( Callable [ [ float , float , float , float ] , tuple [ float , float , float ] ] ) mobject ( Mobject ) run_time ( float ) apply_function_kwargs ( dict [ str , Any ] | None ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.movement.Homotopy.html"}
{"prompt": "class MoveAlongPath(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Animation Make one mobject move along the path of another mobject. Example: MoveAlongPathExample   from manim import * class MoveAlongPathExample ( Scene ): def construct ( self ): d1 = Dot () . set_color ( ORANGE ) l1 = Line ( LEFT , RIGHT ) l2 = VMobject () self . add ( d1 , l1 , l2 ) l2 . add_updater ( lambda x : x . become ( Line ( LEFT , d1 . get_center ()) . set_color ( ORANGE ))) self . play ( MoveAlongPath ( d1 , l1 ), rate_func = linear ) class MoveAlongPathExample(Scene):\n    def construct(self):\n        d1 = Dot().set_color(ORANGE)\n        l1 = Line(LEFT, RIGHT)\n        l2 = VMobject()\n        self.add(d1, l1, l2)\n        l2.add_updater(lambda x: x.become(Line(LEFT, d1.get_center()).set_color(ORANGE)))\n        self.play(MoveAlongPath(d1, l1), rate_func=linear) Methods interpolate_mobject Interpolates the mobject of the Animation based on alpha value. Attributes run_time Parameters : mobject ( Mobject ) path ( VMobject ) suspend_mobject_updating ( bool | None ) _original__init__ ( mobject , path , suspend_mobject_updating = False , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) path ( VMobject ) suspend_mobject_updating ( bool | None ) Return type : None interpolate_mobject ( alpha ) [source]   Interpolates the mobject of the Animation based on alpha value. Parameters : alpha ( float ) \u2013 A float between 0 and 1 expressing the ratio to which the animation\nis completed. For example, alpha-values of 0, 0.5, and 1 correspond\nto the animation being completed 0%, 50%, and 100%, respectively. Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.movement.MoveAlongPath.html"}
{"prompt": "class PhaseFlow(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Animation Methods interpolate_mobject Interpolates the mobject of the Animation based on alpha value. Attributes run_time Parameters : function ( Callable [ [ np.ndarray ] , np.ndarray ] ) mobject ( Mobject ) virtual_time ( float ) suspend_mobject_updating ( bool ) rate_func ( Callable [ [ float ] , float ] ) _original__init__ ( function , mobject , virtual_time=1 , suspend_mobject_updating=False , rate_func=<function linear> , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : function ( Callable [ [ np.ndarray ] , np.ndarray ] ) mobject ( Mobject ) virtual_time ( float ) suspend_mobject_updating ( bool ) rate_func ( Callable [ [ float ] , float ] ) Return type : None interpolate_mobject ( alpha ) [source]   Interpolates the mobject of the Animation based on alpha value. Parameters : alpha ( float ) \u2013 A float between 0 and 1 expressing the ratio to which the animation\nis completed. For example, alpha-values of 0, 0.5, and 1 correspond\nto the animation being completed 0%, 50%, and 100%, respectively. Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.movement.PhaseFlow.html"}
{"prompt": "class SmoothedVectorizedHomotopy(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Homotopy Methods interpolate_submobject Attributes run_time Parameters : homotopy ( Callable [ [ float , float , float , float ] , tuple [ float , float , float ] ] ) mobject ( Mobject ) run_time ( float ) apply_function_kwargs ( dict [ str , Any ] | None ) _original__init__ ( homotopy , mobject , run_time = 3 , apply_function_kwargs = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : homotopy ( Callable [ [ float , float , float , float ] , tuple [ float , float , float ] ] ) mobject ( Mobject ) run_time ( float ) apply_function_kwargs ( dict [ str , Any ] | None ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.movement.SmoothedVectorizedHomotopy.html"}
{"prompt": "class ChangeDecimalToValue(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: ChangingDecimal Methods Attributes run_time Parameters : decimal_mob ( DecimalNumber ) target_number ( int ) _original__init__ ( decimal_mob , target_number , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : decimal_mob ( DecimalNumber ) target_number ( int ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.numbers.ChangeDecimalToValue.html"}
{"prompt": "class ChangingDecimal(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Animation Methods check_validity_of_input interpolate_mobject Interpolates the mobject of the Animation based on alpha value. Attributes run_time Parameters : decimal_mob ( DecimalNumber ) number_update_func ( Callable [ [ float ] , float ] ) suspend_mobject_updating ( bool | None ) _original__init__ ( decimal_mob , number_update_func , suspend_mobject_updating = False , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : decimal_mob ( DecimalNumber ) number_update_func ( Callable [ [ float ] , float ] ) suspend_mobject_updating ( bool | None ) Return type : None interpolate_mobject ( alpha ) [source]   Interpolates the mobject of the Animation based on alpha value. Parameters : alpha ( float ) \u2013 A float between 0 and 1 expressing the ratio to which the animation\nis completed. For example, alpha-values of 0, 0.5, and 1 correspond\nto the animation being completed 0%, 50%, and 100%, respectively. Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.numbers.ChangingDecimal.html"}
{"prompt": "class Rotate(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Transform Animation that rotates a Mobject. Parameters : mobject ( Mobject ) \u2013 The mobject to be rotated. angle ( float ) \u2013 The rotation angle. axis ( np.ndarray ) \u2013 The rotation axis as a numpy vector. about_point ( Sequence [ float ] | None ) \u2013 The rotation center. about_edge ( Sequence [ float ] | None ) \u2013 If about_point is None , this argument specifies\nthe direction of the bounding box point to be taken as\nthe rotation center. Examples Example: UsingRotate   from manim import * class UsingRotate ( Scene ): def construct ( self ): self . play ( Rotate ( Square ( side_length = 0.5 ) . shift ( UP * 2 ), angle = 2 * PI , about_point = ORIGIN , rate_func = linear , ), Rotate ( Square ( side_length = 0.5 ), angle = 2 * PI , rate_func = linear ), ) class UsingRotate(Scene):\n    def construct(self):\n        self.play(\n            Rotate(\n                Square(side_length=0.5).shift(UP * 2),\n                angle=2*PI,\n                about_point=ORIGIN,\n                rate_func=linear,\n            ),\n            Rotate(Square(side_length=0.5), angle=2*PI, rate_func=linear),\n            ) Methods create_target Attributes path_arc path_func run_time _original__init__ ( mobject , angle = 3.141592653589793 , axis = array([0., 0., 1.]) , about_point = None , about_edge = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) angle ( float ) axis ( np.ndarray ) about_point ( Sequence [ float ] | None ) about_edge ( Sequence [ float ] | None ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.rotation.Rotate.html"}
{"prompt": "class Rotating(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Animation Methods interpolate_mobject Interpolates the mobject of the Animation based on alpha value. Attributes run_time Parameters : mobject ( Mobject ) axis ( np.ndarray ) radians ( np.ndarray ) about_point ( np.ndarray | None ) about_edge ( np.ndarray | None ) run_time ( float ) rate_func ( Callable [ [ float ] , float ] ) _original__init__ ( mobject , axis=array([0. , 0. , 1.]) , radians=6.283185307179586 , about_point=None , about_edge=None , run_time=5 , rate_func=<function linear> , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) axis ( np.ndarray ) radians ( np.ndarray ) about_point ( np.ndarray | None ) about_edge ( np.ndarray | None ) run_time ( float ) rate_func ( Callable [ [ float ] , float ] ) Return type : None interpolate_mobject ( alpha ) [source]   Interpolates the mobject of the Animation based on alpha value. Parameters : alpha ( float ) \u2013 A float between 0 and 1 expressing the ratio to which the animation\nis completed. For example, alpha-values of 0, 0.5, and 1 correspond\nto the animation being completed 0%, 50%, and 100%, respectively. Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.rotation.Rotating.html"}
{"prompt": "class Broadcast(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: LaggedStart Broadcast a mobject starting from an initial_width , up to the actual size of the mobject. Parameters : mobject \u2013 The mobject to be broadcast. focal_point ( Sequence [ float ] ) \u2013 The center of the broadcast, by default ORIGIN. n_mobs ( int ) \u2013 The number of mobjects that emerge from the focal point, by default 5. initial_opacity ( float ) \u2013 The starting stroke opacity of the mobjects emitted from the broadcast, by default 1. final_opacity ( float ) \u2013 The final stroke opacity of the mobjects emitted from the broadcast, by default 0. initial_width ( float ) \u2013 The initial width of the mobjects, by default 0.0. remover ( bool ) \u2013 Whether the mobjects should be removed from the scene after the animation, by default True. lag_ratio ( float ) \u2013 The time between each iteration of the mobject, by default 0.2. run_time ( float ) \u2013 The total duration of the animation, by default 3. kwargs ( Any ) \u2013 Additional arguments to be passed to LaggedStart . Examples Example: BroadcastExample   from manim import * class BroadcastExample ( Scene ): def construct ( self ): mob = Circle ( radius = 4 , color = TEAL_A ) self . play ( Broadcast ( mob )) class BroadcastExample(Scene):\n    def construct(self):\n        mob = Circle(radius=4, color=TEAL_A)\n        self.play(Broadcast(mob)) Methods Attributes run_time _original__init__ ( mobject , focal_point = array([0., 0., 0.]) , n_mobs = 5 , initial_opacity = 1 , final_opacity = 0 , initial_width = 0.0 , remover = True , lag_ratio = 0.2 , run_time = 3 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : focal_point ( Sequence [ float ] ) n_mobs ( int ) initial_opacity ( float ) final_opacity ( float ) initial_width ( float ) remover ( bool ) lag_ratio ( float ) run_time ( float ) kwargs ( Any )", "source": "https://docs.manim.community/en/stable/reference/manim.animation.specialized.Broadcast.html"}
{"prompt": "class ChangeSpeed(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Animation Modifies the speed of passed animation. AnimationGroup with different lag_ratio can also be used\nwhich combines multiple animations into one.\nThe run_time of the passed animation is changed to modify the speed. Parameters : anim ( Animation | _AnimationBuilder ) \u2013 Animation of which the speed is to be modified. speedinfo ( dict [ float , float ] ) \u2013 Contains nodes (percentage of run_time ) and its corresponding speed factor. rate_func ( Callable [ [ float ] , float ] | None ) \u2013 Overrides rate_func of passed animation, applied before changing speed. affects_speed_updaters ( bool ) Examples Example: SpeedModifierExample   from manim import * class SpeedModifierExample ( Scene ): def construct ( self ): a = Dot () . shift ( LEFT * 4 ) b = Dot () . shift ( RIGHT * 4 ) self . add ( a , b ) self . play ( ChangeSpeed ( AnimationGroup ( a . animate ( run_time = 1 ) . shift ( RIGHT * 8 ), b . animate ( run_time = 1 ) . shift ( LEFT * 8 ), ), speedinfo = { 0.3 : 1 , 0.4 : 0.1 , 0.6 : 0.1 , 1 : 1 }, rate_func = linear , ) ) class SpeedModifierExample(Scene):\n    def construct(self):\n        a = Dot().shift(LEFT * 4)\n        b = Dot().shift(RIGHT * 4)\n        self.add(a, b)\n        self.play(\n            ChangeSpeed(\n                AnimationGroup(\n                    a.animate(run_time=1).shift(RIGHT * 8),\n                    b.animate(run_time=1).shift(LEFT * 8),\n                ),\n                speedinfo={0.3: 1, 0.4: 0.1, 0.6: 0.1, 1: 1},\n                rate_func=linear,\n            )\n        ) Example: SpeedModifierUpdaterExample   from manim import * class SpeedModifierUpdaterExample ( Scene ): def construct ( self ): a = Dot () . shift ( LEFT * 4 ) self . add ( a ) ChangeSpeed . add_updater ( a , lambda x , dt : x . shift ( RIGHT * 4 * dt )) self . play ( ChangeSpeed ( Wait ( 2 ), speedinfo = { 0.4 : 1 , 0.5 : 0.2 , 0.8 : 0.2 , 1 : 1 }, affects_speed_updaters = True , ) ) class SpeedModifierUpdaterExample(Scene):\n    def construct(self):\n        a = Dot().shift(LEFT * 4)\n        self.add(a)\n\n        ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))\n        self.play(\n            ChangeSpeed(\n                Wait(2),\n                speedinfo={0.4: 1, 0.5: 0.2, 0.8: 0.2, 1: 1},\n                affects_speed_updaters=True,\n            )\n        ) Example: SpeedModifierUpdaterExample2   from manim import * class SpeedModifierUpdaterExample2 ( Scene ): def construct ( self ): a = Dot () . shift ( LEFT * 4 ) self . add ( a ) ChangeSpeed . add_updater ( a , lambda x , dt : x . shift ( RIGHT * 4 * dt )) self . wait () self . play ( ChangeSpeed ( Wait (), speedinfo = { 1 : 0 }, affects_speed_updaters = True , ) ) class SpeedModifierUpdaterExample2(Scene):\n    def construct(self):\n        a = Dot().shift(LEFT * 4)\n        self.add(a)\n\n        ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))\n        self.wait()\n        self.play(\n            ChangeSpeed(\n                Wait(),\n                speedinfo={1: 0},\n                affects_speed_updaters=True,\n            )\n        ) Methods add_updater This static method can be used to apply speed change to updaters. begin Begin the animation. clean_up_from_scene Clean up the Scene after finishing the animation. finish Finish the animation. get_scaled_total_time The time taken by the animation under the assumption that the run_time is 1. interpolate Set the animation progress. setup update_mobjects Updates things like starting_mobject, and (for Transforms) target_mobject. Attributes dt is_changing_dt run_time _original__init__ ( anim , speedinfo , rate_func = None , affects_speed_updaters = True , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : anim ( Animation | _AnimationBuilder ) speedinfo ( dict [ float , float ] ) rate_func ( Callable [ [ float ] , float ] | None ) affects_speed_updaters ( bool ) Return type : None _setup_scene ( scene ) [source]   Setup up the Scene before starting the animation. This includes to add() the Animation\u2019s Mobject if the animation is an introducer. Parameters : scene \u2013 The scene the animation should be cleaned up from. Return type : None classmethod add_updater ( mobject , update_function , index = None , call_updater = False ) [source]   This static method can be used to apply speed change to updaters. This updater will follow speed and rate function of any ChangeSpeed animation that is playing with affects_speed_updaters=True . By default,\nupdater functions added via the usual Mobject.add_updater() method\ndo not respect the change of animation speed. Parameters : mobject ( Mobject ) \u2013 The mobject to which the updater should be attached. update_function ( Updater ) \u2013 The function that is called whenever a new frame is rendered. index ( int | None ) \u2013 The position in the list of the mobject\u2019s updaters at which the\nfunction should be inserted. call_updater ( bool ) \u2013 If True , calls the update function when attaching it to the\nmobject. See also ChangeSpeed , Mobject.add_updater() begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None finish ( ) [source]   Finish the animation. This method gets called when the animation is over. Return type : None get_scaled_total_time ( ) [source]   The time taken by the animation under the assumption that the run_time is 1. Return type : float interpolate ( alpha ) [source]   Set the animation progress. This method gets called for every frame during an animation. Parameters : alpha ( float ) \u2013 The relative time to set the animation to, 0 meaning the start, 1 meaning\nthe end. Return type : None update_mobjects ( dt ) [source]   Updates things like starting_mobject, and (for\nTransforms) target_mobject.  Note, since typically\n(always?) self.mobject will have its updating\nsuspended during the animation, this will do\nnothing to self.mobject. Parameters : dt ( float ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.speedmodifier.ChangeSpeed.html"}
{"prompt": "class ApplyComplexFunction(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: ApplyMethod Methods Attributes path_arc path_func run_time Parameters : function ( types.MethodType ) mobject ( Mobject ) _original__init__ ( function , mobject , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : function ( MethodType ) mobject ( Mobject ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ApplyComplexFunction.html"}
{"prompt": "class ApplyFunction(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Transform Methods create_target Attributes path_arc path_func run_time Parameters : function ( types.MethodType ) mobject ( Mobject ) _original__init__ ( function , mobject , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : function ( MethodType ) mobject ( Mobject ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ApplyFunction.html"}
{"prompt": "class ApplyMatrix(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: ApplyPointwiseFunction Applies a matrix transform to an mobject. Parameters : matrix ( np.ndarray ) \u2013 The transformation matrix. mobject ( Mobject ) \u2013 The Mobject . about_point ( np.ndarray ) \u2013 The origin point for the transform. Defaults to ORIGIN . kwargs \u2013 Further keyword arguments that are passed to ApplyPointwiseFunction . Examples Example: ApplyMatrixExample   from manim import * class ApplyMatrixExample ( Scene ): def construct ( self ): matrix = [[ 1 , 1 ], [ 0 , 2 / 3 ]] self . play ( ApplyMatrix ( matrix , Text ( \"Hello World!\" )), ApplyMatrix ( matrix , NumberPlane ())) class ApplyMatrixExample(Scene):\n    def construct(self):\n        matrix = [[1, 1], [0, 2/3]]\n        self.play(ApplyMatrix(matrix, Text(\"Hello World!\")), ApplyMatrix(matrix, NumberPlane())) Methods initialize_matrix Attributes path_arc path_func run_time _original__init__ ( matrix , mobject , about_point = array([0., 0., 0.]) , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : matrix ( ndarray ) mobject ( Mobject ) about_point ( ndarray ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ApplyMatrix.html"}
{"prompt": "class ApplyMethod(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Transform Animates a mobject by applying a method. Note that only the method needs to be passed to this animation,\nit is not required to pass the corresponding mobject. Furthermore,\nthis animation class only works if the method returns the modified\nmobject. Parameters : method ( Callable ) \u2013 The method that will be applied in the animation. args \u2013 Any positional arguments to be passed when applying the method. kwargs \u2013 Any keyword arguments passed to Transform . Methods check_validity_of_input create_target Attributes path_arc path_func run_time _original__init__ ( method , * args , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : method ( Callable ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ApplyMethod.html"}
{"prompt": "class ApplyPointwiseFunction(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: ApplyMethod Animation that applies a pointwise function to a mobject. Examples Example: WarpSquare   from manim import * class WarpSquare ( Scene ): def construct ( self ): square = Square () self . play ( ApplyPointwiseFunction ( lambda point : complex_to_R3 ( np . exp ( R3_to_complex ( point ))), square ) ) self . wait () class WarpSquare(Scene):\n    def construct(self):\n        square = Square()\n        self.play(\n            ApplyPointwiseFunction(\n                lambda point: complex_to_R3(np.exp(R3_to_complex(point))), square\n            )\n        )\n        self.wait() Methods Attributes path_arc path_func run_time Parameters : function ( types.MethodType ) mobject ( Mobject ) run_time ( float ) _original__init__ ( function , mobject , run_time = 3.0 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : function ( MethodType ) mobject ( Mobject ) run_time ( float ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ApplyPointwiseFunction.html"}
{"prompt": "class ApplyPointwiseFunctionToCenter(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: ApplyPointwiseFunction Methods begin Begin the animation. Attributes path_arc path_func run_time Parameters : function ( types.MethodType ) mobject ( Mobject ) _original__init__ ( function , mobject , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : function ( MethodType ) mobject ( Mobject ) Return type : None begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ApplyPointwiseFunctionToCenter.html"}
{"prompt": "class ClockwiseTransform(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Transform Transforms the points of a mobject along a clockwise oriented arc. See also Transform , CounterclockwiseTransform Examples Example: ClockwiseExample   from manim import * class ClockwiseExample ( Scene ): def construct ( self ): dl , dr = Dot (), Dot () sl , sr = Square (), Square () VGroup ( dl , sl ) . arrange ( DOWN ) . shift ( 2 * LEFT ) VGroup ( dr , sr ) . arrange ( DOWN ) . shift ( 2 * RIGHT ) self . add ( dl , dr ) self . wait () self . play ( ClockwiseTransform ( dl , sl ), Transform ( dr , sr ) ) self . wait () class ClockwiseExample(Scene):\n    def construct(self):\n        dl, dr = Dot(), Dot()\n        sl, sr = Square(), Square()\n\n        VGroup(dl, sl).arrange(DOWN).shift(2*LEFT)\n        VGroup(dr, sr).arrange(DOWN).shift(2*RIGHT)\n\n        self.add(dl, dr)\n        self.wait()\n        self.play(\n            ClockwiseTransform(dl, sl),\n            Transform(dr, sr)\n        )\n        self.wait() Methods Attributes path_arc path_func run_time Parameters : mobject ( Mobject ) target_mobject ( Mobject ) path_arc ( float ) _original__init__ ( mobject , target_mobject , path_arc = -3.141592653589793 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) target_mobject ( Mobject ) path_arc ( float ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ClockwiseTransform.html"}
{"prompt": "class CounterclockwiseTransform(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Transform Transforms the points of a mobject along a counterclockwise oriented arc. See also Transform , ClockwiseTransform Examples Example: CounterclockwiseTransform_vs_Transform   from manim import * class CounterclockwiseTransform_vs_Transform ( Scene ): def construct ( self ): # set up the numbers c_transform = VGroup ( DecimalNumber ( number = 3.141 , num_decimal_places = 3 ), DecimalNumber ( number = 1.618 , num_decimal_places = 3 )) text_1 = Text ( \"CounterclockwiseTransform\" , color = RED ) c_transform . add ( text_1 ) transform = VGroup ( DecimalNumber ( number = 1.618 , num_decimal_places = 3 ), DecimalNumber ( number = 3.141 , num_decimal_places = 3 )) text_2 = Text ( \"Transform\" , color = BLUE ) transform . add ( text_2 ) ints = VGroup ( c_transform , transform ) texts = VGroup ( text_1 , text_2 ) . scale ( 0.75 ) c_transform . arrange ( direction = UP , buff = 1 ) transform . arrange ( direction = UP , buff = 1 ) ints . arrange ( buff = 2 ) self . add ( ints , texts ) # The mobs move in clockwise direction for ClockwiseTransform() self . play ( CounterclockwiseTransform ( c_transform [ 0 ], c_transform [ 1 ])) # The mobs move straight up for Transform() self . play ( Transform ( transform [ 0 ], transform [ 1 ])) class CounterclockwiseTransform_vs_Transform(Scene):\n    def construct(self):\n        # set up the numbers\n        c_transform = VGroup(DecimalNumber(number=3.141, num_decimal_places=3), DecimalNumber(number=1.618, num_decimal_places=3))\n        text_1 = Text(\"CounterclockwiseTransform\", color=RED)\n        c_transform.add(text_1)\n\n        transform = VGroup(DecimalNumber(number=1.618, num_decimal_places=3), DecimalNumber(number=3.141, num_decimal_places=3))\n        text_2 = Text(\"Transform\", color=BLUE)\n        transform.add(text_2)\n\n        ints = VGroup(c_transform, transform)\n        texts = VGroup(text_1, text_2).scale(0.75)\n        c_transform.arrange(direction=UP, buff=1)\n        transform.arrange(direction=UP, buff=1)\n\n        ints.arrange(buff=2)\n        self.add(ints, texts)\n\n        # The mobs move in clockwise direction for ClockwiseTransform()\n        self.play(CounterclockwiseTransform(c_transform[0], c_transform[1]))\n\n        # The mobs move straight up for Transform()\n        self.play(Transform(transform[0], transform[1])) Methods Attributes path_arc path_func run_time Parameters : mobject ( Mobject ) target_mobject ( Mobject ) path_arc ( float ) _original__init__ ( mobject , target_mobject , path_arc = 3.141592653589793 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) target_mobject ( Mobject ) path_arc ( float ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.CounterclockwiseTransform.html"}
{"prompt": "class CyclicReplace(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Transform An animation moving mobjects cyclically. In particular, this means: the first mobject takes the place\nof the second mobject, the second one takes the place of\nthe third mobject, and so on. The last mobject takes the\nplace of the first one. Parameters : mobjects ( Mobject ) \u2013 List of mobjects to be transformed. path_arc ( float ) \u2013 The angle of the arc (in radians) that the mobjects will follow to reach\ntheir target. kwargs \u2013 Further keyword arguments that are passed to Transform . Examples Example: CyclicReplaceExample   from manim import * class CyclicReplaceExample ( Scene ): def construct ( self ): group = VGroup ( Square (), Circle (), Triangle (), Star ()) group . arrange ( RIGHT ) self . add ( group ) for _ in range ( 4 ): self . play ( CyclicReplace ( * group )) class CyclicReplaceExample(Scene):\n    def construct(self):\n        group = VGroup(Square(), Circle(), Triangle(), Star())\n        group.arrange(RIGHT)\n        self.add(group)\n\n        for _ in range(4):\n            self.play(CyclicReplace(*group)) Methods create_target Attributes path_arc path_func run_time _original__init__ ( * mobjects , path_arc = 1.5707963267948966 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobjects ( Mobject ) path_arc ( float ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.CyclicReplace.html"}
{"prompt": "class FadeToColor(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: ApplyMethod Animation that changes color of a mobject. Examples Example: FadeToColorExample   from manim import * class FadeToColorExample ( Scene ): def construct ( self ): self . play ( FadeToColor ( Text ( \"Hello World!\" ), color = RED )) class FadeToColorExample(Scene):\n    def construct(self):\n        self.play(FadeToColor(Text(\"Hello World!\"), color=RED)) Methods Attributes path_arc path_func run_time Parameters : mobject ( Mobject ) color ( str ) _original__init__ ( mobject , color , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) color ( str ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.FadeToColor.html"}
{"prompt": "class FadeTransform(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Transform Fades one mobject into another. Parameters : mobject \u2013 The starting Mobject . target_mobject \u2013 The target Mobject . stretch \u2013 Controls whether the target Mobject is stretched during\nthe animation. Default: True . dim_to_match \u2013 If the target mobject is not stretched automatically, this allows\nto adjust the initial scale of the target Mobject while\nit is shifted in. Setting this to 0, 1, and 2, respectively,\nmatches the length of the target with the length of the starting Mobject in x, y, and z direction, respectively. kwargs \u2013 Further keyword arguments are passed to the parent class. Examples Example: DifferentFadeTransforms   from manim import * class DifferentFadeTransforms ( Scene ): def construct ( self ): starts = [ Rectangle ( width = 4 , height = 1 ) for _ in range ( 3 )] VGroup ( * starts ) . arrange ( DOWN , buff = 1 ) . shift ( 3 * LEFT ) targets = [ Circle ( fill_opacity = 1 ) . scale ( 0.25 ) for _ in range ( 3 )] VGroup ( * targets ) . arrange ( DOWN , buff = 1 ) . shift ( 3 * RIGHT ) self . play ( * [ FadeIn ( s ) for s in starts ]) self . play ( FadeTransform ( starts [ 0 ], targets [ 0 ], stretch = True ), FadeTransform ( starts [ 1 ], targets [ 1 ], stretch = False , dim_to_match = 0 ), FadeTransform ( starts [ 2 ], targets [ 2 ], stretch = False , dim_to_match = 1 ) ) self . play ( * [ FadeOut ( mobj ) for mobj in self . mobjects ]) class DifferentFadeTransforms(Scene):\n    def construct(self):\n        starts = [Rectangle(width=4, height=1) for _ in range(3)]\n        VGroup(*starts).arrange(DOWN, buff=1).shift(3*LEFT)\n        targets = [Circle(fill_opacity=1).scale(0.25) for _ in range(3)]\n        VGroup(*targets).arrange(DOWN, buff=1).shift(3*RIGHT)\n\n        self.play(*[FadeIn(s) for s in starts])\n        self.play(\n            FadeTransform(starts[0], targets[0], stretch=True),\n            FadeTransform(starts[1], targets[1], stretch=False, dim_to_match=0),\n            FadeTransform(starts[2], targets[2], stretch=False, dim_to_match=1)\n        )\n\n        self.play(*[FadeOut(mobj) for mobj in self.mobjects]) Methods begin Initial setup for the animation. clean_up_from_scene Clean up the Scene after finishing the animation. get_all_families_zipped get_all_mobjects Get all mobjects involved in the animation. ghost_to Replaces the source by the target and sets the opacity to 0. Attributes path_arc path_func run_time _original__init__ ( mobject , target_mobject , stretch = True , dim_to_match = 1 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. begin ( ) [source]   Initial setup for the animation. The mobject to which this animation is bound is a group consisting of\nboth the starting and the ending mobject. At the start, the ending\nmobject replaces the starting mobject (and is completely faded). In the\nend, it is set to be the other way around. clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene \u2013 The scene the animation should be cleaned up from. get_all_mobjects ( ) [source]   Get all mobjects involved in the animation. Ordering must match the ordering of arguments to interpolate_submobject Returns : The sequence of mobjects. Return type : Sequence[ Mobject ] ghost_to ( source , target ) [source]   Replaces the source by the target and sets the opacity to 0. If the provided target has no points, and thus a location of [0, 0, 0]\nthe source will simply fade out where it currently is.", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.FadeTransform.html"}
{"prompt": "class FadeTransformPieces(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: FadeTransform Fades submobjects of one mobject into submobjects of another one. See also FadeTransform Examples Example: FadeTransformSubmobjects   from manim import * class FadeTransformSubmobjects ( Scene ): def construct ( self ): src = VGroup ( Square (), Circle () . shift ( LEFT + UP )) src . shift ( 3 * LEFT + 2 * UP ) src_copy = src . copy () . shift ( 4 * DOWN ) target = VGroup ( Circle (), Triangle () . shift ( RIGHT + DOWN )) target . shift ( 3 * RIGHT + 2 * UP ) target_copy = target . copy () . shift ( 4 * DOWN ) self . play ( FadeIn ( src ), FadeIn ( src_copy )) self . play ( FadeTransform ( src , target ), FadeTransformPieces ( src_copy , target_copy ) ) self . play ( * [ FadeOut ( mobj ) for mobj in self . mobjects ]) class FadeTransformSubmobjects(Scene):\n    def construct(self):\n        src = VGroup(Square(), Circle().shift(LEFT + UP))\n        src.shift(3*LEFT + 2*UP)\n        src_copy = src.copy().shift(4*DOWN)\n\n        target = VGroup(Circle(), Triangle().shift(RIGHT + DOWN))\n        target.shift(3*RIGHT + 2*UP)\n        target_copy = target.copy().shift(4*DOWN)\n\n        self.play(FadeIn(src), FadeIn(src_copy))\n        self.play(\n            FadeTransform(src, target),\n            FadeTransformPieces(src_copy, target_copy)\n        )\n        self.play(*[FadeOut(mobj) for mobj in self.mobjects]) Methods begin Initial setup for the animation. ghost_to Replaces the source submobjects by the target submobjects and sets the opacity to 0. Attributes path_arc path_func run_time _original__init__ ( mobject , target_mobject , stretch = True , dim_to_match = 1 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. begin ( ) [source]   Initial setup for the animation. The mobject to which this animation is bound is a group consisting of\nboth the starting and the ending mobject. At the start, the ending\nmobject replaces the starting mobject (and is completely faded). In the\nend, it is set to be the other way around. ghost_to ( source , target ) [source]   Replaces the source submobjects by the target submobjects and sets\nthe opacity to 0.", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.FadeTransformPieces.html"}
{"prompt": "class MoveToTarget(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Transform Transforms a mobject to the mobject stored in its target attribute. After calling the generate_target() method, the target attribute of the mobject is populated with a copy of it. After modifying the attribute,\nplaying the MoveToTarget animation transforms the original mobject\ninto the modified one stored in the target attribute. Examples Example: MoveToTargetExample   from manim import * class MoveToTargetExample ( Scene ): def construct ( self ): c = Circle () c . generate_target () c . target . set_fill ( color = GREEN , opacity = 0.5 ) c . target . shift ( 2 * RIGHT + UP ) . scale ( 0.5 ) self . add ( c ) self . play ( MoveToTarget ( c )) class MoveToTargetExample(Scene):\n    def construct(self):\n        c = Circle()\n\n        c.generate_target()\n        c.target.set_fill(color=GREEN, opacity=0.5)\n        c.target.shift(2*RIGHT + UP).scale(0.5)\n\n        self.add(c)\n        self.play(MoveToTarget(c)) Methods check_validity_of_input Attributes path_arc path_func run_time Parameters : mobject ( Mobject ) _original__init__ ( mobject , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.MoveToTarget.html"}
{"prompt": "class ReplacementTransform(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Transform Replaces and morphs a mobject into a target mobject. Parameters : mobject ( Mobject ) \u2013 The starting Mobject . target_mobject ( Mobject ) \u2013 The target Mobject . kwargs \u2013 Further keyword arguments that are passed to Transform . Examples Example: ReplacementTransformOrTransform   from manim import * class ReplacementTransformOrTransform ( Scene ): def construct ( self ): # set up the numbers r_transform = VGroup ( * [ Integer ( i ) for i in range ( 1 , 4 )]) text_1 = Text ( \"ReplacementTransform\" , color = RED ) r_transform . add ( text_1 ) transform = VGroup ( * [ Integer ( i ) for i in range ( 4 , 7 )]) text_2 = Text ( \"Transform\" , color = BLUE ) transform . add ( text_2 ) ints = VGroup ( r_transform , transform ) texts = VGroup ( text_1 , text_2 ) . scale ( 0.75 ) r_transform . arrange ( direction = UP , buff = 1 ) transform . arrange ( direction = UP , buff = 1 ) ints . arrange ( buff = 2 ) self . add ( ints , texts ) # The mobs replace each other and none are left behind self . play ( ReplacementTransform ( r_transform [ 0 ], r_transform [ 1 ])) self . play ( ReplacementTransform ( r_transform [ 1 ], r_transform [ 2 ])) # The mobs linger after the Transform() self . play ( Transform ( transform [ 0 ], transform [ 1 ])) self . play ( Transform ( transform [ 1 ], transform [ 2 ])) self . wait () class ReplacementTransformOrTransform(Scene):\n    def construct(self):\n        # set up the numbers\n        r_transform = VGroup(*[Integer(i) for i in range(1,4)])\n        text_1 = Text(\"ReplacementTransform\", color=RED)\n        r_transform.add(text_1)\n\n        transform = VGroup(*[Integer(i) for i in range(4,7)])\n        text_2 = Text(\"Transform\", color=BLUE)\n        transform.add(text_2)\n\n        ints = VGroup(r_transform, transform)\n        texts = VGroup(text_1, text_2).scale(0.75)\n        r_transform.arrange(direction=UP, buff=1)\n        transform.arrange(direction=UP, buff=1)\n\n        ints.arrange(buff=2)\n        self.add(ints, texts)\n\n        # The mobs replace each other and none are left behind\n        self.play(ReplacementTransform(r_transform[0], r_transform[1]))\n        self.play(ReplacementTransform(r_transform[1], r_transform[2]))\n\n        # The mobs linger after the Transform()\n        self.play(Transform(transform[0], transform[1]))\n        self.play(Transform(transform[1], transform[2]))\n        self.wait() Methods Attributes path_arc path_func run_time _original__init__ ( mobject , target_mobject , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) target_mobject ( Mobject ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ReplacementTransform.html"}
{"prompt": "class Restore(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: ApplyMethod Transforms a mobject to its last saved state. To save the state of a mobject, use the save_state() method. Examples Example: RestoreExample   from manim import * class RestoreExample ( Scene ): def construct ( self ): s = Square () s . save_state () self . play ( FadeIn ( s )) self . play ( s . animate . set_color ( PURPLE ) . set_opacity ( 0.5 ) . shift ( 2 * LEFT ) . scale ( 3 )) self . play ( s . animate . shift ( 5 * DOWN ) . rotate ( PI / 4 )) self . wait () self . play ( Restore ( s ), run_time = 2 ) class RestoreExample(Scene):\n    def construct(self):\n        s = Square()\n        s.save_state()\n        self.play(FadeIn(s))\n        self.play(s.animate.set_color(PURPLE).set_opacity(0.5).shift(2*LEFT).scale(3))\n        self.play(s.animate.shift(5*DOWN).rotate(PI/4))\n        self.wait()\n        self.play(Restore(s), run_time=2) Methods Attributes path_arc path_func run_time Parameters : mobject ( Mobject ) _original__init__ ( mobject , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.Restore.html"}
{"prompt": "class ScaleInPlace(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: ApplyMethod Animation that scales a mobject by a certain factor. Examples Example: ScaleInPlaceExample   from manim import * class ScaleInPlaceExample ( Scene ): def construct ( self ): self . play ( ScaleInPlace ( Text ( \"Hello World!\" ), 2 )) class ScaleInPlaceExample(Scene):\n    def construct(self):\n        self.play(ScaleInPlace(Text(\"Hello World!\"), 2)) Methods Attributes path_arc path_func run_time Parameters : mobject ( Mobject ) scale_factor ( float ) _original__init__ ( mobject , scale_factor , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) scale_factor ( float ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ScaleInPlace.html"}
{"prompt": "class ShrinkToCenter(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: ScaleInPlace Animation that makes a mobject shrink to center. Examples Example: ShrinkToCenterExample   from manim import * class ShrinkToCenterExample ( Scene ): def construct ( self ): self . play ( ShrinkToCenter ( Text ( \"Hello World!\" ))) class ShrinkToCenterExample(Scene):\n    def construct(self):\n        self.play(ShrinkToCenter(Text(\"Hello World!\"))) Methods Attributes path_arc path_func run_time Parameters : mobject ( Mobject ) _original__init__ ( mobject , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ShrinkToCenter.html"}
{"prompt": "class Swap(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: CyclicReplace Methods Attributes path_arc path_func run_time Parameters : mobjects ( Mobject ) path_arc ( float ) _original__init__ ( * mobjects , path_arc = 1.5707963267948966 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobjects ( Mobject ) path_arc ( float ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.Swap.html"}
{"prompt": "class Transform(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Animation A Transform transforms a Mobject into a target Mobject. Parameters : mobject ( Mobject | None ) \u2013 The Mobject to be transformed. It will be mutated to become the target_mobject . target_mobject ( Mobject | None ) \u2013 The target of the transformation. path_func ( Callable | None ) \u2013 A function defining the path that the points of the mobject are being moved\nalong until they match the points of the target_mobject , see utils.paths . path_arc ( float ) \u2013 The arc angle (in radians) that the points of mobject will follow to reach\nthe points of the target if using a circular path arc, see path_arc_centers .\nSee also manim.utils.paths.path_along_arc() . path_arc_axis ( np.ndarray ) \u2013 The axis to rotate along if using a circular path arc, see path_arc_centers . path_arc_centers ( np.ndarray ) \u2013 The center of the circular arcs along which the points of mobject are\nmoved by the transformation. If this is set and path_func is not set, then a path_along_circles path will be generated\nusing the path_arc parameters and stored in path_func . If path_func is set, this and the\nother path_arc fields are set as attributes, but a path_func is not generated from it. replace_mobject_with_target_in_scene ( bool ) \u2013 Controls which mobject is replaced when the transformation is complete. If set to True, mobject will be removed from the scene and target_mobject will\nreplace it. Otherwise, target_mobject is never added and mobject just takes its shape. Examples Example: TransformPathArc   from manim import * class TransformPathArc ( Scene ): def construct ( self ): def make_arc_path ( start , end , arc_angle ): points = [] p_fn = path_along_arc ( arc_angle ) # alpha animates between 0.0 and 1.0, where 0.0 # is the beginning of the animation and 1.0 is the end. for alpha in range ( 0 , 11 ): points . append ( p_fn ( start , end , alpha / 10.0 )) path = VMobject ( stroke_color = YELLOW ) path . set_points_smoothly ( points ) return path left = Circle ( stroke_color = BLUE_E , fill_opacity = 1.0 , radius = 0.5 ) . move_to ( LEFT * 2 ) colors = [ TEAL_A , TEAL_B , TEAL_C , TEAL_D , TEAL_E , GREEN_A ] # Positive angles move counter-clockwise, negative angles move clockwise. examples = [ - 90 , 0 , 30 , 90 , 180 , 270 ] anims = [] for idx , angle in enumerate ( examples ): left_c = left . copy () . shift (( 3 - idx ) * UP ) left_c . fill_color = colors [ idx ] right_c = left_c . copy () . shift ( 4 * RIGHT ) path_arc = make_arc_path ( left_c . get_center (), right_c . get_center (), arc_angle = angle * DEGREES ) desc = Text ( ' %d \u00b0' % examples [ idx ]) . next_to ( left_c , LEFT ) # Make the circles in front of the text in front of the arcs. self . add ( path_arc . set_z_index ( 1 ), desc . set_z_index ( 2 ), left_c . set_z_index ( 3 ), ) anims . append ( Transform ( left_c , right_c , path_arc = angle * DEGREES )) self . play ( * anims , run_time = 2 ) self . wait () class TransformPathArc(Scene):\n    def construct(self):\n        def make_arc_path(start, end, arc_angle):\n            points = []\n            p_fn = path_along_arc(arc_angle)\n            # alpha animates between 0.0 and 1.0, where 0.0\n            # is the beginning of the animation and 1.0 is the end.\n            for alpha in range(0, 11):\n                points.append(p_fn(start, end, alpha / 10.0))\n            path = VMobject(stroke_color=YELLOW)\n            path.set_points_smoothly(points)\n            return path\n\n        left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)\n        colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]\n        # Positive angles move counter-clockwise, negative angles move clockwise.\n        examples = [-90, 0, 30, 90, 180, 270]\n        anims = []\n        for idx, angle in enumerate(examples):\n            left_c = left.copy().shift((3 - idx) * UP)\n            left_c.fill_color = colors[idx]\n            right_c = left_c.copy().shift(4 * RIGHT)\n            path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),\n                                     arc_angle=angle * DEGREES)\n            desc = Text('%d\u00b0' % examples[idx]).next_to(left_c, LEFT)\n            # Make the circles in front of the text in front of the arcs.\n            self.add(\n                path_arc.set_z_index(1),\n                desc.set_z_index(2),\n                left_c.set_z_index(3),\n            )\n            anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))\n\n        self.play(*anims, run_time=2)\n        self.wait() Methods begin Begin the animation. clean_up_from_scene Clean up the Scene after finishing the animation. create_target get_all_families_zipped get_all_mobjects Get all mobjects involved in the animation. interpolate_submobject Attributes path_arc path_func run_time _original__init__ ( mobject , target_mobject = None , path_func = None , path_arc = 0 , path_arc_axis = array([0., 0., 1.]) , path_arc_centers = None , replace_mobject_with_target_in_scene = False , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject | None ) target_mobject ( Mobject | None ) path_func ( Callable | None ) path_arc ( float ) path_arc_axis ( ndarray ) path_arc_centers ( ndarray ) replace_mobject_with_target_in_scene ( bool ) Return type : None begin ( ) [source]   Begin the animation. This method is called right as an animation is being played. As much\ninitialization as possible, especially any mobject copying, should live in this\nmethod. Return type : None clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None get_all_mobjects ( ) [source]   Get all mobjects involved in the animation. Ordering must match the ordering of arguments to interpolate_submobject Returns : The sequence of mobjects. Return type : Sequence[ Mobject ]", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.Transform.html"}
{"prompt": "class TransformAnimations(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Transform Methods interpolate Set the animation progress. Attributes path_arc path_func run_time Parameters : start_anim ( Animation ) end_anim ( Animation ) rate_func ( Callable ) _original__init__ ( start_anim , end_anim , rate_func=<function squish_rate_func.<locals>.result> , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : start_anim ( Animation ) end_anim ( Animation ) rate_func ( Callable ) Return type : None interpolate ( alpha ) [source]   Set the animation progress. This method gets called for every frame during an animation. Parameters : alpha ( float ) \u2013 The relative time to set the animation to, 0 meaning the start, 1 meaning\nthe end. Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.TransformAnimations.html"}
{"prompt": "class TransformFromCopy(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: Transform Performs a reversed Transform Methods interpolate Set the animation progress. Attributes path_arc path_func run_time Parameters : mobject ( Mobject ) target_mobject ( Mobject ) _original__init__ ( mobject , target_mobject , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) target_mobject ( Mobject ) Return type : None interpolate ( alpha ) [source]   Set the animation progress. This method gets called for every frame during an animation. Parameters : alpha ( float ) \u2013 The relative time to set the animation to, 0 meaning the start, 1 meaning\nthe end. Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform.TransformFromCopy.html"}
{"prompt": "class TransformMatchingAbstractBase(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: AnimationGroup Abstract base class for transformations that keep track of matching parts. Subclasses have to implement the two static methods get_mobject_parts() and get_mobject_key() . Basically, this transformation first maps all submobjects returned\nby the get_mobject_parts method to certain keys by applying the get_mobject_key method. Then, submobjects with matching keys\nare transformed into each other. Parameters : mobject ( Mobject ) \u2013 The starting Mobject . target_mobject ( Mobject ) \u2013 The target Mobject . transform_mismatches ( bool ) \u2013 Controls whether submobjects without a matching key are transformed\ninto each other by using Transform . Default: False . fade_transform_mismatches ( bool ) \u2013 Controls whether submobjects without a matching key are transformed\ninto each other by using FadeTransform . Default: False . key_map ( dict | None ) \u2013 Optional. A dictionary mapping keys belonging to some of the starting mobject\u2019s\nsubmobjects (i.e., the return values of the get_mobject_key method)\nto some keys belonging to the target mobject\u2019s submobjects that should\nbe transformed although the keys don\u2019t match. kwargs \u2013 All further keyword arguments are passed to the submobject transformations. Note If neither transform_mismatches nor fade_transform_mismatches are set to True , submobjects without matching keys in the starting\nmobject are faded out in the direction of the unmatched submobjects in\nthe target mobject, and unmatched submobjects in the target mobject\nare faded in from the direction of the unmatched submobjects in the\nstart mobject. Methods clean_up_from_scene Clean up the Scene after finishing the animation. get_mobject_key get_mobject_parts get_shape_map Attributes run_time _original__init__ ( mobject , target_mobject , transform_mismatches = False , fade_transform_mismatches = False , key_map = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) target_mobject ( Mobject ) transform_mismatches ( bool ) fade_transform_mismatches ( bool ) key_map ( dict | None ) clean_up_from_scene ( scene ) [source]   Clean up the Scene after finishing the animation. This includes to remove() the Animation\u2019s Mobject if the animation is a remover. Parameters : scene ( Scene ) \u2013 The scene the animation should be cleaned up from. Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform_matching_parts.TransformMatchingAbstractBase.html"}
{"prompt": "class TransformMatchingShapes(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: TransformMatchingAbstractBase An animation trying to transform groups by matching the shape\nof their submobjects. Two submobjects match if the hash of their point coordinates after\nnormalization (i.e., after translation to the origin, fixing the submobject\nheight at 1 unit, and rounding the coordinates to three decimal places)\nmatches. See also TransformMatchingAbstractBase Examples Example: Anagram   from manim import * class Anagram ( Scene ): def construct ( self ): src = Text ( \"the morse code\" ) tar = Text ( \"here come dots\" ) self . play ( Write ( src )) self . wait ( 0.5 ) self . play ( TransformMatchingShapes ( src , tar , path_arc = PI / 2 )) self . wait ( 0.5 ) class Anagram(Scene):\n    def construct(self):\n        src = Text(\"the morse code\")\n        tar = Text(\"here come dots\")\n        self.play(Write(src))\n        self.wait(0.5)\n        self.play(TransformMatchingShapes(src, tar, path_arc=PI/2))\n        self.wait(0.5) Methods get_mobject_key get_mobject_parts Attributes run_time Parameters : mobject ( Mobject ) target_mobject ( Mobject ) transform_mismatches ( bool ) fade_transform_mismatches ( bool ) key_map ( dict | None ) _original__init__ ( mobject , target_mobject , transform_mismatches = False , fade_transform_mismatches = False , key_map = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) target_mobject ( Mobject ) transform_mismatches ( bool ) fade_transform_mismatches ( bool ) key_map ( dict | None )", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform_matching_parts.TransformMatchingShapes.html"}
{"prompt": "class TransformMatchingTex(mobject=None, *args, use_override=True, **kwargs)", "response": "Bases: TransformMatchingAbstractBase A transformation trying to transform rendered LaTeX strings. Two submobjects match if their tex_string matches. See also TransformMatchingAbstractBase Examples Example: MatchingEquationParts   from manim import * class MatchingEquationParts ( Scene ): def construct ( self ): variables = VGroup ( MathTex ( \"a\" ), MathTex ( \"b\" ), MathTex ( \"c\" )) . arrange_submobjects () . shift ( UP ) eq1 = MathTex ( \"{{x}}^2\" , \"+\" , \"{{y}}^2\" , \"=\" , \"{{z}}^2\" ) eq2 = MathTex ( \"{{a}}^2\" , \"+\" , \"{{b}}^2\" , \"=\" , \"{{c}}^2\" ) eq3 = MathTex ( \"{{a}}^2\" , \"=\" , \"{{c}}^2\" , \"-\" , \"{{b}}^2\" ) self . add ( eq1 ) self . wait ( 0.5 ) self . play ( TransformMatchingTex ( Group ( eq1 , variables ), eq2 )) self . wait ( 0.5 ) self . play ( TransformMatchingTex ( eq2 , eq3 )) self . wait ( 0.5 ) class MatchingEquationParts(Scene):\n    def construct(self):\n        variables = VGroup(MathTex(\"a\"), MathTex(\"b\"), MathTex(\"c\")).arrange_submobjects().shift(UP)\n\n        eq1 = MathTex(\"{{x}}^2\", \"+\", \"{{y}}^2\", \"=\", \"{{z}}^2\")\n        eq2 = MathTex(\"{{a}}^2\", \"+\", \"{{b}}^2\", \"=\", \"{{c}}^2\")\n        eq3 = MathTex(\"{{a}}^2\", \"=\", \"{{c}}^2\", \"-\", \"{{b}}^2\")\n\n        self.add(eq1)\n        self.wait(0.5)\n        self.play(TransformMatchingTex(Group(eq1, variables), eq2))\n        self.wait(0.5)\n        self.play(TransformMatchingTex(eq2, eq3))\n        self.wait(0.5) Methods get_mobject_key get_mobject_parts Attributes run_time Parameters : mobject ( Mobject ) target_mobject ( Mobject ) transform_mismatches ( bool ) fade_transform_mismatches ( bool ) key_map ( dict | None ) _original__init__ ( mobject , target_mobject , transform_mismatches = False , fade_transform_mismatches = False , key_map = None , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : mobject ( Mobject ) target_mobject ( Mobject ) transform_mismatches ( bool ) fade_transform_mismatches ( bool ) key_map ( dict | None )", "source": "https://docs.manim.community/en/stable/reference/manim.animation.transform_matching_parts.TransformMatchingTex.html"}
{"prompt": "class BackgroundColoredVMobjectDisplayer(camera)", "response": "Bases: object Auxiliary class that handles displaying vectorized mobjects with\na set background image. Parameters : camera ( Camera ) \u2013 Camera object to use. Methods display Displays the colored VMobjects. get_background_array Gets the background array that has the passed file_name. reset_pixel_array resize_background_array Resizes the pixel array representing the background. resize_background_array_to_match Resizes the background array to match the passed pixel array. display ( * cvmobjects ) [source]   Displays the colored VMobjects. Parameters : *cvmobjects ( VMobject ) \u2013 The VMobjects Returns : The pixel array with the cvmobjects displayed. Return type : np.array get_background_array ( image ) [source]   Gets the background array that has the passed file_name. Parameters : image ( Image | Path | str ) \u2013 The background image or its file name. Returns : The pixel array of the image. Return type : np.ndarray resize_background_array ( background_array , new_width , new_height , mode = 'RGBA' ) [source]   Resizes the pixel array representing the background. Parameters : background_array ( ndarray ) \u2013 The pixel new_width ( float ) \u2013 The new width of the background new_height ( float ) \u2013 The new height of the background mode ( str ) \u2013 The PIL image mode, by default \u201cRGBA\u201d Returns : The numpy pixel array of the resized background. Return type : np.array resize_background_array_to_match ( background_array , pixel_array ) [source]   Resizes the background array to match the passed pixel array. Parameters : background_array ( ndarray ) \u2013 The prospective pixel array. pixel_array ( ndarray ) \u2013 The pixel array whose width and height should be matched. Returns : The resized background array. Return type : np.array", "source": "https://docs.manim.community/en/stable/reference/manim.camera.camera.BackgroundColoredVMobjectDisplayer.html"}
{"prompt": "class Camera(background_image=None, frame_center=array(", "response": "Bases: object Base camera class. This is the object which takes care of what exactly is displayed\non screen at any given moment. Parameters : background_image ( str | None ) \u2013 The path to an image that should be the background image.\nIf not set, the background is filled with self.background_color background ( np.ndarray | None ) \u2013 What background is set to. By default, None . pixel_height ( int | None ) \u2013 The height of the scene in pixels. pixel_width ( int | None ) \u2013 The width of the scene in pixels. kwargs \u2013 Additional arguments ( background_color , background_opacity )\nto be set. frame_center ( np.ndarray ) image_mode ( str ) n_channels ( int ) pixel_array_dtype ( str ) cairo_line_width_multiple ( float ) use_z_index ( bool ) frame_height ( float | None ) frame_width ( float | None ) frame_rate ( float | None ) background_color ( ParsableManimColor | None ) background_opacity ( float | None ) Methods adjust_out_of_range_points If any of the points in the passed array are out of the viable range, they are adjusted suitably. adjusted_thickness Computes the adjusted stroke width for a zoomed camera. apply_fill Fills the cairo context apply_stroke Applies a stroke to the VMobject in the cairo context. cache_cairo_context Caches the passed Pixel array into a Cairo Context capture_mobject Capture mobjects by storing it in pixel_array . capture_mobjects Capture mobjects by printing them on pixel_array . convert_pixel_array Converts a pixel array from values that have floats in then to proper RGB values. display_image_mobject Displays an ImageMobject by changing the pixel_array suitably. display_multiple_background_colored_vmobjects Displays multiple vmobjects that have the same color as the background. display_multiple_image_mobjects Displays multiple image mobjects by modifying the passed pixel_array. display_multiple_non_background_colored_vmobjects Displays multiple VMobjects in the cairo context, as long as they don't have background colors. display_multiple_point_cloud_mobjects Displays multiple PMobjects by modifying the passed pixel array. display_multiple_vectorized_mobjects Displays multiple VMobjects in the pixel_array display_point_cloud Displays a PMobject by modifying the pixel array suitably. display_vectorized Displays a VMobject in the cairo context get_background_colored_vmobject_displayer Returns the background_colored_vmobject_displayer if it exists or makes one and returns it if not. get_cached_cairo_context Returns the cached cairo context of the passed pixel array if it exists, and None if it doesn't. get_cairo_context Returns the cairo context for a pixel array after caching it to self.pixel_array_to_cairo_context If that array has already been cached, it returns the cached version instead. get_coords_of_all_pixels Returns the cartesian coordinates of each pixel. get_fill_rgbas Returns the RGBA array of the fill of the passed VMobject get_image Returns an image from the passed pixel array, or from the current frame if the passed pixel array is none. get_mobjects_to_display Used to get the list of mobjects to display with the camera. get_stroke_rgbas Gets the RGBA array for the stroke of the passed VMobject. get_thickening_nudges Determine a list of vectors used to nudge two-dimensional pixel coordinates. init_background Initialize the background. is_in_frame Checks whether the passed mobject is in frame or not. make_background_from_func Makes a pixel array for the background by using coords_to_colors_func to determine each pixel's color. on_screen_pixels Returns array of pixels that are on the screen from a given array of pixel_coordinates overlay_PIL_image Overlays a PIL image on the passed pixel array. overlay_rgba_array Overlays an RGBA array on top of the given Pixel array. points_to_pixel_coords reset Resets the camera's pixel array to that of the background reset_pixel_shape This method resets the height and width of a single pixel to the passed new_height and new_width. resize_frame_shape Changes frame_shape to match the aspect ratio of the pixels, where fixed_dimension determines whether frame_height or frame_width remains fixed while the other changes accordingly. set_background Sets the background to the passed pixel_array after converting to valid RGB values. set_background_from_func Sets the background to a pixel array using coords_to_colors_func to determine each pixel's color. set_cairo_context_color Sets the color of the cairo context set_cairo_context_path Sets a path for the cairo context with the vmobject passed set_frame_to_background set_pixel_array Sets the pixel array of the camera to the passed pixel array. thickened_coordinates Returns thickened coordinates for a passed array of pixel coords and a thickness to thicken by. transform_points_pre_display type_or_raise Return the type of mobject, if it is a type that can be rendered. Attributes background_color background_opacity adjust_out_of_range_points ( points ) [source]   If any of the points in the passed array are out of\nthe viable range, they are adjusted suitably. Parameters : points ( ndarray ) \u2013 The points to adjust Returns : The adjusted points. Return type : np.array adjusted_thickness ( thickness ) [source]   Computes the adjusted stroke width for a zoomed camera. Parameters : thickness ( float ) \u2013 The stroke width of a mobject. Returns : The adjusted stroke width that reflects zooming in with\nthe camera. Return type : float apply_fill ( ctx , vmobject ) [source]   Fills the cairo context Parameters : ctx ( Context ) \u2013 The cairo context vmobject ( VMobject ) \u2013 The VMobject Returns : The camera object. Return type : Camera apply_stroke ( ctx , vmobject , background = False ) [source]   Applies a stroke to the VMobject in the cairo context. Parameters : ctx ( Context ) \u2013 The cairo context vmobject ( VMobject ) \u2013 The VMobject background ( bool ) \u2013 Whether or not to consider the background when applying this\nstroke width, by default False Returns : The camera object with the stroke applied. Return type : Camera cache_cairo_context ( pixel_array , ctx ) [source]   Caches the passed Pixel array into a Cairo Context Parameters : pixel_array ( ndarray ) \u2013 The pixel array to cache ctx ( Context ) \u2013 The context to cache it into. capture_mobject ( mobject , ** kwargs ) [source]   Capture mobjects by storing it in pixel_array . This is a single-mobject version of capture_mobjects() . Parameters : mobject ( Mobject ) \u2013 Mobject to capture. kwargs ( Any ) \u2013 Keyword arguments to be passed to get_mobjects_to_display() . capture_mobjects ( mobjects , ** kwargs ) [source]   Capture mobjects by printing them on pixel_array . This is the essential function that converts the contents of a Scene\ninto an array, which is then converted to an image or video. Parameters : mobjects ( Iterable [ Mobject ] ) \u2013 Mobjects to capture. kwargs \u2013 Keyword arguments to be passed to get_mobjects_to_display() . Notes For a list of classes that can currently be rendered, see display_funcs() . convert_pixel_array ( pixel_array , convert_from_floats = False ) [source]   Converts a pixel array from values that have floats in then\nto proper RGB values. Parameters : pixel_array ( ndarray | list | tuple ) \u2013 Pixel array to convert. convert_from_floats ( bool ) \u2013 Whether or not to convert float values to ints, by default False Returns : The new, converted pixel array. Return type : np.array display_image_mobject ( image_mobject , pixel_array ) [source]   Displays an ImageMobject by changing the pixel_array suitably. Parameters : image_mobject ( AbstractImageMobject ) \u2013 The imageMobject to display pixel_array ( ndarray ) \u2013 The Pixel array to put the imagemobject in. display_multiple_background_colored_vmobjects ( cvmobjects , pixel_array ) [source]   Displays multiple vmobjects that have the same color as the background. Parameters : cvmobjects ( list ) \u2013 List of Colored VMobjects pixel_array ( ndarray ) \u2013 The pixel array. Returns : The camera object. Return type : Camera display_multiple_image_mobjects ( image_mobjects , pixel_array ) [source]   Displays multiple image mobjects by modifying the passed pixel_array. Parameters : image_mobjects ( list ) \u2013 list of ImageMobjects pixel_array ( ndarray ) \u2013 The pixel array to modify. display_multiple_non_background_colored_vmobjects ( vmobjects , pixel_array ) [source]   Displays multiple VMobjects in the cairo context, as long as they don\u2019t have\nbackground colors. Parameters : vmobjects ( list ) \u2013 list of the VMobjects pixel_array ( ndarray ) \u2013 The Pixel array to add the VMobjects to. display_multiple_point_cloud_mobjects ( pmobjects , pixel_array ) [source]   Displays multiple PMobjects by modifying the passed pixel array. Parameters : pmobjects ( list ) \u2013 List of PMobjects pixel_array ( ndarray ) \u2013 The pixel array to modify. display_multiple_vectorized_mobjects ( vmobjects , pixel_array ) [source]   Displays multiple VMobjects in the pixel_array Parameters : vmobjects ( list ) \u2013 list of VMobjects to display pixel_array ( ndarray ) \u2013 The pixel array display_point_cloud ( pmobject , points , rgbas , thickness , pixel_array ) [source]   Displays a PMobject by modifying the pixel array suitably. TODO: Write a description for the rgbas argument. Parameters : pmobject ( PMobject ) \u2013 Point Cloud Mobject points ( list ) \u2013 The points to display in the point cloud mobject rgbas ( ndarray ) thickness ( float ) \u2013 The thickness of each point of the PMobject pixel_array ( ndarray ) \u2013 The pixel array to modify. display_vectorized ( vmobject , ctx ) [source]   Displays a VMobject in the cairo context Parameters : vmobject ( VMobject ) \u2013 The Vectorized Mobject to display ctx ( Context ) \u2013 The cairo context to use. Returns : The camera object Return type : Camera get_background_colored_vmobject_displayer ( ) [source]   Returns the background_colored_vmobject_displayer\nif it exists or makes one and returns it if not. Returns : Object that displays VMobjects that have the same color\nas the background. Return type : BackGroundColoredVMobjectDisplayer get_cached_cairo_context ( pixel_array ) [source]   Returns the cached cairo context of the passed\npixel array if it exists, and None if it doesn\u2019t. Parameters : pixel_array ( ndarray ) \u2013 The pixel array to check. Returns : The cached cairo context. Return type : cairo.Context get_cairo_context ( pixel_array ) [source]   Returns the cairo context for a pixel array after\ncaching it to self.pixel_array_to_cairo_context\nIf that array has already been cached, it returns the\ncached version instead. Parameters : pixel_array ( ndarray ) \u2013 The Pixel array to get the cairo context of. Returns : The cairo context of the pixel array. Return type : cairo.Context get_coords_of_all_pixels ( ) [source]   Returns the cartesian coordinates of each pixel. Returns : The array of cartesian coordinates. Return type : np.ndarray get_fill_rgbas ( vmobject ) [source]   Returns the RGBA array of the fill of the passed VMobject Parameters : vmobject ( VMobject ) \u2013 The VMobject Returns : The RGBA Array of the fill of the VMobject Return type : np.array get_image ( pixel_array = None ) [source]   Returns an image from the passed\npixel array, or from the current frame\nif the passed pixel array is none. Parameters : pixel_array ( ndarray | list | tuple | None ) \u2013 The pixel array from which to get an image, by default None Returns : The PIL image of the array. Return type : PIL.Image get_mobjects_to_display ( mobjects , include_submobjects = True , excluded_mobjects = None ) [source]   Used to get the list of mobjects to display\nwith the camera. Parameters : mobjects ( Iterable [ Mobject ] ) \u2013 The Mobjects include_submobjects ( bool ) \u2013 Whether or not to include the submobjects of mobjects, by default True excluded_mobjects ( list | None ) \u2013 Any mobjects to exclude, by default None Returns : list of mobjects Return type : list get_stroke_rgbas ( vmobject , background = False ) [source]   Gets the RGBA array for the stroke of the passed\nVMobject. Parameters : vmobject ( VMobject ) \u2013 The VMobject background ( bool ) \u2013 Whether or not to consider the background when getting the stroke\nRGBAs, by default False Returns : The RGBA array of the stroke. Return type : np.ndarray get_thickening_nudges ( thickness ) [source]   Determine a list of vectors used to nudge\ntwo-dimensional pixel coordinates. Parameters : thickness ( float ) Return type : np.array init_background ( ) [source]   Initialize the background.\nIf self.background_image is the path of an image\nthe image is set as background; else, the default\nbackground color fills the background. is_in_frame ( mobject ) [source]   Checks whether the passed mobject is in\nframe or not. Parameters : mobject ( Mobject ) \u2013 The mobject for which the checking needs to be done. Returns : True if in frame, False otherwise. Return type : bool make_background_from_func ( coords_to_colors_func ) [source]   Makes a pixel array for the background by using coords_to_colors_func to determine each pixel\u2019s color. Each input\npixel\u2019s color. Each input to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not\npixel coordinates), and each output is expected to be an RGBA array of 4 floats. Parameters : coords_to_colors_func ( Callable [ [ ndarray ] , ndarray ] ) \u2013 The function whose input is an (x,y) pair of coordinates and\nwhose return values must be the colors for that point Returns : The pixel array which can then be passed to set_background. Return type : np.array on_screen_pixels ( pixel_coords ) [source]   Returns array of pixels that are on the screen from a given\narray of pixel_coordinates Parameters : pixel_coords ( ndarray ) \u2013 The pixel coords to check. Returns : The pixel coords on screen. Return type : np.array overlay_PIL_image ( pixel_array , image ) [source]   Overlays a PIL image on the passed pixel array. Parameters : pixel_array ( ndarray ) \u2013 The Pixel array image ( <module 'PIL.Image' from '/home/docs/checkouts/readthedocs.org/user_builds/manimce/envs/stable/lib/python3.13/site-packages/PIL/Image.py'> ) \u2013 The Image to overlay. overlay_rgba_array ( pixel_array , new_array ) [source]   Overlays an RGBA array on top of the given Pixel array. Parameters : pixel_array ( ndarray ) \u2013 The original pixel array to modify. new_array ( ndarray ) \u2013 The new pixel array to overlay. reset ( ) [source]   Resets the camera\u2019s pixel array\nto that of the background Returns : The camera object after setting the pixel array. Return type : Camera reset_pixel_shape ( new_height , new_width ) [source]   This method resets the height and width\nof a single pixel to the passed new_height and new_width. Parameters : new_height ( float ) \u2013 The new height of the entire scene in pixels new_width ( float ) \u2013 The new width of the entire scene in pixels resize_frame_shape ( fixed_dimension = 0 ) [source]   Changes frame_shape to match the aspect ratio\nof the pixels, where fixed_dimension determines\nwhether frame_height or frame_width\nremains fixed while the other changes accordingly. Parameters : fixed_dimension ( int ) \u2013 If 0, height is scaled with respect to width\nelse, width is scaled with respect to height. set_background ( pixel_array , convert_from_floats = False ) [source]   Sets the background to the passed pixel_array after converting\nto valid RGB values. Parameters : pixel_array ( ndarray | list | tuple ) \u2013 The pixel array to set the background to. convert_from_floats ( bool ) \u2013 Whether or not to convert floats values to proper RGB valid ones, by default False set_background_from_func ( coords_to_colors_func ) [source]   Sets the background to a pixel array using coords_to_colors_func to determine each pixel\u2019s color. Each input\npixel\u2019s color. Each input to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not\npixel coordinates), and each output is expected to be an RGBA array of 4 floats. Parameters : coords_to_colors_func ( Callable [ [ ndarray ] , ndarray ] ) \u2013 The function whose input is an (x,y) pair of coordinates and\nwhose return values must be the colors for that point set_cairo_context_color ( ctx , rgbas , vmobject ) [source]   Sets the color of the cairo context Parameters : ctx ( Context ) \u2013 The cairo context rgbas ( ndarray ) \u2013 The RGBA array with which to color the context. vmobject ( VMobject ) \u2013 The VMobject with which to set the color. Returns : The camera object Return type : Camera set_cairo_context_path ( ctx , vmobject ) [source]   Sets a path for the cairo context with the vmobject passed Parameters : ctx ( Context ) \u2013 The cairo context vmobject ( VMobject ) \u2013 The VMobject Returns : Camera object after setting cairo_context_path Return type : Camera set_pixel_array ( pixel_array , convert_from_floats = False ) [source]   Sets the pixel array of the camera to the passed pixel array. Parameters : pixel_array ( ndarray | list | tuple ) \u2013 The pixel array to convert and then set as the camera\u2019s pixel array. convert_from_floats ( bool ) \u2013 Whether or not to convert float values to proper RGB values, by default False thickened_coordinates ( pixel_coords , thickness ) [source]   Returns thickened coordinates for a passed array of pixel coords and\na thickness to thicken by. Parameters : pixel_coords ( ndarray ) \u2013 Pixel coordinates thickness ( float ) \u2013 Thickness Returns : Array of thickened pixel coords. Return type : np.array type_or_raise ( mobject ) [source]   Return the type of mobject, if it is a type that can be rendered. If mobject is an instance of a class that inherits from a class that\ncan be rendered, return the super class.  For example, an instance of a\nSquare is also an instance of VMobject, and these can be rendered.\nTherefore, type_or_raise(Square()) returns True. Parameters : mobject ( Mobject ) \u2013 The object to take the type of. Notes For a list of classes that can currently be rendered, see display_funcs() . Returns : The type of mobjects, if it can be rendered. Return type : Type[ Mobject ] Raises : TypeError \u2013 When mobject is not an instance of a class that can be rendered. Parameters : mobject ( Mobject )", "source": "https://docs.manim.community/en/stable/reference/manim.camera.camera.Camera.html"}
{"prompt": "class MappingCamera(mapping_func=<function MappingCamera.<lambda>>, min_num_curves=50, allow_object_intrusion=False, **kwargs)", "response": "Bases: Camera Camera object that allows mapping\nbetween objects. Methods capture_mobjects Capture mobjects by printing them on pixel_array . points_to_pixel_coords Attributes background_color background_opacity capture_mobjects ( mobjects , ** kwargs ) [source]   Capture mobjects by printing them on pixel_array . This is the essential function that converts the contents of a Scene\ninto an array, which is then converted to an image or video. Parameters : mobjects \u2013 Mobjects to capture. kwargs \u2013 Keyword arguments to be passed to get_mobjects_to_display() . Notes For a list of classes that can currently be rendered, see display_funcs() .", "source": "https://docs.manim.community/en/stable/reference/manim.camera.mapping_camera.MappingCamera.html"}
{"prompt": "class OldMultiCamera(*cameras_with_start_positions, **kwargs)", "response": "Bases: Camera Methods capture_mobjects Capture mobjects by printing them on pixel_array . init_background Initialize the background. set_background Sets the background to the passed pixel_array after converting to valid RGB values. set_pixel_array Sets the pixel array of the camera to the passed pixel array. Attributes background_color background_opacity capture_mobjects ( mobjects , ** kwargs ) [source]   Capture mobjects by printing them on pixel_array . This is the essential function that converts the contents of a Scene\ninto an array, which is then converted to an image or video. Parameters : mobjects \u2013 Mobjects to capture. kwargs \u2013 Keyword arguments to be passed to get_mobjects_to_display() . Notes For a list of classes that can currently be rendered, see display_funcs() . init_background ( ) [source]   Initialize the background.\nIf self.background_image is the path of an image\nthe image is set as background; else, the default\nbackground color fills the background. set_background ( pixel_array , ** kwargs ) [source]   Sets the background to the passed pixel_array after converting\nto valid RGB values. Parameters : pixel_array \u2013 The pixel array to set the background to. convert_from_floats \u2013 Whether or not to convert floats values to proper RGB valid ones, by default False set_pixel_array ( pixel_array , ** kwargs ) [source]   Sets the pixel array of the camera to the passed pixel array. Parameters : pixel_array \u2013 The pixel array to convert and then set as the camera\u2019s pixel array. convert_from_floats \u2013 Whether or not to convert float values to proper RGB values, by default False", "source": "https://docs.manim.community/en/stable/reference/manim.camera.mapping_camera.OldMultiCamera.html"}
{"prompt": "class SplitScreenCamera(left_camera, right_camera, **kwargs)", "response": "Bases: OldMultiCamera Methods Attributes background_color background_opacity", "source": "https://docs.manim.community/en/stable/reference/manim.camera.mapping_camera.SplitScreenCamera.html"}
{"prompt": "class MovingCamera(frame=None, fixed_dimension=0, default_frame_stroke_color=ManimColor('#FFFFFF'), default_frame_stroke_width=0, **kwargs)", "response": "Bases: Camera Stays in line with the height, width and position of it\u2019s \u2018frame\u2019, which is a Rectangle See also MovingCameraScene Frame is a Mobject, (should almost certainly be a rectangle)\ndetermining which region of space the camera displays Methods auto_zoom Zooms on to a given array of mobjects (or a singular mobject) and automatically resizes to frame all the mobjects. cache_cairo_context Since the frame can be moving around, the cairo context used for updating should be regenerated at each frame. capture_mobjects Capture mobjects by printing them on pixel_array . get_cached_cairo_context Since the frame can be moving around, the cairo context used for updating should be regenerated at each frame. get_mobjects_indicating_movement Returns all mobjects whose movement implies that the camera should think of all other mobjects on the screen as moving Attributes background_color background_opacity frame_center Returns the centerpoint of the frame in cartesian coordinates. frame_height Returns the height of the frame. frame_width Returns the width of the frame auto_zoom ( mobjects , margin = 0 , only_mobjects_in_frame = False , animate = True ) [source]   Zooms on to a given array of mobjects (or a singular mobject)\nand automatically resizes to frame all the mobjects. Note This method only works when 2D-objects in the XY-plane are considered, it\nwill not work correctly when the camera has been rotated. Parameters : mobjects ( list [ Mobject ] ) \u2013 The mobject or array of mobjects that the camera will focus on. margin ( float ) \u2013 The width of the margin that is added to the frame (optional, 0 by default). only_mobjects_in_frame ( bool ) \u2013 If set to True , only allows focusing on mobjects that are already in frame. animate ( bool ) \u2013 If set to False , applies the changes instead of returning the corresponding animation Returns : _AnimationBuilder that zooms the camera view to a given list of mobjects\nor ScreenRectangle with position and size updated to zoomed position. Return type : Union [_AnimationBuilder, ScreenRectangle ] cache_cairo_context ( pixel_array , ctx ) [source]   Since the frame can be moving around, the cairo\ncontext used for updating should be regenerated\nat each frame.  So no caching. capture_mobjects ( mobjects , ** kwargs ) [source]   Capture mobjects by printing them on pixel_array . This is the essential function that converts the contents of a Scene\ninto an array, which is then converted to an image or video. Parameters : mobjects \u2013 Mobjects to capture. kwargs \u2013 Keyword arguments to be passed to get_mobjects_to_display() . Notes For a list of classes that can currently be rendered, see display_funcs() . property frame_center   Returns the centerpoint of the frame in cartesian coordinates. Returns : The cartesian coordinates of the center of the frame. Return type : np.array property frame_height   Returns the height of the frame. Returns : The height of the frame. Return type : float property frame_width   Returns the width of the frame Returns : The width of the frame. Return type : float get_cached_cairo_context ( pixel_array ) [source]   Since the frame can be moving around, the cairo\ncontext used for updating should be regenerated\nat each frame.  So no caching. get_mobjects_indicating_movement ( ) [source]   Returns all mobjects whose movement implies that the camera\nshould think of all other mobjects on the screen as moving Return type : list", "source": "https://docs.manim.community/en/stable/reference/manim.camera.moving_camera.MovingCamera.html"}
{"prompt": "class MultiCamera(image_mobjects_from_cameras=None, allow_cameras_to_capture_their_own_display=False, **kwargs)", "response": "Bases: MovingCamera Camera Object that allows for multiple perspectives. Initialises the MultiCamera Parameters : image_mobjects_from_cameras ( ImageMobject | None ) kwargs \u2013 Any valid keyword arguments of MovingCamera. Methods add_image_mobject_from_camera Adds an ImageMobject that's been obtained from the camera into the list self.image_mobject_from_cameras capture_mobjects Capture mobjects by printing them on pixel_array . get_mobjects_indicating_movement Returns all mobjects whose movement implies that the camera should think of all other mobjects on the screen as moving reset Resets the MultiCamera. update_sub_cameras Reshape sub_camera pixel_arrays Attributes background_color background_opacity frame_center Returns the centerpoint of the frame in cartesian coordinates. frame_height Returns the height of the frame. frame_width Returns the width of the frame add_image_mobject_from_camera ( image_mobject_from_camera ) [source]   Adds an ImageMobject that\u2019s been obtained from the camera\ninto the list self.image_mobject_from_cameras Parameters : image_mobject_from_camera ( ImageMobject ) \u2013 The ImageMobject to add to self.image_mobject_from_cameras capture_mobjects ( mobjects , ** kwargs ) [source]   Capture mobjects by printing them on pixel_array . This is the essential function that converts the contents of a Scene\ninto an array, which is then converted to an image or video. Parameters : mobjects \u2013 Mobjects to capture. kwargs \u2013 Keyword arguments to be passed to get_mobjects_to_display() . Notes For a list of classes that can currently be rendered, see display_funcs() . get_mobjects_indicating_movement ( ) [source]   Returns all mobjects whose movement implies that the camera\nshould think of all other mobjects on the screen as moving Return type : list reset ( ) [source]   Resets the MultiCamera. Returns : The reset MultiCamera Return type : MultiCamera update_sub_cameras ( ) [source]   Reshape sub_camera pixel_arrays", "source": "https://docs.manim.community/en/stable/reference/manim.camera.multi_camera.MultiCamera.html"}
{"prompt": "class ThreeDCamera(focal_distance=20.0, shading_factor=0.2, default_distance=5.0, light_source_start_point=array(", "response": "Bases: Camera Initializes the ThreeDCamera Parameters : *kwargs \u2013 Any keyword argument of Camera. Methods add_fixed_in_frame_mobjects This method allows the mobject to have a fixed position, even when the camera moves around. add_fixed_orientation_mobjects This method allows the mobject to have a fixed orientation, even when the camera moves around. capture_mobjects Capture mobjects by printing them on pixel_array . generate_rotation_matrix Generates a rotation matrix based off the current position of the camera. get_fill_rgbas Returns the RGBA array of the fill of the passed VMobject get_focal_distance Returns focal_distance of the Camera. get_gamma Returns the rotation of the camera about the vector from the ORIGIN to the Camera. get_mobjects_to_display Used to get the list of mobjects to display with the camera. get_phi Returns the Polar angle (the angle off Z_AXIS) phi. get_rotation_matrix Returns the matrix corresponding to the current position of the camera. get_stroke_rgbas Gets the RGBA array for the stroke of the passed VMobject. get_theta Returns the Azimuthal i.e the angle that spins the camera around the Z_AXIS. get_value_trackers A list of ValueTrackers of phi, theta, focal_distance, gamma and zoom. get_zoom Returns the zoom amount of the camera. modified_rgbas project_point Applies the current rotation_matrix as a projection matrix to the passed point. project_points Applies the current rotation_matrix as a projection matrix to the passed array of points. remove_fixed_in_frame_mobjects If a mobject was fixed in frame by passing it through add_fixed_in_frame_mobjects() , then this undoes that fixing. remove_fixed_orientation_mobjects If a mobject was fixed in its orientation by passing it through add_fixed_orientation_mobjects() , then this undoes that fixing. reset_rotation_matrix Sets the value of self.rotation_matrix to the matrix corresponding to the current position of the camera set_focal_distance Sets the focal_distance of the Camera. set_gamma Sets the angle of rotation of the camera about the vector from the ORIGIN to the Camera. set_phi Sets the polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians. set_theta Sets the azimuthal angle i.e the angle that spins the camera around Z_AXIS in radians. set_zoom Sets the zoom amount of the camera. transform_points_pre_display Attributes background_color background_opacity frame_center add_fixed_in_frame_mobjects ( * mobjects ) [source]   This method allows the mobject to have a fixed position,\neven when the camera moves around.\nE.G If it was passed through this method, at the top of the frame, it\nwill continue to be displayed at the top of the frame. Highly useful when displaying Titles or formulae or the like. Parameters : **mobjects ( Mobject ) \u2013 The mobject to fix in frame. add_fixed_orientation_mobjects ( * mobjects , use_static_center_func = False , center_func = None ) [source]   This method allows the mobject to have a fixed orientation,\neven when the camera moves around.\nE.G If it was passed through this method, facing the camera, it\nwill continue to face the camera even as the camera moves.\nHighly useful when adding labels to graphs and the like. Parameters : *mobjects ( Mobject ) \u2013 The mobject whose orientation must be fixed. use_static_center_func ( bool ) \u2013 Whether or not to use the function that takes the mobject\u2019s\ncenter as centerpoint, by default False center_func ( Callable [ [ ] , ndarray ] | None ) \u2013 The function which returns the centerpoint\nwith respect to which the mobject will be oriented, by default None capture_mobjects ( mobjects , ** kwargs ) [source]   Capture mobjects by printing them on pixel_array . This is the essential function that converts the contents of a Scene\ninto an array, which is then converted to an image or video. Parameters : mobjects \u2013 Mobjects to capture. kwargs \u2013 Keyword arguments to be passed to get_mobjects_to_display() . Notes For a list of classes that can currently be rendered, see display_funcs() . generate_rotation_matrix ( ) [source]   Generates a rotation matrix based off the current position of the camera. Returns : The matrix corresponding to the current position of the camera. Return type : np.array get_fill_rgbas ( vmobject ) [source]   Returns the RGBA array of the fill of the passed VMobject Parameters : vmobject \u2013 The VMobject Returns : The RGBA Array of the fill of the VMobject Return type : np.array get_focal_distance ( ) [source]   Returns focal_distance of the Camera. Returns : The focal_distance of the Camera in MUnits. Return type : float get_gamma ( ) [source]   Returns the rotation of the camera about the vector from the ORIGIN to the Camera. Returns : The angle of rotation of the camera about the vector\nfrom the ORIGIN to the Camera in radians Return type : float get_mobjects_to_display ( * args , ** kwargs ) [source]   Used to get the list of mobjects to display\nwith the camera. Parameters : mobjects \u2013 The Mobjects include_submobjects \u2013 Whether or not to include the submobjects of mobjects, by default True excluded_mobjects \u2013 Any mobjects to exclude, by default None Returns : list of mobjects Return type : list get_phi ( ) [source]   Returns the Polar angle (the angle off Z_AXIS) phi. Returns : The Polar angle in radians. Return type : float get_rotation_matrix ( ) [source]   Returns the matrix corresponding to the current position of the camera. Returns : The matrix corresponding to the current position of the camera. Return type : np.array get_stroke_rgbas ( vmobject , background = False ) [source]   Gets the RGBA array for the stroke of the passed\nVMobject. Parameters : vmobject \u2013 The VMobject background \u2013 Whether or not to consider the background when getting the stroke\nRGBAs, by default False Returns : The RGBA array of the stroke. Return type : np.ndarray get_theta ( ) [source]   Returns the Azimuthal i.e the angle that spins the camera around the Z_AXIS. Returns : The Azimuthal angle in radians. Return type : float get_value_trackers ( ) [source]   A list of ValueTrackers of phi, theta, focal_distance,\ngamma and zoom. Returns : list of ValueTracker objects Return type : list get_zoom ( ) [source]   Returns the zoom amount of the camera. Returns : The zoom amount of the camera. Return type : float project_point ( point ) [source]   Applies the current rotation_matrix as a projection\nmatrix to the passed point. Parameters : point ( list | ndarray ) \u2013 The point to project. Returns : The point after projection. Return type : np.array project_points ( points ) [source]   Applies the current rotation_matrix as a projection\nmatrix to the passed array of points. Parameters : points ( ndarray | list ) \u2013 The list of points to project. Returns : The points after projecting. Return type : np.array remove_fixed_in_frame_mobjects ( * mobjects ) [source]   If a mobject was fixed in frame by passing it through add_fixed_in_frame_mobjects() , then this undoes that fixing.\nThe Mobject will no longer be fixed in frame. Parameters : mobjects ( Mobject ) \u2013 The mobjects which need not be fixed in frame any longer. remove_fixed_orientation_mobjects ( * mobjects ) [source]   If a mobject was fixed in its orientation by passing it through add_fixed_orientation_mobjects() , then this undoes that fixing.\nThe Mobject will no longer have a fixed orientation. Parameters : mobjects ( Mobject ) \u2013 The mobjects whose orientation need not be fixed any longer. reset_rotation_matrix ( ) [source]   Sets the value of self.rotation_matrix to\nthe matrix corresponding to the current position of the camera set_focal_distance ( value ) [source]   Sets the focal_distance of the Camera. Parameters : value ( float ) \u2013 The focal_distance of the Camera. set_gamma ( value ) [source]   Sets the angle of rotation of the camera about the vector from the ORIGIN to the Camera. Parameters : value ( float ) \u2013 The new angle of rotation of the camera. set_phi ( value ) [source]   Sets the polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians. Parameters : value ( float ) \u2013 The new value of the polar angle in radians. set_theta ( value ) [source]   Sets the azimuthal angle i.e the angle that spins the camera around Z_AXIS in radians. Parameters : value ( float ) \u2013 The new value of the azimuthal angle in radians. set_zoom ( value ) [source]   Sets the zoom amount of the camera. Parameters : value ( float ) \u2013 The zoom amount of the camera.", "source": "https://docs.manim.community/en/stable/reference/manim.camera.three_d_camera.ThreeDCamera.html"}
{"prompt": "tempconfig(temp)", "response": "Context manager that temporarily modifies the global config object. Inside the with statement, the modified config will be used.  After\ncontext manager exits, the config will be restored to its original state. Parameters : temp ( ManimConfig | dict [ str , Any ] ) \u2013 Object whose keys will be used to temporarily update the global config . Return type : Generator [None, None, None] Examples Use with tempconfig({...}) to temporarily change the default values of\ncertain config options. >>> config [ \"frame_height\" ] 8.0 >>> with tempconfig ({ \"frame_height\" : 100.0 }): ... print ( config [ \"frame_height\" ]) 100.0 >>> config [ \"frame_height\" ] 8.0", "source": "https://docs.manim.community/en/stable/reference/manim._config.html"}
{"prompt": "config_file_paths()", "response": "The paths where .cfg files will be searched for. When manim is first imported, it processes any .cfg files it finds.  This\nfunction returns the locations in which these files are searched for.  In\nascending order of precedence, these are: the library-wide config file, the\nuser-wide config file, and the folder-wide config file. The library-wide config file determines manim\u2019s default behavior.  The\nuser-wide config file is stored in the user\u2019s home folder, and determines\nthe behavior of manim whenever the user invokes it from anywhere in the\nsystem.  The folder-wide config file only affects scenes that are in the\nsame folder.  The latter two files are optional. These files, if they exist, are meant to loaded into a single configparser.ConfigParser object, and then processed by ManimConfig . Returns : List of paths which may contain .cfg files, in ascending order of\nprecedence. Return type : List[ Path ] See also make_config_parser() , ManimConfig.digest_file() , ManimConfig.digest_parser() Notes The location of the user-wide config file is OS-specific.", "source": "https://docs.manim.community/en/stable/reference/manim._config.utils.html"}
{"prompt": "make_config_parser(custom_file=None)", "response": "Make a ConfigParser object and load any .cfg files. The user-wide file, if it exists, overrides the library-wide file.  The\nfolder-wide file, if it exists, overrides the other two. The folder-wide file can be ignored by passing custom_file .  However,\nthe user-wide and library-wide config files cannot be ignored. Parameters : custom_file ( StrPath | None ) \u2013 Path to a custom config file.  If used, the folder-wide file in the\nrelevant directory will be ignored, if it exists.  If None, the\nfolder-wide file will be used, if it exists. Returns : A parser containing the config options found in the .cfg files that\nwere found.  It is guaranteed to contain at least the config options\nfound in the library-wide file. Return type : ConfigParser See also config_file_paths()", "source": "https://docs.manim.community/en/stable/reference/manim._config.utils.html"}
{"prompt": "make_logger(parser, verbosity)", "response": "Make the manim logger and console. Parameters : parser ( SectionProxy ) \u2013 A parser containing any .cfg files in use. verbosity ( str ) \u2013 The verbosity level of the logger. Returns : The manim logger and consoles. The first console outputs\nto stdout, the second to stderr. All use the theme returned by parse_theme() . Return type : logging.Logger , rich.Console , rich.Console See also make_config_parser() , parse_theme() Notes The parser is assumed to contain only the options related to\nconfiguring the logger at the top level.", "source": "https://docs.manim.community/en/stable/reference/manim._config.logger_utils.html"}
{"prompt": "parse_theme(parser)", "response": "Configure the rich style of logger and console output. Parameters : parser ( SectionProxy ) \u2013 A parser containing any .cfg files in use. Returns : The rich theme to be used by the manim logger. Return type : rich.Theme See also make_logger()", "source": "https://docs.manim.community/en/stable/reference/manim._config.logger_utils.html"}
{"prompt": "set_file_logger(scene_name, module_name, log_dir)", "response": "Add a file handler to manim logger. The path to the file is built using config.log_dir . Parameters : scene_name ( str ) \u2013 The name of the scene, used in the name of the log file. module_name ( str ) \u2013 The name of the module, used in the name of the log file. log_dir ( Path ) \u2013 Path to the folder where log files are stored. Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim._config.logger_utils.html"}
{"prompt": "class FullScreenRectangle(**kwargs)", "response": "Bases: ScreenRectangle Methods Attributes animate Used to animate the application of any method of self . animation_overrides aspect_ratio The aspect ratio. color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( ** kwargs )   Initialize self.  See help(type(self)) for accurate signature.", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.frame.FullScreenRectangle.html"}
{"prompt": "class ScreenRectangle(aspect_ratio=1.7777777777777777, height=4, **kwargs)", "response": "Bases: Rectangle Methods Attributes animate Used to animate the application of any method of self . animation_overrides aspect_ratio The aspect ratio. color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( aspect_ratio = 1.7777777777777777 , height = 4 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. property aspect_ratio   The aspect ratio. When set, the width is stretched to accommodate\nthe new aspect ratio.", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.frame.ScreenRectangle.html"}
{"prompt": "class NxGraph", "response": "nx . classes . graph . Graph | nx . classes . digraph . DiGraph", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.html"}
{"prompt": "class NxGraph", "response": "nx . classes . graph . Graph | nx . classes . digraph . DiGraph", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.html#manim.mobject.graph.NxGraph"}
{"prompt": "class DiGraph(vertices, edges, labels=False, label_fill_color=ManimColor('#000000'), layout='spring', layout_scale=2, layout_config=None, vertex_type=<class 'manim.mobject.geometry.arc.Dot'>, vertex_config=None, vertex_mobjects=None, edge_type=<class 'manim.mobject.geometry.line.Line'>, partitions=None, root_vertex=None, edge_config=None)", "response": "Bases: GenericGraph A directed graph. Note In contrast to undirected graphs, the order in which vertices in a given\nedge are specified is relevant here. See also GenericGraph Parameters : vertices ( Sequence [ Hashable ] ) \u2013 A list of vertices. Must be hashable elements. edges ( Sequence [ tuple [ Hashable , Hashable ] ] ) \u2013 A list of edges, specified as tuples (u, v) where both u and v are vertices. The edge is directed from u to v . labels ( bool | dict ) \u2013 Controls whether or not vertices are labeled. If False (the default),\nthe vertices are not labeled; if True they are labeled using their\nnames (as specified in vertices ) via MathTex . Alternatively,\ncustom labels can be specified by passing a dictionary whose keys are\nthe vertices, and whose values are the corresponding vertex labels\n(rendered via, e.g., Text or Tex ). label_fill_color ( str ) \u2013 Sets the fill color of the default labels generated when labels is set to True . Has no effect for other values of labels . layout ( LayoutName | dict [ Hashable , Point3DLike ] | LayoutFunction ) \u2013 Either one of \"spring\" (the default), \"circular\" , \"kamada_kawai\" , \"planar\" , \"random\" , \"shell\" , \"spectral\" , \"spiral\" , \"tree\" , and \"partite\" for automatic vertex positioning using networkx (see their documentation for more details), or a dictionary specifying a coordinate (value)\nfor each vertex (key) for manual positioning. layout_config ( dict | None ) \u2013 Only for automatically generated layouts. A dictionary whose entries\nare passed as keyword arguments to the automatic layout algorithm\nspecified via layout of networkx .\nThe tree layout also accepts a special parameter vertex_spacing passed as a keyword argument inside the layout_config dictionary.\nPassing a tuple (space_x, space_y) as this argument overrides\nthe value of layout_scale and ensures that vertices are arranged\nin a way such that the centers of siblings in the same layer are\nat least space_x units apart horizontally, and neighboring layers\nare spaced space_y units vertically. layout_scale ( float | tuple [ float , float , float ] ) \u2013 The scale of automatically generated layouts: the vertices will\nbe arranged such that the coordinates are located within the\ninterval [-scale, scale] . Some layouts accept a tuple (scale_x, scale_y) causing the first coordinate to be in the interval [-scale_x, scale_x] ,\nand the second in [-scale_y, scale_y] . Default: 2. vertex_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying vertices in the scene. vertex_config ( dict | None ) \u2013 Either a dictionary containing keyword arguments to be passed to\nthe class specified via vertex_type , or a dictionary whose keys\nare the vertices, and whose values are dictionaries containing keyword\narguments for the mobject related to the corresponding vertex. vertex_mobjects ( dict | None ) \u2013 A dictionary whose keys are the vertices, and whose values are\nmobjects to be used as vertices. Passing vertices here overrides\nall other configuration options for a vertex. edge_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying edges in the scene. edge_config ( dict | None ) \u2013 Either a dictionary containing keyword arguments to be passed\nto the class specified via edge_type , or a dictionary whose\nkeys are the edges, and whose values are dictionaries containing\nkeyword arguments for the mobject related to the corresponding edge.\nYou can further customize the tip by adding a tip_config dictionary\nfor global styling, or by adding the dict to a specific edge_config . partitions ( Sequence [ Sequence [ Hashable ] ] | None ) root_vertex ( Hashable | None ) Examples Example: MovingDiGraph   from manim import * class MovingDiGraph ( Scene ): def construct ( self ): vertices = [ 1 , 2 , 3 , 4 ] edges = [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 1 , 3 ), ( 1 , 4 )] g = DiGraph ( vertices , edges ) self . add ( g ) self . play ( g [ 1 ] . animate . move_to ([ 1 , 1 , 1 ]), g [ 2 ] . animate . move_to ([ - 1 , 1 , 2 ]), g [ 3 ] . animate . move_to ([ 1 , - 1 , - 1 ]), g [ 4 ] . animate . move_to ([ - 1 , - 1 , 0 ]), ) self . wait () class MovingDiGraph(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]\n\n        g = DiGraph(vertices, edges)\n\n        self.add(g)\n        self.play(\n            g[1].animate.move_to([1, 1, 1]),\n            g[2].animate.move_to([-1, 1, 2]),\n            g[3].animate.move_to([1, -1, -1]),\n            g[4].animate.move_to([-1, -1, 0]),\n        )\n        self.wait() You can customize the edges and arrow tips globally or locally. Example: CustomDiGraph   from manim import * class CustomDiGraph ( Scene ): def construct ( self ): vertices = [ i for i in range ( 5 )] edges = [ ( 0 , 1 ), ( 1 , 2 ), ( 3 , 2 ), ( 3 , 4 ), ] edge_config = { \"stroke_width\" : 2 , \"tip_config\" : { \"tip_shape\" : ArrowSquareTip , \"tip_length\" : 0.15 , }, ( 3 , 4 ): { \"color\" : RED , \"tip_config\" : { \"tip_length\" : 0.25 , \"tip_width\" : 0.25 } }, } g = DiGraph ( vertices , edges , labels = True , layout = \"circular\" , edge_config = edge_config , ) . scale ( 1.4 ) self . play ( Create ( g )) self . wait () class CustomDiGraph(Scene):\n    def construct(self):\n        vertices = [i for i in range(5)]\n        edges = [\n            (0, 1),\n            (1, 2),\n            (3, 2),\n            (3, 4),\n        ]\n\n        edge_config = {\n            \"stroke_width\": 2,\n            \"tip_config\": {\n                \"tip_shape\": ArrowSquareTip,\n                \"tip_length\": 0.15,\n            },\n            (3, 4): {\n                \"color\": RED,\n                \"tip_config\": {\"tip_length\": 0.25, \"tip_width\": 0.25}\n            },\n        }\n\n        g = DiGraph(\n            vertices,\n            edges,\n            labels=True,\n            layout=\"circular\",\n            edge_config=edge_config,\n        ).scale(1.4)\n\n        self.play(Create(g))\n        self.wait() Since this implementation respects the labels boundary you can also use\nit for an undirected moving graph with labels. Example: UndirectedMovingDiGraph   from manim import * class UndirectedMovingDiGraph ( Scene ): def construct ( self ): vertices = [ i for i in range ( 5 )] edges = [ ( 0 , 1 ), ( 1 , 2 ), ( 3 , 2 ), ( 3 , 4 ), ] edge_config = { \"stroke_width\" : 2 , \"tip_config\" : { \"tip_length\" : 0 , \"tip_width\" : 0 }, ( 3 , 4 ): { \"color\" : RED }, } g = DiGraph ( vertices , edges , labels = True , layout = \"circular\" , edge_config = edge_config , ) . scale ( 1.4 ) self . play ( Create ( g )) self . wait () self . play ( g [ 1 ] . animate . move_to ([ 1 , 1 , 1 ]), g [ 2 ] . animate . move_to ([ - 1 , 1 , 2 ]), g [ 3 ] . animate . move_to ([ - 1.5 , - 1.5 , - 1 ]), g [ 4 ] . animate . move_to ([ 1 , - 2 , - 1 ]), ) self . wait () class UndirectedMovingDiGraph(Scene):\n    def construct(self):\n        vertices = [i for i in range(5)]\n        edges = [\n            (0, 1),\n            (1, 2),\n            (3, 2),\n            (3, 4),\n        ]\n\n        edge_config = {\n            \"stroke_width\": 2,\n            \"tip_config\": {\"tip_length\": 0, \"tip_width\": 0},\n            (3, 4): {\"color\": RED},\n        }\n\n        g = DiGraph(\n            vertices,\n            edges,\n            labels=True,\n            layout=\"circular\",\n            edge_config=edge_config,\n        ).scale(1.4)\n\n        self.play(Create(g))\n        self.wait()\n\n        self.play(\n            g[1].animate.move_to([1, 1, 1]),\n            g[2].animate.move_to([-1, 1, 2]),\n            g[3].animate.move_to([-1.5, -1.5, -1]),\n            g[4].animate.move_to([1, -2, -1]),\n        )\n        self.wait() Methods update_edges Updates the edges to stick at their corresponding vertices. Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. static _empty_networkx_graph ( ) [source]   Return an empty networkx graph for the given graph type. Return type : DiGraph _original__init__ ( vertices , edges , labels=False , label_fill_color=ManimColor('#000000') , layout='spring' , layout_scale=2 , layout_config=None , vertex_type=<class 'manim.mobject.geometry.arc.Dot'> , vertex_config=None , vertex_mobjects=None , edge_type=<class 'manim.mobject.geometry.line.Line'> , partitions=None , root_vertex=None , edge_config=None )   Initialize self.  See help(type(self)) for accurate signature. Parameters : vertices ( Sequence [ Hashable ] ) edges ( Sequence [ tuple [ Hashable , Hashable ] ] ) labels ( bool | dict ) label_fill_color ( str ) layout ( Literal [ 'circular' , 'kamada_kawai' , 'partite' , 'planar' , 'random' , 'shell' , 'spectral' , 'spiral' , 'spring' , 'tree' ] | dict [ ~collections.abc.Hashable , ~manim.typing.Point3DLike ] | ~manim.mobject.graph.LayoutFunction ) layout_scale ( float | tuple [ float , float , float ] ) layout_config ( dict | None ) vertex_type ( type [ Mobject ] ) vertex_config ( dict | None ) vertex_mobjects ( dict | None ) edge_type ( type [ Mobject ] ) partitions ( Sequence [ Sequence [ Hashable ] ] | None ) root_vertex ( Hashable | None ) edge_config ( dict | None ) Return type : None _populate_edge_dict ( edges , edge_type ) [source]   Helper method for populating the edges of the graph. Parameters : edges ( list [ tuple [ Hashable , Hashable ] ] ) edge_type ( type [ Mobject ] ) update_edges ( graph ) [source]   Updates the edges to stick at their corresponding vertices. Arrow tips need to be repositioned since otherwise they can be\ndeformed.", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.DiGraph.html"}
{"prompt": "class GenericGraph(vertices, edges, labels=False, label_fill_color=ManimColor('#000000'), layout='spring', layout_scale=2, layout_config=None, vertex_type=<class 'manim.mobject.geometry.arc.Dot'>, vertex_config=None, vertex_mobjects=None, edge_type=<class 'manim.mobject.geometry.line.Line'>, partitions=None, root_vertex=None, edge_config=None)", "response": "Bases: VMobject Abstract base class for graphs (that is, a collection of vertices\nconnected with edges). Graphs can be instantiated by passing both a list of (distinct, hashable)\nvertex names, together with list of edges (as tuples of vertex names). See\nthe examples for concrete implementations of this class for details. Note This implementation uses updaters to make the edges move with\nthe vertices. See also Graph , DiGraph Parameters : vertices ( Sequence [ Hashable ] ) \u2013 A list of vertices. Must be hashable elements. edges ( Sequence [ tuple [ Hashable , Hashable ] ] ) \u2013 A list of edges, specified as tuples (u, v) where both u and v are vertices. labels ( bool | dict ) \u2013 Controls whether or not vertices are labeled. If False (the default),\nthe vertices are not labeled; if True they are labeled using their\nnames (as specified in vertices ) via MathTex . Alternatively,\ncustom labels can be specified by passing a dictionary whose keys are\nthe vertices, and whose values are the corresponding vertex labels\n(rendered via, e.g., Text or Tex ). label_fill_color ( str ) \u2013 Sets the fill color of the default labels generated when labels is set to True . Has no effect for other values of labels . layout ( LayoutName | dict [ Hashable , Point3DLike ] | LayoutFunction ) \u2013 Either one of \"spring\" (the default), \"circular\" , \"kamada_kawai\" , \"planar\" , \"random\" , \"shell\" , \"spectral\" , \"spiral\" , \"tree\" , and \"partite\" for automatic vertex positioning primarily using networkx (see their documentation for more details), a dictionary specifying a coordinate (value)\nfor each vertex (key) for manual positioning, or a .:class: ~.LayoutFunction with a user-defined automatic layout. layout_config ( dict | None ) \u2013 Only for automatic layouts. A dictionary whose entries\nare passed as keyword arguments to the named layout or automatic layout function\nspecified via layout .\nThe tree layout also accepts a special parameter vertex_spacing passed as a keyword argument inside the layout_config dictionary.\nPassing a tuple (space_x, space_y) as this argument overrides\nthe value of layout_scale and ensures that vertices are arranged\nin a way such that the centers of siblings in the same layer are\nat least space_x units apart horizontally, and neighboring layers\nare spaced space_y units vertically. layout_scale ( float | tuple [ float , float , float ] ) \u2013 The scale of automatically generated layouts: the vertices will\nbe arranged such that the coordinates are located within the\ninterval [-scale, scale] . Some layouts accept a tuple (scale_x, scale_y) causing the first coordinate to be in the interval [-scale_x, scale_x] ,\nand the second in [-scale_y, scale_y] . Default: 2. vertex_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying vertices in the scene. vertex_config ( dict | None ) \u2013 Either a dictionary containing keyword arguments to be passed to\nthe class specified via vertex_type , or a dictionary whose keys\nare the vertices, and whose values are dictionaries containing keyword\narguments for the mobject related to the corresponding vertex. vertex_mobjects ( dict | None ) \u2013 A dictionary whose keys are the vertices, and whose values are\nmobjects to be used as vertices. Passing vertices here overrides\nall other configuration options for a vertex. edge_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying edges in the scene.\nMust be a subclass of Line for default updaters to work. edge_config ( dict | None ) \u2013 Either a dictionary containing keyword arguments to be passed\nto the class specified via edge_type , or a dictionary whose\nkeys are the edges, and whose values are dictionaries containing\nkeyword arguments for the mobject related to the corresponding edge. partitions ( Sequence [ Sequence [ Hashable ] ] | None ) root_vertex ( Hashable | None ) Methods add_edges Add new edges to the graph. add_vertices Add a list of vertices to the graph. change_layout Change the layout of this graph. from_networkx Build a Graph or DiGraph from a given networkx graph. remove_edges Remove several edges from the graph. remove_vertices Remove several vertices from the graph. Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _add_edge ( edge , edge_type=<class 'manim.mobject.geometry.line.Line'> , edge_config=None ) [source]   Add a new edge to the graph. Parameters : edge ( tuple [ Hashable , Hashable ] ) \u2013 The edge (as a tuple of vertex identifiers) to be added. If a non-existing\nvertex is passed, a new vertex with default settings will be created. Create\nnew vertices yourself beforehand to customize them. edge_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying edges in the scene. edge_config ( dict | None ) \u2013 A dictionary containing keyword arguments to be passed\nto the class specified via edge_type . Returns : A group containing all newly added vertices and edges. Return type : Group _add_vertex ( vertex , position=None , label=False , label_fill_color=ManimColor('#000000') , vertex_type=<class 'manim.mobject.geometry.arc.Dot'> , vertex_config=None , vertex_mobject=None ) [source]   Add a vertex to the graph. Parameters : vertex ( Hashable ) \u2013 A hashable vertex identifier. position ( Point3DLike | None ) \u2013 The coordinates where the new vertex should be added. If None , the center\nof the graph is used. label ( bool ) \u2013 Controls whether or not the vertex is labeled. If False (the default),\nthe vertex is not labeled; if True it is labeled using its\nnames (as specified in vertex ) via MathTex . Alternatively,\nany Mobject can be passed to be used as the label. label_fill_color ( str ) \u2013 Sets the fill color of the default labels generated when labels is set to True . Has no effect for other values of label . vertex_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying vertices in the scene. vertex_config ( dict | None ) \u2013 A dictionary containing keyword arguments to be passed to\nthe class specified via vertex_type . vertex_mobject ( dict | None ) \u2013 The mobject to be used as the vertex. Overrides all other\nvertex customization options. Return type : Mobject static _empty_networkx_graph ( ) [source]   Return an empty networkx graph for the given graph type. Return type : Graph _original__init__ ( vertices , edges , labels=False , label_fill_color=ManimColor('#000000') , layout='spring' , layout_scale=2 , layout_config=None , vertex_type=<class 'manim.mobject.geometry.arc.Dot'> , vertex_config=None , vertex_mobjects=None , edge_type=<class 'manim.mobject.geometry.line.Line'> , partitions=None , root_vertex=None , edge_config=None )   Initialize self.  See help(type(self)) for accurate signature. Parameters : vertices ( Sequence [ Hashable ] ) edges ( Sequence [ tuple [ Hashable , Hashable ] ] ) labels ( bool | dict ) label_fill_color ( str ) layout ( Literal [ 'circular' , 'kamada_kawai' , 'partite' , 'planar' , 'random' , 'shell' , 'spectral' , 'spiral' , 'spring' , 'tree' ] | dict [ ~collections.abc.Hashable , ~manim.typing.Point3DLike ] | ~manim.mobject.graph.LayoutFunction ) layout_scale ( float | tuple [ float , float , float ] ) layout_config ( dict | None ) vertex_type ( type [ Mobject ] ) vertex_config ( dict | None ) vertex_mobjects ( dict | None ) edge_type ( type [ Mobject ] ) partitions ( Sequence [ Sequence [ Hashable ] ] | None ) root_vertex ( Hashable | None ) edge_config ( dict | None ) Return type : None _populate_edge_dict ( edges , edge_type ) [source]   Helper method for populating the edges of the graph. Parameters : edges ( list [ tuple [ Hashable , Hashable ] ] ) edge_type ( type [ Mobject ] ) _remove_edge ( edge ) [source]   Remove an edge from the graph. Parameters : edge ( tuple [ Hashable ] ) \u2013 The edge (i.e., a tuple of vertex identifiers) to be removed from the graph. Returns : The removed edge. Return type : Mobject _remove_vertex ( vertex ) [source]   Remove a vertex (as well as all incident edges) from the graph. Parameters : vertex \u2013 The identifier of a vertex to be removed. Returns : A mobject containing all removed objects. Return type : Group add_edges ( *edges , edge_type=<class 'manim.mobject.geometry.line.Line'> , edge_config=None , **kwargs ) [source]   Add new edges to the graph. Parameters : edges ( tuple [ Hashable , Hashable ] ) \u2013 Edges (as tuples of vertex identifiers) to be added. If a non-existing\nvertex is passed, a new vertex with default settings will be created. Create\nnew vertices yourself beforehand to customize them. edge_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying edges in the scene. edge_config ( dict | None ) \u2013 A dictionary either containing keyword arguments to be passed\nto the class specified via edge_type , or a dictionary\nwhose keys are the edge tuples, and whose values are dictionaries\ncontaining keyword arguments to be passed for the construction\nof the corresponding edge. kwargs \u2013 Any further keyword arguments are passed to add_vertices() which is used to create new vertices in the passed edges. Returns : A group containing all newly added vertices and edges. Return type : Group add_vertices ( *vertices , positions=None , labels=False , label_fill_color=ManimColor('#000000') , vertex_type=<class 'manim.mobject.geometry.arc.Dot'> , vertex_config=None , vertex_mobjects=None ) [source]   Add a list of vertices to the graph. Parameters : vertices ( Hashable ) \u2013 Hashable vertex identifiers. positions ( dict | None ) \u2013 A dictionary specifying the coordinates where the new vertices should be added.\nIf None , all vertices are created at the center of the graph. labels ( bool ) \u2013 Controls whether or not the vertex is labeled. If False (the default),\nthe vertex is not labeled; if True it is labeled using its\nnames (as specified in vertex ) via MathTex . Alternatively,\nany Mobject can be passed to be used as the label. label_fill_color ( str ) \u2013 Sets the fill color of the default labels generated when labels is set to True . Has no effect for other values of labels . vertex_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying vertices in the scene. vertex_config ( dict | None ) \u2013 A dictionary containing keyword arguments to be passed to\nthe class specified via vertex_type . vertex_mobjects ( dict | None ) \u2013 A dictionary whose keys are the vertex identifiers, and whose\nvalues are mobjects that should be used as vertices. Overrides\nall other vertex customization options. self ( Graph ) change_layout ( layout = 'spring' , layout_scale = 2 , layout_config = None , partitions = None , root_vertex = None ) [source]   Change the layout of this graph. See the documentation of Graph for details about the\nkeyword arguments. Examples Example: ChangeGraphLayout   from manim import * class ChangeGraphLayout ( Scene ): def construct ( self ): G = Graph ([ 1 , 2 , 3 , 4 , 5 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 5 )], layout = { 1 : [ - 2 , 0 , 0 ], 2 : [ - 1 , 0 , 0 ], 3 : [ 0 , 0 , 0 ], 4 : [ 1 , 0 , 0 ], 5 : [ 2 , 0 , 0 ]} ) self . play ( Create ( G )) self . play ( G . animate . change_layout ( \"circular\" )) self . wait () class ChangeGraphLayout(Scene):\n    def construct(self):\n        G = Graph([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)],\n                  layout={1: [-2, 0, 0], 2: [-1, 0, 0], 3: [0, 0, 0],\n                          4: [1, 0, 0], 5: [2, 0, 0]}\n                  )\n        self.play(Create(G))\n        self.play(G.animate.change_layout(\"circular\"))\n        self.wait() Parameters : layout ( Literal [ 'circular' , 'kamada_kawai' , 'partite' , 'planar' , 'random' , 'shell' , 'spectral' , 'spiral' , 'spring' , 'tree' ] | dict [ ~collections.abc.Hashable , ~manim.typing.Point3DLike ] | ~manim.mobject.graph.LayoutFunction ) layout_scale ( float | tuple [ float , float , float ] ) layout_config ( dict [ str , Any ] | None ) partitions ( list [ list [ Hashable ] ] | None ) root_vertex ( Hashable | None ) Return type : Graph classmethod from_networkx ( nxgraph , ** kwargs ) [source]   Build a Graph or DiGraph from a\ngiven networkx graph. Parameters : nxgraph ( Graph | DiGraph ) \u2013 A networkx graph or digraph. **kwargs \u2013 Keywords to be passed to the constructor of Graph . Examples Example: ImportNetworkxGraph   from manim import * import networkx as nx nxgraph = nx . erdos_renyi_graph ( 14 , 0.5 ) class ImportNetworkxGraph ( Scene ): def construct ( self ): G = Graph . from_networkx ( nxgraph , layout = \"spring\" , layout_scale = 3.5 ) self . play ( Create ( G )) self . play ( * [ G [ v ] . animate . move_to ( 5 * RIGHT * np . cos ( ind / 7 * PI ) + 3 * UP * np . sin ( ind / 7 * PI )) for ind , v in enumerate ( G . vertices )]) self . play ( Uncreate ( G )) import networkx as nx\n\nnxgraph = nx.erdos_renyi_graph(14, 0.5)\n\nclass ImportNetworkxGraph(Scene):\n    def construct(self):\n        G = Graph.from_networkx(nxgraph, layout=\"spring\", layout_scale=3.5)\n        self.play(Create(G))\n        self.play(*[G[v].animate.move_to(5*RIGHT*np.cos(ind/7 * PI) +\n                                         3*UP*np.sin(ind/7 * PI))\n                    for ind, v in enumerate(G.vertices)])\n        self.play(Uncreate(G)) remove_edges ( * edges ) [source]   Remove several edges from the graph. Parameters : edges ( tuple [ Hashable ] ) \u2013 Edges to be removed from the graph. Returns : A group containing all removed edges. Return type : Group remove_vertices ( * vertices ) [source]   Remove several vertices from the graph. Parameters : vertices \u2013 Vertices to be removed from the graph. Examples >>> G = Graph ([ 1 , 2 , 3 ], [( 1 , 2 ), ( 2 , 3 )]) >>> removed = G . remove_vertices ( 2 , 3 ); removed VGroup(Line, Line, Dot, Dot) >>> G Undirected graph on 1 vertices and 0 edges", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.GenericGraph.html"}
{"prompt": "class Graph(vertices, edges, labels=False, label_fill_color=ManimColor('#000000'), layout='spring', layout_scale=2, layout_config=None, vertex_type=<class 'manim.mobject.geometry.arc.Dot'>, vertex_config=None, vertex_mobjects=None, edge_type=<class 'manim.mobject.geometry.line.Line'>, partitions=None, root_vertex=None, edge_config=None)", "response": "Bases: GenericGraph An undirected graph (vertices connected with edges). The graph comes with an updater which makes the edges stick to\nthe vertices when moved around. See DiGraph for\na version with directed edges. See also GenericGraph Parameters : vertices ( Sequence [ Hashable ] ) \u2013 A list of vertices. Must be hashable elements. edges ( Sequence [ tuple [ Hashable , Hashable ] ] ) \u2013 A list of edges, specified as tuples (u, v) where both u and v are vertices. The vertex order is irrelevant. labels ( bool | dict ) \u2013 Controls whether or not vertices are labeled. If False (the default),\nthe vertices are not labeled; if True they are labeled using their\nnames (as specified in vertices ) via MathTex . Alternatively,\ncustom labels can be specified by passing a dictionary whose keys are\nthe vertices, and whose values are the corresponding vertex labels\n(rendered via, e.g., Text or Tex ). label_fill_color ( str ) \u2013 Sets the fill color of the default labels generated when labels is set to True . Has no effect for other values of labels . layout ( LayoutName | dict [ Hashable , Point3DLike ] | LayoutFunction ) \u2013 Either one of \"spring\" (the default), \"circular\" , \"kamada_kawai\" , \"planar\" , \"random\" , \"shell\" , \"spectral\" , \"spiral\" , \"tree\" , and \"partite\" for automatic vertex positioning using networkx (see their documentation for more details), or a dictionary specifying a coordinate (value)\nfor each vertex (key) for manual positioning. layout_config ( dict | None ) \u2013 Only for automatically generated layouts. A dictionary whose entries\nare passed as keyword arguments to the automatic layout algorithm\nspecified via layout of networkx .\nThe tree layout also accepts a special parameter vertex_spacing passed as a keyword argument inside the layout_config dictionary.\nPassing a tuple (space_x, space_y) as this argument overrides\nthe value of layout_scale and ensures that vertices are arranged\nin a way such that the centers of siblings in the same layer are\nat least space_x units apart horizontally, and neighboring layers\nare spaced space_y units vertically. layout_scale ( float | tuple [ float , float , float ] ) \u2013 The scale of automatically generated layouts: the vertices will\nbe arranged such that the coordinates are located within the\ninterval [-scale, scale] . Some layouts accept a tuple (scale_x, scale_y) causing the first coordinate to be in the interval [-scale_x, scale_x] ,\nand the second in [-scale_y, scale_y] . Default: 2. vertex_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying vertices in the scene. vertex_config ( dict | None ) \u2013 Either a dictionary containing keyword arguments to be passed to\nthe class specified via vertex_type , or a dictionary whose keys\nare the vertices, and whose values are dictionaries containing keyword\narguments for the mobject related to the corresponding vertex. vertex_mobjects ( dict | None ) \u2013 A dictionary whose keys are the vertices, and whose values are\nmobjects to be used as vertices. Passing vertices here overrides\nall other configuration options for a vertex. edge_type ( type [ Mobject ] ) \u2013 The mobject class used for displaying edges in the scene. edge_config ( dict | None ) \u2013 Either a dictionary containing keyword arguments to be passed\nto the class specified via edge_type , or a dictionary whose\nkeys are the edges, and whose values are dictionaries containing\nkeyword arguments for the mobject related to the corresponding edge. partitions ( Sequence [ Sequence [ Hashable ] ] | None ) root_vertex ( Hashable | None ) Examples First, we create a small graph and demonstrate that the edges move\ntogether with the vertices. Example: MovingVertices   from manim import * class MovingVertices ( Scene ): def construct ( self ): vertices = [ 1 , 2 , 3 , 4 ] edges = [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 1 , 3 ), ( 1 , 4 )] g = Graph ( vertices , edges ) self . play ( Create ( g )) self . wait () self . play ( g [ 1 ] . animate . move_to ([ 1 , 1 , 0 ]), g [ 2 ] . animate . move_to ([ - 1 , 1 , 0 ]), g [ 3 ] . animate . move_to ([ 1 , - 1 , 0 ]), g [ 4 ] . animate . move_to ([ - 1 , - 1 , 0 ])) self . wait () class MovingVertices(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]\n        g = Graph(vertices, edges)\n        self.play(Create(g))\n        self.wait()\n        self.play(g[1].animate.move_to([1, 1, 0]),\n                  g[2].animate.move_to([-1, 1, 0]),\n                  g[3].animate.move_to([1, -1, 0]),\n                  g[4].animate.move_to([-1, -1, 0]))\n        self.wait() There are several automatic positioning algorithms to choose from: Example: GraphAutoPosition   from manim import * class GraphAutoPosition ( Scene ): def construct ( self ): vertices = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] edges = [( 1 , 7 ), ( 1 , 8 ), ( 2 , 3 ), ( 2 , 4 ), ( 2 , 5 ), ( 2 , 8 ), ( 3 , 4 ), ( 6 , 1 ), ( 6 , 2 ), ( 6 , 3 ), ( 7 , 2 ), ( 7 , 4 )] autolayouts = [ \"spring\" , \"circular\" , \"kamada_kawai\" , \"planar\" , \"random\" , \"shell\" , \"spectral\" , \"spiral\" ] graphs = [ Graph ( vertices , edges , layout = lt ) . scale ( 0.5 ) for lt in autolayouts ] r1 = VGroup ( * graphs [: 3 ]) . arrange () r2 = VGroup ( * graphs [ 3 : 6 ]) . arrange () r3 = VGroup ( * graphs [ 6 :]) . arrange () self . add ( VGroup ( r1 , r2 , r3 ) . arrange ( direction = DOWN )) class GraphAutoPosition(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4, 5, 6, 7, 8]\n        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\n                 (2, 8), (3, 4), (6, 1), (6, 2),\n                 (6, 3), (7, 2), (7, 4)]\n        autolayouts = [\"spring\", \"circular\", \"kamada_kawai\",\n                       \"planar\", \"random\", \"shell\",\n                       \"spectral\", \"spiral\"]\n        graphs = [Graph(vertices, edges, layout=lt).scale(0.5)\n                  for lt in autolayouts]\n        r1 = VGroup(*graphs[:3]).arrange()\n        r2 = VGroup(*graphs[3:6]).arrange()\n        r3 = VGroup(*graphs[6:]).arrange()\n        self.add(VGroup(r1, r2, r3).arrange(direction=DOWN)) Vertices can also be positioned manually: Example: GraphManualPosition   from manim import * class GraphManualPosition ( Scene ): def construct ( self ): vertices = [ 1 , 2 , 3 , 4 ] edges = [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 1 )] lt = { 1 : [ 0 , 0 , 0 ], 2 : [ 1 , 1 , 0 ], 3 : [ 1 , - 1 , 0 ], 4 : [ - 1 , 0 , 0 ]} G = Graph ( vertices , edges , layout = lt ) self . add ( G ) class GraphManualPosition(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2), (2, 3), (3, 4), (4, 1)]\n        lt = {1: [0, 0, 0], 2: [1, 1, 0], 3: [1, -1, 0], 4: [-1, 0, 0]}\n        G = Graph(vertices, edges, layout=lt)\n        self.add(G) The vertices in graphs can be labeled, and configurations for vertices\nand edges can be modified both by default and for specific vertices and\nedges. Note In edge_config , edges can be passed in both directions: if (u, v) is an edge in the graph, both (u, v) as well\nas (v, u) can be used as keys in the dictionary. Example: LabeledModifiedGraph   from manim import * class LabeledModifiedGraph ( Scene ): def construct ( self ): vertices = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] edges = [( 1 , 7 ), ( 1 , 8 ), ( 2 , 3 ), ( 2 , 4 ), ( 2 , 5 ), ( 2 , 8 ), ( 3 , 4 ), ( 6 , 1 ), ( 6 , 2 ), ( 6 , 3 ), ( 7 , 2 ), ( 7 , 4 )] g = Graph ( vertices , edges , layout = \"circular\" , layout_scale = 3 , labels = True , vertex_config = { 7 : { \"fill_color\" : RED }}, edge_config = {( 1 , 7 ): { \"stroke_color\" : RED }, ( 2 , 7 ): { \"stroke_color\" : RED }, ( 4 , 7 ): { \"stroke_color\" : RED }}) self . add ( g ) class LabeledModifiedGraph(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4, 5, 6, 7, 8]\n        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\n                 (2, 8), (3, 4), (6, 1), (6, 2),\n                 (6, 3), (7, 2), (7, 4)]\n        g = Graph(vertices, edges, layout=\"circular\", layout_scale=3,\n                  labels=True, vertex_config={7: {\"fill_color\": RED}},\n                  edge_config={(1, 7): {\"stroke_color\": RED},\n                               (2, 7): {\"stroke_color\": RED},\n                               (4, 7): {\"stroke_color\": RED}})\n        self.add(g) You can also lay out a partite graph on columns by specifying\na list of the vertices on each side and choosing the partite layout. Note All vertices in your graph which are not listed in any of the partitions\nare collected in their own partition and rendered in the rightmost column. Example: PartiteGraph   from manim import * import networkx as nx class PartiteGraph ( Scene ): def construct ( self ): G = nx . Graph () G . add_nodes_from ([ 0 , 1 , 2 , 3 ]) G . add_edges_from ([( 0 , 2 ), ( 0 , 3 ), ( 1 , 2 )]) graph = Graph ( list ( G . nodes ), list ( G . edges ), layout = \"partite\" , partitions = [[ 0 , 1 ]]) self . play ( Create ( graph )) import networkx as nx\n\nclass PartiteGraph(Scene):\n    def construct(self):\n        G = nx.Graph()\n        G.add_nodes_from([0, 1, 2, 3])\n        G.add_edges_from([(0, 2), (0,3), (1, 2)])\n        graph = Graph(list(G.nodes), list(G.edges), layout=\"partite\", partitions=[[0, 1]])\n        self.play(Create(graph)) The representation of a linear artificial neural network is facilitated\nby the use of the partite layout and defining partitions for each layer. Example: LinearNN   from manim import * class LinearNN ( Scene ): def construct ( self ): edges = [] partitions = [] c = 0 layers = [ 2 , 3 , 3 , 2 ] # the number of neurons in each layer for i in layers : partitions . append ( list ( range ( c + 1 , c + i + 1 ))) c += i for i , v in enumerate ( layers [ 1 :]): last = sum ( layers [: i + 1 ]) for j in range ( v ): for k in range ( last - layers [ i ], last ): edges . append (( k + 1 , j + last + 1 )) vertices = np . arange ( 1 , sum ( layers ) + 1 ) graph = Graph ( vertices , edges , layout = 'partite' , partitions = partitions , layout_scale = 3 , vertex_config = { 'radius' : 0.20 }, ) self . add ( graph ) class LinearNN(Scene):\n    def construct(self):\n        edges = []\n        partitions = []\n        c = 0\n        layers = [2, 3, 3, 2]  # the number of neurons in each layer\n\n        for i in layers:\n            partitions.append(list(range(c + 1, c + i + 1)))\n            c += i\n        for i, v in enumerate(layers[1:]):\n                last = sum(layers[:i+1])\n                for j in range(v):\n                    for k in range(last - layers[i], last):\n                        edges.append((k + 1, j + last + 1))\n\n        vertices = np.arange(1, sum(layers) + 1)\n\n        graph = Graph(\n            vertices,\n            edges,\n            layout='partite',\n            partitions=partitions,\n            layout_scale=3,\n            vertex_config={'radius': 0.20},\n        )\n        self.add(graph) The custom tree layout can be used to show the graph\nby distance from the root vertex. You must pass the root vertex\nof the tree. Example: Tree   from manim import * import networkx as nx class Tree ( Scene ): def construct ( self ): G = nx . Graph () G . add_node ( \"ROOT\" ) for i in range ( 5 ): G . add_node ( \"Child_ %i \" % i ) G . add_node ( \"Grandchild_ %i \" % i ) G . add_node ( \"Greatgrandchild_ %i \" % i ) G . add_edge ( \"ROOT\" , \"Child_ %i \" % i ) G . add_edge ( \"Child_ %i \" % i , \"Grandchild_ %i \" % i ) G . add_edge ( \"Grandchild_ %i \" % i , \"Greatgrandchild_ %i \" % i ) self . play ( Create ( Graph ( list ( G . nodes ), list ( G . edges ), layout = \"tree\" , root_vertex = \"ROOT\" ))) import networkx as nx\n\nclass Tree(Scene):\n    def construct(self):\n        G = nx.Graph()\n\n        G.add_node(\"ROOT\")\n\n        for i in range(5):\n            G.add_node(\"Child_%i\" % i)\n            G.add_node(\"Grandchild_%i\" % i)\n            G.add_node(\"Greatgrandchild_%i\" % i)\n\n            G.add_edge(\"ROOT\", \"Child_%i\" % i)\n            G.add_edge(\"Child_%i\" % i, \"Grandchild_%i\" % i)\n            G.add_edge(\"Grandchild_%i\" % i, \"Greatgrandchild_%i\" % i)\n\n        self.play(Create(\n            Graph(list(G.nodes), list(G.edges), layout=\"tree\", root_vertex=\"ROOT\"))) The following code sample illustrates the use of the vertex_spacing layout parameter specific to the \"tree\" layout. As mentioned\nabove, setting vertex_spacing overrides the specified value\nfor layout_scale , and as such it is harder to control the size\nof the mobject. However, we can adjust the captured frame and\nzoom out by using a MovingCameraScene : class LargeTreeGeneration ( MovingCameraScene ): DEPTH = 4 CHILDREN_PER_VERTEX = 3 LAYOUT_CONFIG = { \"vertex_spacing\" : ( 0.5 , 1 )} VERTEX_CONF = { \"radius\" : 0.25 , \"color\" : BLUE_B , \"fill_opacity\" : 1 } def expand_vertex ( self , g , vertex_id : str , depth : int ): new_vertices = [ f \" { vertex_id } / { i } \" for i in range ( self . CHILDREN_PER_VERTEX ) ] new_edges = [( vertex_id , child_id ) for child_id in new_vertices ] g . add_edges ( * new_edges , vertex_config = self . VERTEX_CONF , positions = { k : g . vertices [ vertex_id ] . get_center () + 0.1 * DOWN for k in new_vertices }, ) if depth < self . DEPTH : for child_id in new_vertices : self . expand_vertex ( g , child_id , depth + 1 ) return g def construct ( self ): g = Graph ([ \"ROOT\" ], [], vertex_config = self . VERTEX_CONF ) g = self . expand_vertex ( g , \"ROOT\" , 1 ) self . add ( g ) self . play ( g . animate . change_layout ( \"tree\" , root_vertex = \"ROOT\" , layout_config = self . LAYOUT_CONFIG , ) ) self . play ( self . camera . auto_zoom ( g , margin = 1 ), run_time = 0.5 ) Methods update_edges Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. static _empty_networkx_graph ( ) [source]   Return an empty networkx graph for the given graph type. Return type : Graph _original__init__ ( vertices , edges , labels=False , label_fill_color=ManimColor('#000000') , layout='spring' , layout_scale=2 , layout_config=None , vertex_type=<class 'manim.mobject.geometry.arc.Dot'> , vertex_config=None , vertex_mobjects=None , edge_type=<class 'manim.mobject.geometry.line.Line'> , partitions=None , root_vertex=None , edge_config=None )   Initialize self.  See help(type(self)) for accurate signature. Parameters : vertices ( Sequence [ Hashable ] ) edges ( Sequence [ tuple [ Hashable , Hashable ] ] ) labels ( bool | dict ) label_fill_color ( str ) layout ( Literal [ 'circular' , 'kamada_kawai' , 'partite' , 'planar' , 'random' , 'shell' , 'spectral' , 'spiral' , 'spring' , 'tree' ] | dict [ ~collections.abc.Hashable , ~manim.typing.Point3DLike ] | ~manim.mobject.graph.LayoutFunction ) layout_scale ( float | tuple [ float , float , float ] ) layout_config ( dict | None ) vertex_type ( type [ Mobject ] ) vertex_config ( dict | None ) vertex_mobjects ( dict | None ) edge_type ( type [ Mobject ] ) partitions ( Sequence [ Sequence [ Hashable ] ] | None ) root_vertex ( Hashable | None ) edge_config ( dict | None ) Return type : None _populate_edge_dict ( edges , edge_type ) [source]   Helper method for populating the edges of the graph. Parameters : edges ( list [ tuple [ Hashable , Hashable ] ] ) edge_type ( type [ Mobject ] )", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.Graph.html"}
{"prompt": "class LayoutFunction(*args, **kwargs)", "response": "Bases: Protocol A protocol for automatic layout functions that compute a layout for a graph to be used in change_layout() . Note The layout function must be a pure function, i.e., it must not modify the graph passed to it. Examples Here is an example that arranges nodes in an n x m grid in sorted order. Example: CustomLayoutExample   from manim import * class CustomLayoutExample ( Scene ): def construct ( self ): import numpy as np import networkx as nx # create custom layout def custom_layout ( graph : nx . Graph , scale : float | tuple [ float , float , float ] = 2 , n : int | None = None , * args : Any , ** kwargs : Any , ): nodes = sorted ( list ( graph )) height = len ( nodes ) // n return { node : ( scale * np . array ([ ( i % n ) - ( n - 1 ) / 2 , - ( i // n ) + height / 2 , 0 ])) for i , node in enumerate ( graph ) } # draw graph n = 4 graph = Graph ( [ i for i in range ( 4 * 2 - 1 )], [( 0 , 1 ), ( 0 , 4 ), ( 1 , 2 ), ( 1 , 5 ), ( 2 , 3 ), ( 2 , 6 ), ( 4 , 5 ), ( 5 , 6 )], labels = True , layout = custom_layout , layout_config = { 'n' : n } ) self . add ( graph ) class CustomLayoutExample(Scene):\n    def construct(self):\n        import numpy as np\n        import networkx as nx\n\n        # create custom layout\n        def custom_layout(\n            graph: nx.Graph,\n            scale: float | tuple[float, float, float] = 2,\n            n: int | None = None,\n            *args: Any,\n            **kwargs: Any,\n        ):\n            nodes = sorted(list(graph))\n            height = len(nodes) // n\n            return {\n                node: (scale * np.array([\n                    (i % n) - (n-1)/2,\n                    -(i // n) + height/2,\n                    0\n                ])) for i, node in enumerate(graph)\n            }\n\n        # draw graph\n        n = 4\n        graph = Graph(\n            [i for i in range(4 * 2 - 1)],\n            [(0, 1), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (4, 5), (5, 6)],\n            labels=True,\n            layout=custom_layout,\n            layout_config={'n': n}\n        )\n        self.add(graph) Several automatic layouts are provided by manim, and can be used by passing their name as the layout parameter to change_layout() .\nAlternatively, a custom layout function can be passed to change_layout() as the layout parameter. Such a function must adhere to the LayoutFunction protocol. The LayoutFunction s provided by manim are illustrated below: Circular Layout: places the vertices on a circle Example: CircularLayout   from manim import * class CircularLayout ( Scene ): def construct ( self ): graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 5 ), ( 5 , 6 ), ( 6 , 1 ), ( 5 , 1 ), ( 1 , 3 ), ( 3 , 5 )], layout = \"circular\" , labels = True ) self . add ( graph ) class CircularLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"circular\",\n            labels=True\n        )\n        self.add(graph) Kamada Kawai Layout: tries to place the vertices such that the given distances between them are respected Example: KamadaKawaiLayout   from manim import * class KamadaKawaiLayout ( Scene ): def construct ( self ): from collections import defaultdict distances : dict [ int , dict [ int , float ]] = defaultdict ( dict ) # set desired distances distances [ 1 ][ 2 ] = 1 # distance between vertices 1 and 2 is 1 distances [ 2 ][ 3 ] = 1 # distance between vertices 2 and 3 is 1 distances [ 3 ][ 4 ] = 2 # etc distances [ 4 ][ 5 ] = 3 distances [ 5 ][ 6 ] = 5 distances [ 6 ][ 1 ] = 8 graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 5 ), ( 5 , 6 ), ( 6 , 1 )], layout = \"kamada_kawai\" , layout_config = { \"dist\" : distances }, layout_scale = 4 , labels = True ) self . add ( graph ) class KamadaKawaiLayout(Scene):\n    def construct(self):\n        from collections import defaultdict\n        distances: dict[int, dict[int, float]] = defaultdict(dict)\n\n        # set desired distances\n        distances[1][2] = 1  # distance between vertices 1 and 2 is 1\n        distances[2][3] = 1  # distance between vertices 2 and 3 is 1\n        distances[3][4] = 2  # etc\n        distances[4][5] = 3\n        distances[5][6] = 5\n        distances[6][1] = 8\n\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)],\n            layout=\"kamada_kawai\",\n            layout_config={\"dist\": distances},\n            layout_scale=4,\n            labels=True\n        )\n        self.add(graph) Partite Layout: places vertices into distinct partitions Example: PartiteLayout   from manim import * class PartiteLayout ( Scene ): def construct ( self ): graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 5 ), ( 5 , 6 ), ( 6 , 1 ), ( 5 , 1 ), ( 1 , 3 ), ( 3 , 5 )], layout = \"partite\" , layout_config = { \"partitions\" : [[ 1 , 2 ],[ 3 , 4 ],[ 5 , 6 ]]}, labels = True ) self . add ( graph ) class PartiteLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"partite\",\n            layout_config={\"partitions\": [[1,2],[3,4],[5,6]]},\n            labels=True\n        )\n        self.add(graph) Planar Layout: places vertices such that edges do not cross Example: PlanarLayout   from manim import * class PlanarLayout ( Scene ): def construct ( self ): graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 5 ), ( 5 , 6 ), ( 6 , 1 ), ( 5 , 1 ), ( 1 , 3 ), ( 3 , 5 )], layout = \"planar\" , layout_scale = 4 , labels = True ) self . add ( graph ) class PlanarLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"planar\",\n            layout_scale=4,\n            labels=True\n        )\n        self.add(graph) Random Layout: randomly places vertices Example: RandomLayout   from manim import * class RandomLayout ( Scene ): def construct ( self ): graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 5 ), ( 5 , 6 ), ( 6 , 1 ), ( 5 , 1 ), ( 1 , 3 ), ( 3 , 5 )], layout = \"random\" , labels = True ) self . add ( graph ) class RandomLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"random\",\n            labels=True\n        )\n        self.add(graph) Shell Layout: places vertices in concentric circles Example: ShellLayout   from manim import * class ShellLayout ( Scene ): def construct ( self ): nlist = [[ 1 , 2 , 3 ], [ 4 , 5 , 6 , 7 , 8 , 9 ]] graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 1 ), ( 4 , 1 ), ( 4 , 2 ), ( 5 , 2 ), ( 6 , 2 ), ( 6 , 3 ), ( 7 , 3 ), ( 8 , 3 ), ( 8 , 1 ), ( 9 , 1 )], layout = \"shell\" , layout_config = { \"nlist\" : nlist }, labels = True ) self . add ( graph ) class ShellLayout(Scene):\n    def construct(self):\n        nlist = [[1, 2, 3], [4, 5, 6, 7, 8, 9]]\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6, 7, 8, 9],\n            [(1, 2), (2, 3), (3, 1), (4, 1), (4, 2), (5, 2), (6, 2), (6, 3), (7, 3), (8, 3), (8, 1), (9, 1)],\n            layout=\"shell\",\n            layout_config={\"nlist\": nlist},\n            labels=True\n        )\n        self.add(graph) Spectral Layout: places vertices using the eigenvectors of the graph Laplacian (clusters nodes which are an approximation of the ratio cut) Example: SpectralLayout   from manim import * class SpectralLayout ( Scene ): def construct ( self ): graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 5 ), ( 5 , 6 ), ( 6 , 1 ), ( 5 , 1 ), ( 1 , 3 ), ( 3 , 5 )], layout = \"spectral\" , labels = True ) self . add ( graph ) class SpectralLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spectral\",\n            labels=True\n        )\n        self.add(graph) Sprial Layout: places vertices in a spiraling pattern Example: SpiralLayout   from manim import * class SpiralLayout ( Scene ): def construct ( self ): graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 5 ), ( 5 , 6 ), ( 6 , 1 ), ( 5 , 1 ), ( 1 , 3 ), ( 3 , 5 )], layout = \"spiral\" , labels = True ) self . add ( graph ) class SpiralLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spiral\",\n            labels=True\n        )\n        self.add(graph) Spring Layout: places nodes according to the Fruchterman-Reingold force-directed algorithm (attempts to minimize edge length while maximizing node separation) Example: SpringLayout   from manim import * class SpringLayout ( Scene ): def construct ( self ): graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 ], [( 1 , 2 ), ( 2 , 3 ), ( 3 , 4 ), ( 4 , 5 ), ( 5 , 6 ), ( 6 , 1 ), ( 5 , 1 ), ( 1 , 3 ), ( 3 , 5 )], layout = \"spring\" , labels = True ) self . add ( graph ) class SpringLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spring\",\n            labels=True\n        )\n        self.add(graph) Tree Layout: places vertices into a tree with a root node and branches (can only be used with legal trees) Example: TreeLayout   from manim import * class TreeLayout ( Scene ): def construct ( self ): graph = Graph ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ], [( 1 , 2 ), ( 1 , 3 ), ( 2 , 4 ), ( 2 , 5 ), ( 3 , 6 ), ( 3 , 7 )], layout = \"tree\" , layout_config = { \"root_vertex\" : 1 }, labels = True ) self . add ( graph ) class TreeLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6, 7],\n            [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)],\n            layout=\"tree\",\n            layout_config={\"root_vertex\": 1},\n            labels=True\n        )\n        self.add(graph) Methods", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html"}
{"prompt": "class ManimBanner(dark_theme=True)", "response": "Bases: VGroup Convenience class representing Manim\u2019s banner. Can be animated using custom methods. Parameters : dark_theme ( bool ) \u2013 If True (the default), the dark theme version of the logo\n(with light text font) will be rendered. Otherwise, if False ,\nthe light theme version (with dark text font) is used. Examples Example: DarkThemeBanner   from manim import * class DarkThemeBanner ( Scene ): def construct ( self ): banner = ManimBanner () self . play ( banner . create ()) self . play ( banner . expand ()) self . wait () self . play ( Unwrite ( banner )) class DarkThemeBanner(Scene):\n    def construct(self):\n        banner = ManimBanner()\n        self.play(banner.create())\n        self.play(banner.expand())\n        self.wait()\n        self.play(Unwrite(banner)) Example: LightThemeBanner   from manim import * class LightThemeBanner ( Scene ): def construct ( self ): self . camera . background_color = \"#ece6e2\" banner = ManimBanner ( dark_theme = False ) self . play ( banner . create ()) self . play ( banner . expand ()) self . wait () self . play ( Unwrite ( banner )) class LightThemeBanner(Scene):\n    def construct(self):\n        self.camera.background_color = \"#ece6e2\"\n        banner = ManimBanner(dark_theme=False)\n        self.play(banner.create())\n        self.play(banner.expand())\n        self.wait()\n        self.play(Unwrite(banner)) Methods create The creation animation for Manim's logo. expand An animation that expands Manim's logo into its banner. scale Scale the banner by the specified scale factor. Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( dark_theme = True )   Initialize self.  See help(type(self)) for accurate signature. Parameters : dark_theme ( bool ) create ( run_time = 2 ) [source]   The creation animation for Manim\u2019s logo. Parameters : run_time ( float ) \u2013 The run time of the animation. Returns : An animation to be used in a Scene.play() call. Return type : AnimationGroup expand ( run_time = 1.5 , direction = 'center' ) [source]   An animation that expands Manim\u2019s logo into its banner. The returned animation transforms the banner from its initial\nstate (representing Manim\u2019s logo with just the icons) to its\nexpanded state (showing the full name together with the icons). See the class documentation for how to use this. Note Before calling this method, the text \u201canim\u201d is not a\nsubmobject of the banner object. After the expansion,\nit is added as a submobject so subsequent animations\nto the banner object apply to the text \u201canim\u201d as well. Parameters : run_time ( float ) \u2013 The run time of the animation. direction \u2013 The direction in which the logo is expanded. Returns : An animation to be used in a Scene.play() call. Return type : Succession Examples Example: ExpandDirections   from manim import * class ExpandDirections ( Scene ): def construct ( self ): banners = [ ManimBanner () . scale ( 0.5 ) . shift ( UP * x ) for x in [ - 2 , 0 , 2 ]] self . play ( banners [ 0 ] . expand ( direction = \"right\" ), banners [ 1 ] . expand ( direction = \"center\" ), banners [ 2 ] . expand ( direction = \"left\" ), ) class ExpandDirections(Scene):\n    def construct(self):\n        banners = [ManimBanner().scale(0.5).shift(UP*x) for x in [-2, 0, 2]]\n        self.play(\n            banners[0].expand(direction=\"right\"),\n            banners[1].expand(direction=\"center\"),\n            banners[2].expand(direction=\"left\"),\n        ) scale ( scale_factor , ** kwargs ) [source]   Scale the banner by the specified scale factor. Parameters : scale_factor ( float ) \u2013 The factor used for scaling the banner. Returns : The scaled banner. Return type : ManimBanner", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.logo.ManimBanner.html"}
{"prompt": "get_det_text(matrix, determinant=None, background_rect=False, initial_scale_factor=2)", "response": "Helper function to create determinant. Parameters : matrix ( Matrix ) \u2013 The matrix whose determinant is to be created determinant ( int | str | None ) \u2013 The value of the determinant of the matrix background_rect ( bool ) \u2013 The background rectangle initial_scale_factor ( float ) \u2013 The scale of the text det w.r.t the matrix Returns : A VGroup containing the determinant Return type : VGroup Examples Example: DeterminantOfAMatrix   from manim import * class DeterminantOfAMatrix ( Scene ): def construct ( self ): matrix = Matrix ([ [ 2 , 0 ], [ - 1 , 1 ] ]) # scaling down the `det` string det = get_det_text ( matrix , determinant = 3 , initial_scale_factor = 1 ) # must add the matrix self . add ( matrix ) self . add ( det ) class DeterminantOfAMatrix(Scene):\n    def construct(self):\n        matrix = Matrix([\n            [2, 0],\n            [-1, 1]\n        ])\n\n        # scaling down the `det` string\n        det = get_det_text(matrix,\n                    determinant=3,\n                    initial_scale_factor=1)\n\n        # must add the matrix\n        self.add(matrix)\n        self.add(det)", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.html"}
{"prompt": "class DecimalMatrix(matrix, element_to_mobject=<class 'manim.mobject.text.numbers.DecimalNumber'>, element_to_mobject_config={'num_decimal_places': 1}, **kwargs)", "response": "Bases: Matrix A mobject that displays a matrix with decimal entries on the screen. Examples Example: DecimalMatrixExample   from manim import * class DecimalMatrixExample ( Scene ): def construct ( self ): m0 = DecimalMatrix ( [[ 3.456 , 2.122 ], [ 33.2244 , 12 ]], element_to_mobject_config = { \"num_decimal_places\" : 2 }, left_bracket = \" \\\\ {\" , right_bracket = \" \\\\ }\" ) self . add ( m0 ) class DecimalMatrixExample(Scene):\n    def construct(self):\n        m0 = DecimalMatrix(\n            [[3.456, 2.122], [33.2244, 12]],\n            element_to_mobject_config={\"num_decimal_places\": 2},\n            left_bracket=\"\\\\{\",\n            right_bracket=\"\\\\}\")\n        self.add(m0) Will round/truncate the decimal places as per the provided config. Parameters : matrix ( Iterable ) \u2013 A numpy 2d array or list of lists element_to_mobject ( Mobject ) \u2013 Mobject to use, by default DecimalNumber element_to_mobject_config ( dict [ str , Mobject ] ) \u2013 Config for the desired mobject, by default {\u201cnum_decimal_places\u201d: 1} Methods Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( matrix , element_to_mobject=<class 'manim.mobject.text.numbers.DecimalNumber'> , element_to_mobject_config={'num_decimal_places': 1} , **kwargs )   Will round/truncate the decimal places as per the provided config. Parameters : matrix ( Iterable ) \u2013 A numpy 2d array or list of lists element_to_mobject ( Mobject ) \u2013 Mobject to use, by default DecimalNumber element_to_mobject_config ( dict [ str , Mobject ] ) \u2013 Config for the desired mobject, by default {\u201cnum_decimal_places\u201d: 1}", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.DecimalMatrix.html"}
{"prompt": "class IntegerMatrix(matrix, element_to_mobject=<class 'manim.mobject.text.numbers.Integer'>, **kwargs)", "response": "Bases: Matrix A mobject that displays a matrix with integer entries on the screen. Examples Example: IntegerMatrixExample   from manim import * class IntegerMatrixExample ( Scene ): def construct ( self ): m0 = IntegerMatrix ( [[ 3.7 , 2 ], [ 42.2 , 12 ]], left_bracket = \"(\" , right_bracket = \")\" ) self . add ( m0 ) class IntegerMatrixExample(Scene):\n    def construct(self):\n        m0 = IntegerMatrix(\n            [[3.7, 2], [42.2, 12]],\n            left_bracket=\"(\",\n            right_bracket=\")\")\n        self.add(m0) Will round if there are decimal entries in the matrix. Parameters : matrix ( Iterable ) \u2013 A numpy 2d array or list of lists element_to_mobject ( Mobject ) \u2013 Mobject to use, by default Integer Methods Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( matrix , element_to_mobject=<class 'manim.mobject.text.numbers.Integer'> , **kwargs )   Will round if there are decimal entries in the matrix. Parameters : matrix ( Iterable ) \u2013 A numpy 2d array or list of lists element_to_mobject ( Mobject ) \u2013 Mobject to use, by default Integer", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.IntegerMatrix.html"}
{"prompt": "class Matrix(matrix, v_buff=0.8, h_buff=1.3, bracket_h_buff=0.25, bracket_v_buff=0.25, add_background_rectangles_to_entries=False, include_background_rectangle=False, element_to_mobject=<class 'manim.mobject.text.tex_mobject.MathTex'>, element_to_mobject_config={}, element_alignment_corner=array(", "response": "Bases: VMobject A mobject that displays a matrix on the screen. Parameters : matrix ( Iterable ) \u2013 A numpy 2d array or list of lists. v_buff ( float ) \u2013 Vertical distance between elements, by default 0.8. h_buff ( float ) \u2013 Horizontal distance between elements, by default 1.3. bracket_h_buff ( float ) \u2013 Distance of the brackets from the matrix, by default MED_SMALL_BUFF . bracket_v_buff ( float ) \u2013 Height of the brackets, by default MED_SMALL_BUFF . add_background_rectangles_to_entries ( bool ) \u2013 True if should add backgraound rectangles to entries, by default False . include_background_rectangle ( bool ) \u2013 True if should include background rectangle, by default False . element_to_mobject ( type [ MathTex ] ) \u2013 The mobject class used to construct the elements, by default MathTex . element_to_mobject_config ( dict ) \u2013 Additional arguments to be passed to the constructor in element_to_mobject ,\nby default {} . element_alignment_corner ( Sequence [ float ] ) \u2013 The corner to which elements are aligned, by default DR . left_bracket ( str ) \u2013 The left bracket type, by default \"[\" . right_bracket ( str ) \u2013 The right bracket type, by default \"]\" . stretch_brackets ( bool ) \u2013 True if should stretch the brackets to fit the height of matrix contents, by default True . bracket_config ( dict ) \u2013 Additional arguments to be passed to MathTex when constructing\nthe brackets. Examples The first example shows a variety of uses of this module while the second example\nexlpains the use of the options add_background_rectangles_to_entries and include_background_rectangle . Example: MatrixExamples   from manim import * class MatrixExamples ( Scene ): def construct ( self ): m0 = Matrix ([[ 2 , r \"\\pi\" ], [ - 1 , 1 ]]) m1 = Matrix ([[ 2 , 0 , 4 ], [ - 1 , 1 , 5 ]], v_buff = 1.3 , h_buff = 0.8 , bracket_h_buff = SMALL_BUFF , bracket_v_buff = SMALL_BUFF , left_bracket = r \"\\{\" , right_bracket = r \"\\}\" ) m1 . add ( SurroundingRectangle ( m1 . get_columns ()[ 1 ])) m2 = Matrix ([[ 2 , 1 ], [ - 1 , 3 ]], element_alignment_corner = UL , left_bracket = \"(\" , right_bracket = \")\" ) m3 = Matrix ([[ 2 , 1 ], [ - 1 , 3 ]], left_bracket = r \"\\langle\" , right_bracket = r \"\\rangle\" ) m4 = Matrix ([[ 2 , 1 ], [ - 1 , 3 ]], ) . set_column_colors ( RED , GREEN ) m5 = Matrix ([[ 2 , 1 ], [ - 1 , 3 ]], ) . set_row_colors ( RED , GREEN ) g = Group ( m0 , m1 , m2 , m3 , m4 , m5 ) . arrange_in_grid ( buff = 2 ) self . add ( g ) class MatrixExamples(Scene):\n    def construct(self):\n        m0 = Matrix([[2, r\"\\pi\"], [-1, 1]])\n        m1 = Matrix([[2, 0, 4], [-1, 1, 5]],\n            v_buff=1.3,\n            h_buff=0.8,\n            bracket_h_buff=SMALL_BUFF,\n            bracket_v_buff=SMALL_BUFF,\n            left_bracket=r\"\\{\",\n            right_bracket=r\"\\}\")\n        m1.add(SurroundingRectangle(m1.get_columns()[1]))\n        m2 = Matrix([[2, 1], [-1, 3]],\n            element_alignment_corner=UL,\n            left_bracket=\"(\",\n            right_bracket=\")\")\n        m3 = Matrix([[2, 1], [-1, 3]],\n            left_bracket=r\"\\langle\",\n            right_bracket=r\"\\rangle\")\n        m4 = Matrix([[2, 1], [-1, 3]],\n        ).set_column_colors(RED, GREEN)\n        m5 = Matrix([[2, 1], [-1, 3]],\n        ).set_row_colors(RED, GREEN)\n        g = Group(\n            m0,m1,m2,m3,m4,m5\n        ).arrange_in_grid(buff=2)\n        self.add(g) Example: BackgroundRectanglesExample   from manim import * class BackgroundRectanglesExample ( Scene ): def construct ( self ): background = Rectangle () . scale ( 3.2 ) background . set_fill ( opacity = .5 ) background . set_color ([ TEAL , RED , YELLOW ]) self . add ( background ) m0 = Matrix ([[ 12 , - 30 ], [ - 1 , 15 ]], add_background_rectangles_to_entries = True ) m1 = Matrix ([[ 2 , 0 ], [ - 1 , 1 ]], include_background_rectangle = True ) m2 = Matrix ([[ 12 , - 30 ], [ - 1 , 15 ]]) g = Group ( m0 , m1 , m2 ) . arrange ( buff = 2 ) self . add ( g ) class BackgroundRectanglesExample(Scene):\n    def construct(self):\n        background= Rectangle().scale(3.2)\n        background.set_fill(opacity=.5)\n        background.set_color([TEAL, RED, YELLOW])\n        self.add(background)\n        m0 = Matrix([[12, -30], [-1, 15]],\n            add_background_rectangles_to_entries=True)\n        m1 = Matrix([[2, 0], [-1, 1]],\n            include_background_rectangle=True)\n        m2 = Matrix([[12, -30], [-1, 15]])\n        g = Group(m0, m1, m2).arrange(buff=2)\n        self.add(g) Methods add_background_to_entries Add a black background rectangle to the matrix, see above for an example. get_brackets Return the bracket mobjects. get_columns Return columns of the matrix as VGroups. get_entries Return the individual entries of the matrix. get_mob_matrix Return the underlying mob matrix mobjects. get_rows Return rows of the matrix as VGroups. set_column_colors Set individual colors for each columns of the matrix. set_row_colors Set individual colors for each row of the matrix. Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _add_brackets ( left = '[' , right = ']' , ** kwargs ) [source]   Adds the brackets to the Matrix mobject. See Latex document for various bracket types. Parameters : left ( str ) \u2013 the left bracket, by default \u201c[\u201d right ( str ) \u2013 the right bracket, by default \u201c]\u201d Returns : The current matrix object (self). Return type : Matrix _original__init__ ( matrix , v_buff=0.8 , h_buff=1.3 , bracket_h_buff=0.25 , bracket_v_buff=0.25 , add_background_rectangles_to_entries=False , include_background_rectangle=False , element_to_mobject=<class 'manim.mobject.text.tex_mobject.MathTex'> , element_to_mobject_config={} , element_alignment_corner=array([ 1. , -1. , 0.]) , left_bracket='[' , right_bracket=']' , stretch_brackets=True , bracket_config={} , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : matrix ( Iterable ) v_buff ( float ) h_buff ( float ) bracket_h_buff ( float ) bracket_v_buff ( float ) add_background_rectangles_to_entries ( bool ) include_background_rectangle ( bool ) element_to_mobject ( type [ MathTex ] ) element_to_mobject_config ( dict ) element_alignment_corner ( Sequence [ float ] ) left_bracket ( str ) right_bracket ( str ) stretch_brackets ( bool ) bracket_config ( dict ) add_background_to_entries ( ) [source]   Add a black background rectangle to the matrix,\nsee above for an example. Returns : The current matrix object (self). Return type : Matrix get_brackets ( ) [source]   Return the bracket mobjects. Returns : Each VGroup contains a bracket Return type : List[ VGroup ] Examples Example: GetBracketsExample   from manim import * class GetBracketsExample ( Scene ): def construct ( self ): m0 = Matrix ([[ \" \\\\ pi\" , 3 ], [ 1 , 5 ]]) bra = m0 . get_brackets () colors = [ BLUE , GREEN ] for k in range ( len ( colors )): bra [ k ] . set_color ( colors [ k ]) self . add ( m0 ) class GetBracketsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 3], [1, 5]])\n        bra = m0.get_brackets()\n        colors = [BLUE, GREEN]\n        for k in range(len(colors)):\n            bra[k].set_color(colors[k])\n        self.add(m0) get_columns ( ) [source]   Return columns of the matrix as VGroups. Returns : Each VGroup contains a column of the matrix. Return type : List[ VGroup ] Examples Example: GetColumnsExample   from manim import * class GetColumnsExample ( Scene ): def construct ( self ): m0 = Matrix ([[ r \"\\pi\" , 3 ], [ 1 , 5 ]]) m0 . add ( SurroundingRectangle ( m0 . get_columns ()[ 1 ])) self . add ( m0 ) class GetColumnsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[r\"\\pi\", 3], [1, 5]])\n        m0.add(SurroundingRectangle(m0.get_columns()[1]))\n        self.add(m0) get_entries ( ) [source]   Return the individual entries of the matrix. Returns : VGroup containing entries of the matrix. Return type : VGroup Examples Example: GetEntriesExample   from manim import * class GetEntriesExample ( Scene ): def construct ( self ): m0 = Matrix ([[ 2 , 3 ], [ 1 , 5 ]]) ent = m0 . get_entries () colors = [ BLUE , GREEN , YELLOW , RED ] for k in range ( len ( colors )): ent [ k ] . set_color ( colors [ k ]) self . add ( m0 ) class GetEntriesExample(Scene):\n    def construct(self):\n        m0 = Matrix([[2, 3], [1, 5]])\n        ent = m0.get_entries()\n        colors = [BLUE, GREEN, YELLOW, RED]\n        for k in range(len(colors)):\n            ent[k].set_color(colors[k])\n        self.add(m0) get_mob_matrix ( ) [source]   Return the underlying mob matrix mobjects. Returns : Each VGroup contains a row of the matrix. Return type : List[ VGroup ] get_rows ( ) [source]   Return rows of the matrix as VGroups. Returns : Each VGroup contains a row of the matrix. Return type : List[ VGroup ] Examples Example: GetRowsExample   from manim import * class GetRowsExample ( Scene ): def construct ( self ): m0 = Matrix ([[ \" \\\\ pi\" , 3 ], [ 1 , 5 ]]) m0 . add ( SurroundingRectangle ( m0 . get_rows ()[ 1 ])) self . add ( m0 ) class GetRowsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 3], [1, 5]])\n        m0.add(SurroundingRectangle(m0.get_rows()[1]))\n        self.add(m0) set_column_colors ( * colors ) [source]   Set individual colors for each columns of the matrix. Parameters : colors ( str ) \u2013 The list of colors; each color specified corresponds to a column. Returns : The current matrix object (self). Return type : Matrix Examples Example: SetColumnColorsExample   from manim import * class SetColumnColorsExample ( Scene ): def construct ( self ): m0 = Matrix ([[ \" \\\\ pi\" , 1 ], [ - 1 , 3 ]], ) . set_column_colors ([ RED , BLUE ], GREEN ) self . add ( m0 ) class SetColumnColorsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 1], [-1, 3]],\n        ).set_column_colors([RED,BLUE], GREEN)\n        self.add(m0) set_row_colors ( * colors ) [source]   Set individual colors for each row of the matrix. Parameters : colors ( str ) \u2013 The list of colors; each color specified corresponds to a row. Returns : The current matrix object (self). Return type : Matrix Examples Example: SetRowColorsExample   from manim import * class SetRowColorsExample ( Scene ): def construct ( self ): m0 = Matrix ([[ \" \\\\ pi\" , 1 ], [ - 1 , 3 ]], ) . set_row_colors ([ RED , BLUE ], GREEN ) self . add ( m0 ) class SetRowColorsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 1], [-1, 3]],\n        ).set_row_colors([RED,BLUE], GREEN)\n        self.add(m0)", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.Matrix.html"}
{"prompt": "class MobjectMatrix(matrix, element_to_mobject=<function MobjectMatrix.<lambda>>, **kwargs)", "response": "Bases: Matrix A mobject that displays a matrix of mobject entries on the screen. Examples Example: MobjectMatrixExample   from manim import * class MobjectMatrixExample ( Scene ): def construct ( self ): a = Circle () . scale ( 0.3 ) b = Square () . scale ( 0.3 ) c = MathTex ( \" \\\\ pi\" ) . scale ( 2 ) d = Star () . scale ( 0.3 ) m0 = MobjectMatrix ([[ a , b ], [ c , d ]]) self . add ( m0 ) class MobjectMatrixExample(Scene):\n    def construct(self):\n        a = Circle().scale(0.3)\n        b = Square().scale(0.3)\n        c = MathTex(\"\\\\pi\").scale(2)\n        d = Star().scale(0.3)\n        m0 = MobjectMatrix([[a, b], [c, d]])\n        self.add(m0) Methods Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( matrix , element_to_mobject=<function MobjectMatrix.<lambda>> , **kwargs )   Initialize self.  See help(type(self)) for accurate signature.", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.MobjectMatrix.html"}
{"prompt": "get_det_text(matrix, determinant=None, background_rect=False, initial_scale_factor=2)", "response": "Helper function to create determinant. Parameters : matrix ( Matrix ) \u2013 The matrix whose determinant is to be created determinant ( int | str | None ) \u2013 The value of the determinant of the matrix background_rect ( bool ) \u2013 The background rectangle initial_scale_factor ( float ) \u2013 The scale of the text det w.r.t the matrix Returns : A VGroup containing the determinant Return type : VGroup Examples Example: DeterminantOfAMatrix   from manim import * class DeterminantOfAMatrix ( Scene ): def construct ( self ): matrix = Matrix ([ [ 2 , 0 ], [ - 1 , 1 ] ]) # scaling down the `det` string det = get_det_text ( matrix , determinant = 3 , initial_scale_factor = 1 ) # must add the matrix self . add ( matrix ) self . add ( det ) class DeterminantOfAMatrix(Scene):\n    def construct(self):\n        matrix = Matrix([\n            [2, 0],\n            [-1, 1]\n        ])\n\n        # scaling down the `det` string\n        det = get_det_text(matrix,\n                    determinant=3,\n                    initial_scale_factor=1)\n\n        # must add the matrix\n        self.add(matrix)\n        self.add(det)", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.html#manim.mobject.matrix.get_det_text"}
{"prompt": "get_det_text(matrix, determinant=None, background_rect=False, initial_scale_factor=2)", "response": "Helper function to create determinant. Parameters : matrix ( Matrix ) \u2013 The matrix whose determinant is to be created determinant ( int | str | None ) \u2013 The value of the determinant of the matrix background_rect ( bool ) \u2013 The background rectangle initial_scale_factor ( float ) \u2013 The scale of the text det w.r.t the matrix Returns : A VGroup containing the determinant Return type : VGroup Examples Example: DeterminantOfAMatrix   from manim import * class DeterminantOfAMatrix ( Scene ): def construct ( self ): matrix = Matrix ([ [ 2 , 0 ], [ - 1 , 1 ] ]) # scaling down the `det` string det = get_det_text ( matrix , determinant = 3 , initial_scale_factor = 1 ) # must add the matrix self . add ( matrix ) self . add ( det ) class DeterminantOfAMatrix(Scene):\n    def construct(self):\n        matrix = Matrix([\n            [2, 0],\n            [-1, 1]\n        ])\n\n        # scaling down the `det` string\n        det = get_det_text(matrix,\n                    determinant=3,\n                    initial_scale_factor=1)\n\n        # must add the matrix\n        self.add(matrix)\n        self.add(det)", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.html#manim.mobject.matrix.matrix_to_mobject"}
{"prompt": "get_det_text(matrix, determinant=None, background_rect=False, initial_scale_factor=2)", "response": "Helper function to create determinant. Parameters : matrix ( Matrix ) \u2013 The matrix whose determinant is to be created determinant ( int | str | None ) \u2013 The value of the determinant of the matrix background_rect ( bool ) \u2013 The background rectangle initial_scale_factor ( float ) \u2013 The scale of the text det w.r.t the matrix Returns : A VGroup containing the determinant Return type : VGroup Examples Example: DeterminantOfAMatrix   from manim import * class DeterminantOfAMatrix ( Scene ): def construct ( self ): matrix = Matrix ([ [ 2 , 0 ], [ - 1 , 1 ] ]) # scaling down the `det` string det = get_det_text ( matrix , determinant = 3 , initial_scale_factor = 1 ) # must add the matrix self . add ( matrix ) self . add ( det ) class DeterminantOfAMatrix(Scene):\n    def construct(self):\n        matrix = Matrix([\n            [2, 0],\n            [-1, 1]\n        ])\n\n        # scaling down the `det` string\n        det = get_det_text(matrix,\n                    determinant=3,\n                    initial_scale_factor=1)\n\n        # must add the matrix\n        self.add(matrix)\n        self.add(det)", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.html#manim.mobject.matrix.matrix_to_tex_string"}
{"prompt": "class TimeBasedUpdater", "response": "Callable [[ 'Mobject' , float ], object ]", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html"}
{"prompt": "class NonTimeBasedUpdater", "response": "Callable [[ 'Mobject' ], object ]", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html"}
{"prompt": "class Updater", "response": "NonTimeBasedUpdater` | TimeBasedUpdater`", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html"}
{"prompt": "override_animate(method)", "response": "Decorator for overriding method animations. This allows to specify a method (returning an Animation )\nwhich is called when the decorated method is used with the .animate syntax\nfor animating the application of a method. See also Mobject.animate Note Overridden methods cannot be combined with normal or other overridden\nmethods using method chaining with the .animate syntax. Examples Example: AnimationOverrideExample   from manim import * class CircleWithContent ( VGroup ): def __init__ ( self , content ): super () . __init__ () self . circle = Circle () self . content = content self . add ( self . circle , content ) content . move_to ( self . circle . get_center ()) def clear_content ( self ): self . remove ( self . content ) self . content = None @override_animate ( clear_content ) def _clear_content_animation ( self , anim_args = None ): if anim_args is None : anim_args = {} anim = Uncreate ( self . content , ** anim_args ) self . clear_content () return anim class AnimationOverrideExample ( Scene ): def construct ( self ): t = Text ( \"hello!\" ) my_mobject = CircleWithContent ( t ) self . play ( Create ( my_mobject )) self . play ( my_mobject . animate . clear_content ()) self . wait () class CircleWithContent(VGroup):\n    def __init__(self, content):\n        super().__init__()\n        self.circle = Circle()\n        self.content = content\n        self.add(self.circle, content)\n        content.move_to(self.circle.get_center())\n\n    def clear_content(self):\n        self.remove(self.content)\n        self.content = None\n\n    @override_animate(clear_content)\n    def _clear_content_animation(self, anim_args=None):\n        if anim_args is None:\n            anim_args = {}\n        anim = Uncreate(self.content, **anim_args)\n        self.clear_content()\n        return anim\n\nclass AnimationOverrideExample(Scene):\n    def construct(self):\n        t = Text(\"hello!\")\n        my_mobject = CircleWithContent(t)\n        self.play(Create(my_mobject))\n        self.play(my_mobject.animate.clear_content())\n        self.wait() Return type : LambdaType", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html"}
{"prompt": "class TimeBasedUpdater", "response": "Callable [[ 'Mobject' , float ], object ]", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html#manim.mobject.mobject.TimeBasedUpdater"}
{"prompt": "class NonTimeBasedUpdater", "response": "Callable [[ 'Mobject' ], object ]", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html#manim.mobject.mobject.TimeBasedUpdater"}
{"prompt": "class Updater", "response": "NonTimeBasedUpdater` | TimeBasedUpdater`", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html#manim.mobject.mobject.TimeBasedUpdater"}
{"prompt": "override_animate(method)", "response": "Decorator for overriding method animations. This allows to specify a method (returning an Animation )\nwhich is called when the decorated method is used with the .animate syntax\nfor animating the application of a method. See also Mobject.animate Note Overridden methods cannot be combined with normal or other overridden\nmethods using method chaining with the .animate syntax. Examples Example: AnimationOverrideExample   from manim import * class CircleWithContent ( VGroup ): def __init__ ( self , content ): super () . __init__ () self . circle = Circle () self . content = content self . add ( self . circle , content ) content . move_to ( self . circle . get_center ()) def clear_content ( self ): self . remove ( self . content ) self . content = None @override_animate ( clear_content ) def _clear_content_animation ( self , anim_args = None ): if anim_args is None : anim_args = {} anim = Uncreate ( self . content , ** anim_args ) self . clear_content () return anim class AnimationOverrideExample ( Scene ): def construct ( self ): t = Text ( \"hello!\" ) my_mobject = CircleWithContent ( t ) self . play ( Create ( my_mobject )) self . play ( my_mobject . animate . clear_content ()) self . wait () class CircleWithContent(VGroup):\n    def __init__(self, content):\n        super().__init__()\n        self.circle = Circle()\n        self.content = content\n        self.add(self.circle, content)\n        content.move_to(self.circle.get_center())\n\n    def clear_content(self):\n        self.remove(self.content)\n        self.content = None\n\n    @override_animate(clear_content)\n    def _clear_content_animation(self, anim_args=None):\n        if anim_args is None:\n            anim_args = {}\n        anim = Uncreate(self.content, **anim_args)\n        self.clear_content()\n        return anim\n\nclass AnimationOverrideExample(Scene):\n    def construct(self):\n        t = Text(\"hello!\")\n        my_mobject = CircleWithContent(t)\n        self.play(Create(my_mobject))\n        self.play(my_mobject.animate.clear_content())\n        self.wait() Return type : LambdaType", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html#manim.mobject.mobject.TimeBasedUpdater"}
{"prompt": "class TimeBasedUpdater", "response": "Callable [[ 'Mobject' , float ], object ]", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html#manim.mobject.mobject.NonTimeBasedUpdater"}
{"prompt": "class NonTimeBasedUpdater", "response": "Callable [[ 'Mobject' ], object ]", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html#manim.mobject.mobject.NonTimeBasedUpdater"}
{"prompt": "class Updater", "response": "NonTimeBasedUpdater` | TimeBasedUpdater`", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html#manim.mobject.mobject.NonTimeBasedUpdater"}
{"prompt": "override_animate(method)", "response": "Decorator for overriding method animations. This allows to specify a method (returning an Animation )\nwhich is called when the decorated method is used with the .animate syntax\nfor animating the application of a method. See also Mobject.animate Note Overridden methods cannot be combined with normal or other overridden\nmethods using method chaining with the .animate syntax. Examples Example: AnimationOverrideExample   from manim import * class CircleWithContent ( VGroup ): def __init__ ( self , content ): super () . __init__ () self . circle = Circle () self . content = content self . add ( self . circle , content ) content . move_to ( self . circle . get_center ()) def clear_content ( self ): self . remove ( self . content ) self . content = None @override_animate ( clear_content ) def _clear_content_animation ( self , anim_args = None ): if anim_args is None : anim_args = {} anim = Uncreate ( self . content , ** anim_args ) self . clear_content () return anim class AnimationOverrideExample ( Scene ): def construct ( self ): t = Text ( \"hello!\" ) my_mobject = CircleWithContent ( t ) self . play ( Create ( my_mobject )) self . play ( my_mobject . animate . clear_content ()) self . wait () class CircleWithContent(VGroup):\n    def __init__(self, content):\n        super().__init__()\n        self.circle = Circle()\n        self.content = content\n        self.add(self.circle, content)\n        content.move_to(self.circle.get_center())\n\n    def clear_content(self):\n        self.remove(self.content)\n        self.content = None\n\n    @override_animate(clear_content)\n    def _clear_content_animation(self, anim_args=None):\n        if anim_args is None:\n            anim_args = {}\n        anim = Uncreate(self.content, **anim_args)\n        self.clear_content()\n        return anim\n\nclass AnimationOverrideExample(Scene):\n    def construct(self):\n        t = Text(\"hello!\")\n        my_mobject = CircleWithContent(t)\n        self.play(Create(my_mobject))\n        self.play(my_mobject.animate.clear_content())\n        self.wait() Return type : LambdaType", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html#manim.mobject.mobject.NonTimeBasedUpdater"}
{"prompt": "class TimeBasedUpdater", "response": "Callable [[ 'Mobject' , float ], object ]", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html#manim.mobject.mobject.Updater"}
{"prompt": "class NonTimeBasedUpdater", "response": "Callable [[ 'Mobject' ], object ]", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html#manim.mobject.mobject.Updater"}
{"prompt": "class Updater", "response": "NonTimeBasedUpdater` | TimeBasedUpdater`", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html#manim.mobject.mobject.Updater"}
{"prompt": "override_animate(method)", "response": "Decorator for overriding method animations. This allows to specify a method (returning an Animation )\nwhich is called when the decorated method is used with the .animate syntax\nfor animating the application of a method. See also Mobject.animate Note Overridden methods cannot be combined with normal or other overridden\nmethods using method chaining with the .animate syntax. Examples Example: AnimationOverrideExample   from manim import * class CircleWithContent ( VGroup ): def __init__ ( self , content ): super () . __init__ () self . circle = Circle () self . content = content self . add ( self . circle , content ) content . move_to ( self . circle . get_center ()) def clear_content ( self ): self . remove ( self . content ) self . content = None @override_animate ( clear_content ) def _clear_content_animation ( self , anim_args = None ): if anim_args is None : anim_args = {} anim = Uncreate ( self . content , ** anim_args ) self . clear_content () return anim class AnimationOverrideExample ( Scene ): def construct ( self ): t = Text ( \"hello!\" ) my_mobject = CircleWithContent ( t ) self . play ( Create ( my_mobject )) self . play ( my_mobject . animate . clear_content ()) self . wait () class CircleWithContent(VGroup):\n    def __init__(self, content):\n        super().__init__()\n        self.circle = Circle()\n        self.content = content\n        self.add(self.circle, content)\n        content.move_to(self.circle.get_center())\n\n    def clear_content(self):\n        self.remove(self.content)\n        self.content = None\n\n    @override_animate(clear_content)\n    def _clear_content_animation(self, anim_args=None):\n        if anim_args is None:\n            anim_args = {}\n        anim = Uncreate(self.content, **anim_args)\n        self.clear_content()\n        return anim\n\nclass AnimationOverrideExample(Scene):\n    def construct(self):\n        t = Text(\"hello!\")\n        my_mobject = CircleWithContent(t)\n        self.play(Create(my_mobject))\n        self.play(my_mobject.animate.clear_content())\n        self.wait() Return type : LambdaType", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html#manim.mobject.mobject.Updater"}
{"prompt": "class Group(*mobjects, **kwargs)", "response": "Bases: Mobject Groups together multiple Mobjects . Notes When adding the same mobject more than once, repetitions are ignored.\nUse Mobject.copy() to create a separate copy which can then\nbe added to the group. Methods Attributes animate Used to animate the application of any method of self . animation_overrides depth The depth of the mobject. height The height of the mobject. width The width of the mobject. _original__init__ ( * mobjects , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Group.html"}
{"prompt": "class Mobject(color=ManimColor('#FFFFFF'), name=None, dim=3, target=None, z_index=0)", "response": "Bases: object Mathematical Object: base class for objects that can be displayed on screen. There is a compatibility layer that allows for\ngetting and setting generic attributes with get_* and set_* methods. See set() for more details. Parameters : color ( ParsableManimColor | list [ ParsableManimColor ] ) name ( str | None ) dim ( int ) z_index ( float ) submobjects   The contained objects. Type : List[ Mobject ] points   The points of the objects. See also VMobject Type : numpy.ndarray Methods add Add mobjects as submobjects. add_animation_override Add an animation override. add_background_rectangle Add a BackgroundRectangle as submobject. add_background_rectangle_to_family_members_with_points add_background_rectangle_to_submobjects add_n_more_submobjects add_to_back Add all passed mobjects to the back of the submobjects. add_updater Add an update function to this mobject. align_data Aligns the data of this mobject with another mobject. align_on_border Direction just needs to be a vector pointing towards side or corner in the 2d plane. align_points align_points_with_larger align_submobjects align_to Aligns mobject to another Mobject in a certain direction. animation_override_for Returns the function defining a specific animation override for this class. apply_complex_function Applies a complex function to a Mobject . apply_function apply_function_to_position apply_function_to_submobject_positions apply_matrix apply_over_attr_arrays apply_points_function_about_point apply_to_family Apply a function to self and every submobject with points recursively. arrange Sorts Mobject next to each other on screen. arrange_in_grid Arrange submobjects in a grid. arrange_submobjects Arrange the position of submobjects with a small buffer. become Edit points, colors and submobjects to be identical to another Mobject center Moves the center of the mobject to the center of the scene. clear_updaters Remove every updater. copy Create and return an identical copy of the Mobject including all submobjects . fade fade_to family_members_with_points flip Flips/Mirrors an mobject about its center. generate_points Initializes points and therefore the shape. generate_target get_all_points Return all points from this mobject and all submobjects. get_array_attrs get_bottom Get bottom Point3Ds of a box bounding the Mobject get_boundary_point get_center Get center Point3Ds get_center_of_mass get_color Returns the color of the Mobject get_coord Meant to generalize get_x , get_y and get_z get_corner Get corner Point3Ds for certain direction. get_critical_point Picture a box bounding the Mobject . get_edge_center Get edge Point3Ds for certain direction. get_end Returns the point, where the stroke that surrounds the Mobject ends. get_extremum_along_dim get_family get_family_updaters get_group_class get_image get_left Get left Point3Ds of a box bounding the Mobject get_merged_array Return all of a given attribute from this mobject and all submobjects. get_midpoint Get Point3Ds of the middle of the path that forms the Mobject . get_mobject_type_class Return the base class of this mobject type. get_nadir Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D Mobject . get_num_points get_pieces get_point_mobject The simplest Mobject to be transformed to or from self. get_points_defining_boundary get_right Get right Point3Ds of a box bounding the Mobject get_start Returns the point, where the stroke that surrounds the Mobject starts. get_start_and_end Returns starting and ending point of a stroke as a tuple . get_time_based_updaters Return all updaters using the dt parameter. get_top Get top Point3Ds of a box bounding the Mobject get_updaters Return all updaters. get_x Returns x Point3D of the center of the Mobject as float get_y Returns y Point3D of the center of the Mobject as float get_z Returns z Point3D of the center of the Mobject as float get_z_index_reference_point get_zenith Get zenith Point3Ds of a box bounding a 3D Mobject . has_no_points Check if Mobject does not contains points. has_points Check if Mobject contains points. has_time_based_updater Test if self has a time based updater. init_colors Initializes the colors. insert Inserts a mobject at a specific position into self.submobjects interpolate Turns this Mobject into an interpolation between mobject1 and mobject2 . interpolate_color invert Inverts the list of submobjects . is_off_screen length_over_dim Measure the length of an Mobject in a certain direction. match_color Match the color with the color of another Mobject . match_coord Match the Point3Ds with the Point3Ds of another Mobject . match_depth Match the depth with the depth of another Mobject . match_dim_size Match the specified dimension with the dimension of another Mobject . match_height Match the height with the height of another Mobject . match_points Edit points, positions, and submobjects to be identical to another Mobject , while keeping the style unchanged. match_updaters Match the updaters of the given mobject. match_width Match the width with the width of another Mobject . match_x Match x coord. match_y Match y coord. match_z Match z coord. move_to Move center of the Mobject to certain Point3D. next_to Move this Mobject next to another's Mobject or Point3D. nonempty_submobjects null_point_align If a Mobject with points is being aligned to one without, treat both as groups, and push the one with points into its own submobjects list. point_from_proportion pose_at_angle proportion_from_point push_self_into_submobjects put_start_and_end_on reduce_across_dimension Find the min or max value from a dimension across all points in this and submobjects. remove Remove submobjects . remove_updater Remove an updater. repeat This can make transition animations nicer repeat_submobject replace rescale_to_fit reset_points Sets points to be an empty array. restore Restores the state that was previously saved with save_state() . resume_updating Enable updating from updaters and animations. reverse_points rotate Rotates the Mobject about a certain point. rotate_about_origin Rotates the Mobject about the ORIGIN, which is at [0,0,0]. save_image Saves an image of only this Mobject at its position to a png file. save_state Save the current state (position, color & size). scale Scale the size by a factor. scale_to_fit_depth Scales the Mobject to fit a depth while keeping width/height proportional. scale_to_fit_height Scales the Mobject to fit a height while keeping width/depth proportional. scale_to_fit_width Scales the Mobject to fit a width while keeping height/depth proportional. set Sets attributes. set_color Condition is function which takes in one arguments, (x, y, z). set_color_by_gradient set_colors_by_radial_gradient set_coord set_default Sets the default values of keyword arguments. set_submobject_colors_by_gradient set_submobject_colors_by_radial_gradient set_x Set x value of the center of the Mobject ( int or float ) set_y Set y value of the center of the Mobject ( int or float ) set_z Set z value of the center of the Mobject ( int or float ) set_z_index Sets the Mobject 's z_index to the value specified in z_index_value . set_z_index_by_z_Point3D Sets the Mobject 's z Point3D to the value of z_index . shift Shift by the given vectors. shift_onto_screen show shuffle Shuffles the list of submobjects . shuffle_submobjects Shuffles the order of submobjects sort Sorts the list of submobjects by a function defined by submob_func . sort_submobjects Sort the submobjects space_out_submobjects split stretch stretch_about_point stretch_to_fit_depth Stretches the Mobject to fit a depth, not keeping width/height proportional. stretch_to_fit_height Stretches the Mobject to fit a height, not keeping width/depth proportional. stretch_to_fit_width Stretches the Mobject to fit a width, not keeping height/depth proportional. surround suspend_updating Disable updating from updaters and animations. throw_error_if_no_points to_corner Moves this Mobject to the given corner of the screen. to_edge Moves this Mobject to the given edge of the screen, without affecting its position in the other dimension. to_original_color update Apply all updaters. Attributes animate Used to animate the application of any method of self . animation_overrides depth The depth of the mobject. height The height of the mobject. width The width of the mobject. classmethod _add_intrinsic_animation_overrides ( ) [source]   Initializes animation overrides marked with the override_animation() decorator. Return type : None _assert_valid_submobjects ( submobjects ) [source]   Check that all submobjects are actually instances of Mobject , and that none of them is self (a Mobject cannot contain itself). This is an auxiliary function called when adding Mobjects to the submobjects list. This function is intended to be overridden by subclasses such as VMobject , which should assert that only other VMobjects\nmay be added into it. Parameters : submobjects ( Iterable [ Mobject ] ) \u2013 The list containing values to validate. Returns : The Mobject itself. Return type : Mobject Raises : TypeError \u2013 If any of the values in submobjects is not a Mobject . ValueError \u2013 If there was an attempt to add a Mobject as its own\n    submobject. add ( * mobjects ) [source]   Add mobjects as submobjects. The mobjects are added to submobjects . Subclasses of mobject may implement + and += dunder methods. Parameters : mobjects ( Mobject ) \u2013 The mobjects to add. Returns : self Return type : Mobject Raises : ValueError \u2013 When a mobject tries to add itself. TypeError \u2013 When trying to add an object that is not an instance of Mobject . Notes A mobject cannot contain itself, and it cannot contain a submobject\nmore than once.  If the parent mobject is displayed, the newly-added\nsubmobjects will also be displayed (i.e. they are automatically added\nto the parent Scene). See also remove() , add_to_back() Examples >>> outer = Mobject () >>> inner = Mobject () >>> outer = outer . add ( inner ) Duplicates are not added again: >>> outer = outer . add ( inner ) >>> len ( outer . submobjects ) 1 Only Mobjects can be added: >>> outer . add ( 3 ) Traceback (most recent call last): ... TypeError : Only values of type Mobject can be added as submobjects of Mobject, but the value 3 (at index 0) is of type int. Adding an object to itself raises an error: >>> outer . add ( outer ) Traceback (most recent call last): ... ValueError : Cannot add Mobject as a submobject of itself (at index 0). A given mobject cannot be added as a submobject\ntwice to some parent: >>> parent = Mobject ( name = \"parent\" ) >>> child = Mobject ( name = \"child\" ) >>> parent . add ( child , child ) [...] WARNING  ... parent >>> parent . submobjects [child] classmethod add_animation_override ( animation_class , override_func ) [source]   Add an animation override. This does not apply to subclasses. Parameters : animation_class ( type [ Animation ] ) \u2013 The animation type to be overridden override_func ( FunctionOverride ) \u2013 The function returning an animation replacing the default animation. It gets\npassed the parameters given to the animation constructor. Raises : MultiAnimationOverrideException \u2013 If the overridden animation was already overridden. Return type : None add_background_rectangle ( color = None , opacity = 0.75 , ** kwargs ) [source]   Add a BackgroundRectangle as submobject. The BackgroundRectangle is added behind other submobjects. This can be used to increase the mobjects visibility in front of a noisy background. Parameters : color ( ParsableManimColor | None ) \u2013 The color of the BackgroundRectangle opacity ( float ) \u2013 The opacity of the BackgroundRectangle kwargs \u2013 Additional keyword arguments passed to the BackgroundRectangle constructor Returns : self Return type : Mobject See also add_to_back() , BackgroundRectangle add_to_back ( * mobjects ) [source]   Add all passed mobjects to the back of the submobjects. If submobjects already contains the given mobjects, they just get moved\nto the back instead. Parameters : mobjects ( Mobject ) \u2013 The mobjects to add. Returns : self Return type : Mobject Note Technically, this is done by adding (or moving) the mobjects to\nthe head of submobjects . The head of this list is rendered\nfirst, which places the corresponding mobjects behind the\nsubsequent list members. Raises : ValueError \u2013 When a mobject tries to add itself. TypeError \u2013 When trying to add an object that is not an instance of Mobject . Parameters : mobjects ( Mobject ) Return type : Self Notes A mobject cannot contain itself, and it cannot contain a submobject\nmore than once.  If the parent mobject is displayed, the newly-added\nsubmobjects will also be displayed (i.e. they are automatically added\nto the parent Scene). See also remove() , add() add_updater ( update_function , index = None , call_updater = False ) [source]   Add an update function to this mobject. Update functions, or updaters in short, are functions that are applied to the\nMobject in every frame. Parameters : update_function ( Updater ) \u2013 The update function to be added.\nWhenever update() is called, this update function gets called using self as the first parameter.\nThe updater can have a second parameter dt . If it uses this parameter,\nit gets called using a second value dt , usually representing the time\nin seconds since the last call of update() . index ( int | None ) \u2013 The index at which the new updater should be added in self.updaters .\nIn case index is None the updater will be added at the end. call_updater ( bool ) \u2013 Whether or not to call the updater initially. If True , the updater will\nbe called using dt=0 . Returns : self Return type : Mobject Examples Example: NextToUpdater   from manim import * class NextToUpdater ( Scene ): def construct ( self ): def dot_position ( mobject ): mobject . set_value ( dot . get_center ()[ 0 ]) mobject . next_to ( dot ) dot = Dot ( RIGHT * 3 ) label = DecimalNumber () label . add_updater ( dot_position ) self . add ( dot , label ) self . play ( Rotating ( dot , about_point = ORIGIN , angle = TAU , run_time = TAU , rate_func = linear )) class NextToUpdater(Scene):\n    def construct(self):\n        def dot_position(mobject):\n            mobject.set_value(dot.get_center()[0])\n            mobject.next_to(dot)\n\n        dot = Dot(RIGHT*3)\n        label = DecimalNumber()\n        label.add_updater(dot_position)\n        self.add(dot, label)\n\n        self.play(Rotating(dot, about_point=ORIGIN, angle=TAU, run_time=TAU, rate_func=linear)) Example: DtUpdater   from manim import * class DtUpdater ( Scene ): def construct ( self ): square = Square () #Let the square rotate 90\u00b0 per second square . add_updater ( lambda mobject , dt : mobject . rotate ( dt * 90 * DEGREES )) self . add ( square ) self . wait ( 2 ) class DtUpdater(Scene):\n    def construct(self):\n        square = Square()\n\n        #Let the square rotate 90\u00b0 per second\n        square.add_updater(lambda mobject, dt: mobject.rotate(dt*90*DEGREES))\n        self.add(square)\n        self.wait(2) See also get_updaters() , remove_updater() , UpdateFromFunc align_data ( mobject , skip_point_alignment = False ) [source]   Aligns the data of this mobject with another mobject. Afterwards, the two mobjects will have the same number of submobjects\n(see align_submobjects() ), the same parent structure (see null_point_align() ). If skip_point_alignment is false,\nthey will also have the same number of points (see align_points() ). Parameters : mobject ( Mobject ) \u2013 The other mobject this mobject should be aligned to. skip_point_alignment ( bool ) \u2013 Controls whether or not the computationally expensive\npoint alignment is skipped (default: False). Return type : None align_on_border ( direction , buff = 0.5 ) [source]   Direction just needs to be a vector pointing towards side or\ncorner in the 2d plane. Parameters : direction ( Vector3D ) buff ( float ) Return type : Self align_to ( mobject_or_point , direction = array([0., 0., 0.]) ) [source]   Aligns mobject to another Mobject in a certain direction. Examples:\nmob1.align_to(mob2, UP) moves mob1 vertically so that its\ntop edge lines ups with mob2\u2019s top edge. Parameters : mobject_or_point ( Mobject | Point3DLike ) direction ( Vector3D ) Return type : Self property animate : _AnimationBuilder | Self   Used to animate the application of any method of self . Any method called on animate is converted to an animation of applying\nthat method on the mobject itself. For example, square.set_fill(WHITE) sets the fill color of a square,\nwhile square.animate.set_fill(WHITE) animates this action. Multiple methods can be put in a single animation once via chaining: self . play ( my_mobject . animate . shift ( RIGHT ) . rotate ( PI )) Warning Passing multiple animations for the same Mobject in one\ncall to play() is discouraged and will most likely\nnot work properly. Instead of writing an animation like self . play ( my_mobject . animate . shift ( RIGHT ), my_mobject . animate . rotate ( PI ) ) make use of method chaining. Keyword arguments that can be passed to Scene.play() can be passed\ndirectly after accessing .animate , like so: self . play ( my_mobject . animate ( rate_func = linear ) . shift ( RIGHT )) This is especially useful when animating simultaneous .animate calls that\nyou want to behave differently: self . play ( mobject1 . animate ( run_time = 2 ) . rotate ( PI ), mobject2 . animate ( rate_func = there_and_back ) . shift ( RIGHT ), ) See also override_animate() Examples Example: AnimateExample   from manim import * class AnimateExample ( Scene ): def construct ( self ): s = Square () self . play ( Create ( s )) self . play ( s . animate . shift ( RIGHT )) self . play ( s . animate . scale ( 2 )) self . play ( s . animate . rotate ( PI / 2 )) self . play ( Uncreate ( s )) class AnimateExample(Scene):\n    def construct(self):\n        s = Square()\n        self.play(Create(s))\n        self.play(s.animate.shift(RIGHT))\n        self.play(s.animate.scale(2))\n        self.play(s.animate.rotate(PI / 2))\n        self.play(Uncreate(s)) Example: AnimateChainExample   from manim import * class AnimateChainExample ( Scene ): def construct ( self ): s = Square () self . play ( Create ( s )) self . play ( s . animate . shift ( RIGHT ) . scale ( 2 ) . rotate ( PI / 2 )) self . play ( Uncreate ( s )) class AnimateChainExample(Scene):\n    def construct(self):\n        s = Square()\n        self.play(Create(s))\n        self.play(s.animate.shift(RIGHT).scale(2).rotate(PI / 2))\n        self.play(Uncreate(s)) Example: AnimateWithArgsExample   from manim import * class AnimateWithArgsExample ( Scene ): def construct ( self ): s = Square () c = Circle () VGroup ( s , c ) . arrange ( RIGHT , buff = 2 ) self . add ( s , c ) self . play ( s . animate ( run_time = 2 ) . rotate ( PI / 2 ), c . animate ( rate_func = there_and_back ) . shift ( RIGHT ), ) class AnimateWithArgsExample(Scene):\n    def construct(self):\n        s = Square()\n        c = Circle()\n\n        VGroup(s, c).arrange(RIGHT, buff=2)\n        self.add(s, c)\n\n        self.play(\n            s.animate(run_time=2).rotate(PI / 2),\n            c.animate(rate_func=there_and_back).shift(RIGHT),\n        ) Warning .animate will interpolate the Mobject between its points prior to .animate and its points after applying .animate to it. This may\nresult in unexpected behavior when attempting to interpolate along paths,\nor rotations.\nIf you want animations to consider the points between, consider using ValueTracker with updaters instead. classmethod animation_override_for ( animation_class ) [source]   Returns the function defining a specific animation override for this class. Parameters : animation_class ( type [ Animation ] ) \u2013 The animation class for which the override function should be returned. Returns : The function returning the override animation or None if no such animation\noverride is defined. Return type : Optional[Callable[[ Mobject , \u2026], Animation ]] apply_complex_function ( function , ** kwargs ) [source]   Applies a complex function to a Mobject .\nThe x and y Point3Ds correspond to the real and imaginary parts respectively. Example Example: ApplyFuncExample   from manim import * class ApplyFuncExample ( Scene ): def construct ( self ): circ = Circle () . scale ( 1.5 ) circ_ref = circ . copy () circ . apply_complex_function ( lambda x : np . exp ( x * 1 j ) ) t = ValueTracker ( 0 ) circ . add_updater ( lambda x : x . become ( circ_ref . copy () . apply_complex_function ( lambda x : np . exp ( x + t . get_value () * 1 j ) )) . set_color ( BLUE ) ) self . add ( circ_ref ) self . play ( TransformFromCopy ( circ_ref , circ )) self . play ( t . animate . set_value ( TAU ), run_time = 3 ) class ApplyFuncExample(Scene):\n    def construct(self):\n        circ = Circle().scale(1.5)\n        circ_ref = circ.copy()\n        circ.apply_complex_function(\n            lambda x: np.exp(x*1j)\n        )\n        t = ValueTracker(0)\n        circ.add_updater(\n            lambda x: x.become(circ_ref.copy().apply_complex_function(\n                lambda x: np.exp(x+t.get_value()*1j)\n            )).set_color(BLUE)\n        )\n        self.add(circ_ref)\n        self.play(TransformFromCopy(circ_ref, circ))\n        self.play(t.animate.set_value(TAU), run_time=3) Parameters : function ( Callable [ [ complex ] , complex ] ) Return type : Self apply_to_family ( func ) [source]   Apply a function to self and every submobject with points recursively. Parameters : func ( Callable [ [ Mobject ] , None ] ) \u2013 The function to apply to each mobject. func gets passed the respective\n(sub)mobject as parameter. Returns : self Return type : Mobject See also family_members_with_points() arrange ( direction = array([1., 0., 0.]) , buff = 0.25 , center = True , ** kwargs ) [source]   Sorts Mobject next to each other on screen. Examples Example: Example   from manim import * class Example ( Scene ): def construct ( self ): s1 = Square () s2 = Square () s3 = Square () s4 = Square () x = VGroup ( s1 , s2 , s3 , s4 ) . set_x ( 0 ) . arrange ( buff = 1.0 ) self . add ( x ) class Example(Scene):\n    def construct(self):\n        s1 = Square()\n        s2 = Square()\n        s3 = Square()\n        s4 = Square()\n        x = VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)\n        self.add(x) Parameters : direction ( Vector3D ) buff ( float ) center ( bool ) Return type : Self arrange_in_grid ( rows = None , cols = None , buff = 0.25 , cell_alignment = array([0., 0., 0.]) , row_alignments = None , col_alignments = None , row_heights = None , col_widths = None , flow_order = 'rd' , ** kwargs ) [source]   Arrange submobjects in a grid. Parameters : rows ( int | None ) \u2013 The number of rows in the grid. cols ( int | None ) \u2013 The number of columns in the grid. buff ( float | tuple [ float , float ] ) \u2013 The gap between grid cells. To specify a different buffer in the horizontal and\nvertical directions, a tuple of two values can be given - (row, col) . cell_alignment ( Vector3D ) \u2013 The way each submobject is aligned in its grid cell. row_alignments ( str | None ) \u2013 The vertical alignment for each row (top to bottom). Accepts the following characters: \"u\" -\nup, \"c\" - center, \"d\" - down. col_alignments ( str | None ) \u2013 The horizontal alignment for each column (left to right). Accepts the following characters \"l\" - left, \"c\" - center, \"r\" - right. row_heights ( Iterable [ float | None ] | None ) \u2013 Defines a list of heights for certain rows (top to bottom). If the list contains None , the corresponding row will fit its height automatically based\non the highest element in that row. col_widths ( Iterable [ float | None ] | None ) \u2013 Defines a list of widths for certain columns (left to right). If the list contains None , the\ncorresponding column will fit its width automatically based on the widest element in that column. flow_order ( str ) \u2013 The order in which submobjects fill the grid. Can be one of the following values:\n\u201crd\u201d, \u201cdr\u201d, \u201cld\u201d, \u201cdl\u201d, \u201cru\u201d, \u201cur\u201d, \u201clu\u201d, \u201cul\u201d. (\u201crd\u201d -> fill rightwards then downwards) Returns : self Return type : Mobject Raises : ValueError \u2013 If rows and cols are too small to fit all submobjects. ValueError \u2013 If cols , col_alignments and col_widths or rows , row_alignments and row_heights have mismatching sizes. Notes If only one of cols and rows is set implicitly, the other one will be chosen big\nenough to fit all submobjects. If neither is set, they will be chosen to be about the same,\ntending towards cols > rows (simply because videos are wider than they are high). If both cell_alignment and row_alignments / col_alignments are\ndefined, the latter has higher priority. Examples Example: ExampleBoxes   from manim import * class ExampleBoxes ( Scene ): def construct ( self ): boxes = VGroup ( * [ Square () for s in range ( 0 , 6 )]) boxes . arrange_in_grid ( rows = 2 , buff = 0.1 ) self . add ( boxes ) class ExampleBoxes(Scene):\n    def construct(self):\n        boxes=VGroup(*[Square() for s in range(0,6)])\n        boxes.arrange_in_grid(rows=2, buff=0.1)\n        self.add(boxes) Example: ArrangeInGrid   from manim import * class ArrangeInGrid ( Scene ): def construct ( self ): boxes = VGroup ( * [ Rectangle ( WHITE , 0.5 , 0.5 ) . add ( Text ( str ( i + 1 )) . scale ( 0.5 )) for i in range ( 24 ) ]) self . add ( boxes ) boxes . arrange_in_grid ( buff = ( 0.25 , 0.5 ), col_alignments = \"lccccr\" , row_alignments = \"uccd\" , col_widths = [ 1 , * [ None ] * 4 , 1 ], row_heights = [ 1 , None , None , 1 ], flow_order = \"dr\" ) class ArrangeInGrid(Scene):\n    def construct(self):\n        boxes = VGroup(*[\n            Rectangle(WHITE, 0.5, 0.5).add(Text(str(i+1)).scale(0.5))\n            for i in range(24)\n        ])\n        self.add(boxes)\n\n        boxes.arrange_in_grid(\n            buff=(0.25,0.5),\n            col_alignments=\"lccccr\",\n            row_alignments=\"uccd\",\n            col_widths=[1, *[None]*4, 1],\n            row_heights=[1, None, None, 1],\n            flow_order=\"dr\"\n        ) arrange_submobjects ( * args , ** kwargs ) [source]   Arrange the position of submobjects with a small buffer. Examples Example: ArrangeSumobjectsExample   from manim import * class ArrangeSumobjectsExample ( Scene ): def construct ( self ): s = VGroup ( * [ Dot () . shift ( i * 0.1 * RIGHT * np . random . uniform ( - 1 , 1 ) + UP * np . random . uniform ( - 1 , 1 )) for i in range ( 0 , 15 )]) s . shift ( UP ) . set_color ( BLUE ) s2 = s . copy () . set_color ( RED ) s2 . arrange_submobjects () s2 . shift ( DOWN ) self . add ( s , s2 ) class ArrangeSumobjectsExample(Scene):\n    def construct(self):\n        s= VGroup(*[Dot().shift(i*0.1*RIGHT*np.random.uniform(-1,1)+UP*np.random.uniform(-1,1)) for i in range(0,15)])\n        s.shift(UP).set_color(BLUE)\n        s2= s.copy().set_color(RED)\n        s2.arrange_submobjects()\n        s2.shift(DOWN)\n        self.add(s,s2) Return type : Self become ( mobject , match_height = False , match_width = False , match_depth = False , match_center = False , stretch = False ) [source]   Edit points, colors and submobjects to be identical\nto another Mobject Note If both match_height and match_width are True then the transformed Mobject will match the height first and then the width. Parameters : match_height ( bool ) \u2013 Whether or not to preserve the height of the original Mobject . match_width ( bool ) \u2013 Whether or not to preserve the width of the original Mobject . match_depth ( bool ) \u2013 Whether or not to preserve the depth of the original Mobject . match_center ( bool ) \u2013 Whether or not to preserve the center of the original Mobject . stretch ( bool ) \u2013 Whether or not to stretch the target mobject to match the\nthe proportions of the original Mobject . mobject ( Mobject ) Return type : Self Examples Example: BecomeScene   from manim import * class BecomeScene ( Scene ): def construct ( self ): circ = Circle ( fill_color = RED , fill_opacity = 0.8 ) square = Square ( fill_color = BLUE , fill_opacity = 0.2 ) self . add ( circ ) self . wait ( 0.5 ) circ . become ( square ) self . wait ( 0.5 ) class BecomeScene(Scene):\n    def construct(self):\n        circ = Circle(fill_color=RED, fill_opacity=0.8)\n        square = Square(fill_color=BLUE, fill_opacity=0.2)\n        self.add(circ)\n        self.wait(0.5)\n        circ.become(square)\n        self.wait(0.5) The following examples illustrate how mobject measurements\nchange when using the match_... and stretch arguments.\nWe start with a rectangle that is 2 units high and 4 units wide,\nwhich we want to turn into a circle of radius 3: >>> from manim import Rectangle , Circle >>> import numpy as np >>> rect = Rectangle ( height = 2 , width = 4 ) >>> circ = Circle ( radius = 3 ) With stretch=True , the target circle is deformed to match\nthe proportions of the rectangle, which results in the target\nmobject being an ellipse with height 2 and width 4. We can\ncheck that the resulting points satisfy the ellipse equation \\(x^2/a^2 + y^2/b^2 = 1\\) with \\(a = 4/2\\) and \\(b = 2/2\\) being the semi-axes: >>> result = rect . copy () . become ( circ , stretch = True ) >>> result . height , result . width (np.float64(2.0), np.float64(4.0)) >>> ellipse_points = np . array ( result . get_anchors ()) >>> ellipse_eq = np . sum ( ellipse_points ** 2 * [ 1 / 4 , 1 , 0 ], axis = 1 ) >>> np . allclose ( ellipse_eq , 1 ) True With match_height=True and match_width=True the circle is\nscaled such that the height or the width of the rectangle will\nbe preserved, respectively.\nThe points of the resulting mobject satisfy the circle equation \\(x^2 + y^2 = r^2\\) for the corresponding radius \\(r\\) : >>> result = rect . copy () . become ( circ , match_height = True ) >>> result . height , result . width (np.float64(2.0), np.float64(2.0)) >>> circle_points = np . array ( result . get_anchors ()) >>> circle_eq = np . sum ( circle_points ** 2 , axis = 1 ) >>> np . allclose ( circle_eq , 1 ) True >>> result = rect . copy () . become ( circ , match_width = True ) >>> result . height , result . width (np.float64(4.0), np.float64(4.0)) >>> circle_points = np . array ( result . get_anchors ()) >>> circle_eq = np . sum ( circle_points ** 2 , axis = 1 ) >>> np . allclose ( circle_eq , 2 ** 2 ) True With match_center=True , the resulting mobject is moved such that\nits center is the same as the center of the original mobject: >>> rect = rect . shift ( np . array ([ 0 , 1 , 0 ])) >>> np . allclose ( rect . get_center (), circ . get_center ()) False >>> result = rect . copy () . become ( circ , match_center = True ) >>> np . allclose ( rect . get_center (), result . get_center ()) True center ( ) [source]   Moves the center of the mobject to the center of the scene. Returns : The centered mobject. Return type : Mobject clear_updaters ( recursive = True ) [source]   Remove every updater. Parameters : recursive ( bool ) \u2013 Whether to recursively call clear_updaters on all submobjects. Returns : self Return type : Mobject See also remove_updater() , add_updater() , get_updaters() copy ( ) [source]   Create and return an identical copy of the Mobject including all submobjects . Returns : The copy. Return type : Mobject Note The clone is initially not visible in the Scene, even if the original was. property depth : float   The depth of the mobject. Return type : float See also length_over_dim() flip ( axis = array([0., 1., 0.]) , ** kwargs ) [source]   Flips/Mirrors an mobject about its center. Examples Example: FlipExample   from manim import * class FlipExample ( Scene ): def construct ( self ): s = Line ( LEFT , RIGHT + UP ) . shift ( 4 * LEFT ) self . add ( s ) s2 = s . copy () . flip () self . add ( s2 ) class FlipExample(Scene):\n    def construct(self):\n        s= Line(LEFT, RIGHT+UP).shift(4*LEFT)\n        self.add(s)\n        s2= s.copy().flip()\n        self.add(s2) Parameters : axis ( Vector3D ) Return type : Self generate_points ( ) [source]   Initializes points and therefore the shape. Gets called upon creation. This is an empty method that can be implemented by\nsubclasses. Return type : object get_all_points ( ) [source]   Return all points from this mobject and all submobjects. May contain duplicates; the order is in a depth-first (pre-order)\ntraversal of the submobjects. Return type : Point3D_Array get_bottom ( ) [source]   Get bottom Point3Ds of a box bounding the Mobject Return type : Point3D get_center ( ) [source]   Get center Point3Ds Return type : Point3D get_color ( ) [source]   Returns the color of the Mobject Examples >>> from manim import Square , RED >>> Square ( color = RED ) . get_color () == RED True Return type : ManimColor get_coord ( dim , direction = array([0., 0., 0.]) ) [source]   Meant to generalize get_x , get_y and get_z Parameters : dim ( int ) direction ( Vector3D ) get_corner ( direction ) [source]   Get corner Point3Ds for certain direction. Parameters : direction ( Vector3D ) Return type : Point3D get_critical_point ( direction ) [source]   Picture a box bounding the Mobject .  Such a box has\n9 \u2018critical points\u2019: 4 corners, 4 edge center, the\ncenter. This returns one of them, along the given direction. sample = Arc ( start_angle = PI / 7 , angle = PI / 5 ) # These are all equivalent max_y_1 = sample . get_top ()[ 1 ] max_y_2 = sample . get_critical_point ( UP )[ 1 ] max_y_3 = sample . get_extremum_along_dim ( dim = 1 , key = 1 ) Parameters : direction ( Vector3D ) Return type : Point3D get_edge_center ( direction ) [source]   Get edge Point3Ds for certain direction. Parameters : direction ( Vector3D ) Return type : Point3D get_end ( ) [source]   Returns the point, where the stroke that surrounds the Mobject ends. Return type : Point3D get_left ( ) [source]   Get left Point3Ds of a box bounding the Mobject Return type : Point3D get_merged_array ( array_attr ) [source]   Return all of a given attribute from this mobject and all submobjects. May contain duplicates; the order is in a depth-first (pre-order)\ntraversal of the submobjects. Parameters : array_attr ( str ) Return type : ndarray get_midpoint ( ) [source]   Get Point3Ds of the middle of the path that forms the Mobject . Examples Example: AngleMidPoint   from manim import * class AngleMidPoint ( Scene ): def construct ( self ): line1 = Line ( ORIGIN , 2 * RIGHT ) line2 = Line ( ORIGIN , 2 * RIGHT ) . rotate_about_origin ( 80 * DEGREES ) a = Angle ( line1 , line2 , radius = 1.5 , other_angle = False ) d = Dot ( a . get_midpoint ()) . set_color ( RED ) self . add ( line1 , line2 , a , d ) self . wait () class AngleMidPoint(Scene):\n    def construct(self):\n        line1 = Line(ORIGIN, 2*RIGHT)\n        line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)\n\n        a = Angle(line1, line2, radius=1.5, other_angle=False)\n        d = Dot(a.get_midpoint()).set_color(RED)\n\n        self.add(line1, line2, a, d)\n        self.wait() Return type : Point3D static get_mobject_type_class ( ) [source]   Return the base class of this mobject type. Return type : type[ Mobject ] get_nadir ( ) [source]   Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D Mobject . Return type : Point3D get_point_mobject ( center = None ) [source]   The simplest Mobject to be transformed to or from self.\nShould by a point of the appropriate type get_right ( ) [source]   Get right Point3Ds of a box bounding the Mobject Return type : Point3D get_start ( ) [source]   Returns the point, where the stroke that surrounds the Mobject starts. Return type : Point3D get_start_and_end ( ) [source]   Returns starting and ending point of a stroke as a tuple . Return type : tuple[ Point3D , Point3D ] get_time_based_updaters ( ) [source]   Return all updaters using the dt parameter. The updaters use this parameter as the input for difference in time. Returns : The list of time based updaters. Return type : List[ Callable ] See also get_updaters() , has_time_based_updater() get_top ( ) [source]   Get top Point3Ds of a box bounding the Mobject Return type : Point3D get_updaters ( ) [source]   Return all updaters. Returns : The list of updaters. Return type : List[ Callable ] See also add_updater() , get_time_based_updaters() get_x ( direction = array([0., 0., 0.]) ) [source]   Returns x Point3D of the center of the Mobject as float Parameters : direction ( Vector3D ) Return type : float get_y ( direction = array([0., 0., 0.]) ) [source]   Returns y Point3D of the center of the Mobject as float Parameters : direction ( Vector3D ) Return type : float get_z ( direction = array([0., 0., 0.]) ) [source]   Returns z Point3D of the center of the Mobject as float Parameters : direction ( Vector3D ) Return type : float get_zenith ( ) [source]   Get zenith Point3Ds of a box bounding a 3D Mobject . Return type : Point3D has_no_points ( ) [source]   Check if Mobject does not contains points. Return type : bool has_points ( ) [source]   Check if Mobject contains points. Return type : bool has_time_based_updater ( ) [source]   Test if self has a time based updater. Returns : True if at least one updater uses the dt parameter, False otherwise. Return type : bool See also get_time_based_updaters() property height : float   The height of the mobject. Return type : float Examples Example: HeightExample   from manim import * class HeightExample ( Scene ): def construct ( self ): decimal = DecimalNumber () . to_edge ( UP ) rect = Rectangle ( color = BLUE ) rect_copy = rect . copy () . set_stroke ( GRAY , opacity = 0.5 ) decimal . add_updater ( lambda d : d . set_value ( rect . height )) self . add ( rect_copy , rect , decimal ) self . play ( rect . animate . set ( height = 5 )) self . wait () class HeightExample(Scene):\n    def construct(self):\n        decimal = DecimalNumber().to_edge(UP)\n        rect = Rectangle(color=BLUE)\n        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)\n\n        decimal.add_updater(lambda d: d.set_value(rect.height))\n\n        self.add(rect_copy, rect, decimal)\n        self.play(rect.animate.set(height=5))\n        self.wait() See also length_over_dim() init_colors ( ) [source]   Initializes the colors. Gets called upon creation. This is an empty method that can be implemented by\nsubclasses. Return type : object insert ( index , mobject ) [source]   Inserts a mobject at a specific position into self.submobjects Effectively just calls self.submobjects.insert(index, mobject) ,\nwhere self.submobjects is a list. Highly adapted from Mobject.add . Parameters : index ( int ) \u2013 The index at which mobject ( Mobject ) \u2013 The mobject to be inserted. Return type : None interpolate ( mobject1 , mobject2 , alpha , path_func=<function interpolate> ) [source]   Turns this Mobject into an interpolation between mobject1 and mobject2 . Examples Example: DotInterpolation   from manim import * class DotInterpolation ( Scene ): def construct ( self ): dotR = Dot ( color = DARK_GREY ) dotR . shift ( 2 * RIGHT ) dotL = Dot ( color = WHITE ) dotL . shift ( 2 * LEFT ) dotMiddle = VMobject () . interpolate ( dotL , dotR , alpha = 0.3 ) self . add ( dotL , dotR , dotMiddle ) class DotInterpolation(Scene):\n    def construct(self):\n        dotR = Dot(color=DARK_GREY)\n        dotR.shift(2 * RIGHT)\n        dotL = Dot(color=WHITE)\n        dotL.shift(2 * LEFT)\n\n        dotMiddle = VMobject().interpolate(dotL, dotR, alpha=0.3)\n\n        self.add(dotL, dotR, dotMiddle) Parameters : mobject1 ( Mobject ) mobject2 ( Mobject ) alpha ( float ) path_func ( PathFuncType ) Return type : Self invert ( recursive = False ) [source]   Inverts the list of submobjects . Parameters : recursive ( bool ) \u2013 If True , all submobject lists of this mobject\u2019s family are inverted. Return type : None Examples Example: InvertSumobjectsExample   from manim import * class InvertSumobjectsExample ( Scene ): def construct ( self ): s = VGroup ( * [ Dot () . shift ( i * 0.1 * RIGHT ) for i in range ( - 20 , 20 )]) s2 = s . copy () s2 . invert () s2 . shift ( DOWN ) self . play ( Write ( s ), Write ( s2 )) class InvertSumobjectsExample(Scene):\n    def construct(self):\n        s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n        s2 = s.copy()\n        s2.invert()\n        s2.shift(DOWN)\n        self.play(Write(s), Write(s2)) length_over_dim ( dim ) [source]   Measure the length of an Mobject in a certain direction. Parameters : dim ( int ) Return type : float match_color ( mobject ) [source]   Match the color with the color of another Mobject . Parameters : mobject ( Mobject ) Return type : Self match_coord ( mobject , dim , direction = array([0., 0., 0.]) ) [source]   Match the Point3Ds with the Point3Ds of another Mobject . Parameters : mobject ( Mobject ) dim ( int ) direction ( Vector3D ) Return type : Self match_depth ( mobject , ** kwargs ) [source]   Match the depth with the depth of another Mobject . Parameters : mobject ( Mobject ) Return type : Self match_dim_size ( mobject , dim , ** kwargs ) [source]   Match the specified dimension with the dimension of another Mobject . Parameters : mobject ( Mobject ) dim ( int ) Return type : Self match_height ( mobject , ** kwargs ) [source]   Match the height with the height of another Mobject . Parameters : mobject ( Mobject ) Return type : Self match_points ( mobject , copy_submobjects = True ) [source]   Edit points, positions, and submobjects to be identical\nto another Mobject , while keeping the style unchanged. Examples Example: MatchPointsScene   from manim import * class MatchPointsScene ( Scene ): def construct ( self ): circ = Circle ( fill_color = RED , fill_opacity = 0.8 ) square = Square ( fill_color = BLUE , fill_opacity = 0.2 ) self . add ( circ ) self . wait ( 0.5 ) self . play ( circ . animate . match_points ( square )) self . wait ( 0.5 ) class MatchPointsScene(Scene):\n    def construct(self):\n        circ = Circle(fill_color=RED, fill_opacity=0.8)\n        square = Square(fill_color=BLUE, fill_opacity=0.2)\n        self.add(circ)\n        self.wait(0.5)\n        self.play(circ.animate.match_points(square))\n        self.wait(0.5) Parameters : mobject ( Mobject ) copy_submobjects ( bool ) Return type : Self match_updaters ( mobject ) [source]   Match the updaters of the given mobject. Parameters : mobject ( Mobject ) \u2013 The mobject whose updaters get matched. Returns : self Return type : Mobject Note All updaters from submobjects are removed, but only updaters of the given\nmobject are matched, not those of it\u2019s submobjects. See also add_updater() , clear_updaters() match_width ( mobject , ** kwargs ) [source]   Match the width with the width of another Mobject . Parameters : mobject ( Mobject ) Return type : Self match_x ( mobject , direction = array([0., 0., 0.]) ) [source]   Match x coord. to the x coord. of another Mobject . Parameters : mobject ( Mobject ) Return type : Self match_y ( mobject , direction = array([0., 0., 0.]) ) [source]   Match y coord. to the x coord. of another Mobject . Parameters : mobject ( Mobject ) Return type : Self match_z ( mobject , direction = array([0., 0., 0.]) ) [source]   Match z coord. to the x coord. of another Mobject . Parameters : mobject ( Mobject ) Return type : Self move_to ( point_or_mobject , aligned_edge = array([0., 0., 0.]) , coor_mask = array([1, 1, 1]) ) [source]   Move center of the Mobject to certain Point3D. Parameters : point_or_mobject ( Point3DLike | Mobject ) aligned_edge ( Vector3D ) coor_mask ( Vector3D ) Return type : Self next_to ( mobject_or_point , direction = array([1., 0., 0.]) , buff = 0.25 , aligned_edge = array([0., 0., 0.]) , submobject_to_align = None , index_of_submobject_to_align = None , coor_mask = array([1, 1, 1]) ) [source]   Move this Mobject next to another\u2019s Mobject or Point3D. Examples Example: GeometricShapes   from manim import * class GeometricShapes ( Scene ): def construct ( self ): d = Dot () c = Circle () s = Square () t = Triangle () d . next_to ( c , RIGHT ) s . next_to ( c , LEFT ) t . next_to ( c , DOWN ) self . add ( d , c , s , t ) class GeometricShapes(Scene):\n    def construct(self):\n        d = Dot()\n        c = Circle()\n        s = Square()\n        t = Triangle()\n        d.next_to(c, RIGHT)\n        s.next_to(c, LEFT)\n        t.next_to(c, DOWN)\n        self.add(d, c, s, t) Parameters : mobject_or_point ( Mobject | Point3DLike ) direction ( Vector3D ) buff ( float ) aligned_edge ( Vector3D ) submobject_to_align ( Mobject | None ) index_of_submobject_to_align ( int | None ) coor_mask ( Vector3D ) Return type : Self null_point_align ( mobject ) [source]   If a Mobject with points is being aligned to\none without, treat both as groups, and push\nthe one with points into its own submobjects\nlist. Returns : self Return type : Mobject Parameters : mobject ( Mobject ) reduce_across_dimension ( reduce_func , dim ) [source]   Find the min or max value from a dimension across all points in this and submobjects. Parameters : reduce_func ( Callable ) dim ( int ) remove ( * mobjects ) [source]   Remove submobjects . The mobjects are removed from submobjects , if they exist. Subclasses of mobject may implement - and -= dunder methods. Parameters : mobjects ( Mobject ) \u2013 The mobjects to remove. Returns : self Return type : Mobject See also add() remove_updater ( update_function ) [source]   Remove an updater. If the same updater is applied multiple times, every instance gets removed. Parameters : update_function ( Updater ) \u2013 The update function to be removed. Returns : self Return type : Mobject See also clear_updaters() , add_updater() , get_updaters() repeat ( count ) [source]   This can make transition animations nicer Parameters : count ( int ) Return type : Self reset_points ( ) [source]   Sets points to be an empty array. Return type : None restore ( ) [source]   Restores the state that was previously saved with save_state() . Return type : Self resume_updating ( recursive = True ) [source]   Enable updating from updaters and animations. Parameters : recursive ( bool ) \u2013 Whether to recursively enable updating on all submobjects. Returns : self Return type : Mobject See also suspend_updating() , add_updater() rotate ( angle , axis = array([0., 0., 1.]) , about_point = None , ** kwargs ) [source]   Rotates the Mobject about a certain point. Parameters : angle ( float ) axis ( Vector3D ) about_point ( Point3DLike | None ) Return type : Self rotate_about_origin ( angle , axis = array([0., 0., 1.]) , axes = [] ) [source]   Rotates the Mobject about the ORIGIN, which is at [0,0,0]. Parameters : angle ( float ) axis ( Vector3D ) Return type : Self save_image ( name = None ) [source]   Saves an image of only this Mobject at its position to a png\nfile. Parameters : name ( str | None ) Return type : None save_state ( ) [source]   Save the current state (position, color & size). Can be restored with restore() . Return type : Self scale ( scale_factor , ** kwargs ) [source]   Scale the size by a factor. Default behavior is to scale about the center of the mobject. Parameters : scale_factor ( float ) \u2013 The scaling factor \\(\\alpha\\) . If \\(0 < |\\alpha|\u00a0< 1\\) , the mobject\nwill shrink, and for \\(|\\alpha| > 1\\) it will grow. Furthermore,\nif \\(\\alpha < 0\\) , the mobject is also flipped. kwargs \u2013 Additional keyword arguments passed to apply_points_function_about_point() . Returns : self Return type : Mobject Examples Example: MobjectScaleExample   from manim import * class MobjectScaleExample ( Scene ): def construct ( self ): f1 = Text ( \"F\" ) f2 = Text ( \"F\" ) . scale ( 2 ) f3 = Text ( \"F\" ) . scale ( 0.5 ) f4 = Text ( \"F\" ) . scale ( - 1 ) vgroup = VGroup ( f1 , f2 , f3 , f4 ) . arrange ( 6 * RIGHT ) self . add ( vgroup ) class MobjectScaleExample(Scene):\n    def construct(self):\n        f1 = Text(\"F\")\n        f2 = Text(\"F\").scale(2)\n        f3 = Text(\"F\").scale(0.5)\n        f4 = Text(\"F\").scale(-1)\n\n        vgroup = VGroup(f1, f2, f3, f4).arrange(6 * RIGHT)\n        self.add(vgroup) See also move_to() scale_to_fit_depth ( depth , ** kwargs ) [source]   Scales the Mobject to fit a depth while keeping width/height proportional. Parameters : depth ( float ) Return type : Self scale_to_fit_height ( height , ** kwargs ) [source]   Scales the Mobject to fit a height while keeping width/depth proportional. Returns : self Return type : Mobject Parameters : height ( float ) Examples >>> from manim import * >>> sq = Square () >>> sq . width np.float64(2.0) >>> sq . scale_to_fit_height ( 5 ) Square >>> sq . height np.float64(5.0) >>> sq . width np.float64(5.0) scale_to_fit_width ( width , ** kwargs ) [source]   Scales the Mobject to fit a width while keeping height/depth proportional. Returns : self Return type : Mobject Parameters : width ( float ) Examples >>> from manim import * >>> sq = Square () >>> sq . height np.float64(2.0) >>> sq . scale_to_fit_width ( 5 ) Square >>> sq . width np.float64(5.0) >>> sq . height np.float64(5.0) set ( ** kwargs ) [source]   Sets attributes. I.e. my_mobject.set(foo=1) applies my_mobject.foo = 1 . This is a convenience to be used along with animate to\nanimate setting attributes. In addition to this method, there is a compatibility\nlayer that allows get_* and set_* methods to\nget and set generic attributes. For instance: >>> mob = Mobject () >>> mob . set_foo ( 0 ) Mobject >>> mob . get_foo () 0 >>> mob . foo 0 This compatibility layer does not interfere with any get_* or set_* methods that are explicitly\ndefined. Warning This compatibility layer is for backwards compatibility\nand is not guaranteed to stay around. Where applicable,\nplease prefer getting/setting attributes normally or with\nthe set() method. Parameters : **kwargs \u2013 The attributes and corresponding values to set. Returns : self Return type : Mobject Examples >>> mob = Mobject () >>> mob . set ( foo = 0 ) Mobject >>> mob . foo 0 set_color ( color = ManimColor('#FFFF00') , family = True ) [source]   Condition is function which takes in one arguments, (x, y, z).\nHere it just recurses to submobjects, but in subclasses this\nshould be further implemented based on the the inner workings\nof color Parameters : color ( ParsableManimColor ) family ( bool ) Return type : Self set_color_by_gradient ( * colors ) [source]   Parameters : colors ( ParsableManimColor ) \u2013 The colors to use for the gradient. Use like set_color_by_gradient(RED, BLUE, GREEN) . ManimColor.parse ( color ) ( self.color = ) self ( return ) Return type : Self classmethod set_default ( ** kwargs ) [source]   Sets the default values of keyword arguments. If this method is called without any additional keyword\narguments, the original default values of the initialization\nmethod of this class are restored. Parameters : kwargs \u2013 Passing any keyword argument will update the default\nvalues of the keyword arguments of the initialization\nfunction of this class. Return type : None Examples >>> from manim import Square , GREEN >>> Square . set_default ( color = GREEN , fill_opacity = 0.25 ) >>> s = Square (); s . color , s . fill_opacity (ManimColor('#83C167'), 0.25) >>> Square . set_default () >>> s = Square (); s . color , s . fill_opacity (ManimColor('#FFFFFF'), 0.0) Example: ChangedDefaultTextcolor   from manim import * config . background_color = WHITE class ChangedDefaultTextcolor ( Scene ): def construct ( self ): Text . set_default ( color = BLACK ) self . add ( Text ( \"Changing default values is easy!\" )) # we revert the colour back to the default to prevent a bug in the docs. Text . set_default ( color = WHITE ) config.background_color = WHITE\n\nclass ChangedDefaultTextcolor(Scene):\n    def construct(self):\n        Text.set_default(color=BLACK)\n        self.add(Text(\"Changing default values is easy!\"))\n\n        # we revert the colour back to the default to prevent a bug in the docs.\n        Text.set_default(color=WHITE) set_x ( x , direction = array([0., 0., 0.]) ) [source]   Set x value of the center of the Mobject ( int or float ) Parameters : x ( float ) direction ( Vector3D ) Return type : Self set_y ( y , direction = array([0., 0., 0.]) ) [source]   Set y value of the center of the Mobject ( int or float ) Parameters : y ( float ) direction ( Vector3D ) Return type : Self set_z ( z , direction = array([0., 0., 0.]) ) [source]   Set z value of the center of the Mobject ( int or float ) Parameters : z ( float ) direction ( Vector3D ) Return type : Self set_z_index ( z_index_value , family = True ) [source]   Sets the Mobject \u2019s z_index to the value specified in z_index_value . Parameters : z_index_value ( float ) \u2013 The new value of z_index set. family ( bool ) \u2013 If True , the z_index value of all submobjects is also set. Returns : The Mobject itself, after z_index is set. For chaining purposes. (Returns self .) Return type : Mobject Examples Example: SetZIndex   from manim import * class SetZIndex ( Scene ): def construct ( self ): text = Text ( 'z_index = 3' , color = PURE_RED ) . shift ( UP ) . set_z_index ( 3 ) square = Square ( 2 , fill_opacity = 1 ) . set_z_index ( 2 ) tex = Tex ( r 'zIndex = 1' , color = PURE_BLUE ) . shift ( DOWN ) . set_z_index ( 1 ) circle = Circle ( radius = 1.7 , color = GREEN , fill_opacity = 1 ) # z_index = 0 # Displaying order is now defined by z_index values self . add ( text ) self . add ( square ) self . add ( tex ) self . add ( circle ) class SetZIndex(Scene):\n    def construct(self):\n        text = Text('z_index = 3', color = PURE_RED).shift(UP).set_z_index(3)\n        square = Square(2, fill_opacity=1).set_z_index(2)\n        tex = Tex(r'zIndex = 1', color = PURE_BLUE).shift(DOWN).set_z_index(1)\n        circle = Circle(radius = 1.7, color = GREEN, fill_opacity = 1) # z_index = 0\n\n        # Displaying order is now defined by z_index values\n        self.add(text)\n        self.add(square)\n        self.add(tex)\n        self.add(circle) set_z_index_by_z_Point3D ( ) [source]   Sets the Mobject \u2019s z Point3D to the value of z_index . Returns : The Mobject itself, after z_index is set. (Returns self .) Return type : Mobject shift ( * vectors ) [source]   Shift by the given vectors. Parameters : vectors ( Vector3D ) \u2013 Vectors to shift by. If multiple vectors are given, they are added\ntogether. Returns : self Return type : Mobject See also move_to() shuffle ( recursive = False ) [source]   Shuffles the list of submobjects . Parameters : recursive ( bool ) Return type : None shuffle_submobjects ( * args , ** kwargs ) [source]   Shuffles the order of submobjects Examples Example: ShuffleSubmobjectsExample   from manim import * class ShuffleSubmobjectsExample ( Scene ): def construct ( self ): s = VGroup ( * [ Dot () . shift ( i * 0.1 * RIGHT ) for i in range ( - 20 , 20 )]) s2 = s . copy () s2 . shuffle_submobjects () s2 . shift ( DOWN ) self . play ( Write ( s ), Write ( s2 )) class ShuffleSubmobjectsExample(Scene):\n    def construct(self):\n        s= VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n        s2= s.copy()\n        s2.shuffle_submobjects()\n        s2.shift(DOWN)\n        self.play(Write(s), Write(s2)) Return type : None sort ( point_to_num_func=<function Mobject.<lambda>> , submob_func=None ) [source]   Sorts the list of submobjects by a function defined by submob_func . Parameters : point_to_num_func ( Callable [ [ Point3DLike ] , float ] ) submob_func ( Callable [ [ Mobject ] , Any ] | None ) Return type : Self sort_submobjects ( * args , ** kwargs ) [source]   Sort the submobjects Return type : Self stretch_to_fit_depth ( depth , ** kwargs ) [source]   Stretches the Mobject to fit a depth, not keeping width/height proportional. Parameters : depth ( float ) Return type : Self stretch_to_fit_height ( height , ** kwargs ) [source]   Stretches the Mobject to fit a height, not keeping width/depth proportional. Returns : self Return type : Mobject Parameters : height ( float ) Examples >>> from manim import * >>> sq = Square () >>> sq . width np.float64(2.0) >>> sq . stretch_to_fit_height ( 5 ) Square >>> sq . height np.float64(5.0) >>> sq . width np.float64(2.0) stretch_to_fit_width ( width , ** kwargs ) [source]   Stretches the Mobject to fit a width, not keeping height/depth proportional. Returns : self Return type : Mobject Parameters : width ( float ) Examples >>> from manim import * >>> sq = Square () >>> sq . height np.float64(2.0) >>> sq . stretch_to_fit_width ( 5 ) Square >>> sq . width np.float64(5.0) >>> sq . height np.float64(2.0) suspend_updating ( recursive = True ) [source]   Disable updating from updaters and animations. Parameters : recursive ( bool ) \u2013 Whether to recursively suspend updating on all submobjects. Returns : self Return type : Mobject See also resume_updating() , add_updater() to_corner ( corner = array([-1., -1., 0.]) , buff = 0.5 ) [source]   Moves this Mobject to the given corner of the screen. Returns : The newly positioned mobject. Return type : Mobject Parameters : corner ( Vector3D ) buff ( float ) Examples Example: ToCornerExample   from manim import * class ToCornerExample ( Scene ): def construct ( self ): c = Circle () c . to_corner ( UR ) t = Tex ( \"To the corner!\" ) t2 = MathTex ( \"x^3\" ) . shift ( DOWN ) self . add ( c , t , t2 ) t . to_corner ( DL , buff = 0 ) t2 . to_corner ( UL , buff = 1.5 ) class ToCornerExample(Scene):\n    def construct(self):\n        c = Circle()\n        c.to_corner(UR)\n        t = Tex(\"To the corner!\")\n        t2 = MathTex(\"x^3\").shift(DOWN)\n        self.add(c,t,t2)\n        t.to_corner(DL, buff=0)\n        t2.to_corner(UL, buff=1.5) to_edge ( edge = array([-1., 0., 0.]) , buff = 0.5 ) [source]   Moves this Mobject to the given edge of the screen,\nwithout affecting its position in the other dimension. Returns : The newly positioned mobject. Return type : Mobject Parameters : edge ( Vector3D ) buff ( float ) Examples Example: ToEdgeExample   from manim import * class ToEdgeExample ( Scene ): def construct ( self ): tex_top = Tex ( \"I am at the top!\" ) tex_top . to_edge ( UP ) tex_side = Tex ( \"I am moving to the side!\" ) c = Circle () . shift ( 2 * DOWN ) self . add ( tex_top , tex_side , c ) tex_side . to_edge ( LEFT ) c . to_edge ( RIGHT , buff = 0 ) class ToEdgeExample(Scene):\n    def construct(self):\n        tex_top = Tex(\"I am at the top!\")\n        tex_top.to_edge(UP)\n        tex_side = Tex(\"I am moving to the side!\")\n        c = Circle().shift(2*DOWN)\n        self.add(tex_top, tex_side, c)\n        tex_side.to_edge(LEFT)\n        c.to_edge(RIGHT, buff=0) update ( dt = 0 , recursive = True ) [source]   Apply all updaters. Does nothing if updating is suspended. Parameters : dt ( float ) \u2013 The parameter dt to pass to the update functions. Usually this is the\ntime in seconds since the last call of update . recursive ( bool ) \u2013 Whether to recursively update all submobjects. Returns : self Return type : Mobject See also add_updater() , get_updaters() property width : float   The width of the mobject. Return type : float Examples Example: WidthExample   from manim import * class WidthExample ( Scene ): def construct ( self ): decimal = DecimalNumber () . to_edge ( UP ) rect = Rectangle ( color = BLUE ) rect_copy = rect . copy () . set_stroke ( GRAY , opacity = 0.5 ) decimal . add_updater ( lambda d : d . set_value ( rect . width )) self . add ( rect_copy , rect , decimal ) self . play ( rect . animate . set ( width = 7 )) self . wait () class WidthExample(Scene):\n    def construct(self):\n        decimal = DecimalNumber().to_edge(UP)\n        rect = Rectangle(color=BLUE)\n        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)\n\n        decimal.add_updater(lambda d: d.set_value(rect.width))\n\n        self.add(rect_copy, rect, decimal)\n        self.play(rect.animate.set(width=7))\n        self.wait() See also length_over_dim()", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html"}
{"prompt": "class TimeBasedUpdater", "response": "Callable [[ 'Mobject' , float ], object ]", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html#manim.mobject.mobject.override_animate"}
{"prompt": "class NonTimeBasedUpdater", "response": "Callable [[ 'Mobject' ], object ]", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html#manim.mobject.mobject.override_animate"}
{"prompt": "class Updater", "response": "NonTimeBasedUpdater` | TimeBasedUpdater`", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html#manim.mobject.mobject.override_animate"}
{"prompt": "override_animate(method)", "response": "Decorator for overriding method animations. This allows to specify a method (returning an Animation )\nwhich is called when the decorated method is used with the .animate syntax\nfor animating the application of a method. See also Mobject.animate Note Overridden methods cannot be combined with normal or other overridden\nmethods using method chaining with the .animate syntax. Examples Example: AnimationOverrideExample   from manim import * class CircleWithContent ( VGroup ): def __init__ ( self , content ): super () . __init__ () self . circle = Circle () self . content = content self . add ( self . circle , content ) content . move_to ( self . circle . get_center ()) def clear_content ( self ): self . remove ( self . content ) self . content = None @override_animate ( clear_content ) def _clear_content_animation ( self , anim_args = None ): if anim_args is None : anim_args = {} anim = Uncreate ( self . content , ** anim_args ) self . clear_content () return anim class AnimationOverrideExample ( Scene ): def construct ( self ): t = Text ( \"hello!\" ) my_mobject = CircleWithContent ( t ) self . play ( Create ( my_mobject )) self . play ( my_mobject . animate . clear_content ()) self . wait () class CircleWithContent(VGroup):\n    def __init__(self, content):\n        super().__init__()\n        self.circle = Circle()\n        self.content = content\n        self.add(self.circle, content)\n        content.move_to(self.circle.get_center())\n\n    def clear_content(self):\n        self.remove(self.content)\n        self.content = None\n\n    @override_animate(clear_content)\n    def _clear_content_animation(self, anim_args=None):\n        if anim_args is None:\n            anim_args = {}\n        anim = Uncreate(self.content, **anim_args)\n        self.clear_content()\n        return anim\n\nclass AnimationOverrideExample(Scene):\n    def construct(self):\n        t = Text(\"hello!\")\n        my_mobject = CircleWithContent(t)\n        self.play(Create(my_mobject))\n        self.play(my_mobject.animate.clear_content())\n        self.wait() Return type : LambdaType", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html#manim.mobject.mobject.override_animate"}
{"prompt": "class DecimalTable(table, element_to_mobject=<class 'manim.mobject.text.numbers.DecimalNumber'>, element_to_mobject_config={'num_decimal_places': 1}, **kwargs)", "response": "Bases: Table A specialized Table mobject for use with DecimalNumber to display decimal entries. Examples Example: DecimalTableExample   from manim import * class DecimalTableExample ( Scene ): def construct ( self ): x_vals = [ - 2 , - 1 , 0 , 1 , 2 ] y_vals = np . exp ( x_vals ) t0 = DecimalTable ( [ x_vals , y_vals ], row_labels = [ MathTex ( \"x\" ), MathTex ( \"f(x)=e^ {x} \" )], h_buff = 1 , element_to_mobject_config = { \"num_decimal_places\" : 2 }) self . add ( t0 ) class DecimalTableExample(Scene):\n    def construct(self):\n        x_vals = [-2,-1,0,1,2]\n        y_vals = np.exp(x_vals)\n        t0 = DecimalTable(\n            [x_vals, y_vals],\n            row_labels=[MathTex(\"x\"), MathTex(\"f(x)=e^{x}\")],\n            h_buff=1,\n            element_to_mobject_config={\"num_decimal_places\": 2})\n        self.add(t0) Special case of Table with element_to_mobject set to DecimalNumber .\nBy default, num_decimal_places is set to 1.\nWill round/truncate the decimal places based on the provided element_to_mobject_config . Parameters : table ( Iterable [ Iterable [ float | str ] ] ) \u2013 A 2D array, or a list of lists. Content of the table must be valid input\nfor DecimalNumber . element_to_mobject ( Callable [ [ float | str ] , VMobject ] ) \u2013 The Mobject class applied to the table entries. Set as DecimalNumber . element_to_mobject_config ( dict ) \u2013 Element to mobject config, here set as {\u201cnum_decimal_places\u201d: 1}. kwargs \u2013 Additional arguments to be passed to Table . Methods Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( table , element_to_mobject=<class 'manim.mobject.text.numbers.DecimalNumber'> , element_to_mobject_config={'num_decimal_places': 1} , **kwargs )   Special case of Table with element_to_mobject set to DecimalNumber .\nBy default, num_decimal_places is set to 1.\nWill round/truncate the decimal places based on the provided element_to_mobject_config . Parameters : table ( Iterable [ Iterable [ float | str ] ] ) \u2013 A 2D array, or a list of lists. Content of the table must be valid input\nfor DecimalNumber . element_to_mobject ( Callable [ [ float | str ] , VMobject ] ) \u2013 The Mobject class applied to the table entries. Set as DecimalNumber . element_to_mobject_config ( dict ) \u2013 Element to mobject config, here set as {\u201cnum_decimal_places\u201d: 1}. kwargs \u2013 Additional arguments to be passed to Table .", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.table.DecimalTable.html"}
{"prompt": "class IntegerTable(table, element_to_mobject=<class 'manim.mobject.text.numbers.Integer'>, **kwargs)", "response": "Bases: Table A specialized Table mobject for use with Integer . Examples Example: IntegerTableExample   from manim import * class IntegerTableExample ( Scene ): def construct ( self ): t0 = IntegerTable ( [[ 0 , 30 , 45 , 60 , 90 ], [ 90 , 60 , 45 , 30 , 0 ]], col_labels = [ MathTex ( r \"\\frac{\\sqrt {0} } {2} \" ), MathTex ( r \"\\frac{\\sqrt {1} } {2} \" ), MathTex ( r \"\\frac{\\sqrt {2} } {2} \" ), MathTex ( r \"\\frac{\\sqrt {3} } {2} \" ), MathTex ( r \"\\frac{\\sqrt {4} } {2} \" )], row_labels = [ MathTex ( r \"\\sin\" ), MathTex ( r \"\\cos\" )], h_buff = 1 , element_to_mobject_config = { \"unit\" : r \"^{\\circ}\" }) self . add ( t0 ) class IntegerTableExample(Scene):\n    def construct(self):\n        t0 = IntegerTable(\n            [[0,30,45,60,90],\n            [90,60,45,30,0]],\n            col_labels=[\n                MathTex(r\"\\frac{\\sqrt{0}}{2}\"),\n                MathTex(r\"\\frac{\\sqrt{1}}{2}\"),\n                MathTex(r\"\\frac{\\sqrt{2}}{2}\"),\n                MathTex(r\"\\frac{\\sqrt{3}}{2}\"),\n                MathTex(r\"\\frac{\\sqrt{4}}{2}\")],\n            row_labels=[MathTex(r\"\\sin\"), MathTex(r\"\\cos\")],\n            h_buff=1,\n            element_to_mobject_config={\"unit\": r\"^{\\circ}\"})\n        self.add(t0) Special case of Table with element_to_mobject set to Integer .\nWill round if there are decimal entries in the table. Parameters : table ( Iterable [ Iterable [ float | str ] ] ) \u2013 A 2d array or list of lists. Content of the table has to be valid input\nfor Integer . element_to_mobject ( Callable [ [ float | str ] , VMobject ] ) \u2013 The Mobject class applied to the table entries. Set as Integer . kwargs \u2013 Additional arguments to be passed to Table . Methods Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( table , element_to_mobject=<class 'manim.mobject.text.numbers.Integer'> , **kwargs )   Special case of Table with element_to_mobject set to Integer .\nWill round if there are decimal entries in the table. Parameters : table ( Iterable [ Iterable [ float | str ] ] ) \u2013 A 2d array or list of lists. Content of the table has to be valid input\nfor Integer . element_to_mobject ( Callable [ [ float | str ] , VMobject ] ) \u2013 The Mobject class applied to the table entries. Set as Integer . kwargs \u2013 Additional arguments to be passed to Table .", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.table.IntegerTable.html"}
{"prompt": "class MathTable(table, element_to_mobject=<class 'manim.mobject.text.tex_mobject.MathTex'>, **kwargs)", "response": "Bases: Table A specialized Table mobject for use with LaTeX. Examples Example: MathTableExample   from manim import * class MathTableExample ( Scene ): def construct ( self ): t0 = MathTable ( [[ \"+\" , 0 , 5 , 10 ], [ 0 , 0 , 5 , 10 ], [ 2 , 2 , 7 , 12 ], [ 4 , 4 , 9 , 14 ]], include_outer_lines = True ) self . add ( t0 ) class MathTableExample(Scene):\n    def construct(self):\n        t0 = MathTable(\n            [[\"+\", 0, 5, 10],\n            [0, 0, 5, 10],\n            [2, 2, 7, 12],\n            [4, 4, 9, 14]],\n            include_outer_lines=True)\n        self.add(t0) Special case of Table with element_to_mobject set to MathTex .\nEvery entry in table is set in a Latex align environment. Parameters : table ( Iterable [ Iterable [ float | str ] ] ) \u2013 A 2d array or list of lists. Content of the table have to be valid input\nfor MathTex . element_to_mobject ( Callable [ [ float | str ] , VMobject ] ) \u2013 The Mobject class applied to the table entries. Set as MathTex . kwargs \u2013 Additional arguments to be passed to Table . Methods Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( table , element_to_mobject=<class 'manim.mobject.text.tex_mobject.MathTex'> , **kwargs )   Special case of Table with element_to_mobject set to MathTex .\nEvery entry in table is set in a Latex align environment. Parameters : table ( Iterable [ Iterable [ float | str ] ] ) \u2013 A 2d array or list of lists. Content of the table have to be valid input\nfor MathTex . element_to_mobject ( Callable [ [ float | str ] , VMobject ] ) \u2013 The Mobject class applied to the table entries. Set as MathTex . kwargs \u2013 Additional arguments to be passed to Table .", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.table.MathTable.html"}
{"prompt": "class MobjectTable(table, element_to_mobject=<function MobjectTable.<lambda>>, **kwargs)", "response": "Bases: Table A specialized Table mobject for use with Mobject . Examples Example: MobjectTableExample   from manim import * class MobjectTableExample ( Scene ): def construct ( self ): cross = VGroup ( Line ( UP + LEFT , DOWN + RIGHT ), Line ( UP + RIGHT , DOWN + LEFT ), ) a = Circle () . set_color ( RED ) . scale ( 0.5 ) b = cross . set_color ( BLUE ) . scale ( 0.5 ) t0 = MobjectTable ( [[ a . copy (), b . copy (), a . copy ()], [ b . copy (), a . copy (), a . copy ()], [ a . copy (), b . copy (), b . copy ()]] ) line = Line ( t0 . get_corner ( DL ), t0 . get_corner ( UR ) ) . set_color ( RED ) self . add ( t0 , line ) class MobjectTableExample(Scene):\n    def construct(self):\n        cross = VGroup(\n            Line(UP + LEFT, DOWN + RIGHT),\n            Line(UP + RIGHT, DOWN + LEFT),\n        )\n        a = Circle().set_color(RED).scale(0.5)\n        b = cross.set_color(BLUE).scale(0.5)\n        t0 = MobjectTable(\n            [[a.copy(),b.copy(),a.copy()],\n            [b.copy(),a.copy(),a.copy()],\n            [a.copy(),b.copy(),b.copy()]]\n        )\n        line = Line(\n            t0.get_corner(DL), t0.get_corner(UR)\n        ).set_color(RED)\n        self.add(t0, line) Special case of Table with element_to_mobject set to an identity function.\nHere, every item in table must already be of type Mobject . Parameters : table ( Iterable [ Iterable [ VMobject ] ] ) \u2013 A 2D array or list of lists. Content of the table must be of type Mobject . element_to_mobject ( Callable [ [ VMobject ] , VMobject ] ) \u2013 The Mobject class applied to the table entries. Set as lambda m : m to return itself. kwargs \u2013 Additional arguments to be passed to Table . Methods Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( table , element_to_mobject=<function MobjectTable.<lambda>> , **kwargs )   Special case of Table with element_to_mobject set to an identity function.\nHere, every item in table must already be of type Mobject . Parameters : table ( Iterable [ Iterable [ VMobject ] ] ) \u2013 A 2D array or list of lists. Content of the table must be of type Mobject . element_to_mobject ( Callable [ [ VMobject ] , VMobject ] ) \u2013 The Mobject class applied to the table entries. Set as lambda m : m to return itself. kwargs \u2013 Additional arguments to be passed to Table .", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.table.MobjectTable.html"}
{"prompt": "class Table(table, row_labels=None, col_labels=None, top_left_entry=None, v_buff=0.8, h_buff=1.3, include_outer_lines=False, add_background_rectangles_to_entries=False, entries_background_color=ManimColor('#000000'), include_background_rectangle=False, background_rectangle_color=ManimColor('#000000'), element_to_mobject=<class 'manim.mobject.text.text_mobject.Paragraph'>, element_to_mobject_config={}, arrange_in_grid_config={}, line_config={}, **kwargs)", "response": "Bases: VGroup A mobject that displays a table on the screen. Parameters : table ( Iterable [ Iterable [ float | str | VMobject ] ] ) \u2013 A 2D array or list of lists. Content of the table has to be a valid input\nfor the callable set in element_to_mobject . row_labels ( Iterable [ VMobject ] | None ) \u2013 List of VMobject representing the labels of each row. col_labels ( Iterable [ VMobject ] | None ) \u2013 List of VMobject representing the labels of each column. top_left_entry ( VMobject | None ) \u2013 The top-left entry of the table, can only be specified if row and\ncolumn labels are given. v_buff ( float ) \u2013 Vertical buffer passed to arrange_in_grid() , by default 0.8. h_buff ( float ) \u2013 Horizontal buffer passed to arrange_in_grid() , by default 1.3. include_outer_lines ( bool ) \u2013 True if the table should include outer lines, by default False. add_background_rectangles_to_entries ( bool ) \u2013 True if background rectangles should be added to entries, by default False . entries_background_color ( ParsableManimColor ) \u2013 Background color of entries if add_background_rectangles_to_entries is True . include_background_rectangle ( bool ) \u2013 True if the table should have a background rectangle, by default False . background_rectangle_color ( ParsableManimColor ) \u2013 Background color of table if include_background_rectangle is True . element_to_mobject ( Callable [ [ float | str | VMobject ] , VMobject ] ) \u2013 The Mobject class applied to the table entries. by default Paragraph . For common choices, see text_mobject / tex_mobject . element_to_mobject_config ( dict ) \u2013 Custom configuration passed to element_to_mobject , by default {}. arrange_in_grid_config ( dict ) \u2013 Dict passed to arrange_in_grid() , customizes the arrangement of the table. line_config ( dict ) \u2013 Dict passed to Line , customizes the lines of the table. kwargs \u2013 Additional arguments to be passed to VGroup . Examples Example: TableExamples   from manim import * class TableExamples ( Scene ): def construct ( self ): t0 = Table ( [[ \"This\" , \"is a\" ], [ \"simple\" , \"Table in \\\\ n Manim.\" ]]) t1 = Table ( [[ \"This\" , \"is a\" ], [ \"simple\" , \"Table.\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) t1 . add_highlighted_cell (( 2 , 2 ), color = YELLOW ) t2 = Table ( [[ \"This\" , \"is a\" ], [ \"simple\" , \"Table.\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )], top_left_entry = Star () . scale ( 0.3 ), include_outer_lines = True , arrange_in_grid_config = { \"cell_alignment\" : RIGHT }) t2 . add ( t2 . get_cell (( 2 , 2 ), color = RED )) t3 = Table ( [[ \"This\" , \"is a\" ], [ \"simple\" , \"Table.\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )], top_left_entry = Star () . scale ( 0.3 ), include_outer_lines = True , line_config = { \"stroke_width\" : 1 , \"color\" : YELLOW }) t3 . remove ( * t3 . get_vertical_lines ()) g = Group ( t0 , t1 , t2 , t3 ) . scale ( 0.7 ) . arrange_in_grid ( buff = 1 ) self . add ( g ) class TableExamples(Scene):\n    def construct(self):\n        t0 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table in \\\\n Manim.\"]])\n        t1 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        t1.add_highlighted_cell((2,2), color=YELLOW)\n        t2 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")],\n            top_left_entry=Star().scale(0.3),\n            include_outer_lines=True,\n            arrange_in_grid_config={\"cell_alignment\": RIGHT})\n        t2.add(t2.get_cell((2,2), color=RED))\n        t3 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")],\n            top_left_entry=Star().scale(0.3),\n            include_outer_lines=True,\n            line_config={\"stroke_width\": 1, \"color\": YELLOW})\n        t3.remove(*t3.get_vertical_lines())\n        g = Group(\n            t0,t1,t2,t3\n        ).scale(0.7).arrange_in_grid(buff=1)\n        self.add(g) Example: BackgroundRectanglesExample   from manim import * class BackgroundRectanglesExample ( Scene ): def construct ( self ): background = Rectangle ( height = 6.5 , width = 13 ) background . set_fill ( opacity = .5 ) background . set_color ([ TEAL , RED , YELLOW ]) self . add ( background ) t0 = Table ( [[ \"This\" , \"is a\" ], [ \"simple\" , \"Table.\" ]], add_background_rectangles_to_entries = True ) t1 = Table ( [[ \"This\" , \"is a\" ], [ \"simple\" , \"Table.\" ]], include_background_rectangle = True ) g = Group ( t0 , t1 ) . scale ( 0.7 ) . arrange ( buff = 0.5 ) self . add ( g ) class BackgroundRectanglesExample(Scene):\n    def construct(self):\n        background = Rectangle(height=6.5, width=13)\n        background.set_fill(opacity=.5)\n        background.set_color([TEAL, RED, YELLOW])\n        self.add(background)\n        t0 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            add_background_rectangles_to_entries=True)\n        t1 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            include_background_rectangle=True)\n        g = Group(t0, t1).scale(0.7).arrange(buff=0.5)\n        self.add(g) Methods add_background_to_entries Adds a black BackgroundRectangle to each entry of the table. add_highlighted_cell Highlights one cell at a specific position on the table by adding a BackgroundRectangle . create Customized create-type function for tables. get_cell Returns one specific cell as a rectangular Polygon without the entry. get_col_labels Return the column labels of the table. get_columns Return columns of the table as a VGroup of VGroup . get_entries Return the individual entries of the table (including labels) or one specific entry if the parameter, pos ,  is set. get_entries_without_labels Return the individual entries of the table (without labels) or one specific entry if the parameter, pos , is set. get_highlighted_cell Returns a BackgroundRectangle of the cell at the given position. get_horizontal_lines Return the horizontal lines of the table. get_labels Returns the labels of the table. get_row_labels Return the row labels of the table. get_rows Return the rows of the table as a VGroup of VGroup . get_vertical_lines Return the vertical lines of the table. scale Scale the size by a factor. set_column_colors Set individual colors for each column of the table. set_row_colors Set individual colors for each row of the table. Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _add_horizontal_lines ( ) [source]   Adds the horizontal lines to the table. Return type : Table _add_labels ( mob_table ) [source]   Adds labels to an in a grid arranged VGroup . Parameters : mob_table ( VGroup ) \u2013 An in a grid organized class: ~.VGroup . Returns : Returns the mob_table with added labels. Return type : VGroup _add_vertical_lines ( ) [source]   Adds the vertical lines to the table Return type : Table _organize_mob_table ( table ) [source]   Arranges the VMobject of table in a grid. Parameters : table ( Iterable [ Iterable [ VMobject ] ] ) \u2013 A 2D iterable object with VMobject entries. Returns : The VMobject of the table in a VGroup already\narranged in a table-like grid. Return type : VGroup _original__init__ ( table , row_labels=None , col_labels=None , top_left_entry=None , v_buff=0.8 , h_buff=1.3 , include_outer_lines=False , add_background_rectangles_to_entries=False , entries_background_color=ManimColor('#000000') , include_background_rectangle=False , background_rectangle_color=ManimColor('#000000') , element_to_mobject=<class 'manim.mobject.text.text_mobject.Paragraph'> , element_to_mobject_config={} , arrange_in_grid_config={} , line_config={} , **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : table ( Iterable [ Iterable [ float | str | VMobject ] ] ) row_labels ( Iterable [ VMobject ] | None ) col_labels ( Iterable [ VMobject ] | None ) top_left_entry ( VMobject | None ) v_buff ( float ) h_buff ( float ) include_outer_lines ( bool ) add_background_rectangles_to_entries ( bool ) entries_background_color ( ParsableManimColor ) include_background_rectangle ( bool ) background_rectangle_color ( ParsableManimColor ) element_to_mobject ( Callable [ [ float | str | VMobject ] , VMobject ] ) element_to_mobject_config ( dict ) arrange_in_grid_config ( dict ) line_config ( dict ) _table_to_mob_table ( table ) [source]   Initilaizes the entries of table as VMobject . Parameters : table ( Iterable [ Iterable [ float | str | VMobject ] ] ) \u2013 A 2D array or list of lists. Content of the table has to be a valid input\nfor the callable set in element_to_mobject . Returns : List of VMobject from the entries of table . Return type : List add_background_to_entries ( color = ManimColor('#000000') ) [source]   Adds a black BackgroundRectangle to each entry of the table. Parameters : color ( ParsableManimColor ) Return type : Table add_highlighted_cell ( pos = (1, 1) , color = ManimColor('#FFFF00') , ** kwargs ) [source]   Highlights one cell at a specific position on the table by adding a BackgroundRectangle . Parameters : pos ( Sequence [ int ] ) \u2013 The position of a specific entry on the table. (1,1) being the top left entry\nof the table. color ( ParsableManimColor ) \u2013 The color used to highlight the cell. kwargs \u2013 Additional arguments to be passed to BackgroundRectangle . Return type : Table Examples Example: AddHighlightedCellExample   from manim import * class AddHighlightedCellExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) table . add_highlighted_cell (( 2 , 2 ), color = GREEN ) self . add ( table ) class AddHighlightedCellExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.add_highlighted_cell((2,2), color=GREEN)\n        self.add(table) create ( lag_ratio=1 , line_animation=<class 'manim.animation.creation.Create'> , label_animation=<class 'manim.animation.creation.Write'> , element_animation=<class 'manim.animation.creation.Create'> , entry_animation=<class 'manim.animation.fading.FadeIn'> , **kwargs ) [source]   Customized create-type function for tables. Parameters : lag_ratio ( float ) \u2013 The lag ratio of the animation. line_animation ( Callable [ [ VMobject | VGroup ] , Animation ] ) \u2013 The animation style of the table lines, see creation for examples. label_animation ( Callable [ [ VMobject | VGroup ] , Animation ] ) \u2013 The animation style of the table labels, see creation for examples. element_animation ( Callable [ [ VMobject | VGroup ] , Animation ] ) \u2013 The animation style of the table elements, see creation for examples. entry_animation ( Callable [ [ VMobject | VGroup ] , Animation ] ) \u2013 The entry animation of the table background, see creation for examples. kwargs \u2013 Further arguments passed to the creation animations. Returns : AnimationGroup containing creation of the lines and of the elements. Return type : AnimationGroup Examples Example: CreateTableExample   from manim import * class CreateTableExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )], include_outer_lines = True ) self . play ( table . create ()) self . wait () class CreateTableExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")],\n            include_outer_lines=True)\n        self.play(table.create())\n        self.wait() get_cell ( pos = (1, 1) , ** kwargs ) [source]   Returns one specific cell as a rectangular Polygon without the entry. Parameters : pos ( Sequence [ int ] ) \u2013 The position of a specific entry on the table. (1,1) being the top left entry\nof the table. kwargs \u2013 Additional arguments to be passed to Polygon . Returns : Polygon mimicking one specific cell of the Table. Return type : Polygon Examples Example: GetCellExample   from manim import * class GetCellExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) cell = table . get_cell (( 2 , 2 ), color = RED ) self . add ( table , cell ) class GetCellExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        cell = table.get_cell((2,2), color=RED)\n        self.add(table, cell) get_col_labels ( ) [source]   Return the column labels of the table. Returns : VGroup containing the column labels of the table. Return type : VGroup Examples Example: GetColLabelsExample   from manim import * class GetColLabelsExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) lab = table . get_col_labels () for item in lab : item . set_color ( random_bright_color ()) self . add ( table ) class GetColLabelsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        lab = table.get_col_labels()\n        for item in lab:\n            item.set_color(random_bright_color())\n        self.add(table) get_columns ( ) [source]   Return columns of the table as a VGroup of VGroup . Returns : VGroup containing each column in a VGroup . Return type : VGroup Examples Example: GetColumnsExample   from manim import * class GetColumnsExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) table . add ( SurroundingRectangle ( table . get_columns ()[ 1 ])) self . add ( table ) class GetColumnsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.add(SurroundingRectangle(table.get_columns()[1]))\n        self.add(table) get_entries ( pos = None ) [source]   Return the individual entries of the table (including labels) or one specific entry\nif the parameter, pos ,  is set. Parameters : pos ( Sequence [ int ] | None ) \u2013 The position of a specific entry on the table. (1,1) being the top left entry\nof the table. Returns : VGroup containing all entries of the table (including labels)\nor the VMobject at the given position if pos is set. Return type : Union[ VMobject , VGroup ] Examples Example: GetEntriesExample   from manim import * class GetEntriesExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) ent = table . get_entries () for item in ent : item . set_color ( random_bright_color ()) table . get_entries (( 2 , 2 )) . rotate ( PI ) self . add ( table ) class GetEntriesExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        ent = table.get_entries()\n        for item in ent:\n            item.set_color(random_bright_color())\n        table.get_entries((2,2)).rotate(PI)\n        self.add(table) get_entries_without_labels ( pos = None ) [source]   Return the individual entries of the table (without labels) or one specific entry\nif the parameter, pos , is set. Parameters : pos ( Sequence [ int ] | None ) \u2013 The position of a specific entry on the table. (1,1) being the top left entry\nof the table (without labels). Returns : VGroup containing all entries of the table (without labels)\nor the VMobject at the given position if pos is set. Return type : Union[ VMobject , VGroup ] Examples Example: GetEntriesWithoutLabelsExample   from manim import * class GetEntriesWithoutLabelsExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) ent = table . get_entries_without_labels () colors = [ BLUE , GREEN , YELLOW , RED ] for k in range ( len ( colors )): ent [ k ] . set_color ( colors [ k ]) table . get_entries_without_labels (( 2 , 2 )) . rotate ( PI ) self . add ( table ) class GetEntriesWithoutLabelsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        ent = table.get_entries_without_labels()\n        colors = [BLUE, GREEN, YELLOW, RED]\n        for k in range(len(colors)):\n            ent[k].set_color(colors[k])\n        table.get_entries_without_labels((2,2)).rotate(PI)\n        self.add(table) get_highlighted_cell ( pos = (1, 1) , color = ManimColor('#FFFF00') , ** kwargs ) [source]   Returns a BackgroundRectangle of the cell at the given position. Parameters : pos ( Sequence [ int ] ) \u2013 The position of a specific entry on the table. (1,1) being the top left entry\nof the table. color ( ParsableManimColor ) \u2013 The color used to highlight the cell. kwargs \u2013 Additional arguments to be passed to BackgroundRectangle . Return type : BackgroundRectangle Examples Example: GetHighlightedCellExample   from manim import * class GetHighlightedCellExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) highlight = table . get_highlighted_cell (( 2 , 2 ), color = GREEN ) table . add_to_back ( highlight ) self . add ( table ) class GetHighlightedCellExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        highlight = table.get_highlighted_cell((2,2), color=GREEN)\n        table.add_to_back(highlight)\n        self.add(table) get_horizontal_lines ( ) [source]   Return the horizontal lines of the table. Returns : VGroup containing all the horizontal lines of the table. Return type : VGroup Examples Example: GetHorizontalLinesExample   from manim import * class GetHorizontalLinesExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) table . get_horizontal_lines () . set_color ( RED ) self . add ( table ) class GetHorizontalLinesExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.get_horizontal_lines().set_color(RED)\n        self.add(table) get_labels ( ) [source]   Returns the labels of the table. Returns : VGroup containing all the labels of the table. Return type : VGroup Examples Example: GetLabelsExample   from manim import * class GetLabelsExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) lab = table . get_labels () colors = [ BLUE , GREEN , YELLOW , RED ] for k in range ( len ( colors )): lab [ k ] . set_color ( colors [ k ]) self . add ( table ) class GetLabelsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        lab = table.get_labels()\n        colors = [BLUE, GREEN, YELLOW, RED]\n        for k in range(len(colors)):\n            lab[k].set_color(colors[k])\n        self.add(table) get_row_labels ( ) [source]   Return the row labels of the table. Returns : VGroup containing the row labels of the table. Return type : VGroup Examples Example: GetRowLabelsExample   from manim import * class GetRowLabelsExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) lab = table . get_row_labels () for item in lab : item . set_color ( random_bright_color ()) self . add ( table ) class GetRowLabelsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        lab = table.get_row_labels()\n        for item in lab:\n            item.set_color(random_bright_color())\n        self.add(table) get_rows ( ) [source]   Return the rows of the table as a VGroup of VGroup . Returns : VGroup containing each row in a VGroup . Return type : VGroup Examples Example: GetRowsExample   from manim import * class GetRowsExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) table . add ( SurroundingRectangle ( table . get_rows ()[ 1 ])) self . add ( table ) class GetRowsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.add(SurroundingRectangle(table.get_rows()[1]))\n        self.add(table) get_vertical_lines ( ) [source]   Return the vertical lines of the table. Returns : VGroup containing all the vertical lines of the table. Return type : VGroup Examples Example: GetVerticalLinesExample   from manim import * class GetVerticalLinesExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )]) table . get_vertical_lines ()[ 0 ] . set_color ( RED ) self . add ( table ) class GetVerticalLinesExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.get_vertical_lines()[0].set_color(RED)\n        self.add(table) scale ( scale_factor , ** kwargs ) [source]   Scale the size by a factor. Default behavior is to scale about the center of the vmobject. Parameters : scale_factor ( float ) \u2013 The scaling factor \\(\\alpha\\) . If \\(0 < |\\alpha|\u00a0< 1\\) , the mobject\nwill shrink, and for \\(|\\alpha| > 1\\) it will grow. Furthermore,\nif \\(\\alpha < 0\\) , the mobject is also flipped. scale_stroke \u2013 Boolean determining if the object\u2019s outline is scaled when the object is scaled.\nIf enabled, and object with 2px outline is scaled by a factor of .5, it will have an outline of 1px. kwargs \u2013 Additional keyword arguments passed to scale() . Returns : self Return type : VMobject Examples Example: MobjectScaleExample   from manim import * class MobjectScaleExample ( Scene ): def construct ( self ): c1 = Circle ( 1 , RED ) . set_x ( - 1 ) c2 = Circle ( 1 , GREEN ) . set_x ( 1 ) vg = VGroup ( c1 , c2 ) vg . set_stroke ( width = 50 ) self . add ( vg ) self . play ( c1 . animate . scale ( .25 ), c2 . animate . scale ( .25 , scale_stroke = True ) ) class MobjectScaleExample(Scene):\n    def construct(self):\n        c1 = Circle(1, RED).set_x(-1)\n        c2 = Circle(1, GREEN).set_x(1)\n\n        vg = VGroup(c1, c2)\n        vg.set_stroke(width=50)\n        self.add(vg)\n\n        self.play(\n            c1.animate.scale(.25),\n            c2.animate.scale(.25,\n                scale_stroke=True)\n        ) See also move_to() set_column_colors ( * colors ) [source]   Set individual colors for each column of the table. Parameters : colors ( Iterable [ ParsableManimColor ] ) \u2013 An iterable of colors; each color corresponds to a column. Return type : Table Examples Example: SetColumnColorsExample   from manim import * class SetColumnColorsExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )] ) . set_column_colors ([ RED , BLUE ], GREEN ) self . add ( table ) class SetColumnColorsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")]\n        ).set_column_colors([RED,BLUE], GREEN)\n        self.add(table) set_row_colors ( * colors ) [source]   Set individual colors for each row of the table. Parameters : colors ( Iterable [ ParsableManimColor ] ) \u2013 An iterable of colors; each color corresponds to a row. Return type : Table Examples Example: SetRowColorsExample   from manim import * class SetRowColorsExample ( Scene ): def construct ( self ): table = Table ( [[ \"First\" , \"Second\" ], [ \"Third\" , \"Fourth\" ]], row_labels = [ Text ( \"R1\" ), Text ( \"R2\" )], col_labels = [ Text ( \"C1\" ), Text ( \"C2\" )] ) . set_row_colors ([ RED , BLUE ], GREEN ) self . add ( table ) class SetRowColorsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")]\n        ).set_row_colors([RED,BLUE], GREEN)\n        self.add(table)", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html"}
{"prompt": "get_mobject_class()", "response": "Gets the base mobject class, depending on the currently active renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_mobject_class >>> get_mobject_class () . __name__ in [ 'Mobject' , 'OpenGLMobject' ] True Return type : type", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.utils.html"}
{"prompt": "get_point_mobject_class()", "response": "Gets the point cloud mobject class, depending on the currently\nactive renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_point_mobject_class >>> get_point_mobject_class () . __name__ in [ 'PMobject' , 'OpenGLPMobject' ] True Return type : type", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.utils.html"}
{"prompt": "get_vectorized_mobject_class()", "response": "Gets the vectorized mobject class, depending on the currently\nactive renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_vectorized_mobject_class >>> get_vectorized_mobject_class () . __name__ in [ 'VMobject' , 'OpenGLVMobject' ] True Return type : type", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.utils.html"}
{"prompt": "get_mobject_class()", "response": "Gets the base mobject class, depending on the currently active renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_mobject_class >>> get_mobject_class () . __name__ in [ 'Mobject' , 'OpenGLMobject' ] True Return type : type", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.utils.html#manim.mobject.utils.get_mobject_class"}
{"prompt": "get_point_mobject_class()", "response": "Gets the point cloud mobject class, depending on the currently\nactive renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_point_mobject_class >>> get_point_mobject_class () . __name__ in [ 'PMobject' , 'OpenGLPMobject' ] True Return type : type", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.utils.html#manim.mobject.utils.get_mobject_class"}
{"prompt": "get_vectorized_mobject_class()", "response": "Gets the vectorized mobject class, depending on the currently\nactive renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_vectorized_mobject_class >>> get_vectorized_mobject_class () . __name__ in [ 'VMobject' , 'OpenGLVMobject' ] True Return type : type", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.utils.html#manim.mobject.utils.get_mobject_class"}
{"prompt": "get_mobject_class()", "response": "Gets the base mobject class, depending on the currently active renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_mobject_class >>> get_mobject_class () . __name__ in [ 'Mobject' , 'OpenGLMobject' ] True Return type : type", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.utils.html#manim.mobject.utils.get_point_mobject_class"}
{"prompt": "get_point_mobject_class()", "response": "Gets the point cloud mobject class, depending on the currently\nactive renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_point_mobject_class >>> get_point_mobject_class () . __name__ in [ 'PMobject' , 'OpenGLPMobject' ] True Return type : type", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.utils.html#manim.mobject.utils.get_point_mobject_class"}
{"prompt": "get_vectorized_mobject_class()", "response": "Gets the vectorized mobject class, depending on the currently\nactive renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_vectorized_mobject_class >>> get_vectorized_mobject_class () . __name__ in [ 'VMobject' , 'OpenGLVMobject' ] True Return type : type", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.utils.html#manim.mobject.utils.get_point_mobject_class"}
{"prompt": "get_mobject_class()", "response": "Gets the base mobject class, depending on the currently active renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_mobject_class >>> get_mobject_class () . __name__ in [ 'Mobject' , 'OpenGLMobject' ] True Return type : type", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.utils.html#manim.mobject.utils.get_vectorized_mobject_class"}
{"prompt": "get_point_mobject_class()", "response": "Gets the point cloud mobject class, depending on the currently\nactive renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_point_mobject_class >>> get_point_mobject_class () . __name__ in [ 'PMobject' , 'OpenGLPMobject' ] True Return type : type", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.utils.html#manim.mobject.utils.get_vectorized_mobject_class"}
{"prompt": "get_vectorized_mobject_class()", "response": "Gets the vectorized mobject class, depending on the currently\nactive renderer. Note This method is intended to be used in the code base of Manim itself\nor in plugins where code should work independent of the selected\nrenderer. Examples The function has to be explicitly imported. We test that\nthe name of the returned class is one of the known mobject\nbase classes: >>> from manim.mobject.utils import get_vectorized_mobject_class >>> get_vectorized_mobject_class () . __name__ in [ 'VMobject' , 'OpenGLVMobject' ] True Return type : type", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.utils.html#manim.mobject.utils.get_vectorized_mobject_class"}
{"prompt": "class ComplexValueTracker(value=0, **kwargs)", "response": "Bases: ValueTracker Tracks a complex-valued parameter. When the value is set through animate , the value will take a straight path from the\nsource point to the destination point. Examples Example: ComplexValueTrackerExample   from manim import * class ComplexValueTrackerExample ( Scene ): def construct ( self ): tracker = ComplexValueTracker ( - 2 + 1 j ) dot = Dot () . add_updater ( lambda x : x . move_to ( tracker . points ) ) self . add ( NumberPlane (), dot ) self . play ( tracker . animate . set_value ( 3 + 2 j )) self . play ( tracker . animate . set_value ( tracker . get_value () * 1 j )) self . play ( tracker . animate . set_value ( tracker . get_value () - 2 j )) self . play ( tracker . animate . set_value ( tracker . get_value () / ( - 2 + 3 j ))) class ComplexValueTrackerExample(Scene):\n    def construct(self):\n        tracker = ComplexValueTracker(-2+1j)\n        dot = Dot().add_updater(\n            lambda x: x.move_to(tracker.points)\n        )\n\n        self.add(NumberPlane(), dot)\n\n        self.play(tracker.animate.set_value(3+2j))\n        self.play(tracker.animate.set_value(tracker.get_value() * 1j))\n        self.play(tracker.animate.set_value(tracker.get_value() - 2j))\n        self.play(tracker.animate.set_value(tracker.get_value() / (-2 + 3j))) Methods get_value Get the current value of this value tracker as a complex number. set_value Sets a new complex value to the ComplexValueTracker Attributes animate Used to animate the application of any method of self . animation_overrides depth The depth of the mobject. height The height of the mobject. width The width of the mobject. _original__init__ ( value = 0 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. get_value ( ) [source]   Get the current value of this value tracker as a complex number. The value is internally stored as a points array [a, b, 0]. This can be accessed directly\nto represent the value geometrically, see the usage example. set_value ( z ) [source]   Sets a new complex value to the ComplexValueTracker", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.value_tracker.ComplexValueTracker.html"}
{"prompt": "class ValueTracker(value=0, **kwargs)", "response": "Bases: Mobject A mobject that can be used for tracking (real-valued) parameters.\nUseful for animating parameter changes. Not meant to be displayed.  Instead the position encodes some\nnumber, often one which another animation or continual_animation\nuses for its update function, and by treating it as a mobject it can\nstill be animated and manipulated just like anything else. This value changes continuously when animated using the animate syntax. Examples Example: ValueTrackerExample   from manim import * class ValueTrackerExample ( Scene ): def construct ( self ): number_line = NumberLine () pointer = Vector ( DOWN ) label = MathTex ( \"x\" ) . add_updater ( lambda m : m . next_to ( pointer , UP )) tracker = ValueTracker ( 0 ) pointer . add_updater ( lambda m : m . next_to ( number_line . n2p ( tracker . get_value ()), UP ) ) self . add ( number_line , pointer , label ) tracker += 1.5 self . wait ( 1 ) tracker -= 4 self . wait ( 0.5 ) self . play ( tracker . animate . set_value ( 5 )) self . wait ( 0.5 ) self . play ( tracker . animate . set_value ( 3 )) self . play ( tracker . animate . increment_value ( - 2 )) self . wait ( 0.5 ) class ValueTrackerExample(Scene):\n    def construct(self):\n        number_line = NumberLine()\n        pointer = Vector(DOWN)\n        label = MathTex(\"x\").add_updater(lambda m: m.next_to(pointer, UP))\n\n        tracker = ValueTracker(0)\n        pointer.add_updater(\n            lambda m: m.next_to(\n                        number_line.n2p(tracker.get_value()),\n                        UP\n                    )\n        )\n        self.add(number_line, pointer,label)\n        tracker += 1.5\n        self.wait(1)\n        tracker -= 4\n        self.wait(0.5)\n        self.play(tracker.animate.set_value(5))\n        self.wait(0.5)\n        self.play(tracker.animate.set_value(3))\n        self.play(tracker.animate.increment_value(-2))\n        self.wait(0.5) Note You can also link ValueTrackers to updaters. In this case, you have to make sure that the\nValueTracker is added to the scene by add Example: ValueTrackerExample   from manim import * class ValueTrackerExample ( Scene ): def construct ( self ): tracker = ValueTracker ( 0 ) label = Dot ( radius = 3 ) . add_updater ( lambda x : x . set_x ( tracker . get_value ())) self . add ( label ) self . add ( tracker ) tracker . add_updater ( lambda mobject , dt : mobject . increment_value ( dt )) self . wait ( 2 ) class ValueTrackerExample(Scene):\n    def construct(self):\n        tracker = ValueTracker(0)\n        label = Dot(radius=3).add_updater(lambda x : x.set_x(tracker.get_value()))\n        self.add(label)\n        self.add(tracker)\n        tracker.add_updater(lambda mobject, dt: mobject.increment_value(dt))\n        self.wait(2) Methods get_value Get the current value of this ValueTracker. increment_value Increments (adds) a scalar value  to the ValueTracker interpolate Turns self into an interpolation between mobject1 and mobject2. set_value Sets a new scalar value to the ValueTracker Attributes animate Used to animate the application of any method of self . animation_overrides depth The depth of the mobject. height The height of the mobject. width The width of the mobject. _original__init__ ( value = 0 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. get_value ( ) [source]   Get the current value of this ValueTracker. Return type : float increment_value ( d_value ) [source]   Increments (adds) a scalar value  to the ValueTracker Parameters : d_value ( float ) interpolate ( mobject1 , mobject2 , alpha , path_func=<function interpolate> ) [source]   Turns self into an interpolation between mobject1\nand mobject2. set_value ( value ) [source]   Sets a new scalar value to the ValueTracker Parameters : value ( float )", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.value_tracker.ValueTracker.html"}
{"prompt": "class ArrowVectorField(func, color=None, color_scheme=None, min_color_scheme_value=0, max_color_scheme_value=2, colors=", "response": "Bases: VectorField A VectorField represented by a set of change vectors. Vector fields are always based on a function defining the Vector at every position.\nThe values of this functions is displayed as a grid of vectors.\nBy default the color of each vector is determined by it\u2019s magnitude.\nOther color schemes can be used however. Parameters : func ( Callable [ [ np.ndarray ] , np.ndarray ] ) \u2013 The function defining the rate of change at every position of the vector field. color ( ParsableManimColor | None ) \u2013 The color of the vector field. If set, position-specific coloring is disabled. color_scheme ( Callable [ [ np.ndarray ] , float ] | None ) \u2013 A function mapping a vector to a single value. This value gives the position in the color gradient defined using min_color_scheme_value , max_color_scheme_value and colors . min_color_scheme_value ( float ) \u2013 The value of the color_scheme function to be mapped to the first color in colors . Lower values also result in the first color of the gradient. max_color_scheme_value ( float ) \u2013 The value of the color_scheme function to be mapped to the last color in colors . Higher values also result in the last color of the gradient. colors ( Sequence [ ParsableManimColor ] ) \u2013 The colors defining the color gradient of the vector field. x_range ( Sequence [ float ] ) \u2013 A sequence of x_min, x_max, delta_x y_range ( Sequence [ float ] ) \u2013 A sequence of y_min, y_max, delta_y z_range ( Sequence [ float ] ) \u2013 A sequence of z_min, z_max, delta_z three_dimensions ( bool ) \u2013 Enables three_dimensions. Default set to False, automatically turns True if\nz_range is not None. length_func ( Callable [ [ float ] , float ] ) \u2013 The function determining the displayed size of the vectors. The actual size\nof the vector is passed, the returned value will be used as display size for the\nvector. By default this is used to cap the displayed size of vectors to reduce the clutter. opacity ( float ) \u2013 The opacity of the arrows. vector_config ( dict | None ) \u2013 Additional arguments to be passed to the Vector constructor kwargs \u2013 Additional arguments to be passed to the VGroup constructor Examples Example: BasicUsage   from manim import * class BasicUsage ( Scene ): def construct ( self ): func = lambda pos : (( pos [ 0 ] * UR + pos [ 1 ] * LEFT ) - pos ) / 3 self . add ( ArrowVectorField ( func )) class BasicUsage(Scene):\n    def construct(self):\n        func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3\n        self.add(ArrowVectorField(func)) Example: SizingAndSpacing   from manim import * class SizingAndSpacing ( Scene ): def construct ( self ): func = lambda pos : np . sin ( pos [ 0 ] / 2 ) * UR + np . cos ( pos [ 1 ] / 2 ) * LEFT vf = ArrowVectorField ( func , x_range = [ - 7 , 7 , 1 ]) self . add ( vf ) self . wait () length_func = lambda x : x / 3 vf2 = ArrowVectorField ( func , x_range = [ - 7 , 7 , 1 ], length_func = length_func ) self . play ( vf . animate . become ( vf2 )) self . wait () class SizingAndSpacing(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n        vf = ArrowVectorField(func, x_range=[-7, 7, 1])\n        self.add(vf)\n        self.wait()\n\n        length_func = lambda x: x / 3\n        vf2 = ArrowVectorField(func, x_range=[-7, 7, 1], length_func=length_func)\n        self.play(vf.animate.become(vf2))\n        self.wait() Example: Coloring   from manim import * class Coloring ( Scene ): def construct ( self ): func = lambda pos : pos - LEFT * 5 colors = [ RED , YELLOW , BLUE , DARK_GRAY ] min_radius = Circle ( radius = 2 , color = colors [ 0 ]) . shift ( LEFT * 5 ) max_radius = Circle ( radius = 10 , color = colors [ - 1 ]) . shift ( LEFT * 5 ) vf = ArrowVectorField ( func , min_color_scheme_value = 2 , max_color_scheme_value = 10 , colors = colors ) self . add ( vf , min_radius , max_radius ) class Coloring(Scene):\n    def construct(self):\n        func = lambda pos: pos - LEFT * 5\n        colors = [RED, YELLOW, BLUE, DARK_GRAY]\n        min_radius = Circle(radius=2, color=colors[0]).shift(LEFT * 5)\n        max_radius = Circle(radius=10, color=colors[-1]).shift(LEFT * 5)\n        vf = ArrowVectorField(\n            func, min_color_scheme_value=2, max_color_scheme_value=10, colors=colors\n        )\n        self.add(vf, min_radius, max_radius) Methods get_vector Creates a vector in the vector field. Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( func, color=None, color_scheme=None, min_color_scheme_value=0, max_color_scheme_value=2, colors=[ManimColor('#236B8E'), ManimColor('#83C167'), ManimColor('#FFFF00'), ManimColor('#FC6255')], x_range=None, y_range=None, z_range=None, three_dimensions=False, length_func=<function ArrowVectorField.<lambda>>, opacity=1.0, vector_config=None, **kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : func ( Callable [ [ np.ndarray ] , np.ndarray ] ) color ( ParsableManimColor | None ) color_scheme ( Callable [ [ np.ndarray ] , float ] | None ) min_color_scheme_value ( float ) max_color_scheme_value ( float ) colors ( Sequence [ ParsableManimColor ] ) x_range ( Sequence [ float ] ) y_range ( Sequence [ float ] ) z_range ( Sequence [ float ] ) three_dimensions ( bool ) length_func ( Callable [ [ float ] , float ] ) opacity ( float ) vector_config ( dict | None ) get_vector ( point ) [source]   Creates a vector in the vector field. The created vector is based on the function of the vector field and is\nrooted in the given point. Color and length fit the specifications of\nthis vector field. Parameters : point ( ndarray ) \u2013 The root point of the vector.", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.ArrowVectorField.html"}
{"prompt": "class StreamLines(func, color=None, color_scheme=None, min_color_scheme_value=0, max_color_scheme_value=2, colors=", "response": "Bases: VectorField StreamLines represent the flow of a VectorField using the trace of moving agents. Vector fields are always based on a function defining the vector at every position.\nThe values of this functions is displayed by moving many agents along the vector field\nand showing their trace. Parameters : func ( Callable [ [ np.ndarray ] , np.ndarray ] ) \u2013 The function defining the rate of change at every position of the vector field. color ( ParsableManimColor | None ) \u2013 The color of the vector field. If set, position-specific coloring is disabled. color_scheme ( Callable [ [ np.ndarray ] , float ] | None ) \u2013 A function mapping a vector to a single value. This value gives the position in the color gradient defined using min_color_scheme_value , max_color_scheme_value and colors . min_color_scheme_value ( float ) \u2013 The value of the color_scheme function to be mapped to the first color in colors . Lower values also result in the first color of the gradient. max_color_scheme_value ( float ) \u2013 The value of the color_scheme function to be mapped to the last color in colors . Higher values also result in the last color of the gradient. colors ( Sequence [ ParsableManimColor ] ) \u2013 The colors defining the color gradient of the vector field. x_range ( Sequence [ float ] ) \u2013 A sequence of x_min, x_max, delta_x y_range ( Sequence [ float ] ) \u2013 A sequence of y_min, y_max, delta_y z_range ( Sequence [ float ] ) \u2013 A sequence of z_min, z_max, delta_z three_dimensions ( bool ) \u2013 Enables three_dimensions. Default set to False, automatically turns True if\nz_range is not None. noise_factor ( float | None ) \u2013 The amount by which the starting position of each agent is altered along each axis. Defaults to delta_y / 2 if not defined. n_repeats \u2013 The number of agents generated at each starting point. dt \u2013 The factor by which the distance an agent moves per step is stretched. Lower values result in a better approximation of the trajectories in the vector field. virtual_time \u2013 The time the agents get to move in the vector field. Higher values therefore result in longer stream lines. However, this whole time gets simulated upon creation. max_anchors_per_line \u2013 The maximum number of anchors per line. Lines with more anchors get reduced in complexity, not in length. padding \u2013 The distance agents can move out of the generation area before being terminated. stroke_width \u2013 The stroke with of the stream lines. opacity \u2013 The opacity of the stream lines. Examples Example: BasicUsage   from manim import * class BasicUsage ( Scene ): def construct ( self ): func = lambda pos : (( pos [ 0 ] * UR + pos [ 1 ] * LEFT ) - pos ) / 3 self . add ( StreamLines ( func )) class BasicUsage(Scene):\n    def construct(self):\n        func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3\n        self.add(StreamLines(func)) Example: SpawningAndFlowingArea   from manim import * class SpawningAndFlowingArea ( Scene ): def construct ( self ): func = lambda pos : np . sin ( pos [ 0 ]) * UR + np . cos ( pos [ 1 ]) * LEFT + pos / 5 stream_lines = StreamLines ( func , x_range = [ - 3 , 3 , 0.2 ], y_range = [ - 2 , 2 , 0.2 ], padding = 1 ) spawning_area = Rectangle ( width = 6 , height = 4 ) flowing_area = Rectangle ( width = 8 , height = 6 ) labels = [ Tex ( \"Spawning Area\" ), Tex ( \"Flowing Area\" ) . shift ( DOWN * 2.5 )] for lbl in labels : lbl . add_background_rectangle ( opacity = 0.6 , buff = 0.05 ) self . add ( stream_lines , spawning_area , flowing_area , * labels ) class SpawningAndFlowingArea(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[0]) * UR + np.cos(pos[1]) * LEFT + pos / 5\n        stream_lines = StreamLines(\n            func, x_range=[-3, 3, 0.2], y_range=[-2, 2, 0.2], padding=1\n        )\n\n        spawning_area = Rectangle(width=6, height=4)\n        flowing_area = Rectangle(width=8, height=6)\n        labels = [Tex(\"Spawning Area\"), Tex(\"Flowing Area\").shift(DOWN * 2.5)]\n        for lbl in labels:\n            lbl.add_background_rectangle(opacity=0.6, buff=0.05)\n\n        self.add(stream_lines, spawning_area, flowing_area, *labels) Methods create The creation animation of the stream lines. end_animation End the stream line animation smoothly. start_animation Animates the stream lines using an updater. Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( func , color = None , color_scheme = None , min_color_scheme_value = 0 , max_color_scheme_value = 2 , colors = [ManimColor('#236B8E'), ManimColor('#83C167'), ManimColor('#FFFF00'), ManimColor('#FC6255')] , x_range = None , y_range = None , z_range = None , three_dimensions = False , noise_factor = None , n_repeats = 1 , dt = 0.05 , virtual_time = 3 , max_anchors_per_line = 100 , padding = 3 , stroke_width = 1 , opacity = 1 , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : func ( Callable [ [ np.ndarray ] , np.ndarray ] ) color ( ParsableManimColor | None ) color_scheme ( Callable [ [ np.ndarray ] , float ] | None ) min_color_scheme_value ( float ) max_color_scheme_value ( float ) colors ( Sequence [ ParsableManimColor ] ) x_range ( Sequence [ float ] ) y_range ( Sequence [ float ] ) z_range ( Sequence [ float ] ) three_dimensions ( bool ) noise_factor ( float | None ) create ( lag_ratio = None , run_time = None , ** kwargs ) [source]   The creation animation of the stream lines. The stream lines appear in random order. Parameters : lag_ratio ( float | None ) \u2013 The lag ratio of the animation.\nIf undefined, it will be selected so that the total animation length is 1.5 times the run time of each stream line creation. run_time ( Callable [ [ float ] , float ] | None ) \u2013 The run time of every single stream line creation. The runtime of the whole animation might be longer due to the lag_ratio .\nIf undefined, the virtual time of the stream lines is used as run time. Returns : The creation animation of the stream lines. Return type : AnimationGroup Examples Example: StreamLineCreation   from manim import * class StreamLineCreation ( Scene ): def construct ( self ): func = lambda pos : ( pos [ 0 ] * UR + pos [ 1 ] * LEFT ) - pos stream_lines = StreamLines ( func , color = YELLOW , x_range = [ - 7 , 7 , 1 ], y_range = [ - 4 , 4 , 1 ], stroke_width = 3 , virtual_time = 1 , # use shorter lines max_anchors_per_line = 5 , # better performance with fewer anchors ) self . play ( stream_lines . create ()) # uses virtual_time as run_time self . wait () class StreamLineCreation(Scene):\n    def construct(self):\n        func = lambda pos: (pos[0] * UR + pos[1] * LEFT) - pos\n        stream_lines = StreamLines(\n            func,\n            color=YELLOW,\n            x_range=[-7, 7, 1],\n            y_range=[-4, 4, 1],\n            stroke_width=3,\n            virtual_time=1,  # use shorter lines\n            max_anchors_per_line=5,  # better performance with fewer anchors\n        )\n        self.play(stream_lines.create())  # uses virtual_time as run_time\n        self.wait() end_animation ( ) [source]   End the stream line animation smoothly. Returns an animation resulting in fully displayed stream lines without a noticeable cut. Returns : The animation fading out the running stream animation. Return type : AnimationGroup Raises : ValueError \u2013 if no stream line animation is running Examples Example: EndAnimation   from manim import * class EndAnimation ( Scene ): def construct ( self ): func = lambda pos : np . sin ( pos [ 0 ] / 2 ) * UR + np . cos ( pos [ 1 ] / 2 ) * LEFT stream_lines = StreamLines ( func , stroke_width = 3 , max_anchors_per_line = 5 , virtual_time = 1 , color = BLUE ) self . add ( stream_lines ) stream_lines . start_animation ( warm_up = False , flow_speed = 1.5 , time_width = 0.5 ) self . wait ( 1 ) self . play ( stream_lines . end_animation ()) class EndAnimation(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n        stream_lines = StreamLines(\n            func, stroke_width=3, max_anchors_per_line=5, virtual_time=1, color=BLUE\n        )\n        self.add(stream_lines)\n        stream_lines.start_animation(warm_up=False, flow_speed=1.5, time_width=0.5)\n        self.wait(1)\n        self.play(stream_lines.end_animation()) start_animation ( warm_up=True , flow_speed=1 , time_width=0.3 , rate_func=<function linear> , line_animation_class=<class 'manim.animation.indication.ShowPassingFlash'> , **kwargs ) [source]   Animates the stream lines using an updater. The stream lines will continuously flow Parameters : warm_up ( bool ) \u2013 If True the animation is initialized line by line. Otherwise it starts with all lines shown. flow_speed ( float ) \u2013 At flow_speed=1 the distance the flow moves per second is equal to the magnitude of the vector field along its path. The speed value scales the speed of this flow. time_width ( float ) \u2013 The proportion of the stream line shown while being animated rate_func ( Callable [ [ float ] , float ] ) \u2013 The rate function of each stream line flashing line_animation_class ( type [ ShowPassingFlash ] ) \u2013 The animation class being used Return type : None Examples Example: ContinuousMotion   from manim import * class ContinuousMotion ( Scene ): def construct ( self ): func = lambda pos : np . sin ( pos [ 0 ] / 2 ) * UR + np . cos ( pos [ 1 ] / 2 ) * LEFT stream_lines = StreamLines ( func , stroke_width = 3 , max_anchors_per_line = 30 ) self . add ( stream_lines ) stream_lines . start_animation ( warm_up = False , flow_speed = 1.5 ) self . wait ( stream_lines . virtual_time / stream_lines . flow_speed ) class ContinuousMotion(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n        stream_lines = StreamLines(func, stroke_width=3, max_anchors_per_line=30)\n        self.add(stream_lines)\n        stream_lines.start_animation(warm_up=False, flow_speed=1.5)\n        self.wait(stream_lines.virtual_time / stream_lines.flow_speed)", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.StreamLines.html"}
{"prompt": "class VectorField(func, color=None, color_scheme=None, min_color_scheme_value=0, max_color_scheme_value=2, colors=", "response": "Bases: VGroup A vector field. Vector fields are based on a function defining a vector at every position.\nThis class does by default not include any visible elements but provides\nmethods to move other Mobject s along the vector field. Parameters : func ( Callable [ [ np.ndarray ] , np.ndarray ] ) \u2013 The function defining the rate of change at every position of the VectorField . color ( ParsableManimColor | None ) \u2013 The color of the vector field. If set, position-specific coloring is disabled. color_scheme ( Callable [ [ np.ndarray ] , float ] | None ) \u2013 A function mapping a vector to a single value. This value gives the position in the color gradient defined using min_color_scheme_value , max_color_scheme_value and colors . min_color_scheme_value ( float ) \u2013 The value of the color_scheme function to be mapped to the first color in colors . Lower values also result in the first color of the gradient. max_color_scheme_value ( float ) \u2013 The value of the color_scheme function to be mapped to the last color in colors . Higher values also result in the last color of the gradient. colors ( Sequence [ ParsableManimColor ] ) \u2013 The colors defining the color gradient of the vector field. kwargs \u2013 Additional arguments to be passed to the VGroup constructor Methods fit_to_coordinate_system Scale the vector field to fit a coordinate system. get_colored_background_image Generate an image that displays the vector field. get_nudge_updater Get an update function to move a Mobject along the vector field. get_vectorized_rgba_gradient_function Generates a gradient of rgbas as a numpy array nudge Nudge a Mobject along the vector field. nudge_submobjects Apply a nudge along the vector field to all submobjects. scale_func Scale a vector field function. shift_func Shift a vector field function. start_submobject_movement Start continuously moving all submobjects along the vector field. stop_submobject_movement Stops the continuous movement started using start_submobject_movement() . Attributes animate Used to animate the application of any method of self . animation_overrides color depth The depth of the mobject. fill_color If there are multiple colors (for gradient) this returns the first one height The height of the mobject. n_points_per_curve sheen_factor stroke_color width The width of the mobject. _original__init__ ( func , color = None , color_scheme = None , min_color_scheme_value = 0 , max_color_scheme_value = 2 , colors = [ManimColor('#236B8E'), ManimColor('#83C167'), ManimColor('#FFFF00'), ManimColor('#FC6255')] , ** kwargs )   Initialize self.  See help(type(self)) for accurate signature. Parameters : func ( Callable [ [ np.ndarray ] , np.ndarray ] ) color ( ParsableManimColor | None ) color_scheme ( Callable [ [ np.ndarray ] , float ] | None ) min_color_scheme_value ( float ) max_color_scheme_value ( float ) colors ( Sequence [ ParsableManimColor ] ) fit_to_coordinate_system ( coordinate_system ) [source]   Scale the vector field to fit a coordinate system. This method is useful when the vector field is defined in a coordinate system\ndifferent from the one used to display the vector field. This method can only be used once because it transforms the origin of each vector. Parameters : coordinate_system ( CoordinateSystem ) \u2013 The coordinate system to fit the vector field to. get_colored_background_image ( sampling_rate = 5 ) [source]   Generate an image that displays the vector field. The color at each position is calculated by passing the positing through a\nseries of steps:\nCalculate the vector field function at that position, map that vector to a\nsingle value using self.color_scheme and finally generate a color from\nthat value using the color gradient. Parameters : sampling_rate ( int ) \u2013 The stepsize at which pixels get included in the image. Lower values give\nmore accurate results, but may take a long time to compute. Returns : The vector field image. Return type : Image.Imgae get_nudge_updater ( speed = 1 , pointwise = False ) [source]   Get an update function to move a Mobject along the vector field. When used with add_updater() , the mobject will move along the vector field, where its speed is determined by the magnitude of the vector field. Parameters : speed ( float ) \u2013 At speed=1 the distance a mobject moves per second is equal to the magnitude of the vector field along its path. The speed value scales the speed of such a mobject. pointwise ( bool ) \u2013 Whether to move the mobject along the vector field. See nudge() for details. Returns : The update function. Return type : Callable[[ Mobject , float], Mobject ] get_vectorized_rgba_gradient_function ( start , end , colors ) [source]   Generates a gradient of rgbas as a numpy array Parameters : start ( float ) \u2013 start value used for inverse interpolation at inverse_interpolate() end ( float ) \u2013 end value used for inverse interpolation at inverse_interpolate() colors ( Iterable [ ParsableManimColor ] ) \u2013 list of colors to generate the gradient Return type : function to generate the gradients as numpy arrays representing rgba values nudge ( mob , dt = 1 , substeps = 1 , pointwise = False ) [source]   Nudge a Mobject along the vector field. Parameters : mob ( Mobject ) \u2013 The mobject to move along the vector field dt ( float ) \u2013 A scalar to the amount the mobject is moved along the vector field.\nThe actual distance is based on the magnitude of the vector field. substeps ( int ) \u2013 The amount of steps the whole nudge is divided into. Higher values\ngive more accurate approximations. pointwise ( bool ) \u2013 Whether to move the mobject along the vector field. If False the\nvector field takes effect on the center of the given Mobject . If True the vector field takes effect on the\npoints of the individual points of the Mobject ,\npotentially distorting it. Returns : This vector field. Return type : VectorField Examples Example: Nudging   from manim import * class Nudging ( Scene ): def construct ( self ): func = lambda pos : np . sin ( pos [ 1 ] / 2 ) * RIGHT + np . cos ( pos [ 0 ] / 2 ) * UP vector_field = ArrowVectorField ( func , x_range = [ - 7 , 7 , 1 ], y_range = [ - 4 , 4 , 1 ], length_func = lambda x : x / 2 ) self . add ( vector_field ) circle = Circle ( radius = 2 ) . shift ( LEFT ) self . add ( circle . copy () . set_color ( GRAY )) dot = Dot () . move_to ( circle ) vector_field . nudge ( circle , - 2 , 60 , True ) vector_field . nudge ( dot , - 2 , 60 ) circle . add_updater ( vector_field . get_nudge_updater ( pointwise = True )) dot . add_updater ( vector_field . get_nudge_updater ()) self . add ( circle , dot ) self . wait ( 6 ) class Nudging(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[1] / 2) * RIGHT + np.cos(pos[0] / 2) * UP\n        vector_field = ArrowVectorField(\n            func, x_range=[-7, 7, 1], y_range=[-4, 4, 1], length_func=lambda x: x / 2\n        )\n        self.add(vector_field)\n        circle = Circle(radius=2).shift(LEFT)\n        self.add(circle.copy().set_color(GRAY))\n        dot = Dot().move_to(circle)\n\n        vector_field.nudge(circle, -2, 60, True)\n        vector_field.nudge(dot, -2, 60)\n\n        circle.add_updater(vector_field.get_nudge_updater(pointwise=True))\n        dot.add_updater(vector_field.get_nudge_updater())\n        self.add(circle, dot)\n        self.wait(6) nudge_submobjects ( dt = 1 , substeps = 1 , pointwise = False ) [source]   Apply a nudge along the vector field to all submobjects. Parameters : dt ( float ) \u2013 A scalar to the amount the mobject is moved along the vector field.\nThe actual distance is based on the magnitude of the vector field. substeps ( int ) \u2013 The amount of steps the whole nudge is divided into. Higher values\ngive more accurate approximations. pointwise ( bool ) \u2013 Whether to move the mobject along the vector field. See nudge() for details. Returns : This vector field. Return type : VectorField static scale_func ( func , scalar ) [source]   Scale a vector field function. Parameters : func ( Callable [ [ ndarray ] , ndarray ] ) \u2013 The function defining a vector field. scalar ( float ) \u2013 The scalar to be applied to the vector field. Return type : Callable [[ ndarray ], ndarray ] Examples Example: ScaleVectorFieldFunction   from manim import * class ScaleVectorFieldFunction ( Scene ): def construct ( self ): func = lambda pos : np . sin ( pos [ 1 ]) * RIGHT + np . cos ( pos [ 0 ]) * UP vector_field = ArrowVectorField ( func ) self . add ( vector_field ) self . wait () func = VectorField . scale_func ( func , 0.5 ) self . play ( vector_field . animate . become ( ArrowVectorField ( func ))) self . wait () class ScaleVectorFieldFunction(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[1]) * RIGHT + np.cos(pos[0]) * UP\n        vector_field = ArrowVectorField(func)\n        self.add(vector_field)\n        self.wait()\n\n        func = VectorField.scale_func(func, 0.5)\n        self.play(vector_field.animate.become(ArrowVectorField(func)))\n        self.wait() Returns : The scaled vector field function. Return type : Callable[[np.ndarray], np.ndarray] Parameters : func ( Callable [ [ ndarray ] , ndarray ] ) scalar ( float ) static shift_func ( func , shift_vector ) [source]   Shift a vector field function. Parameters : func ( Callable [ [ ndarray ] , ndarray ] ) \u2013 The function defining a vector field. shift_vector ( ndarray ) \u2013 The shift to be applied to the vector field. Returns : The shifted vector field function. Return type : Callable[[np.ndarray], np.ndarray] start_submobject_movement ( speed = 1 , pointwise = False ) [source]   Start continuously moving all submobjects along the vector field. Calling this method multiple times will result in removing the previous updater created by this method. Parameters : speed ( float ) \u2013 The speed at which to move the submobjects. See get_nudge_updater() for details. pointwise ( bool ) \u2013 Whether to move the mobject along the vector field. See nudge() for details. Returns : This vector field. Return type : VectorField stop_submobject_movement ( ) [source]   Stops the continuous movement started using start_submobject_movement() . Returns : This vector field. Return type : VectorField", "source": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.VectorField.html"}
{"prompt": "class MovingCameraScene(camera_class=<class 'manim.camera.moving_camera.MovingCamera'>, **kwargs)", "response": "Bases: Scene This is a Scene, with special configurations and properties that\nmake it suitable for cases where the camera must be moved around. Note: Examples are included in the moving_camera_scene module\ndocumentation, see below in the \u2018see also\u2019 section. See also moving_camera_scene MovingCamera Methods get_moving_mobjects This method returns a list of all of the Mobjects in the Scene that are moving, that are also in the animations passed. Attributes camera time The time since the start of the scene. get_moving_mobjects ( * animations ) [source]   This method returns a list of all of the Mobjects in the Scene that\nare moving, that are also in the animations passed. Parameters : *animations ( Animation ) \u2013 The Animations whose mobjects will be checked.", "source": "https://docs.manim.community/en/stable/reference/manim.scene.moving_camera_scene.MovingCameraScene.html"}
{"prompt": "class DefaultSectionType(value, names=<not given>, *values, module=None, qualname=None, type=None, start=1, boundary=None)", "response": "Bases: str , Enum The type of a section can be used for third party applications.\nA presentation system could for example use the types to created loops. Examples This class can be reimplemented for more types: class PresentationSectionType ( str , Enum ): # start, end, wait for continuation by user NORMAL = \"presentation.normal\" # start, end, immediately continue to next section SKIP = \"presentation.skip\" # start, end, restart, immediately continue to next section when continued by user LOOP = \"presentation.loop\" # start, end, restart, finish animation first when user continues COMPLETE_LOOP = \"presentation.complete_loop\" Methods Attributes NORMAL", "source": "https://docs.manim.community/en/stable/reference/manim.scene.section.DefaultSectionType.html"}
{"prompt": "class Section(type_, video, name, skip_animations)", "response": "Bases: object A Scene can be segmented into multiple Sections.\nRefer to the documentation for more info.\nIt consists of multiple animations. Parameters : type_ ( str ) video ( str | None ) name ( str ) skip_animations ( bool ) type\\_ Can be used by a third party applications to classify different types of sections. video   Path to video file with animations belonging to section relative to sections directory.\nIf None , then the section will not be saved. name   Human readable, non-unique name for this section. skip_animations   Skip rendering the animations in this section when True . partial_movie_files   Animations belonging to this section. See also DefaultSectionType , CairoRenderer.update_skipping_status() , OpenGLRenderer.update_skipping_status() Methods get_clean_partial_movie_files Return all partial movie files that are not None . get_dict Get dictionary representation with metadata of output video. is_empty Check whether this section is empty. get_clean_partial_movie_files ( ) [source]   Return all partial movie files that are not None . Return type : list[str] get_dict ( sections_dir ) [source]   Get dictionary representation with metadata of output video. The output from this function is used from every section to build the sections index file.\nThe output video must have been created in the sections_dir before executing this method.\nThis is the main part of the Segmented Video API. Parameters : sections_dir ( Path ) Return type : dict[str, Any ] is_empty ( ) [source]   Check whether this section is empty. Note that animations represented by None are also counted. Return type : bool", "source": "https://docs.manim.community/en/stable/reference/manim.scene.section.Section.html"}
{"prompt": "class RerunSceneHandler(queue)", "response": "Bases: FileSystemEventHandler A class to handle rerunning a Scene after the input file is modified. Methods on_modified Called when a file or directory is modified. on_modified ( event ) [source]   Called when a file or directory is modified. Parameters : event ( DirModifiedEvent or FileModifiedEvent ) \u2013 Event representing file/directory modification.", "source": "https://docs.manim.community/en/stable/reference/manim.scene.scene.RerunSceneHandler.html"}
{"prompt": "class Scene(renderer=None, camera_class=<class 'manim.camera.camera.Camera'>, always_update_mobjects=False, random_seed=None, skip_animations=False)", "response": "Bases: object A Scene is the canvas of your animation. The primary role of Scene is to provide the user with tools to manage\nmobjects and animations.  Generally speaking, a manim script consists of a class\nthat derives from Scene whose Scene.construct() method is overridden\nby the user\u2019s code. Mobjects are displayed on screen by calling Scene.add() and removed from\nscreen by calling Scene.remove() .  All mobjects currently on screen are kept\nin Scene.mobjects .  Animations are played by calling Scene.play() . A Scene is rendered internally by calling Scene.render() .  This in\nturn calls Scene.setup() , Scene.construct() , and Scene.tear_down() , in that order. It is not recommended to override the __init__ method in user Scenes.  For code\nthat should be ran before a Scene is rendered, use Scene.setup() instead. Examples Override the Scene.construct() method with your code. class MyScene ( Scene ): def construct ( self ): self . play ( Write ( Text ( \"Hello World!\" ))) Methods add Mobjects will be displayed, from background to foreground in the order with which they are added. add_foreground_mobject Adds a single mobject to the foreground, and internally to the list foreground_mobjects, and mobjects. add_foreground_mobjects Adds mobjects to the foreground, and internally to the list foreground_mobjects, and mobjects. add_mobjects_from_animations add_sound This method is used to add a sound to the animation. add_subcaption Adds an entry in the corresponding subcaption file at the current time stamp. add_updater Add an update function to the scene. begin_animations Start the animations of the scene. bring_to_back Removes the mobject from the scene and adds them to the back of the scene. bring_to_front Adds the passed mobjects to the scene again, pushing them to he front of the scene. check_interactive_embed_is_valid clear Removes all mobjects present in self.mobjects and self.foreground_mobjects from the scene. compile_animation_data Given a list of animations, compile the corresponding static and moving mobjects, and gather the animation durations. compile_animations Creates _MethodAnimations from any _AnimationBuilders and updates animation kwargs with kwargs passed to play(). construct Add content to the Scene. embed get_attrs Gets attributes of a scene given the attribute's identifier/name. get_mobject_family_members Returns list of family-members of all mobjects in scene. get_moving_and_static_mobjects get_moving_mobjects Gets all moving mobjects in the passed animation(s). get_restructured_mobject_list Given a list of mobjects and a list of mobjects to be removed, this filters out the removable mobjects from the list of mobjects. get_run_time Gets the total run time for a list of animations. get_time_progression You will hardly use this when making your own animations. get_top_level_mobjects Returns all mobjects which are not submobjects. interact interactive_embed Like embed(), but allows for screen interaction. is_current_animation_frozen_frame Returns whether the current animation produces a static frame (generally a Wait). mouse_drag_orbit_controls mouse_scroll_orbit_controls next_section Create separation here; the last section gets finished and a new one gets created. on_key_press on_key_release on_mouse_drag on_mouse_motion on_mouse_press on_mouse_scroll pause Pauses the scene (i.e., displays a frozen frame). play Plays an animation in this scene. play_internal This method is used to prep the animations for rendering, apply the arguments and parameters required to them, render them, and write them to the video file. remove Removes mobjects in the passed list of mobjects from the scene and the foreground, by removing them from \"mobjects\" and \"foreground_mobjects\" remove_foreground_mobject Removes a single mobject from the foreground, and internally from the list foreground_mobjects. remove_foreground_mobjects Removes mobjects from the foreground, and internally from the list foreground_mobjects. remove_updater Remove an update function from the scene. render Renders this Scene. replace Replace one mobject in the scene with another, preserving draw order. restructure_mobjects tl:wr set_key_function setup This is meant to be implemented by any scenes which are commonly subclassed, and have some common setup involved before the construct method is called. should_update_mobjects Returns True if the mobjects of this scene should be updated. tear_down This is meant to be implemented by any scenes which are commonly subclassed, and have some common method to be invoked before the scene ends. update_meshes update_mobjects Begins updating all mobjects in the Scene. update_self Run all scene updater functions. update_to_time validate_run_time wait Plays a \"no operation\" animation. wait_until Wait until a condition is satisfied, up to a given maximum duration. Attributes camera time The time since the start of the scene. Parameters : renderer ( CairoRenderer | OpenGLRenderer | None ) camera_class ( type [ Camera ] ) always_update_mobjects ( bool ) random_seed ( int | None ) skip_animations ( bool ) _get_animation_time_progression ( animations , duration ) [source]   You will hardly use this when making your own animations.\nThis method is for Manim\u2019s internal use. Uses get_time_progression() to obtain a\nCommandLine ProgressBar whose fill_time is\ndependent on the qualities of the passed Animation, Parameters : animations ( list [ Animation ] ) \u2013 The list of animations to get\nthe time progression for. duration ( float ) \u2013 duration of wait time Returns : The CommandLine Progress Bar. Return type : time_progression add ( * mobjects ) [source]   Mobjects will be displayed, from background to\nforeground in the order with which they are added. Parameters : *mobjects ( Mobject ) \u2013 Mobjects to add. Returns : The same scene after adding the Mobjects in. Return type : Scene add_foreground_mobject ( mobject ) [source]   Adds a single mobject to the foreground, and internally to the list\nforeground_mobjects, and mobjects. Parameters : mobject ( Mobject ) \u2013 The Mobject to add to the foreground. Returns : The Scene, with the foreground mobject added. Return type : Scene add_foreground_mobjects ( * mobjects ) [source]   Adds mobjects to the foreground, and internally to the list\nforeground_mobjects, and mobjects. Parameters : *mobjects ( Mobject ) \u2013 The Mobjects to add to the foreground. Returns : The Scene, with the foreground mobjects added. Return type : Scene add_sound ( sound_file , time_offset = 0 , gain = None , ** kwargs ) [source]   This method is used to add a sound to the animation. Parameters : sound_file ( str ) \u2013 The path to the sound file. time_offset ( float ) \u2013 The offset in the sound file after which\nthe sound can be played. gain ( float | None ) \u2013 Amplification of the sound. Examples Example: SoundExample   from manim import * class SoundExample ( Scene ): # Source of sound under Creative Commons 0 License. https://freesound.org/people/Druminfected/sounds/250551/ def construct ( self ): dot = Dot () . set_color ( GREEN ) self . add_sound ( \"click.wav\" ) self . add ( dot ) self . wait () self . add_sound ( \"click.wav\" ) dot . set_color ( BLUE ) self . wait () self . add_sound ( \"click.wav\" ) dot . set_color ( RED ) self . wait () class SoundExample(Scene):\n    # Source of sound under Creative Commons 0 License. https://freesound.org/people/Druminfected/sounds/250551/\n    def construct(self):\n        dot = Dot().set_color(GREEN)\n        self.add_sound(\"click.wav\")\n        self.add(dot)\n        self.wait()\n        self.add_sound(\"click.wav\")\n        dot.set_color(BLUE)\n        self.wait()\n        self.add_sound(\"click.wav\")\n        dot.set_color(RED)\n        self.wait() Download the resource for the previous example here . add_subcaption ( content , duration = 1 , offset = 0 ) [source]   Adds an entry in the corresponding subcaption file\nat the current time stamp. The current time stamp is obtained from Scene.time . Parameters : content ( str ) \u2013 The subcaption content. duration ( float ) \u2013 The duration (in seconds) for which the subcaption is shown. offset ( float ) \u2013 This offset (in seconds) is added to the starting time stamp\nof the subcaption. Return type : None Examples This example illustrates both possibilities for adding\nsubcaptions to Manimations: class SubcaptionExample ( Scene ): def construct ( self ): square = Square () circle = Circle () # first option: via the add_subcaption method self . add_subcaption ( \"Hello square!\" , duration = 1 ) self . play ( Create ( square )) # second option: within the call to Scene.play self . play ( Transform ( square , circle ), subcaption = \"The square transforms.\" ) add_updater ( func ) [source]   Add an update function to the scene. The scene updater functions are run every frame,\nand they are the last type of updaters to run. Warning When using the Cairo renderer, scene updaters that\nmodify mobjects are not detected in the same way\nthat mobject updaters are. To be more concrete,\na mobject only modified via a scene updater will\nnot necessarily be added to the list of moving\nmobjects and thus might not be updated every frame. TL;DR: Use mobject updaters to update mobjects. Parameters : func ( Callable [ [ float ] , None ] ) \u2013 The updater function. It takes a float, which is the\ntime difference since the last update (usually equal\nto the frame rate). Return type : None See also Scene.remove_updater() , Scene.update_self() begin_animations ( ) [source]   Start the animations of the scene. Return type : None bring_to_back ( * mobjects ) [source]   Removes the mobject from the scene and\nadds them to the back of the scene. Parameters : *mobjects ( Mobject ) \u2013 The mobject(s) to push to the back of the scene. Returns : The Scene, with the mobjects pushed to the back\nof the scene. Return type : Scene bring_to_front ( * mobjects ) [source]   Adds the passed mobjects to the scene again,\npushing them to he front of the scene. Parameters : *mobjects ( Mobject ) \u2013 The mobject(s) to bring to the front of the scene. Returns : The Scene, with the mobjects brought to the front\nof the scene. Return type : Scene clear ( ) [source]   Removes all mobjects present in self.mobjects\nand self.foreground_mobjects from the scene. Returns : The Scene, with all of its mobjects in\nself.mobjects and self.foreground_mobjects\nremoved. Return type : Scene compile_animation_data ( * animations , ** play_kwargs ) [source]   Given a list of animations, compile the corresponding\nstatic and moving mobjects, and gather the animation durations. This also begins the animations. Parameters : animations ( Animation | Mobject | _AnimationBuilder ) \u2013 Animation or mobject with mobject method and params play_kwargs \u2013 Named parameters affecting what was passed in animations ,\ne.g. run_time , lag_ratio and so on. Returns : None if there is nothing to play, or self otherwise. Return type : self, None compile_animations ( * args , ** kwargs ) [source]   Creates _MethodAnimations from any _AnimationBuilders and updates animation\nkwargs with kwargs passed to play(). Parameters : *args ( Animation | Mobject | _AnimationBuilder ) \u2013 Animations to be played. **kwargs \u2013 Configuration for the call to play(). Returns : Animations to be played. Return type : Tuple[ Animation ] construct ( ) [source]   Add content to the Scene. From within Scene.construct() , display mobjects on screen by calling Scene.add() and remove them from screen by calling Scene.remove() .\nAll mobjects currently on screen are kept in Scene.mobjects .  Play\nanimations by calling Scene.play() . Notes Initialization code should go in Scene.setup() .  Termination code should\ngo in Scene.tear_down() . Examples A typical manim script includes a class derived from Scene with an\noverridden Scene.construct() method: class MyScene ( Scene ): def construct ( self ): self . play ( Write ( Text ( \"Hello World!\" ))) See also Scene.setup() , Scene.render() , Scene.tear_down() get_attrs ( * keys ) [source]   Gets attributes of a scene given the attribute\u2019s identifier/name. Parameters : *keys ( str ) \u2013 Name(s) of the argument(s) to return the attribute of. Returns : List of attributes of the passed identifiers. Return type : list get_mobject_family_members ( ) [source]   Returns list of family-members of all mobjects in scene.\nIf a Circle() and a VGroup(Rectangle(),Triangle()) were added,\nit returns not only the Circle(), Rectangle() and Triangle(), but\nalso the VGroup() object. Returns : List of mobject family members. Return type : list get_moving_mobjects ( * animations ) [source]   Gets all moving mobjects in the passed animation(s). Parameters : *animations ( Animation ) \u2013 The animations to check for moving mobjects. Returns : The list of mobjects that could be moving in\nthe Animation(s) Return type : list get_restructured_mobject_list ( mobjects , to_remove ) [source]   Given a list of mobjects and a list of mobjects to be removed, this\nfilters out the removable mobjects from the list of mobjects. Parameters : mobjects ( list ) \u2013 The Mobjects to check. to_remove ( list ) \u2013 The list of mobjects to remove. Returns : The list of mobjects with the mobjects to remove removed. Return type : list get_run_time ( animations ) [source]   Gets the total run time for a list of animations. Parameters : animations ( list [ Animation ] ) \u2013 A list of the animations whose total run_time is to be calculated. Returns : The total run_time of all of the animations in the list. Return type : float get_time_progression ( run_time , description , n_iterations = None , override_skip_animations = False ) [source]   You will hardly use this when making your own animations.\nThis method is for Manim\u2019s internal use. Returns a CommandLine ProgressBar whose fill_time is dependent on the run_time of an animation,\nthe iterations to perform in that animation\nand a bool saying whether or not to consider\nthe skipped animations. Parameters : run_time ( float ) \u2013 The run_time of the animation. n_iterations ( int | None ) \u2013 The number of iterations in the animation. override_skip_animations ( bool ) \u2013 Whether or not to show skipped animations in the progress bar. Returns : The CommandLine Progress Bar. Return type : time_progression get_top_level_mobjects ( ) [source]   Returns all mobjects which are not submobjects. Returns : List of top level mobjects. Return type : list interactive_embed ( ) [source]   Like embed(), but allows for screen interaction. is_current_animation_frozen_frame ( ) [source]   Returns whether the current animation produces a static frame (generally a Wait). Return type : bool next_section ( name = 'unnamed' , section_type = DefaultSectionType.NORMAL , skip_animations = False ) [source]   Create separation here; the last section gets finished and a new one gets created. skip_animations skips the rendering of all animations in this section.\nRefer to the documentation on how to use sections. Parameters : name ( str ) section_type ( str ) skip_animations ( bool ) Return type : None pause ( duration = 1.0 ) [source]   Pauses the scene (i.e., displays a frozen frame). This is an alias for wait() with frozen_frame set to True . Parameters : duration ( float ) \u2013 The duration of the pause. See also wait() , Wait play ( * args , subcaption = None , subcaption_duration = None , subcaption_offset = 0 , ** kwargs ) [source]   Plays an animation in this scene. Parameters : args ( Animation | Mobject | _AnimationBuilder ) \u2013 Animations to be played. subcaption \u2013 The content of the external subcaption that should\nbe added during the animation. subcaption_duration \u2013 The duration for which the specified subcaption is\nadded. If None (the default), the run time of the\nanimation is taken. subcaption_offset \u2013 An offset (in seconds) for the start time of the\nadded subcaption. kwargs \u2013 All other keywords are passed to the renderer. play_internal ( skip_rendering = False ) [source]   This method is used to prep the animations for rendering,\napply the arguments and parameters required to them,\nrender them, and write them to the video file. Parameters : skip_rendering ( bool ) \u2013 Whether the rendering should be skipped, by default False remove ( * mobjects ) [source]   Removes mobjects in the passed list of mobjects\nfrom the scene and the foreground, by removing them\nfrom \u201cmobjects\u201d and \u201cforeground_mobjects\u201d Parameters : *mobjects ( Mobject ) \u2013 The mobjects to remove. remove_foreground_mobject ( mobject ) [source]   Removes a single mobject from the foreground, and internally from the list\nforeground_mobjects. Parameters : mobject ( Mobject ) \u2013 The mobject to remove from the foreground. Returns : The Scene, with the foreground mobject removed. Return type : Scene remove_foreground_mobjects ( * to_remove ) [source]   Removes mobjects from the foreground, and internally from the list\nforeground_mobjects. Parameters : *to_remove ( Mobject ) \u2013 The mobject(s) to remove from the foreground. Returns : The Scene, with the foreground mobjects removed. Return type : Scene remove_updater ( func ) [source]   Remove an update function from the scene. Parameters : func ( Callable [ [ float ] , None ] ) \u2013 The updater function to be removed. Return type : None See also Scene.add_updater() , Scene.update_self() render ( preview = False ) [source]   Renders this Scene. Parameters : preview ( bool ) \u2013 If true, opens scene in a file viewer. replace ( old_mobject , new_mobject ) [source]   Replace one mobject in the scene with another, preserving draw order. If old_mobject is a submobject of some other Mobject (e.g. a Group ), the new_mobject will replace it inside the group,\nwithout otherwise changing the parent mobject. Parameters : old_mobject ( Mobject ) \u2013 The mobject to be replaced. Must be present in the scene. new_mobject ( Mobject ) \u2013 A mobject which must not already be in the scene. Return type : None restructure_mobjects ( to_remove , mobject_list_name = 'mobjects' , extract_families = True ) [source]   tl:wr If your scene has a Group(), and you removed a mobject from the Group,\nthis dissolves the group and puts the rest of the mobjects directly\nin self.mobjects or self.foreground_mobjects. In cases where the scene contains a group, e.g. Group(m1, m2, m3), but one\nof its submobjects is removed, e.g. scene.remove(m1), the list of mobjects\nwill be edited to contain other submobjects, but not m1, e.g. it will now\ninsert m2 and m3 to where the group once was. Parameters : to_remove ( Sequence [ Mobject ] ) \u2013 The Mobject to remove. mobject_list_name ( str ) \u2013 The list of mobjects (\u201cmobjects\u201d, \u201cforeground_mobjects\u201d etc) to remove from. extract_families ( bool ) \u2013 Whether the mobject\u2019s families should be recursively extracted. Returns : The Scene mobject with restructured Mobjects. Return type : Scene setup ( ) [source]   This is meant to be implemented by any scenes which\nare commonly subclassed, and have some common setup\ninvolved before the construct method is called. should_update_mobjects ( ) [source]   Returns True if the mobjects of this scene should be updated. In particular, this checks whether the always_update_mobjects attribute of Scene is set to True , the Scene itself has time-based updaters attached, any mobject in this Scene has time-based updaters attached. This is only called when a single Wait animation is played. Return type : bool tear_down ( ) [source]   This is meant to be implemented by any scenes which\nare commonly subclassed, and have some common method\nto be invoked before the scene ends. property time : float   The time since the start of the scene. update_mobjects ( dt ) [source]   Begins updating all mobjects in the Scene. Parameters : dt ( float ) \u2013 Change in time between updates. Defaults (mostly) to 1/frames_per_second update_self ( dt ) [source]   Run all scene updater functions. Among all types of update functions (mobject updaters, mesh updaters,\nscene updaters), scene update functions are called last. Parameters : dt ( float ) \u2013 Scene time since last update. See also Scene.add_updater() , Scene.remove_updater() wait ( duration = 1.0 , stop_condition = None , frozen_frame = None ) [source]   Plays a \u201cno operation\u201d animation. Parameters : duration ( float ) \u2013 The run time of the animation. stop_condition ( Callable [ [ ] , bool ] | None ) \u2013 A function without positional arguments that is evaluated every time\na frame is rendered. The animation only stops when the return value\nof the function is truthy, or when the time specified in duration passes. frozen_frame ( bool | None ) \u2013 If True, updater functions are not evaluated, and the animation outputs\na frozen frame. If False, updater functions are called and frames\nare rendered as usual. If None (the default), the scene tries to\ndetermine whether or not the frame is frozen on its own. See also Wait , should_mobjects_update() wait_until ( stop_condition , max_time = 60 ) [source]   Wait until a condition is satisfied, up to a given maximum duration. Parameters : stop_condition ( Callable [ [ ] , bool ] ) \u2013 A function with no arguments that determines whether or not the\nscene should keep waiting. max_time ( float ) \u2013 The maximum wait time in seconds.", "source": "https://docs.manim.community/en/stable/reference/manim.scene.scene.Scene.html"}
{"prompt": "convert_audio(input_path, output_path, codec_name)", "response": "Parameters : input_path ( Path ) output_path ( Path ) codec_name ( str )", "source": "https://docs.manim.community/en/stable/reference/manim.scene.scene_file_writer.html"}
{"prompt": "class SceneFileWriter(renderer, scene_name, **kwargs)", "response": "Bases: object SceneFileWriter is the object that actually writes the animations\nplayed, into video files, using FFMPEG.\nThis is mostly for Manim\u2019s internal use. You will rarely, if ever,\nhave to use the methods for this class, unless tinkering with the very\nfabric of Manim\u2019s reality. Parameters : renderer ( CairoRenderer | OpenGLRenderer ) scene_name ( StrPath ) kwargs ( Any ) sections   used to segment scene Type : list of Section sections_output_dir   where are section videos stored Type : pathlib.Path output_name   name of movie without extension and basis for section video names Type : str Some useful attributes are: \u201cwrite_to_movie\u201d (bool=False) Whether or not to write the animations into a video file. \u201cmovie_file_extension\u201d (str=\u201d.mp4\u201d) The file-type extension of the outputted video. \u201cpartial_movie_files\u201d List of all the partial-movie files. Methods add_audio_segment This method adds an audio segment from an AudioSegment type object and suitable parameters. add_partial_movie_file Adds a new partial movie file path to scene.partial_movie_files and current section from a hash. add_sound This method adds an audio segment from a sound file. begin_animation Used internally by manim to stream the animation to FFMPEG for displaying or writing to a file. clean_cache Will clean the cache by removing the oldest partial_movie_files. close_partial_movie_stream Close the currently opened video container. combine_files combine_to_movie Used internally by Manim to combine the separate partial movie files that make up a Scene into a single video file for that Scene. combine_to_section_videos Concatenate partial movie files for each section. create_audio_segment Creates an empty, silent, Audio Segment. encode_and_write_frame For internal use only: takes a given frame in np.ndarray format and write it to the stream end_animation Internally used by Manim to stop streaming to FFMPEG gracefully. finish Finishes writing to the FFMPEG buffer or writing images to output directory. finish_last_section Delete current section if it is empty. flush_cache_directory Delete all the cached partial movie files get_resolution_directory Get the name of the resolution directory directly containing the video file. init_audio Preps the writer for adding audio to the movie. init_output_directories Initialise output directories. is_already_cached Will check if a file named with hash_invocation exists. listen_and_write For internal use only: blocks until new frame is available on the queue. next_section Create segmentation cut here. open_partial_movie_stream Open a container holding a video stream. output_image print_file_ready_message Prints the \"File Ready\" message to STDOUT. save_final_image The name is a misnomer. write_frame Used internally by Manim to write a frame to the FFMPEG input buffer. write_subcaption_file Writes the subcaption file. Attributes force_output_as_scene_name add_audio_segment ( new_segment , time = None , gain_to_background = None ) [source]   This method adds an audio segment from an\nAudioSegment type object and suitable parameters. Parameters : new_segment ( AudioSegment ) \u2013 The audio segment to add time ( float | None ) \u2013 the timestamp at which the\nsound should be added. gain_to_background ( float | None ) \u2013 The gain of the segment from the background. add_partial_movie_file ( hash_animation ) [source]   Adds a new partial movie file path to scene.partial_movie_files and current section from a hash.\nThis method will compute the path from the hash. In addition to that it adds the new animation to the current section. Parameters : hash_animation ( str ) \u2013 Hash of the animation. add_sound ( sound_file , time = None , gain = None , ** kwargs ) [source]   This method adds an audio segment from a sound file. Parameters : sound_file ( str ) \u2013 The path to the sound file. time ( float | None ) \u2013 The timestamp at which the audio should be added. gain ( float | None ) \u2013 The gain of the given audio segment. **kwargs \u2013 This method uses add_audio_segment, so any keyword arguments\nused there can be referenced here. begin_animation ( allow_write = False , file_path = None ) [source]   Used internally by manim to stream the animation to FFMPEG for\ndisplaying or writing to a file. Parameters : allow_write ( bool ) \u2013 Whether or not to write to a video file. file_path ( StrPath | None ) Return type : None clean_cache ( ) [source]   Will clean the cache by removing the oldest partial_movie_files. close_partial_movie_stream ( ) [source]   Close the currently opened video container. Used internally by Manim to first flush the remaining packages\nin the video stream holding a partial file, and then close\nthe corresponding container. Return type : None combine_to_movie ( ) [source]   Used internally by Manim to combine the separate\npartial movie files that make up a Scene into a single\nvideo file for that Scene. combine_to_section_videos ( ) [source]   Concatenate partial movie files for each section. Return type : None create_audio_segment ( ) [source]   Creates an empty, silent, Audio Segment. encode_and_write_frame ( frame , num_frames ) [source]   For internal use only: takes a given frame in np.ndarray format and\nwrite it to the stream Parameters : frame ( PixelArray ) num_frames ( int ) Return type : None end_animation ( allow_write = False ) [source]   Internally used by Manim to stop streaming to\nFFMPEG gracefully. Parameters : allow_write ( bool ) \u2013 Whether or not to write to a video file. Return type : None finish ( ) [source]   Finishes writing to the FFMPEG buffer or writing images\nto output directory.\nCombines the partial movie files into the\nwhole scene.\nIf save_last_frame is True, saves the last\nframe in the default image directory. Return type : None finish_last_section ( ) [source]   Delete current section if it is empty. Return type : None flush_cache_directory ( ) [source]   Delete all the cached partial movie files get_resolution_directory ( ) [source]   Get the name of the resolution directory directly containing\nthe video file. This method gets the name of the directory that immediately contains the\nvideo file. This name is <height_in_pixels_of_video>p<frame_rate> .\nFor example, if you are rendering an 854x480 px animation at 15fps,\nthe name of the directory that immediately contains the video,  file\nwill be 480p15 . The file structure should look something like: MEDIA_DIR |-- Tex |-- texts |-- videos |--< name_of_file_containing_scene > |--< height_in_pixels_of_video > p < frame_rate > |--< scene_name >. mp4 Returns : The name of the directory. Return type : str init_audio ( ) [source]   Preps the writer for adding audio to the movie. init_output_directories ( scene_name ) [source]   Initialise output directories. Notes The directories are read from config , for example config['media_dir'] .  If the target directories don\u2019t already\nexist, they will be created. Parameters : scene_name ( StrPath ) Return type : None is_already_cached ( hash_invocation ) [source]   Will check if a file named with hash_invocation exists. Parameters : hash_invocation ( str ) \u2013 The hash corresponding to an invocation to either scene.play or scene.wait . Returns : Whether the file exists. Return type : bool listen_and_write ( ) [source]   For internal use only: blocks until new frame is available on the queue. next_section ( name , type_ , skip_animations ) [source]   Create segmentation cut here. Parameters : name ( str ) type_ ( str ) skip_animations ( bool ) Return type : None open_partial_movie_stream ( file_path = None ) [source]   Open a container holding a video stream. This is used internally by Manim initialize the container holding\nthe video stream of a partial movie file. Return type : None print_file_ready_message ( file_path ) [source]   Prints the \u201cFile Ready\u201d message to STDOUT. save_final_image ( image ) [source]   The name is a misnomer. This method saves the image\npassed to it as an in the default image directory. Parameters : image ( ndarray ) \u2013 The pixel array of the image to save. write_frame ( frame_or_renderer , num_frames = 1 ) [source]   Used internally by Manim to write a frame to\nthe FFMPEG input buffer. Parameters : frame_or_renderer ( np.ndarray | OpenGLRenderer ) \u2013 Pixel array of the frame. num_frames ( int ) \u2013 The number of times to write frame. write_subcaption_file ( ) [source]   Writes the subcaption file.", "source": "https://docs.manim.community/en/stable/reference/manim.scene.scene_file_writer.SceneFileWriter.html"}
{"prompt": "convert_audio(input_path, output_path, codec_name)", "response": "Parameters : input_path ( Path ) output_path ( Path ) codec_name ( str )", "source": "https://docs.manim.community/en/stable/reference/manim.scene.scene_file_writer.html#manim.scene.scene_file_writer.convert_audio"}
{"prompt": "convert_audio(input_path, output_path, codec_name)", "response": "Parameters : input_path ( Path ) output_path ( Path ) codec_name ( str )", "source": "https://docs.manim.community/en/stable/reference/manim.scene.scene_file_writer.html#manim.scene.scene_file_writer.to_av_frame_rate"}
{"prompt": "class SpecialThreeDScene(cut_axes_at_radius=True, camera_config={'exponential_projection': True, 'should_apply_shading': True}, three_d_axes_config={'axis_config': {'numbers_with_elongated_ticks':", "response": "Bases: ThreeDScene An extension of ThreeDScene with more settings. It has some extra configuration for axes, spheres,\nand an override for low quality rendering. Further key differences\nare: The camera shades applicable 3DMobjects by default,\nexcept if rendering in low quality. Some default params for Spheres and Axes have been added. Methods get_axes Return a set of 3D axes. get_default_camera_position Returns the default_angled_camera position. get_sphere Returns a sphere with the passed keyword arguments as properties. set_camera_to_default_position Sets the camera to its default position. Attributes camera time The time since the start of the scene. get_axes ( ) [source]   Return a set of 3D axes. Returns : A set of 3D axes. Return type : ThreeDAxes get_default_camera_position ( ) [source]   Returns the default_angled_camera position. Returns : Dictionary of phi, theta, focal_distance, and gamma. Return type : dict get_sphere ( ** kwargs ) [source]   Returns a sphere with the passed keyword arguments as properties. Parameters : **kwargs \u2013 Any valid parameter of Sphere or Surface . Returns : The sphere object. Return type : Sphere set_camera_to_default_position ( ) [source]   Sets the camera to its default position.", "source": "https://docs.manim.community/en/stable/reference/manim.scene.three_d_scene.SpecialThreeDScene.html"}
{"prompt": "class ThreeDScene(camera_class=<class 'manim.camera.three_d_camera.ThreeDCamera'>, ambient_camera_rotation=None, default_angled_camera_orientation_kwargs=None, **kwargs)", "response": "Bases: Scene This is a Scene, with special configurations and properties that\nmake it suitable for Three Dimensional Scenes. Methods add_fixed_in_frame_mobjects This method is used to prevent the rotation and movement of mobjects as the camera moves around. add_fixed_orientation_mobjects This method is used to prevent the rotation and tilting of mobjects as the camera moves around. begin_3dillusion_camera_rotation This method creates a 3D camera rotation illusion around the current camera orientation. begin_ambient_camera_rotation This method begins an ambient rotation of the camera about the Z_AXIS, in the anticlockwise direction get_moving_mobjects This method returns a list of all of the Mobjects in the Scene that are moving, that are also in the animations passed. move_camera This method animates the movement of the camera to the given spherical coordinates. remove_fixed_in_frame_mobjects This method undoes what add_fixed_in_frame_mobjects does. remove_fixed_orientation_mobjects This method \"unfixes\" the orientation of the mobjects passed, meaning they will no longer be at the same angle relative to the camera. set_camera_orientation This method sets the orientation of the camera in the scene. set_to_default_angled_camera_orientation This method sets the default_angled_camera_orientation to the keyword arguments passed, and sets the camera to that orientation. stop_3dillusion_camera_rotation This method stops all illusion camera rotations. stop_ambient_camera_rotation This method stops all ambient camera rotation. Attributes camera time The time since the start of the scene. add_fixed_in_frame_mobjects ( * mobjects ) [source]   This method is used to prevent the rotation and movement\nof mobjects as the camera moves around. The mobject is\nessentially overlaid, and is not impacted by the camera\u2019s\nmovement in any way. Parameters : *mobjects ( Mobject ) \u2013 The Mobjects whose orientation must be fixed. add_fixed_orientation_mobjects ( * mobjects , ** kwargs ) [source]   This method is used to prevent the rotation and tilting\nof mobjects as the camera moves around. The mobject can\nstill move in the x,y,z directions, but will always be\nat the angle (relative to the camera) that it was at\nwhen it was passed through this method.) Parameters : *mobjects ( Mobject ) \u2013 The Mobject(s) whose orientation must be fixed. **kwargs \u2013 Some valid kwargs are use_static_center_func : bool\ncenter_func : function begin_3dillusion_camera_rotation ( rate = 1 , origin_phi = None , origin_theta = None ) [source]   This method creates a 3D camera rotation illusion around\nthe current camera orientation. Parameters : rate ( float ) \u2013 The rate at which the camera rotation illusion should operate. origin_phi ( float | None ) \u2013 The polar angle the camera should move around. Defaults\nto the current phi angle. origin_theta ( float | None ) \u2013 The azimutal angle the camera should move around. Defaults\nto the current theta angle. begin_ambient_camera_rotation ( rate = 0.02 , about = 'theta' ) [source]   This method begins an ambient rotation of the camera about the Z_AXIS,\nin the anticlockwise direction Parameters : rate ( float ) \u2013 The rate at which the camera should rotate about the Z_AXIS.\nNegative rate means clockwise rotation. about ( str ) \u2013 one of 3 options: [\u201ctheta\u201d, \u201cphi\u201d, \u201cgamma\u201d]. defaults to theta. get_moving_mobjects ( * animations ) [source]   This method returns a list of all of the Mobjects in the Scene that\nare moving, that are also in the animations passed. Parameters : *animations ( Animation ) \u2013 The animations whose mobjects will be checked. move_camera ( phi = None , theta = None , gamma = None , zoom = None , focal_distance = None , frame_center = None , added_anims = [] , ** kwargs ) [source]   This method animates the movement of the camera\nto the given spherical coordinates. Parameters : phi ( float | None ) \u2013 The polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians. theta ( float | None ) \u2013 The azimuthal angle i.e the angle that spins the camera around the Z_AXIS. focal_distance ( float | None ) \u2013 The radial focal_distance between ORIGIN and Camera. gamma ( float | None ) \u2013 The rotation of the camera about the vector from the ORIGIN to the Camera. zoom ( float | None ) \u2013 The zoom factor of the camera. frame_center ( Mobject | Sequence [ float ] | None ) \u2013 The new center of the camera frame in cartesian coordinates. added_anims ( Iterable [ Animation ] ) \u2013 Any other animations to be played at the same time. remove_fixed_in_frame_mobjects ( * mobjects ) [source]   This method undoes what add_fixed_in_frame_mobjects does.\nIt allows the mobject to be affected by the movement of\nthe camera. Parameters : *mobjects ( Mobject ) \u2013 The Mobjects whose position and orientation must be unfixed. remove_fixed_orientation_mobjects ( * mobjects ) [source]   This method \u201cunfixes\u201d the orientation of the mobjects\npassed, meaning they will no longer be at the same angle\nrelative to the camera. This only makes sense if the\nmobject was passed through add_fixed_orientation_mobjects first. Parameters : *mobjects ( Mobject ) \u2013 The Mobjects whose orientation must be unfixed. set_camera_orientation ( phi = None , theta = None , gamma = None , zoom = None , focal_distance = None , frame_center = None , ** kwargs ) [source]   This method sets the orientation of the camera in the scene. Parameters : phi ( float | None ) \u2013 The polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians. theta ( float | None ) \u2013 The azimuthal angle i.e the angle that spins the camera around the Z_AXIS. focal_distance ( float | None ) \u2013 The focal_distance of the Camera. gamma ( float | None ) \u2013 The rotation of the camera about the vector from the ORIGIN to the Camera. zoom ( float | None ) \u2013 The zoom factor of the scene. frame_center ( Mobject | Sequence [ float ] | None ) \u2013 The new center of the camera frame in cartesian coordinates. set_to_default_angled_camera_orientation ( ** kwargs ) [source]   This method sets the default_angled_camera_orientation to the\nkeyword arguments passed, and sets the camera to that orientation. Parameters : **kwargs \u2013 Some recognised kwargs are phi, theta, focal_distance, gamma,\nwhich have the same meaning as the parameters in set_camera_orientation. stop_3dillusion_camera_rotation ( ) [source]   This method stops all illusion camera rotations. stop_ambient_camera_rotation ( about = 'theta' ) [source]   This method stops all ambient camera rotation.", "source": "https://docs.manim.community/en/stable/reference/manim.scene.three_d_scene.ThreeDScene.html"}
{"prompt": "class LinearTransformationScene(include_background_plane=True, include_foreground_plane=True, background_plane_kwargs=None, foreground_plane_kwargs=None, show_coordinates=False, show_basis_vectors=True, basis_vector_stroke_width=6, i_hat_color=ManimColor('#83C167'), j_hat_color=ManimColor('#FC6255'), leave_ghost_vectors=False, **kwargs)", "response": "Bases: VectorScene This scene contains special methods that make it\nespecially suitable for showing linear transformations. Parameters : include_background_plane ( bool ) \u2013 Whether or not to include the background plane in the scene. include_foreground_plane ( bool ) \u2013 Whether or not to include the foreground plane in the scene. background_plane_kwargs ( dict | None ) \u2013 Parameters to be passed to NumberPlane to adjust the background plane. foreground_plane_kwargs ( dict | None ) \u2013 Parameters to be passed to NumberPlane to adjust the foreground plane. show_coordinates ( bool ) \u2013 Whether or not to include the coordinates for the background plane. show_basis_vectors ( bool ) \u2013 Whether to show the basis x_axis -> i_hat and y_axis -> j_hat vectors. basis_vector_stroke_width ( float ) \u2013 The stroke_width of the basis vectors. i_hat_color ( ParsableManimColor ) \u2013 The color of the i_hat vector. j_hat_color ( ParsableManimColor ) \u2013 The color of the j_hat vector. leave_ghost_vectors ( bool ) \u2013 Indicates the previous position of the basis vectors following a transformation. Examples Example: LinearTransformationSceneExample   from manim import * class LinearTransformationSceneExample ( LinearTransformationScene ): def __init__ ( self , ** kwargs ): LinearTransformationScene . __init__ ( self , show_coordinates = True , leave_ghost_vectors = True , ** kwargs ) def construct ( self ): matrix = [[ 1 , 1 ], [ 0 , 1 ]] self . apply_matrix ( matrix ) self . wait () class LinearTransformationSceneExample(LinearTransformationScene):\n    def __init__(self, **kwargs):\n        LinearTransformationScene.__init__(\n            self,\n            show_coordinates=True,\n            leave_ghost_vectors=True,\n            **kwargs\n        )\n\n    def construct(self):\n        matrix = [[1, 1], [0, 1]]\n        self.apply_matrix(matrix)\n        self.wait() Methods add_background_mobject Adds the mobjects to the special list self.background_mobjects. add_foreground_mobject Adds the mobjects to the special list self.foreground_mobjects. add_moving_mobject Adds the mobject to the special list self.moving_mobject, and adds a property to the mobject called mobject.target, which keeps track of what the mobject will move to or become etc. add_special_mobjects Adds mobjects to a separate list that can be tracked, if these mobjects have some extra importance. add_title Adds a title, after scaling it, adding a background rectangle, moving it to the top and adding it to foreground_mobjects adding it as a local variable of self. add_transformable_label Method for creating, and animating the addition of a transformable label for the vector. add_transformable_mobject Adds the mobjects to the special list self.transformable_mobjects. add_unit_square Adds a unit square to the scene via self.get_unit_square. add_vector Adds a vector to the scene, and puts it in the special list self.moving_vectors. apply_function Applies the given function to each of the mobjects in self.transformable_mobjects, and plays the animation showing this. apply_inverse This method applies the linear transformation represented by the inverse of the passed matrix to the number plane, and each vector/similar mobject on it. apply_inverse_transpose Applies the inverse of the transformation represented by the given transposed matrix to the number plane and each vector/similar mobject on it. apply_matrix Applies the transformation represented by the given matrix to the number plane, and each vector/similar mobject on it. apply_nonlinear_transformation Applies the non-linear transformation represented by the given function to the number plane and each vector/similar mobject on it. apply_transposed_matrix Applies the transformation represented by the given transposed matrix to the number plane, and each vector/similar mobject on it. get_ghost_vectors Returns all ghost vectors ever added to self . get_matrix_transformation Returns a function corresponding to the linear transformation represented by the matrix passed. get_moving_mobject_movement This method returns an animation that moves a mobject in \"self.moving_mobjects\"  to its corresponding .target value. get_piece_movement This method returns an animation that moves an arbitrary mobject in \"pieces\" to its corresponding .target value. get_transformable_label_movement This method returns an animation that moves all labels in \"self.transformable_labels\" to its corresponding .target . get_transposed_matrix_transformation Returns a function corresponding to the linear transformation represented by the transposed matrix passed. get_unit_square Returns a unit square for the current NumberPlane. get_vector_movement This method returns an animation that moves a mobject in \"self.moving_vectors\"  to its corresponding .target value. setup This is meant to be implemented by any scenes which are commonly subclassed, and have some common setup involved before the construct method is called. update_default_configs write_vector_coordinates Returns a column matrix indicating the vector coordinates, after writing them to the screen, and adding them to the special list self.foreground_mobjects Attributes camera time The time since the start of the scene. add_background_mobject ( * mobjects ) [source]   Adds the mobjects to the special list\nself.background_mobjects. Parameters : *mobjects ( Mobject ) \u2013 The mobjects to add to the list. add_foreground_mobject ( * mobjects ) [source]   Adds the mobjects to the special list\nself.foreground_mobjects. Parameters : *mobjects ( Mobject ) \u2013 The mobjects to add to the list add_moving_mobject ( mobject , target_mobject = None ) [source]   Adds the mobject to the special list\nself.moving_mobject, and adds a property\nto the mobject called mobject.target, which\nkeeps track of what the mobject will move to\nor become etc. Parameters : mobject ( Mobject ) \u2013 The mobjects to add to the list target_mobject ( Mobject | None ) \u2013 What the moving_mobject goes to, etc. add_special_mobjects ( mob_list , * mobs_to_add ) [source]   Adds mobjects to a separate list that can be tracked,\nif these mobjects have some extra importance. Parameters : mob_list ( list ) \u2013 The special list to which you want to add\nthese mobjects. *mobs_to_add ( Mobject ) \u2013 The mobjects to add. add_title ( title , scale_factor = 1.5 , animate = False ) [source]   Adds a title, after scaling it, adding a background rectangle,\nmoving it to the top and adding it to foreground_mobjects adding\nit as a local variable of self. Returns the Scene. Parameters : title ( str | MathTex | Tex ) \u2013 What the title should be. scale_factor ( float ) \u2013 How much the title should be scaled by. animate ( bool ) \u2013 Whether or not to animate the addition. Returns : The scene with the title added to it. Return type : LinearTransformationScene add_transformable_label ( vector , label , transformation_name = 'L' , new_label = None , ** kwargs ) [source]   Method for creating, and animating the addition of\na transformable label for the vector. Parameters : vector ( Vector ) \u2013 The vector for which the label must be added. label ( MathTex | str ) \u2013 The MathTex/string of the label. transformation_name ( str | MathTex ) \u2013 The name to give the transformation as a label. new_label ( str | MathTex | None ) \u2013 What the label should display after a Linear Transformation **kwargs \u2013 Any valid keyword argument of get_vector_label Returns : The MathTex of the label. Return type : MathTex add_transformable_mobject ( * mobjects ) [source]   Adds the mobjects to the special list\nself.transformable_mobjects. Parameters : *mobjects ( Mobject ) \u2013 The mobjects to add to the list. add_unit_square ( animate = False , ** kwargs ) [source]   Adds a unit square to the scene via\nself.get_unit_square. Parameters : animate ( bool ) \u2013 Whether or not to animate the addition\nwith DrawBorderThenFill. **kwargs \u2013 Any valid keyword arguments of\nself.get_unit_square() Returns : The unit square. Return type : Square add_vector ( vector , color = ManimColor('#FFFF00') , ** kwargs ) [source]   Adds a vector to the scene, and puts it in the special\nlist self.moving_vectors. Parameters : vector ( Arrow | list | tuple | ndarray ) \u2013 It can be a pre-made graphical vector, or the\ncoordinates of one. color ( str ) \u2013 The string of the hex color of the vector.\nThis is only taken into consideration if\n\u2018vector\u2019 is not an Arrow. Defaults to YELLOW. **kwargs \u2013 Any valid keyword argument of VectorScene.add_vector. Returns : The arrow representing the vector. Return type : Arrow apply_function ( function , added_anims = [] , ** kwargs ) [source]   Applies the given function to each of the mobjects in\nself.transformable_mobjects, and plays the animation showing\nthis. Parameters : function ( Callable [ [ ndarray ] , ndarray ] ) \u2013 The function that affects each point\nof each mobject in self.transformable_mobjects. added_anims ( list ) \u2013 Any other animations that need to be played\nsimultaneously with this. **kwargs \u2013 Any valid keyword argument of a self.play() call. apply_inverse ( matrix , ** kwargs ) [source]   This method applies the linear transformation\nrepresented by the inverse of the passed matrix\nto the number plane, and each vector/similar mobject on it. Parameters : matrix ( ndarray | list | tuple ) \u2013 The matrix whose inverse is to be applied. **kwargs \u2013 Any valid keyword argument of self.apply_matrix() apply_inverse_transpose ( t_matrix , ** kwargs ) [source]   Applies the inverse of the transformation represented\nby the given transposed matrix to the number plane and each\nvector/similar mobject on it. Parameters : t_matrix ( ndarray | list | tuple ) \u2013 The matrix. **kwargs \u2013 Any valid keyword argument of self.apply_transposed_matrix() apply_matrix ( matrix , ** kwargs ) [source]   Applies the transformation represented by the\ngiven matrix to the number plane, and each vector/similar\nmobject on it. Parameters : matrix ( ndarray | list | tuple ) \u2013 The matrix. **kwargs \u2013 Any valid keyword argument of self.apply_transposed_matrix() apply_nonlinear_transformation ( function , ** kwargs ) [source]   Applies the non-linear transformation represented\nby the given function to the number plane and each\nvector/similar mobject on it. Parameters : function ( Callable [ [ ndarray ] , ndarray ] ) \u2013 The function. **kwargs \u2013 Any valid keyword argument of self.apply_function() apply_transposed_matrix ( transposed_matrix , ** kwargs ) [source]   Applies the transformation represented by the\ngiven transposed matrix to the number plane,\nand each vector/similar mobject on it. Parameters : transposed_matrix ( ndarray | list | tuple ) \u2013 The matrix. **kwargs \u2013 Any valid keyword argument of self.apply_function() get_ghost_vectors ( ) [source]   Returns all ghost vectors ever added to self . Each element is a VGroup of\ntwo ghost vectors. Return type : VGroup get_matrix_transformation ( matrix ) [source]   Returns a function corresponding to the linear\ntransformation represented by the matrix passed. Parameters : matrix ( ndarray | list | tuple ) \u2013 The matrix. get_moving_mobject_movement ( func ) [source]   This method returns an animation that moves a mobject\nin \u201cself.moving_mobjects\u201d  to its corresponding .target value.\nfunc is a function that determines where the .target goes. Parameters : func ( Callable [ [ ndarray ] , ndarray ] ) \u2013 The function that determines where the .target of\nthe moving mobject goes. Returns : The animation of the movement. Return type : Animation get_piece_movement ( pieces ) [source]   This method returns an animation that moves an arbitrary\nmobject in \u201cpieces\u201d to its corresponding .target value.\nIf self.leave_ghost_vectors is True, ghosts of the original\npositions/mobjects are left on screen Parameters : pieces ( list | tuple | ndarray ) \u2013 The pieces for which the movement must be shown. Returns : The animation of the movement. Return type : Animation get_transformable_label_movement ( ) [source]   This method returns an animation that moves all labels\nin \u201cself.transformable_labels\u201d to its corresponding .target . Returns : The animation of the movement. Return type : Animation get_transposed_matrix_transformation ( transposed_matrix ) [source]   Returns a function corresponding to the linear\ntransformation represented by the transposed\nmatrix passed. Parameters : transposed_matrix ( ndarray | list | tuple ) \u2013 The matrix. get_unit_square ( color = ManimColor('#FFFF00') , opacity = 0.3 , stroke_width = 3 ) [source]   Returns a unit square for the current NumberPlane. Parameters : color ( str ) \u2013 The string of the hex color code of the color wanted. opacity ( float ) \u2013 The opacity of the square stroke_width ( float ) \u2013 The stroke_width in pixels of the border of the square Return type : Square get_vector_movement ( func ) [source]   This method returns an animation that moves a mobject\nin \u201cself.moving_vectors\u201d  to its corresponding .target value.\nfunc is a function that determines where the .target goes. Parameters : func ( Callable [ [ ndarray ] , ndarray ] ) \u2013 The function that determines where the .target of\nthe moving mobject goes. Returns : The animation of the movement. Return type : Animation setup ( ) [source]   This is meant to be implemented by any scenes which\nare commonly subclassed, and have some common setup\ninvolved before the construct method is called. write_vector_coordinates ( vector , ** kwargs ) [source]   Returns a column matrix indicating the vector coordinates,\nafter writing them to the screen, and adding them to the\nspecial list self.foreground_mobjects Parameters : vector ( Arrow ) \u2013 The arrow representing the vector. **kwargs \u2013 Any valid keyword arguments of VectorScene.write_vector_coordinates Returns : The column matrix representing the vector. Return type : Matrix", "source": "https://docs.manim.community/en/stable/reference/manim.scene.vector_space_scene.LinearTransformationScene.html"}
{"prompt": "class VectorScene(basis_vector_stroke_width=6, **kwargs)", "response": "Bases: Scene Methods add_axes Adds a pair of Axes to the Scene. add_plane Adds a NumberPlane object to the background. add_vector Returns the Vector after adding it to the Plane. coords_to_vector This method writes the vector as a column matrix (henceforth called the label), takes the values in it one by one, and form the corresponding lines that make up the x and y components of the vector. get_basis_vector_labels Returns naming labels for the basis vectors. get_basis_vectors Returns a VGroup of the Basis Vectors (1,0) and (0,1) get_vector Returns an arrow on the Plane given an input numerical vector. get_vector_label Returns naming labels for the passed vector. label_vector Shortcut method for creating, and animating the addition of a label for the vector. lock_in_faded_grid This method freezes the NumberPlane and Axes that were already in the background, and adds new, manipulatable ones to the foreground. position_x_coordinate position_y_coordinate show_ghost_movement This method plays an animation that partially shows the entire plane moving in the direction of a particular vector. vector_to_coords This method displays vector as a Vector() based vector, and then shows the corresponding lines that make up the x and y components of the vector. write_vector_coordinates Returns a column matrix indicating the vector coordinates, after writing them to the screen. Attributes camera time The time since the start of the scene. add_axes ( animate = False , color = ManimColor('#FFFFFF') , ** kwargs ) [source]   Adds a pair of Axes to the Scene. Parameters : animate ( bool ) \u2013 Whether or not to animate the addition of the axes through Create. color ( bool ) \u2013 The color of the axes. Defaults to WHITE. add_plane ( animate = False , ** kwargs ) [source]   Adds a NumberPlane object to the background. Parameters : animate ( bool ) \u2013 Whether or not to animate the addition of the plane via Create. **kwargs \u2013 Any valid keyword arguments accepted by NumberPlane. Returns : The NumberPlane object. Return type : NumberPlane add_vector ( vector , color = ManimColor('#FFFF00') , animate = True , ** kwargs ) [source]   Returns the Vector after adding it to the Plane. Parameters : vector ( Arrow | list | tuple | ndarray ) \u2013 It can be a pre-made graphical vector, or the\ncoordinates of one. color ( str ) \u2013 The string of the hex color of the vector.\nThis is only taken into consideration if\n\u2018vector\u2019 is not an Arrow. Defaults to YELLOW. animate ( bool ) \u2013 Whether or not to animate the addition of the vector\nby using GrowArrow **kwargs \u2013 Any valid keyword argument of Arrow.\nThese are only considered if vector is not\nan Arrow. Returns : The arrow representing the vector. Return type : Arrow coords_to_vector ( vector , coords_start = array([2., 2., 0.]) , clean_up = True ) [source]   This method writes the vector as a column matrix (henceforth called the label),\ntakes the values in it one by one, and form the corresponding\nlines that make up the x and y components of the vector. Then, an\nVector() based vector is created between the lines on the Screen. Parameters : vector ( ndarray | list | tuple ) \u2013 The vector to show. coords_start ( ndarray | list | tuple ) \u2013 The starting point of the location of\nthe label of the vector that shows it\nnumerically.\nDefaults to 2 * RIGHT + 2 * UP or (2,2) clean_up ( bool ) \u2013 Whether or not to remove whatever\nthis method did after it\u2019s done. get_basis_vector_labels ( ** kwargs ) [source]   Returns naming labels for the basis vectors. Parameters : **kwargs \u2013 Any valid keyword arguments of get_vector_label: vector,\nlabel (str,MathTex)\nat_tip (bool=False),\ndirection (str=\u201dleft\u201d),\nrotate (bool),\ncolor (str),\nlabel_scale_factor=VECTOR_LABEL_SCALE_FACTOR (int, float), get_basis_vectors ( i_hat_color = ManimColor('#83C167') , j_hat_color = ManimColor('#FC6255') ) [source]   Returns a VGroup of the Basis Vectors (1,0) and (0,1) Parameters : i_hat_color ( str ) \u2013 The hex colour to use for the basis vector in the x direction j_hat_color ( str ) \u2013 The hex colour to use for the basis vector in the y direction Returns : VGroup of the Vector Mobjects representing the basis vectors. Return type : VGroup get_vector ( numerical_vector , ** kwargs ) [source]   Returns an arrow on the Plane given an input numerical vector. Parameters : numerical_vector ( ndarray | list | tuple ) \u2013 The Vector to plot. **kwargs \u2013 Any valid keyword argument of Arrow. Returns : The Arrow representing the Vector. Return type : Arrow get_vector_label ( vector , label , at_tip = False , direction = 'left' , rotate = False , color = None , label_scale_factor = 0.8 ) [source]   Returns naming labels for the passed vector. Parameters : vector ( Vector ) \u2013 Vector Object for which to get the label. at_tip ( bool ) \u2013 Whether or not to place the label at the tip of the vector. direction ( str ) \u2013 If the label should be on the \u201cleft\u201d or right of the vector. rotate ( bool ) \u2013 Whether or not to rotate it to align it with the vector. color ( str | None ) \u2013 The color to give the label. label_scale_factor ( float ) \u2013 How much to scale the label by. Returns : The MathTex of the label. Return type : MathTex label_vector ( vector , label , animate = True , ** kwargs ) [source]   Shortcut method for creating, and animating the addition of\na label for the vector. Parameters : vector ( Vector ) \u2013 The vector for which the label must be added. label ( MathTex | str ) \u2013 The MathTex/string of the label. animate ( bool ) \u2013 Whether or not to animate the labelling w/ Write **kwargs \u2013 Any valid keyword argument of get_vector_label Returns : The MathTex of the label. Return type : MathTex lock_in_faded_grid ( dimness = 0.7 , axes_dimness = 0.5 ) [source]   This method freezes the NumberPlane and Axes that were already\nin the background, and adds new, manipulatable ones to the foreground. Parameters : dimness ( float ) \u2013 The required dimness of the NumberPlane axes_dimness ( float ) \u2013 The required dimness of the Axes. show_ghost_movement ( vector ) [source]   This method plays an animation that partially shows the entire plane moving\nin the direction of a particular vector. This is useful when you wish to\nconvey the idea of mentally moving the entire plane in a direction, without\nactually moving the plane. Parameters : vector ( Arrow | list | tuple | ndarray ) \u2013 The vector which indicates the direction of movement. vector_to_coords ( vector , integer_labels = True , clean_up = True ) [source]   This method displays vector as a Vector() based vector, and then shows\nthe corresponding lines that make up the x and y components of the vector.\nThen, a column matrix (henceforth called the label) is created near the\nhead of the Vector. Parameters : vector ( ndarray | list | tuple ) \u2013 The vector to show. integer_labels ( bool ) \u2013 Whether or not to round the value displayed.\nin the vector\u2019s label to the nearest integer clean_up ( bool ) \u2013 Whether or not to remove whatever\nthis method did after it\u2019s done. write_vector_coordinates ( vector , ** kwargs ) [source]   Returns a column matrix indicating the vector coordinates,\nafter writing them to the screen. Parameters : vector ( Arrow ) \u2013 The arrow representing the vector. **kwargs \u2013 Any valid keyword arguments of coordinate_label() : Returns : The column matrix representing the vector. Return type : Matrix", "source": "https://docs.manim.community/en/stable/reference/manim.scene.vector_space_scene.VectorScene.html"}
{"prompt": "class ZoomedScene(camera_class=<class 'manim.camera.multi_camera.MultiCamera'>, zoomed_display_height=3, zoomed_display_width=3, zoomed_display_center=None, zoomed_display_corner=array(", "response": "Bases: MovingCameraScene This is a Scene with special configurations made for when\na particular part of the scene must be zoomed in on and displayed\nseparately. Methods activate_zooming This method is used to activate the zooming for the zoomed_camera. get_zoom_factor Returns the Zoom factor of the Zoomed camera. get_zoom_in_animation Returns the animation of camera zooming in. get_zoomed_display_pop_out_animation This is the animation of the popping out of the mini-display that shows the content of the zoomed camera. setup This method is used internally by Manim to setup the scene for proper use. Attributes camera time The time since the start of the scene. activate_zooming ( animate = False ) [source]   This method is used to activate the zooming for\nthe zoomed_camera. Parameters : animate ( bool ) \u2013 Whether or not to animate the activation\nof the zoomed camera. get_zoom_factor ( ) [source]   Returns the Zoom factor of the Zoomed camera.\nDefined as the ratio between the height of the\nzoomed camera and the height of the zoomed mini\ndisplay.\n:returns: The zoom factor.\n:rtype: float get_zoom_in_animation ( run_time = 2 , ** kwargs ) [source]   Returns the animation of camera zooming in. Parameters : run_time ( float ) \u2013 The run_time of the animation of the camera zooming in. **kwargs \u2013 Any valid keyword arguments of ApplyMethod() Returns : The animation of the camera zooming in. Return type : ApplyMethod get_zoomed_display_pop_out_animation ( ** kwargs ) [source]   This is the animation of the popping out of the\nmini-display that shows the content of the zoomed\ncamera. Returns : The Animation of the Zoomed Display popping out. Return type : ApplyMethod setup ( ) [source]   This method is used internally by Manim to\nsetup the scene for proper use.", "source": "https://docs.manim.community/en/stable/reference/manim.scene.zoomed_scene.ZoomedScene.html"}
{"prompt": "bezier(points: BezierPointsLike) \u2192 Callable", "response": "Classic implementation of a B\u00e9zier curve. Parameters : points \u2013 \\((d+1, 3)\\) -shaped array of \\(d+1\\) control points defining a single B\u00e9zier\ncurve of degree \\(d\\) . Alternatively, for vectorization purposes, points can\nalso be a \\((d+1, M, 3)\\) -shaped sequence of \\(d+1\\) arrays of \\(M\\) control points each, which define M B\u00e9zier curves instead. Returns : bezier_func \u2013 Function describing the B\u00e9zier curve. The behaviour of this function depends on\nthe shape of points : If points was a \\((d+1, 3)\\) array representing a single B\u00e9zier curve,\nthen bezier_func can receive either: a float t , in which case it returns a\nsingle \\((1, 3)\\) -shaped Point3D representing the evaluation\nof the B\u00e9zier at t , or an \\((n, 1)\\) -shaped ColVector containing \\(n\\) values to evaluate the B\u00e9zier curve at, returning instead\nan \\((n, 3)\\) -shaped Point3D_Array containing the points\nresulting from evaluating the B\u00e9zier at each of the \\(n\\) values. Warning If passing a vector of \\(t\\) -values to bezier_func , it must be a column vector/matrix of shape \\((n, 1)\\) . Passing an 1D array of\nshape \\((n,)\\) is not supported and will result in undefined behaviour . If points was a \\((d+1, M, 3)\\) array describing \\(M\\) B\u00e9zier curves,\nthen bezier_func can receive either: a float t , in which case it returns an \\((M, 3)\\) -shaped Point3D_Array representing the evaluation\nof the \\(M\\) B\u00e9zier curves at the same value t , or an \\((M, 1)\\) -shaped ColVector containing \\(M\\) values, such that the \\(i\\) -th\nB\u00e9zier curve defined by points is evaluated at the corresponding \\(i\\) -th\nvalue in t , returning again an \\((M, 3)\\) -shaped Point3D_Array containing those \\(M\\) evaluations. Warning Unlike the previous case, if you pass a ColVector to bezier_func ,\nit must contain exactly \\(M\\) values, each value for each of the \\(M\\) B\u00e9zier curves defined by points . Any array of shape other than \\((M, 1)\\) will result in undefined behaviour . Return type : typing.Callable [[ float | ColVector ], Point3D | Point3D_Array ]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.bezier.html"}
{"prompt": "bezier_remap(bezier_tuples, new_number_of_curves)", "response": "Subdivides each curve in bezier_tuples into as many parts as necessary, until the final number of\ncurves reaches a desired amount, new_number_of_curves . Parameters : bezier_tuples ( BezierPointsLike_Array ) \u2013 An array of multiple B\u00e9zier curves of degree \\(d\\) to be remapped. The shape of this array\nmust be (current_number_of_curves, nppc, dim) , where: current_number_of_curves is the current amount of curves in the array bezier_tuples , nppc is the amount of points per curve, such that their degree is nppc-1 , and dim is the dimension of the points, usually \\(3\\) . new_number_of_curves ( int ) \u2013 The number of curves that the output will contain. This needs to be higher than the current number. Returns : The new array of shape (new_number_of_curves, nppc, dim) ,\ncontaining the new B\u00e9zier curves after the remap. Return type : BezierPoints_Array", "source": "https://docs.manim.community/en/stable/reference/manim.utils.bezier.html"}
{"prompt": "get_quadratic_approximation_of_cubic(a0: Point3DLike, h0: Point3DLike, h1: Point3DLike, a1: Point3DLike) \u2192 QuadraticSpline", "response": "If a0 , h0 , h1 and a1 are the control points of a cubic\nB\u00e9zier curve, approximate the curve with two quadratic B\u00e9zier curves and\nreturn an array of 6 points, where the first 3 points represent the first\nquadratic curve and the last 3 represent the second one. Otherwise, if a0 , h0 , h1 and a1 are _arrays_ of \\(N\\) points representing \\(N\\) cubic B\u00e9zier curves, return an array of \\(6N\\) points where each group of \\(6\\) consecutive points\napproximates each of the \\(N\\) curves in a similar way as above. Note If the cubic spline given by the original cubic B\u00e9zier curves is\nsmooth, this algorithm will generate a quadratic spline which is also\nsmooth. If a cubic B\u00e9zier is given by \\[C(t) = (1-t)^3 A_0 + 3(1-t)^2 t H_0 + 3(1-t)t^2 H_1 + t^3 A_1\\] where \\(A_0\\) , \\(H_0\\) , \\(H_1\\) and \\(A_1\\) are its\ncontrol points, then this algorithm should generate two quadratic\nB\u00e9ziers given by \\[\\begin{split}Q_0(t) &= (1-t)^2 A_0 + 2(1-t)t M_0 + t^2 K \\\\\nQ_1(t) &= (1-t)^2 K + 2(1-t)t M_1 + t^2 A_1\\end{split}\\] where \\(M_0\\) and \\(M_1\\) are the respective handles to be\nfound for both curves, and \\(K\\) is the end anchor of the 1st curve\nand the start anchor of the 2nd, which must also be found. To solve for \\(M_0\\) , \\(M_1\\) and \\(K\\) , three conditions\ncan be imposed: \\(Q_0'(0) = \\frac{1}{2}C'(0)\\) . The derivative of the first\nquadratic curve at \\(t = 0\\) should be proportional to that of\nthe original cubic curve, also at \\(t = 0\\) . Because the cubic\ncurve is split into two parts, it is necessary to divide this by\ntwo: the speed of a point travelling through the curve should be\nhalf of the original. This gives: \\[\\begin{split}Q_0'(0) &= \\frac{1}{2}C'(0) \\\\\n2(M_0 - A_0) &= \\frac{3}{2}(H_0 - A_0) \\\\\n2M_0 - 2A_0 &= \\frac{3}{2}H_0 - \\frac{3}{2}A_0 \\\\\n2M_0 &= \\frac{3}{2}H_0 + \\frac{1}{2}A_0 \\\\\nM_0 &= \\frac{1}{4}(3H_0 + A_0)\\end{split}\\] \\(Q_1'(1) = \\frac{1}{2}C'(1)\\) . The derivative of the second\nquadratic curve at \\(t = 1\\) should be half of that of the\noriginal cubic curve for the same reasons as above, also at \\(t = 1\\) . This gives: \\[\\begin{split}Q_1'(1) &= \\frac{1}{2}C'(1) \\\\\n2(A_1 - M_1) &= \\frac{3}{2}(A_1 - H_1) \\\\\n2A_1 - 2M_1 &= \\frac{3}{2}A_1 - \\frac{3}{2}H_1 \\\\\n-2M_1 &= -\\frac{1}{2}A_1 - \\frac{3}{2}H_1 \\\\\nM_1 &= \\frac{1}{4}(3H_1 + A_1)\\end{split}\\] \\(Q_0'(1) = Q_1'(0)\\) . The derivatives of both quadratic curves\nshould match at the point \\(K\\) , in order for the final spline\nto be smooth. This gives: \\[\\begin{split}Q_0'(1) &= Q_1'(0) \\\\\n2(K - M_0) &= 2(M_1 - K) \\\\\n2K - 2M_0 &= 2M_1 - 2K \\\\\n4K &= 2M_0 + 2M_1 \\\\\nK &= \\frac{1}{2}(M_0 + M_1)\\end{split}\\] This is sufficient to find proper control points for the quadratic\nB\u00e9zier curves. Parameters : a0 \u2013 The start anchor of a single cubic B\u00e9zier curve, or an array of \\(N\\) start anchors for \\(N\\) curves. h0 \u2013 The first handle of a single cubic B\u00e9zier curve, or an array of \\(N\\) first handles for \\(N\\) curves. h1 \u2013 The second handle of a single cubic B\u00e9zier curve, or an array of \\(N\\) second handles for \\(N\\) curves. a1 \u2013 The end anchor of a single cubic B\u00e9zier curve, or an array of \\(N\\) end anchors for \\(N\\) curves. Returns : An array containing either 6 points for 2 quadratic B\u00e9zier curves\napproximating the original cubic curve, or \\(6N\\) points for \\(2N\\) quadratic curves approximating \\(N\\) cubic curves. Return type : result Raises : ValueError \u2013 If a0 , h0 , h1 and a1 have different dimensions, or\n    if their number of dimensions is not 1 or 2.", "source": "https://docs.manim.community/en/stable/reference/manim.utils.bezier.html"}
{"prompt": "get_smooth_closed_cubic_bezier_handle_points(anchors)", "response": "Special case of get_smooth_cubic_bezier_handle_points() ,\nwhen the anchors form a closed loop. Note A system of equations must be solved to get the first handles of\nevery B\u00e9zier curve (referred to as \\(H_1\\) ).\nThen \\(H_2\\) (the second handles) can be obtained separately. See also The equations were obtained from: Conditions on control points for continuous curvature. (2016). Jaco Stuifbergen. In general, if there are \\(N+1\\) anchors, there will be \\(N\\) B\u00e9zier curves\nand thus \\(N\\) pairs of handles to find. We must solve the following\nsystem of equations for the 1st handles (example for \\(N = 5\\) ): \\[\\begin{split}\\begin{pmatrix}\n    4 & 1 & 0 & 0 & 1 \\\\\n    1 & 4 & 1 & 0 & 0 \\\\\n    0 & 1 & 4 & 1 & 0 \\\\\n    0 & 0 & 1 & 4 & 1 \\\\\n    1 & 0 & 0 & 1 & 4\n\\end{pmatrix}\n\\begin{pmatrix}\n    H_{1,0} \\\\\n    H_{1,1} \\\\\n    H_{1,2} \\\\\n    H_{1,3} \\\\\n    H_{1,4}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n    4A_0 + 2A_1 \\\\\n    4A_1 + 2A_2 \\\\\n    4A_2 + 2A_3 \\\\\n    4A_3 + 2A_4 \\\\\n    4A_4 + 2A_5\n\\end{pmatrix}\\end{split}\\] which will be expressed as \\(RH_1 = D\\) . \\(R\\) is almost a tridiagonal matrix, so we could use Thomas\u2019 algorithm. See also Tridiagonal matrix algorithm. Wikipedia. However, \\(R\\) has ones at the opposite corners. A solution to this is\nthe first decomposition proposed in the link below, with \\(\\alpha = 1\\) : See also Tridiagonal matrix algorithm # Variants. Wikipedia. \\[\\begin{split}R\n=\n\\begin{pmatrix}\n    4 & 1 & 0 & 0 & 1 \\\\\n    1 & 4 & 1 & 0 & 0 \\\\\n    0 & 1 & 4 & 1 & 0 \\\\\n    0 & 0 & 1 & 4 & 1 \\\\\n    1 & 0 & 0 & 1 & 4\n\\end{pmatrix}\n&=\n\\begin{pmatrix}\n    3 & 1 & 0 & 0 & 0 \\\\\n    1 & 4 & 1 & 0 & 0 \\\\\n    0 & 1 & 4 & 1 & 0 \\\\\n    0 & 0 & 1 & 4 & 1 \\\\\n    0 & 0 & 0 & 1 & 3\n\\end{pmatrix}\n+\n\\begin{pmatrix}\n    1 & 0 & 0 & 0 & 1 \\\\\n    0 & 0 & 0 & 0 & 0 \\\\\n    0 & 0 & 0 & 0 & 0 \\\\\n    0 & 0 & 0 & 0 & 0 \\\\\n    1 & 0 & 0 & 0 & 1\n\\end{pmatrix}\n\\\\\n&\n\\\\\n&=\n\\begin{pmatrix}\n    3 & 1 & 0 & 0 & 0 \\\\\n    1 & 4 & 1 & 0 & 0 \\\\\n    0 & 1 & 4 & 1 & 0 \\\\\n    0 & 0 & 1 & 4 & 1 \\\\\n    0 & 0 & 0 & 1 & 3\n\\end{pmatrix}\n+\n\\begin{pmatrix}\n    1 \\\\\n    0 \\\\\n    0 \\\\\n    0 \\\\\n    1\n\\end{pmatrix}\n\\begin{pmatrix}\n    1 & 0 & 0 & 0 & 1\n\\end{pmatrix}\n\\\\\n&\n\\\\\n&=\nT + uv^t\\end{split}\\] We decompose \\(R = T + uv^t\\) , where \\(T\\) is a tridiagonal matrix, and \\(u, v\\) are \\(N\\) -D vectors such that \\(u_0 = u_{N-1} = v_0 = v_{N-1} = 1\\) ,\nand \\(u_i = v_i = 0, \\forall i \\in \\{1, ..., N-2\\}\\) . Thus: \\[\\begin{split}RH_1 &= D \\\\\n\\Rightarrow (T + uv^t)H_1 &= D\\end{split}\\] If we find a vector \\(q\\) such that \\(Tq = u\\) : \\[\\begin{split}\\Rightarrow (T + Tqv^t)H_1 &= D \\\\\n\\Rightarrow T(I + qv^t)H_1 &= D \\\\\n\\Rightarrow H_1 &= (I + qv^t)^{-1} T^{-1} D\\end{split}\\] According to Sherman-Morrison\u2019s formula: See also Sherman-Morrison\u2019s formula. Wikipedia. \\[(I + qv^t)^{-1} = I - \\frac{1}{1 + v^tq} qv^t\\] If we find \\(Y = T^{-1} D\\) , or in other words, if we solve for \\(Y\\) in \\(TY = D\\) : \\[\\begin{split}H_1 &= (I + qv^t)^{-1} T^{-1} D \\\\\n&= (I + qv^t)^{-1} Y \\\\\n&= (I - \\frac{1}{1 + v^tq} qv^t) Y \\\\\n&= Y - \\frac{1}{1 + v^tq} qv^tY\\end{split}\\] Therefore, we must solve for \\(q\\) and \\(Y\\) in \\(Tq = u\\) and \\(TY = D\\) .\nAs \\(T\\) is now tridiagonal, we shall use Thomas\u2019 algorithm. Define: \\(a = [a_0, \\ a_1, \\ ..., \\ a_{N-2}]\\) as \\(T\\) \u2019s lower diagonal of \\(N-1\\) elements,\nsuch that \\(a_0 = a_1 = ... = a_{N-2} = 1\\) , so this diagonal is filled with ones; \\(b = [b_0, \\ b_1, \\ ..., \\ b_{N-2}, \\ b_{N-1}]\\) as \\(T\\) \u2019s main diagonal of \\(N\\) elements,\nsuch that \\(b_0 = b_{N-1} = 3\\) , and \\(b_1 = b_2 = ... = b_{N-2} = 4\\) ; \\(c = [c_0, \\ c_1, \\ ..., \\ c_{N-2}]\\) as \\(T\\) \u2019s upper diagonal of \\(N-1\\) elements,\nsuch that \\(c_0 = c_1 = ... = c_{N-2} = 1\\) : this diagonal is also filled with ones. If, according to Thomas\u2019 algorithm, we define: \\[\\begin{split}c'_0 &= \\frac{c_0}{b_0} & \\\\\nc'_i &= \\frac{c_i}{b_i - a_{i-1} c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n& & \\\\\nu'_0 &= \\frac{u_0}{b_0} & \\\\\nu'_i &= \\frac{u_i - a_{i-1} u'_{i-1}}{b_i - a_{i-1} c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-1\\} \\\\\n& & \\\\\nD'_0 &= \\frac{1}{b_0} D_0 & \\\\\nD'_i &= \\frac{1}{b_i - a_{i-1} c'_{i-1}} (D_i - a_{i-1} D'_{i-1}), & \\quad \\forall i \\in \\{1, ..., N-1\\}\\end{split}\\] Then: \\[\\begin{split}c'_0     &= \\frac{1}{3} & \\\\\nc'_i     &= \\frac{1}{4 - c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n& & \\\\\nu'_0     &= \\frac{1}{3} & \\\\\nu'_i     &= \\frac{-u'_{i-1}}{4 - c'_{i-1}} = -c'_i u'_{i-1}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\nu'_{N-1} &= \\frac{1 - u'_{N-2}}{3 - c'_{N-2}} & \\\\\n& & \\\\\nD'_0     &= \\frac{1}{3} (4A_0 + 2A_1) & \\\\\nD'_i     &= \\frac{1}{4 - c'_{i-1}} (4A_i + 2A_{i+1} - D'_{i-1}) & \\\\\n&= c_i (4A_i + 2A_{i+1} - D'_{i-1}), & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\nD'_{N-1} &= \\frac{1}{3 - c'_{N-2}} (4A_{N-1} + 2A_N - D'_{N-2}) &\\end{split}\\] Finally, we can do Backward Substitution to find \\(q\\) and \\(Y\\) : \\[\\begin{split}q_{N-1} &= u'_{N-1} & \\\\\nq_i     &= u'_{i} - c'_i q_{i+1}, & \\quad \\forall i \\in \\{0, ..., N-2\\} \\\\\n& & \\\\\nY_{N-1} &= D'_{N-1} & \\\\\nY_i     &= D'_i - c'_i Y_{i+1},   & \\quad \\forall i \\in \\{0, ..., N-2\\}\\end{split}\\] With those values, we can finally calculate \\(H_1 = Y - \\frac{1}{1 + v^tq} qv^tY\\) .\nGiven that \\(v_0 = v_{N-1} = 1\\) , and \\(v_1 = v_2 = ... = v_{N-2} = 0\\) , its dot products\nwith \\(q\\) and \\(Y\\) are respectively \\(v^tq = q_0 + q_{N-1}\\) and \\(v^tY = Y_0 + Y_{N-1}\\) . Thus: \\[H_1 = Y - \\frac{1}{1 + q_0 + q_{N-1}} q(Y_0 + Y_{N-1})\\] Once we have \\(H_1\\) , we can get \\(H_2\\) (the array of second handles) as follows: \\[\\begin{split}H_{2, i}   &= 2A_{i+1} - H_{1, i+1}, & \\quad \\forall i \\in \\{0, ..., N-2\\} \\\\\nH_{2, N-1} &= 2A_0 - H_{1, 0} &\\end{split}\\] Because the matrix \\(R\\) always follows the same pattern (and thus \\(T, u, v\\) as well),\nwe can define a memo list for \\(c'\\) and \\(u'\\) to avoid recalculation. We cannot\nmemoize \\(D\\) and \\(Y\\) , however, because they are always different matrices. We\ncannot make a memo for \\(q\\) either, but we can calculate it faster because \\(u'\\) can be memoized. Parameters : anchors ( Point3DLike_Array ) \u2013 Anchors of a closed cubic spline. Returns : A tuple of two arrays: one containing the 1st handle for every curve in\nthe closed cubic spline, and the other containing the 2nd handles. Return type : tuple [ Point3D_Array , Point3D_Array ]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.bezier.html"}
{"prompt": "get_smooth_cubic_bezier_handle_points(anchors)", "response": "Given an array of anchors for a cubic spline (array of connected cubic\nB\u00e9zier curves), compute the 1st and 2nd handle for every curve, so that\nthe resulting spline is smooth. Parameters : anchors ( Point3DLike_Array ) \u2013 Anchors of a cubic spline. Returns : A tuple of two arrays: one containing the 1st handle for every curve in\nthe cubic spline, and the other containing the 2nd handles. Return type : tuple [ Point3D_Array , Point3D_Array ]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.bezier.html"}
{"prompt": "get_smooth_open_cubic_bezier_handle_points(anchors)", "response": "Special case of get_smooth_cubic_bezier_handle_points() ,\nwhen the anchors do not form a closed loop. Note A system of equations must be solved to get the first handles of\nevery B\u00e8zier curve (referred to as \\(H_1\\) ).\nThen \\(H_2\\) (the second handles) can be obtained separately. See also The equations were obtained from: Smooth B\u00e9zier Spline Through Prescribed Points. (2012). Particle in Cell Consulting LLC. Conditions on control points for continuous curvature. (2016). Jaco Stuifbergen. Warning The equations in the first webpage have some typos which were corrected in the comments. In general, if there are \\(N+1\\) anchors, there will be \\(N\\) B\u00e9zier curves\nand thus \\(N\\) pairs of handles to find. We must solve the following\nsystem of equations for the 1st handles (example for \\(N = 5\\) ): \\[\\begin{split}\\begin{pmatrix}\n    2 & 1 & 0 & 0 & 0 \\\\\n    1 & 4 & 1 & 0 & 0 \\\\\n    0 & 1 & 4 & 1 & 0 \\\\\n    0 & 0 & 1 & 4 & 1 \\\\\n    0 & 0 & 0 & 2 & 7\n\\end{pmatrix}\n\\begin{pmatrix}\n    H_{1,0} \\\\\n    H_{1,1} \\\\\n    H_{1,2} \\\\\n    H_{1,3} \\\\\n    H_{1,4}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n    A_0 + 2A_1 \\\\\n    4A_1 + 2A_2 \\\\\n    4A_2 + 2A_3 \\\\\n    4A_3 + 2A_4 \\\\\n    8A_4 + A_5\n\\end{pmatrix}\\end{split}\\] which will be expressed as \\(TH_1 = D\\) . \\(T\\) is a tridiagonal matrix, so the system can be solved in \\(O(N)\\) operations. Here we shall use Thomas\u2019 algorithm or the tridiagonal matrix\nalgorithm. See also Tridiagonal matrix algorithm. Wikipedia. Define: \\(a = [a_0, \\ a_1, \\ ..., \\ a_{N-2}]\\) as \\(T\\) \u2019s lower diagonal of \\(N-1\\) elements,\nsuch that \\(a_0 = a_1 = ... = a_{N-3} = 1\\) , and \\(a_{N-2} = 2\\) ; \\(b = [b_0, \\ b_1, \\ ..., \\ b_{N-2}, \\ b_{N-1}]\\) as \\(T\\) \u2019s main diagonal of \\(N\\) elements,\nsuch that \\(b_0 = 2\\) , \\(b_1 = b_2 = ... = b_{N-2} = 4\\) , and \\(b_{N-1} = 7\\) ; \\(c = [c_0, \\ c_1, \\ ..., \\ c_{N-2}]\\) as \\(T\\) \u2019s upper diagonal of \\({N-1}\\) elements,\nsuch that \\(c_0 = c_1 = ... = c_{N-2} = 1\\) : this diagonal is filled with ones. If, according to Thomas\u2019 algorithm, we define: \\[\\begin{split}c'_0 &= \\frac{c_0}{b_0} & \\\\\nc'_i &= \\frac{c_i}{b_i - a_{i-1} c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n& & \\\\\nD'_0 &= \\frac{1}{b_0} D_0 & \\\\\nD'_i &= \\frac{1}{b_i - a_{i-1} c'{i-1}} (D_i - a_{i-1} D'_{i-1}), & \\quad \\forall i \\in \\{1, ..., N-1\\}\\end{split}\\] Then: \\[\\begin{split}c'_0     &= 0.5 & \\\\\nc'_i     &= \\frac{1}{4 - c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n& & \\\\\nD'_0     &= 0.5A_0 + A_1 & \\\\\nD'_i     &= \\frac{1}{4 - c'_{i-1}} (4A_i + 2A_{i+1} - D'_{i-1}) & \\\\\n&= c_i (4A_i + 2A_{i+1} - D'_{i-1}), & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\nD'_{N-1} &= \\frac{1}{7 - 2c'_{N-2}} (8A_{N-1} + A_N - 2D'_{N-2}) &\\end{split}\\] Finally, we can do Backward Substitution to find \\(H_1\\) : \\[\\begin{split}H_{1, N-1} &= D'_{N-1} & \\\\\nH_{1, i}   &= D'_i - c'_i H_{1, i+1}, & \\quad \\forall i \\in \\{0, ..., N-2\\}\\end{split}\\] Once we have \\(H_1\\) , we can get \\(H_2\\) (the array of second handles) as follows: \\[\\begin{split}H_{2, i}   &= 2A_{i+1} - H_{1, i+1}, & \\quad \\forall i \\in \\{0, ..., N-2\\} \\\\\nH_{2, N-1} &= 0.5A_N   + 0.5H_{1, N-1} &\\end{split}\\] As the matrix \\(T\\) always follows the same pattern, we can define a memo list\nfor \\(c'\\) to avoid recalculation. We cannot do the same for \\(D\\) , however,\nbecause it is always a different matrix. Parameters : anchors ( Point3DLike_Array ) \u2013 Anchors of an open cubic spline. Returns : A tuple of two arrays: one containing the 1st handle for every curve in\nthe open cubic spline, and the other containing the 2nd handles. Return type : tuple [ Point3D_Array , Point3D_Array ]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.bezier.html"}
{"prompt": "integer_interpolate(start, end, alpha)", "response": "This is a variant of interpolate that returns an integer and the residual Parameters : start ( float ) \u2013 The start of the range end ( float ) \u2013 The end of the range alpha ( float ) \u2013 a float between 0 and 1. Returns : This returns an integer between start and end (inclusive) representing\nappropriate interpolation between them, along with a\n\u201cresidue\u201d representing a new proportion between the\nreturned integer and the next one of the\nlist. Return type : tuple[int, float] Example >>> integer , residue = integer_interpolate ( start = 0 , end = 10 , alpha = 0.46 ) >>> np . allclose (( integer , residue ), ( 4 , 0.6 )) True", "source": "https://docs.manim.community/en/stable/reference/manim.utils.bezier.html"}
{"prompt": "interpolate(start: float, end: float, alpha: float) \u2192 float", "response": "Linearly interpolates between two values start and end . Parameters : start \u2013 The start of the range. end \u2013 The end of the range. alpha \u2013 A float between 0 and 1, or an \\((n, 1)\\) column vector containing \\(n\\) floats between 0 and 1 to interpolate in a vectorized fashion. Returns : The result of the linear interpolation. If start and end are of type float , and: alpha is also a float , the return is simply another float . alpha is a ColVector , the return is another ColVector . If start and end are of type Point3D , and: alpha is a float , the return is another Point3D . alpha is a ColVector , the return is a Point3D_Array . Return type : float | ColVector | Point3D | Point3D_Array", "source": "https://docs.manim.community/en/stable/reference/manim.utils.bezier.html"}
{"prompt": "inverse_interpolate(start: float, end: float, value: float) \u2192 float", "response": "Perform inverse interpolation to determine the alpha\nvalues that would produce the specified value given the start and end values or points. Parameters : start \u2013 The start value or point of the interpolation. end \u2013 The end value or point of the interpolation. value \u2013 The value or point for which the alpha value\nshould be determined. Returns : The alpha values producing the given input when interpolating between start and end . Example >>> inverse_interpolate ( start = 2 , end = 6 , value = 4 ) np.float64(0.5) >>> start = np . array ([ 1 , 2 , 1 ]) >>> end = np . array ([ 7 , 8 , 11 ]) >>> value = np . array ([ 4 , 5 , 5 ]) >>> inverse_interpolate ( start , end , value ) array([0.5, 0.5, 0.4])", "source": "https://docs.manim.community/en/stable/reference/manim.utils.bezier.html"}
{"prompt": "is_closed(points)", "response": "Returns True if the spline given by points is closed, by\nchecking if its first and last points are close to each other, or``False``\notherwise. Note This function reimplements np.allclose() , because repeated\ncalling of np.allclose() for only 2 points is inefficient. Parameters : points ( Point3D_Array ) \u2013 An array of points defining a spline. Returns : Whether the first and last points of the array are close enough or not\nto be considered the same, thus considering the defined spline as\nclosed. Return type : bool Examples >>> import numpy as np >>> from manim import is_closed >>> is_closed ( ... np . array ( ... [ ... [ 0 , 0 , 0 ], ... [ 1 , 2 , 3 ], ... [ 3 , 2 , 1 ], ... [ 0 , 0 , 0 ], ... ] ... ) ... ) True >>> is_closed ( ... np . array ( ... [ ... [ 0 , 0 , 0 ], ... [ 1 , 2 , 3 ], ... [ 3 , 2 , 1 ], ... [ 1e-10 , 1e-10 , 1e-10 ], ... ] ... ) ... ) True >>> is_closed ( ... np . array ( ... [ ... [ 0 , 0 , 0 ], ... [ 1 , 2 , 3 ], ... [ 3 , 2 , 1 ], ... [ 1e-2 , 1e-2 , 1e-2 ], ... ] ... ) ... ) False", "source": "https://docs.manim.community/en/stable/reference/manim.utils.bezier.html"}
{"prompt": "match_interpolate(new_start: float, new_end: float, old_start: float, old_end: float, old_value: float) \u2192 float", "response": "Interpolate a value from an old range to a new range. Parameters : new_start \u2013 The start of the new range. new_end \u2013 The end of the new range. old_start \u2013 The start of the old range. old_end \u2013 The end of the old range. old_value \u2013 The value within the old range whose corresponding\nvalue in the new range (with the same alpha value)\nis desired. Return type : The interpolated value within the new range. Examples >>> match_interpolate ( 0 , 100 , 10 , 20 , 15 ) np.float64(50.0)", "source": "https://docs.manim.community/en/stable/reference/manim.utils.bezier.html"}
{"prompt": "mid(start: float, end: float) \u2192 float", "response": "Returns the midpoint between two values. Parameters : start \u2013 The first value end \u2013 The second value Return type : The midpoint between the two values", "source": "https://docs.manim.community/en/stable/reference/manim.utils.bezier.html"}
{"prompt": "partial_bezier_points(points, a, b)", "response": "Given an array of points which define a B\u00e9zier curve, and two numbers \\(a, b\\) such that \\(0 \\le a < b \\le 1\\) , return an array of the same size, which describes the\nportion of the original B\u00e9zier curve on the interval \\([a, b]\\) . partial_bezier_points() is conceptually equivalent to calling split_bezier() twice and discarding unused B\u00e9zier curves, but this is more efficient and doesn\u2019t waste\ncomputations. See also See split_bezier() for an explanation on how to split B\u00e9zier curves. Note To find the portion of a B\u00e9zier curve with \\(t\\) between \\(a\\) and \\(b\\) : Split the curve at \\(t = a\\) and extract its 2nd subcurve. We cannot evaluate the new subcurve at \\(t = b\\) because its range of values for \\(t\\) is different.\nTo find the correct value, we need to transform the interval \\([a, 1]\\) into \\([0, 1]\\) by first subtracting \\(a\\) to get \\([0, 1-a]\\) and then dividing by \\(1-a\\) . Thus, our new\nvalue must be \\(t = \\frac{b - a}{1 - a}\\) . Define \\(u = \\frac{b - a}{1 - a}\\) . Split the subcurve at \\(t = u\\) and extract its 1st subcurve. The final portion is a linear combination of points, and thus the process can be\nsummarized as a linear transformation by some matrix in terms of \\(a\\) and \\(b\\) .\nThis matrix is given explicitly for B\u00e9zier curves up to degree 3, which are often used in Manim.\nFor higher degrees, the algorithm described previously is used. For the case of a quadratic B\u00e9zier curve: Step 1: \\[\\begin{split}H'_1\n=\n\\begin{pmatrix}\n    (1-a)^2 & 2(1-a)a & a^2 \\\\\n    0 & (1-a) & a \\\\\n    0 & 0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n    p_0 \\\\\n    p_1 \\\\\n    p_2\n\\end{pmatrix}\\end{split}\\] Step 2: \\[\\begin{split}H''_0\n&=\n\\begin{pmatrix}\n    1 & 0 & 0 \\\\\n    (1-u) & u & 0\\\\\n    (1-u)^2 & 2(1-u)u & u^2\n\\end{pmatrix}\nH'_1\n\\\\\n&\n\\\\\n&=\n\\begin{pmatrix}\n    1 & 0 & 0 \\\\\n    (1-u) & u & 0\\\\\n    (1-u)^2 & 2(1-u)u & u^2\n\\end{pmatrix}\n\\begin{pmatrix}\n    (1-a)^2 & 2(1-a)a & a^2 \\\\\n    0 & (1-a) & a \\\\\n    0 & 0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n    p_0 \\\\\n    p_1 \\\\\n    p_2\n\\end{pmatrix}\n\\\\\n&\n\\\\\n&=\n\\begin{pmatrix}\n    (1-a)^2 & 2(1-a)a & a^2 \\\\\n    (1-a)(1-b) & a(1-b) + (1-a)b & ab \\\\\n    (1-b)^2 & 2(1-b)b & b^2\n\\end{pmatrix}\n\\begin{pmatrix}\n    p_0 \\\\\n    p_1 \\\\\n    p_2\n\\end{pmatrix}\\end{split}\\] from where one can define a \\((3, 3)\\) matrix \\(P_2\\) which, when applied over\nthe array of points , will return the desired partial quadratic B\u00e9zier curve: \\[\\begin{split}P_2\n=\n\\begin{pmatrix}\n    (1-a)^2 & 2(1-a)a & a^2 \\\\\n    (1-a)(1-b) & a(1-b) + (1-a)b & ab \\\\\n    (1-b)^2 & 2(1-b)b & b^2\n\\end{pmatrix}\\end{split}\\] Similarly, for the cubic B\u00e9zier curve case, one can define the following \\((4, 4)\\) matrix \\(P_3\\) : \\[\\begin{split}P_3\n=\n\\begin{pmatrix}\n    (1-a)^3 & 3(1-a)^2a & 3(1-a)a^2 & a^3 \\\\\n    (1-a)^2(1-b) & 2(1-a)a(1-b) + (1-a)^2b & a^2(1-b) + 2(1-a)ab & a^2b \\\\\n    (1-a)(1-b)^2 & a(1-b)^2 + 2(1-a)(1-b)b & 2a(1-b)b + (1-a)b^2 & ab^2 \\\\\n    (1-b)^3 & 3(1-b)^2b & 3(1-b)b^2 & b^3\n\\end{pmatrix}\\end{split}\\] Parameters : points ( BezierPointsLike ) \u2013 set of points defining the bezier curve. a ( float ) \u2013 lower bound of the desired partial bezier curve. b ( float ) \u2013 upper bound of the desired partial bezier curve. Returns : An array containing the control points defining the partial B\u00e9zier curve. Return type : BezierPoints", "source": "https://docs.manim.community/en/stable/reference/manim.utils.bezier.html"}
{"prompt": "point_lies_on_bezier(point, control_points, round_to=1e-06)", "response": "Checks if a given point lies on the bezier curves with the given control points. This is done by solving the bezier polynomial with the point as the constant term; if\nany real roots exist, the point lies on the bezier curve. Parameters : point ( Point3DLike ) \u2013 The Cartesian Coordinates of the point to check. control_points ( BezierPointsLike ) \u2013 The Cartesian Coordinates of the ordered control\npoints of the bezier curve on which the point may\nor may not lie. round_to ( float ) \u2013 A float whose number of decimal places all values\nsuch as coordinates of points will be rounded. Returns : Whether the point lies on the curve. Return type : bool", "source": "https://docs.manim.community/en/stable/reference/manim.utils.bezier.html"}
{"prompt": "proportions_along_bezier_curve_for_point(point, control_points, round_to=1e-06)", "response": "Obtains the proportion along the bezier curve corresponding to a given point\ngiven the bezier curve\u2019s control points. The bezier polynomial is constructed using the coordinates of the given point\nas well as the bezier curve\u2019s control points. On solving the polynomial for each dimension,\nif there are roots common to every dimension, those roots give the proportion along the\ncurve the point is at. If there are no real roots, the point does not lie on the curve. Parameters : point ( Point3DLike ) \u2013 The Cartesian Coordinates of the point whose parameter\nshould be obtained. control_points ( BezierPointsLike ) \u2013 The Cartesian Coordinates of the ordered control\npoints of the bezier curve on which the point may\nor may not lie. round_to ( float ) \u2013 A float whose number of decimal places all values\nsuch as coordinates of points will be rounded. Returns : List containing possible parameters (the proportions along the bezier curve)\nfor the given point on the given bezier curve.\nThis usually only contains one or zero elements, but if the\npoint is, say, at the beginning/end of a closed loop, may return\na list with more than 1 value, corresponding to the beginning and\nend etc. of the loop. Return type : np.ndarray[float] Raises : ValueError \u2013 When point and the control points have different shapes.", "source": "https://docs.manim.community/en/stable/reference/manim.utils.bezier.html"}
{"prompt": "split_bezier(points, t)", "response": "Split a B\u00e9zier curve at argument t into two curves. Note See also A Primer on B\u00e9zier Curves #10: Splitting curves. Pomax. As an example for a cubic B\u00e9zier curve, let \\(p_0, p_1, p_2, p_3\\) be the points\nneeded for the curve \\(C_0 = [p_0, \\ p_1, \\ p_2, \\ p_3]\\) . Define the 3 linear B\u00e9ziers \\(L_0, L_1, L_2\\) as interpolations of \\(p_0, p_1, p_2, p_3\\) : \\[\\begin{split}L_0(t) &= p_0 + t(p_1 - p_0) \\\\\nL_1(t) &= p_1 + t(p_2 - p_1) \\\\\nL_2(t) &= p_2 + t(p_3 - p_2)\\end{split}\\] Define the 2 quadratic B\u00e9ziers \\(Q_0, Q_1\\) as interpolations of \\(L_0, L_1, L_2\\) : \\[\\begin{split}Q_0(t) &= L_0(t) + t(L_1(t) - L_0(t)) \\\\\nQ_1(t) &= L_1(t) + t(L_2(t) - L_1(t))\\end{split}\\] Then \\(C_0\\) is the following interpolation of \\(Q_0\\) and \\(Q_1\\) : \\[C_0(t) = Q_0(t) + t(Q_1(t) - Q_0(t))\\] Evaluating \\(C_0\\) at a value \\(t=t'\\) splits \\(C_0\\) into two cubic B\u00e9ziers \\(H_0\\) and \\(H_1\\) , defined by some of the points we calculated earlier: \\[\\begin{split}H_0 &= [p_0, &\\ L_0(t'), &\\ Q_0(t'), &\\ C_0(t') &] \\\\\nH_1 &= [p_0(t'), &\\ Q_1(t'), &\\ L_2(t'), &\\ p_3 &]\\end{split}\\] As the resulting curves are obtained from linear combinations of points , everything can\nbe encoded into a matrix for efficiency, which is done for B\u00e9zier curves of degree up to 3. See also A Primer on B\u00e9zier Curves #11: Splitting curves using matrices. Pomax. For the simpler case of a quadratic B\u00e9zier curve: \\[\\begin{split}H_0\n&=\n\\begin{pmatrix}\n    p_0 \\\\\n    (1-t) p_0 + t p_1 \\\\\n    (1-t)^2 p_0 + 2(1-t)t p_1 + t^2 p_2 \\\\\n\\end{pmatrix}\n&=\n\\begin{pmatrix}\n    1 & 0 & 0 \\\\\n    (1-t) & t & 0\\\\\n    (1-t)^2 & 2(1-t)t & t^2\n\\end{pmatrix}\n\\begin{pmatrix}\n    p_0 \\\\\n    p_1 \\\\\n    p_2\n\\end{pmatrix}\n\\\\\n&\n\\\\\nH_1\n&=\n\\begin{pmatrix}\n    (1-t)^2 p_0 + 2(1-t)t p_1 + t^2 p_2 \\\\\n    (1-t) p_1 + t p_2 \\\\\n    p_2\n\\end{pmatrix}\n&=\n\\begin{pmatrix}\n    (1-t)^2 & 2(1-t)t & t^2 \\\\\n    0 & (1-t) & t \\\\\n    0 & 0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n    p_0 \\\\\n    p_1 \\\\\n    p_2\n\\end{pmatrix}\\end{split}\\] from where one can define a \\((6, 3)\\) split matrix \\(S_2\\) which can multiply\nthe array of points to compute the return value: \\[\\begin{split}S_2\n&=\n\\begin{pmatrix}\n    1 & 0 & 0 \\\\\n    (1-t) & t & 0 \\\\\n    (1-t)^2 & 2(1-t)t & t^2 \\\\\n    (1-t)^2 & 2(1-t)t & t^2 \\\\\n    0 & (1-t) & t \\\\\n    0 & 0 & 1\n\\end{pmatrix}\n\\\\\n&\n\\\\\nS_2 P\n&=\n\\begin{pmatrix}\n    1 & 0 & 0 \\\\\n    (1-t) & t & 0 \\\\\n    (1-t)^2 & 2(1-t)t & t^2 \\\\\n    (1-t)^2 & 2(1-t)t & t^2 \\\\\n    0 & (1-t) & t \\\\\n    0 & 0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n    p_0 \\\\\n    p_1 \\\\\n    p_2\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n    \\vert \\\\\n    H_0 \\\\\n    \\vert \\\\\n    \\vert \\\\\n    H_1 \\\\\n    \\vert\n\\end{pmatrix}\\end{split}\\] For the previous example with a cubic B\u00e9zier curve: \\[\\begin{split}H_0\n&=\n\\begin{pmatrix}\n    p_0 \\\\\n    (1-t) p_0 + t p_1 \\\\\n    (1-t)^2 p_0 + 2(1-t)t p_1 + t^2 p_2 \\\\\n    (1-t)^3 p_0 + 3(1-t)^2 t p_1 + 3(1-t)t^2 p_2 + t^3 p_3\n\\end{pmatrix}\n&=\n\\begin{pmatrix}\n    1 & 0 & 0 & 0 \\\\\n    (1-t) & t & 0 & 0 \\\\\n    (1-t)^2 & 2(1-t)t & t^2 & 0 \\\\\n    (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3\n\\end{pmatrix}\n\\begin{pmatrix}\n    p_0 \\\\\n    p_1 \\\\\n    p_2 \\\\\n    p_3\n\\end{pmatrix}\n\\\\\n&\n\\\\\nH_1\n&=\n\\begin{pmatrix}\n    (1-t)^3 p_0 + 3(1-t)^2 t p_1 + 3(1-t)t^2 p_2 + t^3 p_3 \\\\\n    (1-t)^2 p_1 + 2(1-t)t p_2 + t^2 p_3 \\\\\n    (1-t) p_2 + t p_3 \\\\\n    p_3\n\\end{pmatrix}\n&=\n\\begin{pmatrix}\n    (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n    0 & (1-t)^2 & 2(1-t)t & t^2 \\\\\n    0 & 0 & (1-t) & t \\\\\n    0 & 0 & 0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n    p_0 \\\\\n    p_1 \\\\\n    p_2 \\\\\n    p_3\n\\end{pmatrix}\\end{split}\\] from where one can define a \\((8, 4)\\) split matrix \\(S_3\\) which can multiply\nthe array of points to compute the return value: \\[\\begin{split}S_3\n&=\n\\begin{pmatrix}\n    1 & 0 & 0 & 0 \\\\\n    (1-t) & t & 0 & 0 \\\\\n    (1-t)^2 & 2(1-t)t & t^2 & 0 \\\\\n    (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n    (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n    0 & (1-t)^2 & 2(1-t)t & t^2 \\\\\n    0 & 0 & (1-t) & t \\\\\n    0 & 0 & 0 & 1\n\\end{pmatrix}\n\\\\\n&\n\\\\\nS_3 P\n&=\n\\begin{pmatrix}\n    1 & 0 & 0 & 0 \\\\\n    (1-t) & t & 0 & 0 \\\\\n    (1-t)^2 & 2(1-t)t & t^2 & 0 \\\\\n    (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n    (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n    0 & (1-t)^2 & 2(1-t)t & t^2 \\\\\n    0 & 0 & (1-t) & t \\\\\n    0 & 0 & 0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n    p_0 \\\\\n    p_1 \\\\\n    p_2 \\\\\n    p_3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n    \\vert \\\\\n    H_0 \\\\\n    \\vert \\\\\n    \\vert \\\\\n    H_1 \\\\\n    \\vert\n\\end{pmatrix}\\end{split}\\] Parameters : points ( BezierPointsLike ) \u2013 The control points of the B\u00e9zier curve. t ( float ) \u2013 The t -value at which to split the B\u00e9zier curve. Returns : An array containing the control points defining the two B\u00e9zier curves. Return type : Point3D_Array", "source": "https://docs.manim.community/en/stable/reference/manim.utils.bezier.html"}
{"prompt": "subdivide_bezier(points, n_divisions)", "response": "Subdivide a B\u00e9zier curve into \\(n\\) subcurves which have the same shape. The points at which the curve is split are located at the\narguments \\(t = \\frac{i}{n}\\) , for \\(i \\in \\{1, ..., n-1\\}\\) . See also See split_bezier() for an explanation on how to split B\u00e9zier curves. See partial_bezier_points() for an extra understanding of this function. Note The resulting subcurves can be expressed as linear combinations of points , which can be encoded in a single matrix that is precalculated\nfor 2nd and 3rd degree B\u00e9zier curves. As an example for a quadratic B\u00e9zier curve: taking inspiration from the\nexplanation in partial_bezier_points() , where the following matrix \\(P_2\\) was defined to extract the portion of a quadratic B\u00e9zier\ncurve for \\(t \\in [a, b]\\) : \\[\\begin{split}P_2\n=\n\\begin{pmatrix}\n    (1-a)^2 & 2(1-a)a & a^2 \\\\\n    (1-a)(1-b) & a(1-b) + (1-a)b & ab \\\\\n    (1-b)^2 & 2(1-b)b & b^2\n\\end{pmatrix}\\end{split}\\] the plan is to replace \\([a, b]\\) with \\(\\left[ \\frac{i-1}{n}, \\frac{i}{n} \\right], \\ \\forall i \\in \\{1, ..., n\\}\\) . As an example for \\(n = 2\\) divisions, construct \\(P_1\\) for\nthe interval \\(\\left[ 0, \\frac{1}{2} \\right]\\) , and \\(P_2\\) for the\ninterval \\(\\left[ \\frac{1}{2}, 1 \\right]\\) : \\[\\begin{split}P_1\n=\n\\begin{pmatrix}\n    1 & 0 & 0 \\\\\n    0.5 & 0.5 & 0 \\\\\n    0.25 & 0.5 & 0.25\n\\end{pmatrix}\n,\n\\quad\nP_2\n=\n\\begin{pmatrix}\n    0.25 & 0.5 & 0.25 \\\\\n    0 & 0.5 & 0.5 \\\\\n    0 & 0 & 1\n\\end{pmatrix}\\end{split}\\] Therefore, the following \\((6, 3)\\) subdivision matrix \\(D_2\\) can be\nconstructed, which will subdivide an array of points into 2 parts: \\[\\begin{split}D_2\n=\n\\begin{pmatrix}\n    M_1 \\\\\n    M_2\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n    1 & 0 & 0 \\\\\n    0.5 & 0.5 & 0 \\\\\n    0.25 & 0.5 & 0.25 \\\\\n    0.25 & 0.5 & 0.25 \\\\\n    0 & 0.5 & 0.5 \\\\\n    0 & 0 & 1\n\\end{pmatrix}\\end{split}\\] For quadratic and cubic B\u00e9zier curves, the subdivision matrices are memoized for\nefficiency. For higher degree curves, an iterative algorithm inspired by the\none from split_bezier() is used instead. Parameters : points ( BezierPointsLike ) \u2013 The control points of the B\u00e9zier curve. n_divisions ( int ) \u2013 The number of curves to subdivide the B\u00e9zier curve into Returns : An array containing the points defining the new \\(n\\) subcurves. Return type : Spline", "source": "https://docs.manim.community/en/stable/reference/manim.utils.bezier.html"}
{"prompt": "capture(command, cwd=None, command_input=None)", "response": "Parameters : command ( str ) cwd ( StrOrBytesPath | None ) command_input ( str | None ) Return type : tuple[str, str, int]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.commands.html"}
{"prompt": "get_dir_layout(dirpath)", "response": "Get list of paths relative to dirpath of all files in dir and subdirs recursively. Parameters : dirpath ( Path ) Return type : Generator [str, None, None]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.commands.html"}
{"prompt": "get_video_metadata(path_to_video)", "response": "Parameters : path_to_video ( str | PathLike ) Return type : VideoMetadata", "source": "https://docs.manim.community/en/stable/reference/manim.utils.commands.html"}
{"prompt": "merge_dicts_recursively(*dicts)", "response": "Creates a dict whose keyset is the union of all the\ninput dictionaries.  The value for each key is based\non the first dict in the list with that key. dicts later in the list have higher priority When values are dictionaries, it is applied recursively Parameters : dicts ( dict [ Any , Any ] ) Return type : dict[ Any , Any ]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.config_ops.html"}
{"prompt": "update_dict_recursively(current_dict, *others)", "response": "Parameters : current_dict ( dict [ Any , Any ] ) others ( dict [ Any , Any ] ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.utils.config_ops.html"}
{"prompt": "index_labels(mobject, label_height=0.15, background_stroke_width=5, background_stroke_color=ManimColor('#000000'), **kwargs)", "response": "Returns a VGroup of Integer mobjects\nthat shows the index of each submobject. Useful for working with parts of complicated mobjects. Parameters : mobject ( Mobject ) \u2013 The mobject that will have its submobjects labelled. label_height ( float ) \u2013 The height of the labels, by default 0.15. background_stroke_width ( float ) \u2013 The stroke width of the outline of the labels, by default 5. background_stroke_color ( ManimColor ) \u2013 The stroke color of the outline of labels. kwargs ( Any ) \u2013 Additional parameters to be passed into the :class`~.Integer`\nmobjects used to construct the labels. Return type : VGroup Examples Example: IndexLabelsExample   from manim import * class IndexLabelsExample ( Scene ): def construct ( self ): text = MathTex ( \" \\\\ frac {d}{dx} f(x)g(x)=\" , \"f(x) \\\\ frac {d}{dx} g(x)\" , \"+\" , \"g(x) \\\\ frac {d}{dx} f(x)\" , ) #index the fist term in the MathTex mob indices = index_labels ( text [ 0 ]) text [ 0 ][ 1 ] . set_color ( PURPLE_B ) text [ 0 ][ 8 : 12 ] . set_color ( DARK_BLUE ) self . add ( text , indices ) class IndexLabelsExample(Scene):\n    def construct(self):\n        text = MathTex(\n            \"\\\\frac{d}{dx}f(x)g(x)=\",\n            \"f(x)\\\\frac{d}{dx}g(x)\",\n            \"+\",\n            \"g(x)\\\\frac{d}{dx}f(x)\",\n        )\n\n        #index the fist term in the MathTex mob\n        indices = index_labels(text[0])\n\n        text[0][1].set_color(PURPLE_B)\n        text[0][8:12].set_color(DARK_BLUE)\n\n        self.add(text, indices)", "source": "https://docs.manim.community/en/stable/reference/manim.utils.debug.html"}
{"prompt": "print_family(mobject, n_tabs=0)", "response": "For debugging purposes Parameters : mobject ( Mobject ) n_tabs ( int ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.utils.debug.html"}
{"prompt": "class T", "response": "TypeVar ( 'T' )", "source": "https://docs.manim.community/en/stable/reference/manim.utils.deprecation.html"}
{"prompt": "deprecated(func: Callable", "response": "Decorator to mark a callable as deprecated. The decorated callable will cause a warning when used. The docstring of the\ndeprecated callable is adjusted to indicate that this callable is deprecated. Parameters : func \u2013 The function to be decorated. Should not be set by the user. since \u2013 The version or date since deprecation. until \u2013 The version or date until removal of the deprecated callable. replacement \u2013 The identifier of the callable replacing the deprecated one. message \u2013 The reason for why the callable has been deprecated. Returns : The decorated callable. Return type : Callable Examples Basic usage: from manim.utils.deprecation import deprecated @deprecated def foo ( ** kwargs ): pass @deprecated class Bar : def __init__ ( self ): pass @deprecated def baz ( self ): pass foo () # WARNING  The function foo has been deprecated and may be removed in a later version. a = Bar () # WARNING  The class Bar has been deprecated and may be removed in a later version. a . baz () # WARNING  The method Bar.baz has been deprecated and may be removed in a later version. You can specify additional information for a more precise warning: from manim.utils.deprecation import deprecated @deprecated ( since = \"v0.2\" , until = \"v0.4\" , replacement = \"bar\" , message = \"It is cooler.\" ) def foo (): pass foo () # WARNING  The function foo has been deprecated since v0.2 and is expected to be removed after v0.4. Use bar instead. It is cooler. You may also use dates instead of versions: from manim.utils.deprecation import deprecated @deprecated ( since = \"05/01/2021\" , until = \"06/01/2021\" ) def foo (): pass foo () # WARNING  The function foo has been deprecated since 05/01/2021 and is expected to be removed after 06/01/2021.", "source": "https://docs.manim.community/en/stable/reference/manim.utils.deprecation.html"}
{"prompt": "deprecated_params(params=None, since=None, until=None, message='', redirections=None)", "response": "Decorator to mark parameters of a callable as deprecated. It can also be used to automatically redirect deprecated parameter values to their\nreplacements. Parameters : params ( str | Iterable [ str ] | None ) \u2013 The parameters to be deprecated. Can consist of: An iterable of strings, with each element representing a parameter to deprecate A single string, with parameter names separated by commas or spaces. since ( str | None ) \u2013 The version or date since deprecation. until ( str | None ) \u2013 The version or date until removal of the deprecated callable. message ( str ) \u2013 The reason for why the callable has been deprecated. redirections ( None | Iterable [ tuple [ str , str ] | Callable [ [ ... ] , dict [ str , Any ] ] ] ) \u2013 A list of parameter redirections. Each redirection can be one of the following: A tuple of two strings. The first string defines the name of the deprecated\nparameter; the second string defines the name of the parameter to redirect to,\nwhen attempting to use the first string. A function performing the mapping operation. The parameter names of the\nfunction determine which parameters are used as input. The function must\nreturn a dictionary which contains the redirected arguments. Redirected parameters are also implicitly deprecated. Returns : The decorated callable. Return type : Callable Raises : ValueError \u2013 If no parameters are defined (neither explicitly nor implicitly). ValueError \u2013 If defined parameters are invalid python identifiers. Examples Basic usage: from manim.utils.deprecation import deprecated_params @deprecated_params ( params = \"a, b, c\" ) def foo ( ** kwargs ): pass foo ( x = 2 , y = 3 , z = 4 ) # No warning foo ( a = 2 , b = 3 , z = 4 ) # WARNING  The parameters a and b of method foo have been deprecated and may be removed in a later version. You can also specify additional information for a more precise warning: from manim.utils.deprecation import deprecated_params @deprecated_params ( params = \"a, b, c\" , since = \"v0.2\" , until = \"v0.4\" , message = \"The letters x, y, z are cooler.\" , ) def foo ( ** kwargs ): pass foo ( a = 2 ) # WARNING  The parameter a of method foo has been deprecated since v0.2 and is expected to be removed after v0.4. The letters x, y, z are cooler. Basic parameter redirection: from manim.utils.deprecation import deprecated_params @deprecated_params ( redirections = [ # Two ways to redirect one parameter to another: ( \"old_param\" , \"new_param\" ), lambda old_param2 : { \"new_param22\" : old_param2 }, ] ) def foo ( ** kwargs ): return kwargs foo ( x = 1 , old_param = 2 ) # WARNING  The parameter old_param of method foo has been deprecated and may be removed in a later version. # returns {\"x\": 1, \"new_param\": 2} Redirecting using a calculated value: from manim.utils.deprecation import deprecated_params @deprecated_params ( redirections = [ lambda runtime_in_ms : { \"run_time\" : runtime_in_ms / 1000 }] ) def foo ( ** kwargs ): return kwargs foo ( runtime_in_ms = 500 ) # WARNING  The parameter runtime_in_ms of method foo has been deprecated and may be removed in a later version. # returns {\"run_time\": 0.5} Redirecting multiple parameter values to one: from manim.utils.deprecation import deprecated_params @deprecated_params ( redirections = [ lambda buff_x = 1 , buff_y = 1 : { \"buff\" : ( buff_x , buff_y )}] ) def foo ( ** kwargs ): return kwargs foo ( buff_x = 2 ) # WARNING  The parameter buff_x of method foo has been deprecated and may be removed in a later version. # returns {\"buff\": (2, 1)} Redirect one parameter to multiple: from manim.utils.deprecation import deprecated_params @deprecated_params ( redirections = [ lambda buff = 1 : { \"buff_x\" : buff [ 0 ], \"buff_y\" : buff [ 1 ]} if isinstance ( buff , tuple ) else { \"buff_x\" : buff , \"buff_y\" : buff } ] ) def foo ( ** kwargs ): return kwargs foo ( buff = 0 ) # WARNING  The parameter buff of method foo has been deprecated and may be removed in a later version. # returns {\"buff_x\": 0, buff_y: 0} foo ( buff = ( 1 , 2 )) # WARNING  The parameter buff of method foo has been deprecated and may be removed in a later version. # returns {\"buff_x\": 1, buff_y: 2}", "source": "https://docs.manim.community/en/stable/reference/manim.utils.deprecation.html"}
{"prompt": "get_hash_from_play_call(scene_object, camera_object, animations_list, current_mobjects_list)", "response": "Take the list of animations and a list of mobjects and output their hashes. This is meant to be used for scene.play function. Parameters : scene_object ( Scene ) \u2013 The scene object. camera_object ( Camera | OpenGLCamera ) \u2013 The camera object used in the scene. animations_list ( Iterable [ Animation ] ) \u2013 The list of animations. current_mobjects_list ( Iterable [ Mobject ] ) \u2013 The list of mobjects. Returns : A string concatenation of the respective hashes of camera_object , animations_list and current_mobjects_list , separated by _ . Return type : str", "source": "https://docs.manim.community/en/stable/reference/manim.utils.hashing.html"}
{"prompt": "get_json(obj)", "response": "Recursively serialize object to JSON using the CustomEncoder class. Parameters : obj ( dict ) \u2013 The dict to flatten Returns : The flattened object Return type : str", "source": "https://docs.manim.community/en/stable/reference/manim.utils.hashing.html"}
{"prompt": "change_to_rgba_array(image, dtype='uint8')", "response": "Converts an RGB array into RGBA with the alpha value opacity maxed. Parameters : image ( RGBPixelArray ) dtype ( str ) Return type : RGBPixelArray", "source": "https://docs.manim.community/en/stable/reference/manim.utils.images.html"}
{"prompt": "drag_pixels(frames)", "response": "Parameters : frames ( list [ array ] ) Return type : list[ array ]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.images.html"}
{"prompt": "get_full_raster_image_path(image_file_name)", "response": "Parameters : image_file_name ( str | PurePath ) Return type : Path", "source": "https://docs.manim.community/en/stable/reference/manim.utils.images.html"}
{"prompt": "get_full_vector_image_path(image_file_name)", "response": "Parameters : image_file_name ( str | PurePath ) Return type : Path", "source": "https://docs.manim.community/en/stable/reference/manim.utils.images.html"}
{"prompt": "invert_image(image)", "response": "Parameters : image ( array ) Return type : <module \u2018PIL.Image\u2019 from \u2018/home/docs/checkouts/readthedocs.org/user_builds/manimce/envs/stable/lib/python3.13/site-packages/PIL/Image.py\u2019>", "source": "https://docs.manim.community/en/stable/reference/manim.utils.images.html"}
{"prompt": "class T", "response": "TypeVar ( 'T' )", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "class U", "response": "TypeVar ( 'U' )", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "class F", "response": "TypeVar('F', np.float64, np.int_)", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "class H", "response": "TypeVar ( 'H' , bound = Hashable )", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "adjacent_n_tuples(objects, n)", "response": "Returns the Sequence objects cyclically split into n length tuples. See also adjacent_pairs alias with n=2 Examples >>> list ( adjacent_n_tuples ([ 1 , 2 , 3 , 4 ], 2 )) [(1, 2), (2, 3), (3, 4), (4, 1)] >>> list ( adjacent_n_tuples ([ 1 , 2 , 3 , 4 ], 3 )) [(1, 2, 3), (2, 3, 4), (3, 4, 1), (4, 1, 2)] Parameters : objects ( Sequence [ T ] ) n ( int ) Return type : zip[tuple[ T , \u2026]]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "adjacent_pairs(objects)", "response": "Alias for adjacent_n_tuples(objects, 2) . See also adjacent_n_tuples Examples >>> list ( adjacent_pairs ([ 1 , 2 , 3 , 4 ])) [(1, 2), (2, 3), (3, 4), (4, 1)] Parameters : objects ( Sequence [ T ] ) Return type : zip[tuple[ T , \u2026]]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "all_elements_are_instances(iterable, Class)", "response": "Returns True if all elements of iterable are instances of Class.\nFalse otherwise. Parameters : iterable ( Iterable [ object ] ) Class ( type [ object ] ) Return type : bool", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "batch_by_property(items, property_func)", "response": "Takes in a Sequence, and returns a list of tuples, (batch, prop)\nsuch that all items in a batch have the same output when\nput into the Callable property_func, and such that chaining all these\nbatches together would give the original Sequence (i.e. order is\npreserved). Examples >>> batch_by_property ([( 1 , 2 ), ( 3 , 4 ), ( 5 , 6 , 7 ), ( 8 , 9 )], len ) [([(1, 2), (3, 4)], 2), ([(5, 6, 7)], 3), ([(8, 9)], 2)] Parameters : items ( Iterable [ T ] ) property_func ( Callable [ [ T ] , U ] ) Return type : list[tuple[list[ T ], U | None]]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "concatenate_lists(*list_of_lists)", "response": "Combines the Iterables provided as arguments into one list. Examples >>> concatenate_lists ([ 1 , 2 ], [ 3 , 4 ], [ 5 ]) [1, 2, 3, 4, 5] Parameters : list_of_lists ( Iterable [ T ] ) Return type : list[ T ]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "hash_obj(obj)", "response": "Determines a hash, even of potentially mutable objects. Parameters : obj ( object ) Return type : int", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "list_difference_update(l1, l2)", "response": "Returns a list containing all the elements of l1 not in l2. Examples >>> list_difference_update ([ 1 , 2 , 3 , 4 ], [ 2 , 4 ]) [1, 3] Parameters : l1 ( Iterable [ T ] ) l2 ( Iterable [ T ] ) Return type : list[ T ]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "list_update(l1, l2)", "response": "Used instead of set.update() to maintain order, making sure duplicates are removed from l1, not l2.\nRemoves overlap of l1 and l2 and then concatenates l2 unchanged. Examples >>> list_update ([ 1 , 2 , 3 ], [ 2 , 4 , 4 ]) [1, 3, 2, 4, 4] Parameters : l1 ( Iterable [ T ] ) l2 ( Iterable [ T ] ) Return type : list[ T ]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "listify(obj: str) \u2192 list", "response": "Converts obj to a list intelligently. Examples >>> listify ( \"str\" ) ['str'] >>> listify (( 1 , 2 )) [1, 2] >>> listify ( len ) [<built-in function len>]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "make_even(iterable_1, iterable_2)", "response": "Extends the shorter of the two iterables with duplicate values until its length is equal to the longer iterable (favours earlier elements). See also make_even_by_cycling cycles elements instead of favouring earlier ones Examples >>> make_even ([ 1 , 2 ], [ 3 , 4 , 5 , 6 ]) ([1, 1, 2, 2], [3, 4, 5, 6]) >>> make_even ([ 1 , 2 ], [ 3 , 4 , 5 , 6 , 7 ]) ([1, 1, 1, 2, 2], [3, 4, 5, 6, 7]) Parameters : iterable_1 ( Iterable [ T ] ) iterable_2 ( Iterable [ U ] ) Return type : tuple[list[ T ], list[ U ]]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "make_even_by_cycling(iterable_1, iterable_2)", "response": "Extends the shorter of the two iterables with duplicate values until its length is equal to the longer iterable (cycles over shorter iterable). See also make_even favours earlier elements instead of cycling them Examples >>> make_even_by_cycling ([ 1 , 2 ], [ 3 , 4 , 5 , 6 ]) ([1, 2, 1, 2], [3, 4, 5, 6]) >>> make_even_by_cycling ([ 1 , 2 ], [ 3 , 4 , 5 , 6 , 7 ]) ([1, 2, 1, 2, 1], [3, 4, 5, 6, 7]) Parameters : iterable_1 ( Collection [ T ] ) iterable_2 ( Collection [ U ] ) Return type : tuple[list[ T ], list[ U ]]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "remove_list_redundancies(lst)", "response": "Used instead of list(set(l)) to maintain order.\nKeeps the last occurrence of each element. Parameters : lst ( Reversible [ H ] ) Return type : list[ H ]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "remove_nones(sequence)", "response": "Removes elements where bool(x) evaluates to False. Examples >>> remove_nones ([ \"m\" , \"\" , \"l\" , 0 , 42 , False , True ]) ['m', 'l', 42, True] Parameters : sequence ( Iterable [ T | None ] ) Return type : list[ T ]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "resize_array(nparray, length)", "response": "Extends/truncates nparray so that len(result) == length . The elements of nparray are cycled to achieve the desired length. See also resize_preserving_order favours earlier elements instead of cycling them make_even_by_cycling similar cycling behaviour for balancing 2 iterables Examples >>> points = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> resize_array ( points , 1 ) array([[1, 2]]) >>> resize_array ( points , 3 ) array([[1, 2], [3, 4], [1, 2]]) >>> resize_array ( points , 2 ) array([[1, 2], [3, 4]]) Parameters : nparray ( npt.NDArray [ F ] ) length ( int ) Return type : npt.NDArray[ F ]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "resize_preserving_order(nparray, length)", "response": "Extends/truncates nparray so that len(result) == length . The elements of nparray are duplicated to achieve the desired length\n(favours earlier elements). Constructs a zeroes array of length if nparray is empty. See also resize_array cycles elements instead of favouring earlier ones make_even similar earlier-favouring behaviour for balancing 2 iterables Examples >>> resize_preserving_order ( np . array ([]), 5 ) array([0., 0., 0., 0., 0.]) >>> nparray = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> resize_preserving_order ( nparray , 1 ) array([[1, 2]]) >>> resize_preserving_order ( nparray , 3 ) array([[1, 2], [1, 2], [3, 4]]) Parameters : nparray ( npt.NDArray [ np.float64 ] ) length ( int ) Return type : npt.NDArray[np.float64]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "resize_with_interpolation(nparray, length)", "response": "Extends/truncates nparray so that len(result) == length . New elements are interpolated to achieve the desired length. Note that if nparray\u2019s length changes, its dtype may too\n(e.g. int -> float: see Examples) See also resize_array cycles elements instead of interpolating resize_preserving_order favours earlier elements instead of interpolating Examples >>> nparray = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) >>> resize_with_interpolation ( nparray , 1 ) array([[1., 2.]]) >>> resize_with_interpolation ( nparray , 4 ) array([[1.        , 2.        ], [1.66666667, 2.66666667], [2.33333333, 3.33333333], [3.        , 4.        ]]) >>> nparray = np . array ([[[ 1 , 2 ], [ 3 , 4 ]]]) >>> nparray = np . array ([[ 1 , 2 ], [ 3 , 4 ], [ 5 , 6 ]]) >>> resize_with_interpolation ( nparray , 4 ) array([[1.        , 2.        ], [2.33333333, 3.33333333], [3.66666667, 4.66666667], [5.        , 6.        ]]) >>> nparray = np . array ([[ 1 , 2 ], [ 3 , 4 ], [ 1 , 2 ]]) >>> resize_with_interpolation ( nparray , 4 ) array([[1.        , 2.        ], [2.33333333, 3.33333333], [2.33333333, 3.33333333], [1.        , 2.        ]]) Parameters : nparray ( npt.NDArray [ F ] ) length ( int ) Return type : npt.NDArray[ F ]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "stretch_array_to_length(nparray, length)", "response": "Parameters : nparray ( npt.NDArray [ F ] ) length ( int ) Return type : npt.NDArray[ F ]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "tuplify(obj: str) \u2192 tuple", "response": "Converts obj to a tuple intelligently. Examples >>> tuplify ( \"str\" ) ('str',) >>> tuplify ([ 1 , 2 ]) (1, 2) >>> tuplify ( len ) (<built-in function len>,)", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "uniq_chain(*args)", "response": "Returns a generator that yields all unique elements of the Iterables provided via args in the order provided. Examples >>> gen = uniq_chain ([ 1 , 2 ], [ 2 , 3 ], [ 1 , 4 , 4 ]) >>> from collections.abc import Generator >>> isinstance ( gen , Generator ) True >>> tuple ( gen ) (1, 2, 3, 4) Parameters : args ( Iterable [ T ] ) Return type : Generator [ T , None, None]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.iterables.html"}
{"prompt": "clockwise_path()", "response": "This function transforms each point by moving clockwise around a half circle. Examples Example: ClockwisePathExample   from manim import * class ClockwisePathExample ( Scene ): def construct ( self ): colors = [ RED , GREEN , BLUE ] starting_points = VGroup ( * [ Dot ( LEFT + pos , color = color ) for pos , color in zip ([ UP , DOWN , LEFT ], colors ) ] ) finish_points = VGroup ( * [ Dot ( RIGHT + pos , color = color ) for pos , color in zip ([ ORIGIN , UP , DOWN ], colors ) ] ) self . add ( starting_points ) self . add ( finish_points ) for dot in starting_points : self . add ( TracedPath ( dot . get_center , stroke_color = dot . get_color ())) self . wait () self . play ( Transform ( starting_points , finish_points , path_func = utils . paths . clockwise_path (), run_time = 2 , ) ) self . wait () class ClockwisePathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.clockwise_path(),\n                run_time=2,\n            )\n        )\n        self.wait() Return type : PathFuncType", "source": "https://docs.manim.community/en/stable/reference/manim.utils.paths.html"}
{"prompt": "counterclockwise_path()", "response": "This function transforms each point by moving counterclockwise around a half circle. Examples Example: CounterclockwisePathExample   from manim import * class CounterclockwisePathExample ( Scene ): def construct ( self ): colors = [ RED , GREEN , BLUE ] starting_points = VGroup ( * [ Dot ( LEFT + pos , color = color ) for pos , color in zip ([ UP , DOWN , LEFT ], colors ) ] ) finish_points = VGroup ( * [ Dot ( RIGHT + pos , color = color ) for pos , color in zip ([ ORIGIN , UP , DOWN ], colors ) ] ) self . add ( starting_points ) self . add ( finish_points ) for dot in starting_points : self . add ( TracedPath ( dot . get_center , stroke_color = dot . get_color ())) self . wait () self . play ( Transform ( starting_points , finish_points , path_func = utils . paths . counterclockwise_path (), run_time = 2 , ) ) self . wait () class CounterclockwisePathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.counterclockwise_path(),\n                run_time=2,\n            )\n        )\n        self.wait() Return type : PathFuncType", "source": "https://docs.manim.community/en/stable/reference/manim.utils.paths.html"}
{"prompt": "path_along_arc(arc_angle, axis=array(", "response": "This function transforms each point by moving it along a circular arc. Parameters : arc_angle ( float ) \u2013 The angle each point traverses around a circular arc. axis ( Vector3D ) \u2013 The axis of rotation. Return type : PathFuncType Examples Example: PathAlongArcExample   from manim import * class PathAlongArcExample ( Scene ): def construct ( self ): colors = [ RED , GREEN , BLUE ] starting_points = VGroup ( * [ Dot ( LEFT + pos , color = color ) for pos , color in zip ([ UP , DOWN , LEFT ], colors ) ] ) finish_points = VGroup ( * [ Dot ( RIGHT + pos , color = color ) for pos , color in zip ([ ORIGIN , UP , DOWN ], colors ) ] ) self . add ( starting_points ) self . add ( finish_points ) for dot in starting_points : self . add ( TracedPath ( dot . get_center , stroke_color = dot . get_color ())) self . wait () self . play ( Transform ( starting_points , finish_points , path_func = utils . paths . path_along_arc ( TAU * 2 / 3 ), run_time = 3 , ) ) self . wait () class PathAlongArcExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.path_along_arc(TAU * 2 / 3),\n                run_time=3,\n            )\n        )\n        self.wait()", "source": "https://docs.manim.community/en/stable/reference/manim.utils.paths.html"}
{"prompt": "path_along_circles(arc_angle, circles_centers, axis=array(", "response": "This function transforms each point by moving it roughly along a circle, each with its own specified center. The path may be seen as each point smoothly changing its orbit from its starting position to its destination. Parameters : arc_angle ( float ) \u2013 The angle each point traverses around the quasicircle. circles_centers ( ndarray ) \u2013 The centers of each point\u2019s quasicircle to rotate around. axis ( Vector3D ) \u2013 The axis of rotation. Return type : PathFuncType Examples Example: PathAlongCirclesExample   from manim import * class PathAlongCirclesExample ( Scene ): def construct ( self ): colors = [ RED , GREEN , BLUE ] starting_points = VGroup ( * [ Dot ( LEFT + pos , color = color ) for pos , color in zip ([ UP , DOWN , LEFT ], colors ) ] ) finish_points = VGroup ( * [ Dot ( RIGHT + pos , color = color ) for pos , color in zip ([ ORIGIN , UP , DOWN ], colors ) ] ) self . add ( starting_points ) self . add ( finish_points ) for dot in starting_points : self . add ( TracedPath ( dot . get_center , stroke_color = dot . get_color ())) circle_center = Dot ( 3 * LEFT ) self . add ( circle_center ) self . wait () self . play ( Transform ( starting_points , finish_points , path_func = utils . paths . path_along_circles ( 2 * PI , circle_center . get_center () ), run_time = 3 , ) ) self . wait () class PathAlongCirclesExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        circle_center = Dot(3 * LEFT)\n        self.add(circle_center)\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.path_along_circles(\n                    2 * PI, circle_center.get_center()\n                ),\n                run_time=3,\n            )\n        )\n        self.wait()", "source": "https://docs.manim.community/en/stable/reference/manim.utils.paths.html"}
{"prompt": "spiral_path(angle, axis=array(", "response": "This function transforms each point by moving along a spiral to its destination. Parameters : angle ( float ) \u2013 The angle each point traverses around a spiral. axis ( Vector3D ) \u2013 The axis of rotation. Return type : PathFuncType Examples Example: SpiralPathExample   from manim import * class SpiralPathExample ( Scene ): def construct ( self ): colors = [ RED , GREEN , BLUE ] starting_points = VGroup ( * [ Dot ( LEFT + pos , color = color ) for pos , color in zip ([ UP , DOWN , LEFT ], colors ) ] ) finish_points = VGroup ( * [ Dot ( RIGHT + pos , color = color ) for pos , color in zip ([ ORIGIN , UP , DOWN ], colors ) ] ) self . add ( starting_points ) self . add ( finish_points ) for dot in starting_points : self . add ( TracedPath ( dot . get_center , stroke_color = dot . get_color ())) self . wait () self . play ( Transform ( starting_points , finish_points , path_func = utils . paths . spiral_path ( 2 * TAU ), run_time = 5 , ) ) self . wait () class SpiralPathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.spiral_path(2 * TAU),\n                run_time=5,\n            )\n        )\n        self.wait()", "source": "https://docs.manim.community/en/stable/reference/manim.utils.paths.html"}
{"prompt": "straight_path()", "response": "Simplest path function. Each point in a set goes in a straight path toward its destination. Examples Example: StraightPathExample   from manim import * class StraightPathExample ( Scene ): def construct ( self ): colors = [ RED , GREEN , BLUE ] starting_points = VGroup ( * [ Dot ( LEFT + pos , color = color ) for pos , color in zip ([ UP , DOWN , LEFT ], colors ) ] ) finish_points = VGroup ( * [ Dot ( RIGHT + pos , color = color ) for pos , color in zip ([ ORIGIN , UP , DOWN ], colors ) ] ) self . add ( starting_points ) self . add ( finish_points ) for dot in starting_points : self . add ( TracedPath ( dot . get_center , stroke_color = dot . get_color ())) self . wait () self . play ( Transform ( starting_points , finish_points , path_func = utils . paths . straight_path (), run_time = 2 , ) ) self . wait () class StraightPathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.straight_path(),\n                run_time=2,\n            )\n        )\n        self.wait() Return type : PathFuncType", "source": "https://docs.manim.community/en/stable/reference/manim.utils.paths.html"}
{"prompt": "double_smooth(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_back(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_bounce(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_circ(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_cubic(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_elastic(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_expo(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_out_back(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_out_bounce(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_out_circ(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_out_cubic(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_out_elastic(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_out_expo(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_out_quad(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_out_quart(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_out_quint(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_out_sine(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_quad(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_quart(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_quint(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_in_sine(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_out_back(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_out_bounce(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_out_circ(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_out_cubic(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_out_elastic(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_out_expo(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_out_quad(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_out_quart(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_out_quint(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "ease_out_sine(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "exponential_decay(t, half_life=0.1)", "response": "Parameters : t ( float ) half_life ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "linear(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "lingering(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "not_quite_there(func=<function smooth>, proportion=0.7)", "response": "Parameters : func ( RateFunction ) proportion ( float ) Return type : RateFunction", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "running_start(t, pull_factor=-0.5)", "response": "Parameters : t ( float ) pull_factor ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "rush_from(t, inflection=10.0)", "response": "Parameters : t ( float ) inflection ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "rush_into(t, inflection=10.0)", "response": "Parameters : t ( float ) inflection ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "slow_into(t)", "response": "Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "smooth(t, inflection=10.0)", "response": "Parameters : t ( float ) inflection ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "smoothererstep(t)", "response": "Implementation of the 3rd order SmoothStep sigmoid function.\nThe 1st, 2nd and 3rd derivatives (speed, acceleration and jerk) are zero at the endpoints. https://en.wikipedia.org/wiki/Smoothstep Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "smootherstep(t)", "response": "Implementation of the 2nd order SmoothStep sigmoid function.\nThe 1st and 2nd derivatives (speed and acceleration) are zero at the endpoints. https://en.wikipedia.org/wiki/Smoothstep Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "smoothstep(t)", "response": "Implementation of the 1st order SmoothStep sigmoid function.\nThe 1st derivative (speed) is zero at the endpoints. https://en.wikipedia.org/wiki/Smoothstep Parameters : t ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "squish_rate_func(func, a=0.4, b=0.6)", "response": "Parameters : func ( RateFunction ) a ( float ) b ( float ) Return type : RateFunction", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "there_and_back(t, inflection=10.0)", "response": "Parameters : t ( float ) inflection ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "there_and_back_with_pause(t, pause_ratio=0.3333333333333333)", "response": "Parameters : t ( float ) pause_ratio ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "unit_interval(function)", "response": "Parameters : function ( RateFunction ) Return type : RateFunction", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "wiggle(t, wiggles=2)", "response": "Parameters : t ( float ) wiggles ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "zero(function)", "response": "Parameters : function ( RateFunction ) Return type : RateFunction", "source": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html"}
{"prompt": "class ComparableT", "response": "TypeVar ( 'ComparableT' , bound = Comparable )", "source": "https://docs.manim.community/en/stable/reference/manim.utils.simple_functions.html"}
{"prompt": "binary_search(function, target, lower_bound, upper_bound, tolerance=0.0001)", "response": "Searches for a value in a range by repeatedly dividing the range in half. To be more precise, performs numerical binary search to determine the\ninput to function , between the bounds given, that outputs target to within tolerance (default of 0.0001).\nReturns None if no input can be found within the bounds. Examples Consider the polynomial \\(x^2 + 3x + 1\\) where we search for\na target value of \\(11\\) . An exact solution is \\(x = 2\\) . >>> solution = binary_search ( lambda x : x ** 2 + 3 * x + 1 , 11 , 0 , 5 ) >>> bool ( abs ( solution - 2 ) < 1e-4 ) True >>> solution = binary_search ( lambda x : x ** 2 + 3 * x + 1 , 11 , 0 , 5 , tolerance = 0.01 ) >>> bool ( abs ( solution - 2 ) < 0.01 ) True Searching in the interval \\([0, 5]\\) for a target value of \\(71\\) does not yield a solution: >>> binary_search ( lambda x : x ** 2 + 3 * x + 1 , 71 , 0 , 5 ) is None True Parameters : function ( Callable [ [ float ] , float ] ) target ( float ) lower_bound ( float ) upper_bound ( float ) tolerance ( float ) Return type : float | None", "source": "https://docs.manim.community/en/stable/reference/manim.utils.simple_functions.html"}
{"prompt": "choose(n, k)", "response": "The binomial coefficient n choose k. \\(\\binom{n}{k}\\) describes the number of possible choices of \\(k\\) elements from a set of \\(n\\) elements. References https://en.wikipedia.org/wiki/Combination https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.comb.html Parameters : n ( int ) k ( int ) Return type : int", "source": "https://docs.manim.community/en/stable/reference/manim.utils.simple_functions.html"}
{"prompt": "clip(a, min_a, max_a)", "response": "Clips a to the interval [ min_a , max_a ]. Accepts any comparable objects (i.e. those that support <, >).\nReturns a if it is between min_a and max_a .\nOtherwise, whichever of min_a and max_a is closest. Examples >>> clip ( 15 , 11 , 20 ) 15 >>> clip ( 'a' , 'h' , 'k' ) 'h' Parameters : a ( ComparableT ) min_a ( ComparableT ) max_a ( ComparableT ) Return type : ComparableT", "source": "https://docs.manim.community/en/stable/reference/manim.utils.simple_functions.html"}
{"prompt": "sigmoid(x)", "response": "Returns the output of the logistic function. The logistic function, a common example of a sigmoid function, is defined\nas \\(\\frac{1}{1 + e^{-x}}\\) . References https://en.wikipedia.org/wiki/Sigmoid_function https://en.wikipedia.org/wiki/Logistic_function Parameters : x ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.simple_functions.html"}
{"prompt": "get_full_sound_file_path(sound_file_name)", "response": "Parameters : sound_file_name ( StrPath ) Return type : Path", "source": "https://docs.manim.community/en/stable/reference/manim.utils.sounds.html"}
{"prompt": "R3_to_complex(point)", "response": "Parameters : point ( Sequence [ float ] ) Return type : ndarray", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "angle_axis_from_quaternion(quaternion)", "response": "Gets angle and axis from a quaternion. Parameters : quaternion ( Sequence [ float ] ) \u2013 The quaternion from which we get the angle and axis. Returns : Gives the angle and axis Return type : Sequence[float]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "angle_between_vectors(v1, v2)", "response": "Returns the angle between two vectors.\nThis angle will always be between 0 and pi Parameters : v1 ( ndarray ) \u2013 The first vector. v2 ( ndarray ) \u2013 The second vector. Returns : The angle between the vectors. Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "angle_of_vector(vector)", "response": "Returns polar coordinate theta when vector is projected on xy plane. Parameters : vector ( Sequence [ float ] | ndarray ) \u2013 The vector to find the angle for. Returns : The angle of the vector projected. Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "cartesian_to_spherical(vec)", "response": "Returns an array of numbers corresponding to each\npolar coordinate value (distance, phi, theta). Parameters : vec ( Sequence [ float ] ) \u2013 A numpy array [x, y, z] . Return type : ndarray", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "center_of_mass(points)", "response": "Gets the center of mass of the points in space. Parameters : points ( PointNDLike_Array ) \u2013 The points to find the center of mass from. Returns : The center of mass of the points. Return type : np.ndarray", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "compass_directions(n=4, start_vect=array(", "response": "Finds the cardinal directions using tau. Parameters : n ( int ) \u2013 The amount to be rotated, by default 4 start_vect ( ndarray ) \u2013 The direction for the angle to start with, by default RIGHT Returns : The angle which has been rotated. Return type : np.ndarray", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "complex_func_to_R3_func(complex_func)", "response": "Parameters : complex_func ( Callable [ [ complex ] , complex ] ) Return type : Callable [[ Point3DLike ], Point3D ]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "complex_to_R3(complex_num)", "response": "Parameters : complex_num ( complex ) Return type : ndarray", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "cross(v1, v2)", "response": "Parameters : v1 ( Vector3D ) v2 ( Vector3D ) Return type : Vector3D", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "cross2d(a, b)", "response": "Compute the determinant(s) of the passed\nvector (sequences). Parameters : a ( Vector2D | Vector2D_Array ) \u2013 A vector or a sequence of vectors. b ( Vector2D | Vector2D_Array ) \u2013 A vector or a sequence of vectors. Returns : The determinant or sequence of determinants\nof the first two components of the specified\nvectors. Return type : Sequence[float] | float Examples >>> cross2d ( np . array ([ 1 , 2 ]), np . array ([ 3 , 4 ])) np.int64(-2) >>> cross2d ( ... np . array ([[ 1 , 2 , 0 ], [ 1 , 0 , 0 ]]), ... np . array ([[ 3 , 4 , 0 ], [ 0 , 1 , 0 ]]), ... ) array([-2,  1])", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "earclip_triangulation(verts, ring_ends)", "response": "Returns a list of indices giving a triangulation\nof a polygon, potentially with holes. Parameters : verts ( ndarray ) \u2013 verts is a numpy array of points. ring_ends ( list ) \u2013 ring_ends is a list of indices indicating where\nthe ends of new paths are. Returns : A list of indices giving a triangulation of a polygon. Return type : list", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "find_intersection(p0s, v0s, p1s, v1s, threshold=1e-05)", "response": "Return the intersection of a line passing through p0 in direction v0\nwith one passing through p1 in direction v1 (or array of intersections\nfrom arrays of such points/directions).\nFor 3d values, it returns the point on the ray p0 + v0 * t closest to the\nray p1 + v1 * t Parameters : p0s ( Point3DLike_Array ) v0s ( Vector3D_Array ) p1s ( Point3DLike_Array ) v1s ( Vector3D_Array ) threshold ( float ) Return type : list[ Point3D ]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "get_unit_normal(v1, v2, tol=1e-06)", "response": "Gets the unit normal of the vectors. Parameters : v1 ( Vector3D ) \u2013 The first vector. v2 ( Vector3D ) \u2013 The second vector tol ( float ) \u2013 [description], by default 1e-6 Returns : The normal of the two vectors. Return type : np.ndarray", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "get_winding_number(points)", "response": "Determine the number of times a polygon winds around the origin. The orientation is measured mathematically positively, i.e.,\ncounterclockwise. Parameters : points ( Sequence [ ndarray ] ) \u2013 The vertices of the polygon being queried. Return type : float Examples >>> from manim import Square , get_winding_number >>> polygon = Square () >>> get_winding_number ( polygon . get_vertices ()) np.float64(1.0) >>> polygon . shift ( 2 * UP ) Square >>> get_winding_number ( polygon . get_vertices ()) np.float64(0.0)", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "line_intersection(line1, line2)", "response": "Returns the intersection point of two lines, each defined by\na pair of distinct points lying on the line. Parameters : line1 ( Sequence [ ndarray ] ) \u2013 A list of two points that determine the first line. line2 ( Sequence [ ndarray ] ) \u2013 A list of two points that determine the second line. Returns : The intersection points of the two lines which are intersecting. Return type : np.ndarray Raises : ValueError \u2013 Error is produced if the two lines don\u2019t intersect with each other\n    or if the coordinates don\u2019t lie on the xy-plane.", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "midpoint(point1, point2)", "response": "Gets the midpoint of two points. Parameters : point1 ( Sequence [ float ] ) \u2013 The first point. point2 ( Sequence [ float ] ) \u2013 The second point. Returns : The midpoint of the points Return type : Union [float, np.ndarray]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "norm_squared(v)", "response": "Parameters : v ( float ) Return type : float", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "normalize(vect, fall_back=None)", "response": "Parameters : vect ( ndarray | tuple [ float ] ) fall_back ( ndarray | None ) Return type : ndarray", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "normalize_along_axis(array, axis)", "response": "Normalizes an array with the provided axis. Parameters : array ( ndarray ) \u2013 The array which has to be normalized. axis ( ndarray ) \u2013 The axis to be normalized to. Returns : Array which has been normalized according to the axis. Return type : np.ndarray", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "perpendicular_bisector(line, norm_vector=array(", "response": "Returns a list of two points that correspond\nto the ends of the perpendicular bisector of the\ntwo points given. Parameters : line ( Sequence [ ndarray ] ) \u2013 a list of two numpy array points (corresponding\nto the ends of a line). norm_vector ( Vector3D ) \u2013 the vector perpendicular to both the line given\nand the perpendicular bisector. Returns : A list of two numpy array points that correspond\nto the ends of the perpendicular bisector Return type : list", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "quaternion_conjugate(quaternion)", "response": "Used for finding the conjugate of the quaternion Parameters : quaternion ( Sequence [ float ] ) \u2013 The quaternion for which you want to find the conjugate for. Returns : The conjugate of the quaternion. Return type : np.ndarray", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "quaternion_from_angle_axis(angle, axis, axis_normalized=False)", "response": "Gets a quaternion from an angle and an axis.\nFor more information, check this Wikipedia page . Parameters : angle ( float ) \u2013 The angle for the quaternion. axis ( ndarray ) \u2013 The axis for the quaternion axis_normalized ( bool ) \u2013 Checks whether the axis is normalized, by default False Returns : Gives back a quaternion from the angle and axis Return type : list[float]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "quaternion_mult(*quats)", "response": "Gets the Hamilton product of the quaternions provided.\nFor more information, check this Wikipedia page . Returns : Returns a list of product of two quaternions. Return type : Union [np.ndarray, List[ Union [float, np.ndarray]]] Parameters : quats ( Sequence [ float ] )", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "regular_vertices(n, *, radius=1, start_angle=None)", "response": "Generates regularly spaced vertices around a circle centered at the origin. Parameters : n ( int ) \u2013 The number of vertices radius ( float ) \u2013 The radius of the circle that the vertices are placed on. start_angle ( float | None ) \u2013 The angle the vertices start at. If unspecified, for even n values, 0 will be used.\nFor odd n values, 90 degrees is used. Returns : vertices ( numpy.ndarray ) \u2013 The regularly spaced vertices. start_angle ( float ) \u2013 The angle the vertices start at. Return type : tuple[ ndarray , float]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "rotate_vector(vector, angle, axis=array(", "response": "Function for rotating a vector. Parameters : vector ( ndarray ) \u2013 The vector to be rotated. angle ( float ) \u2013 The angle to be rotated by. axis ( ndarray ) \u2013 The axis to be rotated, by default OUT Returns : The rotated vector with provided angle and axis. Return type : np.ndarray Raises : ValueError \u2013 If vector is not of dimension 2 or 3.", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "rotation_about_z(angle)", "response": "Returns a rotation matrix for a given angle. Parameters : angle ( float ) \u2013 Angle for the rotation matrix. Returns : Gives back the rotated matrix. Return type : np.ndarray", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "rotation_matrix(angle, axis, homogeneous=False)", "response": "Rotation in R^3 about a specified axis of rotation. Parameters : angle ( float ) axis ( ndarray ) homogeneous ( bool ) Return type : ndarray", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "rotation_matrix_from_quaternion(quat)", "response": "Parameters : quat ( ndarray ) Return type : ndarray", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "rotation_matrix_transpose(angle, axis)", "response": "Parameters : angle ( float ) axis ( ndarray ) Return type : ndarray", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "rotation_matrix_transpose_from_quaternion(quat)", "response": "Converts the quaternion, quat, to an equivalent rotation matrix representation.\nFor more information, check this page . Parameters : quat ( ndarray ) \u2013 The quaternion which is to be converted. Returns : Gives back the Rotation matrix representation, returned as a 3-by-3\nmatrix or 3-by-3-by-N multidimensional array. Return type : List[np.ndarray]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "shoelace(x_y)", "response": "2D implementation of the shoelace formula. Returns : Returns signed area. Return type : float Parameters : x_y ( Point2D_Array )", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "shoelace_direction(x_y)", "response": "Uses the area determined by the shoelace method to determine whether\nthe input set of points is directed clockwise or counterclockwise. Returns : Either \"CW\" or \"CCW\" . Return type : str Parameters : x_y ( Point2D_Array )", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "spherical_to_cartesian(spherical)", "response": "Returns a numpy array [x, y, z] based on the spherical\ncoordinates given. Parameters : spherical ( Sequence [ float ] ) \u2013 A list of three floats that correspond to the following: r - The distance between the point and the origin. theta - The azimuthal angle of the point to the positive x-axis. phi - The vertical angle of the point to the positive z-axis. Return type : ndarray", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "thick_diagonal(dim, thickness=2)", "response": "Parameters : dim ( int ) thickness ( int ) Return type : MatrixMN", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "z_to_vector(vector)", "response": "Returns some matrix in SO(3) which takes the z-axis to the\n(normalized) vector provided as an argument Parameters : vector ( ndarray ) Return type : ndarray", "source": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html"}
{"prompt": "compile_tex(tex_file, tex_compiler, output_format)", "response": "Compiles a tex_file into a .dvi or a .xdv or a .pdf Parameters : tex_file ( Path ) \u2013 File name of TeX file to be typeset. tex_compiler ( str ) \u2013 String containing the compiler to be used, e.g. pdflatex or lualatex output_format ( str ) \u2013 String containing the output format generated by the compiler, e.g. .dvi or .pdf Returns : Path to generated output file in desired format (DVI, XDV or PDF). Return type : Path", "source": "https://docs.manim.community/en/stable/reference/manim.utils.tex_file_writing.html"}
{"prompt": "convert_to_svg(dvi_file, extension, page=1)", "response": "Converts a .dvi, .xdv, or .pdf file into an svg using dvisvgm. Parameters : dvi_file ( Path ) \u2013 File name of the input file to be converted. extension ( str ) \u2013 String containing the file extension and thus indicating the file type, e.g. .dvi or .pdf page ( int ) \u2013 Page to be converted if input file is multi-page. Returns : Path to generated SVG file. Return type : Path", "source": "https://docs.manim.community/en/stable/reference/manim.utils.tex_file_writing.html"}
{"prompt": "delete_nonsvg_files(additional_endings=())", "response": "Deletes every file that does not have a suffix in (\".svg\", \".tex\", *additional_endings) Parameters : additional_endings ( Iterable [ str ] ) \u2013 Additional endings to whitelist Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.utils.tex_file_writing.html"}
{"prompt": "generate_tex_file(expression, environment=None, tex_template=None)", "response": "Takes a tex expression (and an optional tex environment),\nand returns a fully formed tex file ready for compilation. Parameters : expression ( str ) \u2013 String containing the TeX expression to be rendered, e.g. \\\\sqrt{2} or foo environment ( str | None ) \u2013 The string containing the environment in which the expression should be typeset, e.g. align* tex_template ( TexTemplate | None ) \u2013 Template class used to typesetting. If not set, use default template set via config[\u201ctex_template\u201d] Returns : Path to generated TeX file Return type : Path", "source": "https://docs.manim.community/en/stable/reference/manim.utils.tex_file_writing.html"}
{"prompt": "insight_inputenc_error(matching)", "response": "Parameters : matching ( Match [ str ] ) Return type : Generator [str]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.tex_file_writing.html"}
{"prompt": "insight_package_not_found_error(matching)", "response": "Parameters : matching ( Match [ str ] ) Return type : Generator [str]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.tex_file_writing.html"}
{"prompt": "make_tex_compilation_command(tex_compiler, output_format, tex_file, tex_dir)", "response": "Prepares the TeX compilation command, i.e. the TeX compiler name\nand all necessary CLI flags. Parameters : tex_compiler ( str ) \u2013 String containing the compiler to be used, e.g. pdflatex or lualatex output_format ( str ) \u2013 String containing the output format generated by the compiler, e.g. .dvi or .pdf tex_file ( Path ) \u2013 File name of TeX file to be typeset. tex_dir ( Path ) \u2013 Path to the directory where compiler output will be stored. Returns : Compilation command according to given parameters Return type : list[str]", "source": "https://docs.manim.community/en/stable/reference/manim.utils.tex_file_writing.html"}
{"prompt": "print_all_tex_errors(log_file, tex_compiler, tex_file)", "response": "Parameters : log_file ( Path ) tex_compiler ( str ) tex_file ( Path ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.utils.tex_file_writing.html"}
{"prompt": "print_tex_error(tex_compilation_log, error_start_index, tex_source)", "response": "Parameters : tex_compilation_log ( Sequence [ str ] ) error_start_index ( int ) tex_source ( Sequence [ str ] ) Return type : None", "source": "https://docs.manim.community/en/stable/reference/manim.utils.tex_file_writing.html"}
{"prompt": "tex_hash(expression)", "response": "Parameters : expression ( Any ) Return type : str", "source": "https://docs.manim.community/en/stable/reference/manim.utils.tex_file_writing.html"}
{"prompt": "tex_to_svg_file(expression, environment=None, tex_template=None)", "response": "Takes a tex expression and returns the svg version of the compiled tex Parameters : expression ( str ) \u2013 String containing the TeX expression to be rendered, e.g. \\\\sqrt{2} or foo environment ( str | None ) \u2013 The string containing the environment in which the expression should be typeset, e.g. align* tex_template ( TexTemplate | None ) \u2013 Template class used to typesetting. If not set, use default template set via config[\u201ctex_template\u201d] Returns : Path to generated SVG file. Return type : Path", "source": "https://docs.manim.community/en/stable/reference/manim.utils.tex_file_writing.html"}
{"prompt": "class ManimFloat", "response": "np . float64 A double-precision floating-point value (64 bits, or 8 bytes),\naccording to the IEEE 754 standard.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class ManimInt", "response": "np . int64 A long integer (64 bits, or 8 bytes). It can take values between \\(-2^{63}\\) and \\(+2^{63} - 1\\) ,\nwhich expressed in base 10 is a range between around \\(-9.223 \\cdot 10^{18}\\) and \\(+9.223 \\cdot 10^{18}\\) .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class ManimColorDType", "response": "ManimFloat Data type used in ManimColorInternal : a\ndouble-precision float between 0 and 1.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class RGB_Array_Float", "response": "NDArray[ ManimColorDType ] shape: (3,) A numpy.ndarray of 3 floats between 0 and 1, representing a\ncolor in RGB format. Its components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class RGB_Tuple_Float", "response": "tuple [ float , float , float ] shape: (3,) A tuple of 3 floats between 0 and 1, representing a color in RGB\nformat. Its components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class RGB_Array_Int", "response": "NDArray[ ManimInt ] shape: (3,) A numpy.ndarray of 3 integers between 0 and 255,\nrepresenting a color in RGB format. Its components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class RGB_Tuple_Int", "response": "tuple [ int , int , int ] shape: (3,) A tuple of 3 integers between 0 and 255, representing a color in RGB\nformat. Its components describe, in order, the intensity of Red, Green, and\nBlue in the represented color.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class RGBA_Array_Float", "response": "NDArray[ ManimColorDType ] shape: (4,) A numpy.ndarray of 4 floats between 0 and 1, representing a\ncolor in RGBA format. Its components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class RGBA_Tuple_Float", "response": "tuple [ float , float , float , float ] shape: (4,) A tuple of 4 floats between 0 and 1, representing a color in RGBA\nformat. Its components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class RGBA_Array_Int", "response": "NDArray[ ManimInt ] shape: (4,) A numpy.ndarray of 4 integers between 0 and 255,\nrepresenting a color in RGBA format. Its components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class RGBA_Tuple_Int", "response": "tuple [ int , int , int , int ] shape: (4,) A tuple of 4 integers between 0 and 255, representing a color in RGBA\nformat. Its components describe, in order, the intensity of Red, Green, Blue\nand Alpha (opacity) in the represented color.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class HSV_Array_Float", "response": "RGB_Array_Float shape: (3,) A numpy.ndarray of 3 floats between 0 and 1, representing a\ncolor in HSV (or HSB) format. Its components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class HSV_Tuple_Float", "response": "RGB_Tuple_Float shape: (3,) A tuple of 3 floats between 0 and 1, representing a color in HSV (or\nHSB) format. Its components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class HSVA_Array_Float", "response": "RGBA_Array_Float shape: (4,) A numpy.ndarray of 4 floats between 0 and 1, representing a\ncolor in HSVA (or HSBA) format. Its components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class HSVA_Tuple_Float", "response": "RGBA_Tuple_Float shape: (4,) A tuple of 4 floats between 0 and 1, representing a color in HSVA (or\nHSBA) format. Its components describe, in order, the Hue, Saturation and Value (or\nBrightness) in the represented color.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class HSL_Array_Float", "response": "RGB_Array_Float shape: (3,) A numpy.ndarray of 3 floats between 0 and 1, representing a\ncolor in HSL format. Its components describe, in order, the Hue, Saturation and Lightness\nin the represented color.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class HSL_Tuple_Float", "response": "RGB_Tuple_Float shape: (3,) A numpy.ndarray of 3 floats between 0 and 1, representing a\ncolor in HSL format. Its components describe, in order, the Hue, Saturation and Lightness\nin the represented color.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class ManimColorInternal", "response": "RGBA_Array_Float shape: (4,) Internal color representation used by ManimColor ,\nfollowing the RGBA format. It is a numpy.ndarray consisting of 4 floats between 0 and\n1, describing respectively the intensities of Red, Green, Blue and\nAlpha (opacity) in the represented color.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class PointDType", "response": "ManimFloat Default type for arrays representing points: a double-precision\nfloating point value.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class Point2D", "response": "NDArray[ PointDType ] shape: (2,) A NumPy array representing a 2-dimensional point: [float, float] .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class Point2DLike", "response": "Point2D | tuple[float, float] shape: (2,) A 2-dimensional point: [float, float] . This represents anything which can be converted to a :class: Point2D NumPy\narray. Normally, a function or method which expects a Point2D as a\nparameter can handle being passed a Point3D instead.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class Point2D_Array", "response": "NDArray[ PointDType ] shape: (M, 2) A NumPy array representing a sequence of Point2D objects: [[float, float], ...] .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class Point2DLike_Array", "response": "Point2D_Array | Sequence[ Point2DLike ] shape: (M, 2) An array of Point2DLike objects: [[float, float], ...] . This represents anything which can be converted to a :class: Point2D_Array NumPy array. Normally, a function or method which expects a Point2D_Array as a\nparameter can handle being passed a Point3D_Array instead. Please refer to the documentation of the function you are using for\nfurther type information.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class Point3D", "response": "NDArray[ PointDType ] shape: (3,) A NumPy array representing a 3-dimensional point: [float, float, float] .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class Point3DLike", "response": "Point3D | tuple[float, float, float] shape: (3,) A 3-dimensional point: [float, float, float] . This represents anything which can be converted to a :class: Point3D NumPy\narray.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class Point3D_Array", "response": "NDArray[ PointDType ] shape: (M, 3) A NumPy array representing a sequence of Point3D objects: [[float, float, float], ...] .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class Point3DLike_Array", "response": "Point3D_Array | Sequence[ Point3DLike ] shape: (M, 3) An array of Point3D objects: [[float, float, float], ...] . This represents anything which can be converted to a :class: Point3D_Array NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class PointND", "response": "NDArray[ PointDType ] shape: (N,) A NumPy array representing an N-dimensional point: [float, ...] .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class PointNDLike", "response": "PointND | Sequence[float] shape: (N,) An N-dimensional point: [float, ...] . This represents anything which can be converted to a :class: PointND NumPy\narray.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class PointND_Array", "response": "NDArray[ PointDType ] shape: (M, N) A NumPy array representing a sequence of PointND objects: [[float, ...], ...] .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class PointNDLike_Array", "response": "PointND_Array | Sequence[ PointNDLike ] shape: (M, N) An array of PointND objects: [[float, ...], ...] . This represents anything which can be converted to a :class: PointND_Array NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class Vector2D", "response": "NDArray[ PointDType ] shape: (2,) A 2-dimensional vector: [float, float] . Normally, a function or method which expects a Vector2D as a\nparameter can handle being passed a Vector3D instead. Caution Do not confuse with the Vector or Arrow VMobjects!", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class Vector2D_Array", "response": "NDArray[ PointDType ] shape: (M, 2) An array of Vector2D objects: [[float, float], ...] . Normally, a function or method which expects a Vector2D_Array as a\nparameter can handle being passed a Vector3D_Array instead.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class Vector3D", "response": "NDArray[ PointDType ] shape: (3,) A 3-dimensional vector: [float, float, float] . Caution Do not confuse with the Vector or Arrow3D VMobjects!", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class Vector3D_Array", "response": "NDArray[ PointDType ] shape: (M, 3) An array of Vector3D objects: [[float, float, float], ...] .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class VectorND", "response": "NDArray[ PointDType ] shape (N,) An \\(N\\) -dimensional vector: [float, ...] . Caution Do not confuse with the Vector VMobject! This type alias\nis named \u201cVectorND\u201d instead of \u201cVector\u201d to avoid potential name\ncollisions.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class VectorND_Array", "response": "NDArray[ PointDType ] shape (M, N) An array of VectorND objects: [[float, ...], ...] .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class RowVector", "response": "NDArray[ PointDType ] shape: (1, N) A row vector: [[float, ...]] .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class ColVector", "response": "NDArray[ PointDType ] shape: (N, 1) A column vector: [[float], [float], ...] .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class MatrixMN", "response": "NDArray[ PointDType ] shape: (M, N) A matrix: [[float, ...], [float, ...], ...] .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class Zeros", "response": "MatrixMN shape: (M, N) A MatrixMN filled with zeros, typically created with numpy.zeros((M, N)) .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class QuadraticBezierPoints", "response": "Point3D_Array shape: (3, 3) A Point3D_Array of three 3D control points for a single quadratic B\u00e9zier\ncurve: [[float, float, float], [float, float, float], [float, float, float]] .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class QuadraticBezierPointsLike", "response": "QuadraticBezierPoints | tuple[ Point3DLike , Point3DLike , Point3DLike ] shape: (3, 3) A Point3DLike_Array of three 3D control points for a single quadratic B\u00e9zier\ncurve: [[float, float, float], [float, float, float], [float, float, float]] . This represents anything which can be converted to a\n:class: QuadraticBezierPoints NumPy array.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class QuadraticBezierPoints_Array", "response": "NDArray[ PointDType ] shape: (N, 3, 3) A NumPy array containing \\(N\\) QuadraticBezierPoints objects: [[[float, float, float], [float, float, float], [float, float, float]], ...] .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class QuadraticBezierPointsLike_Array", "response": "QuadraticBezierPoints_Array | Sequence[ QuadraticBezierPointsLike ] shape: (N, 3, 3) A sequence of \\(N\\) QuadraticBezierPointsLike objects: [[[float, float, float], [float, float, float], [float, float, float]], ...] . This represents anything which can be converted to a\n:class: QuadraticBezierPoints_Array NumPy array.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class QuadraticBezierPath", "response": "Point3D_Array shape: (3*N, 3) A Point3D_Array of \\(3N\\) points, where each one of the \\(N\\) consecutive blocks of 3 points represents a quadratic\nB\u00e9zier curve: [[float, float, float], ...], ...] . Please refer to the documentation of the function you are using for\nfurther type information.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class QuadraticBezierPathLike", "response": "Point3DLike_Array shape: (3*N, 3) A Point3DLike_Array of \\(3N\\) points, where each one of the \\(N\\) consecutive blocks of 3 points represents a quadratic\nB\u00e9zier curve: [[float, float, float], ...], ...] . This represents anything which can be converted to a\n:class: QuadraticBezierPath NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class QuadraticSpline", "response": "QuadraticBezierPath shape: (3*N, 3) A special case of QuadraticBezierPath where all the \\(N\\) quadratic B\u00e9zier curves are connected, forming a quadratic spline: [[float, float, float], ...], ...] . Please refer to the documentation of the function you are using for\nfurther type information.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class QuadraticSplineLike", "response": "QuadraticBezierPathLike shape: (3*N, 3) A special case of QuadraticBezierPathLike where all the \\(N\\) quadratic B\u00e9zier curves are connected, forming a quadratic spline: [[float, float, float], ...], ...] . This represents anything which can be converted to a :class: QuadraticSpline NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class CubicBezierPoints", "response": "Point3D_Array shape: (4, 3) A Point3D_Array of four 3D control points for a single cubic B\u00e9zier curve: [[float, float, float], [float, float, float], [float, float, float], [float, float, float]] .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class CubicBezierPointsLike", "response": "CubicBezierPoints | tuple[ Point3DLike , Point3DLike , Point3DLike , Point3DLike ] shape: (4, 3) A Point3DLike_Array of 4 control points for a single cubic B\u00e9zier curve: [[float, float, float], [float, float, float], [float, float, float], [float, float, float]] . This represents anything which can be converted to a :class: CubicBezierPoints NumPy array.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class CubicBezierPoints_Array", "response": "NDArray[ PointDType ] shape: (N, 4, 3) A NumPy array containing \\(N\\) CubicBezierPoints objects: [[[float, float, float], [float, float, float], [float, float, float], [float, float, float]], ...] .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class CubicBezierPointsLike_Array", "response": "CubicBezierPoints_Array | Sequence[ CubicBezierPointsLike ] shape: (N, 4, 3) A sequence of \\(N\\) CubicBezierPointsLike objects: [[[float, float, float], [float, float, float], [float, float, float], [float, float, float]], ...] . This represents anything which can be converted to a\n:class: CubicBezierPoints_Array NumPy array.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class CubicBezierPath", "response": "Point3D_Array shape: (4*N, 3) A Point3D_Array of \\(4N\\) points, where each one of the \\(N\\) consecutive blocks of 4 points represents a cubic B\u00e9zier\ncurve: [[float, float, float], ...], ...] . Please refer to the documentation of the function you are using for\nfurther type information.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class CubicBezierPathLike", "response": "Point3DLike_Array shape: (4*N, 3) A Point3DLike_Array of \\(4N\\) points, where each one of the \\(N\\) consecutive blocks of 4 points represents a cubic B\u00e9zier\ncurve: [[float, float, float], ...], ...] . This represents anything which can be converted to a\n:class: CubicBezierPath NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class CubicSpline", "response": "CubicBezierPath shape: (4*N, 3) A special case of CubicBezierPath where all the \\(N\\) cubic\nB\u00e9zier curves are connected, forming a quadratic spline: [[float, float, float], ...], ...] . Please refer to the documentation of the function you are using for\nfurther type information.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class CubicSplineLike", "response": "CubicBezierPathLike shape: (4*N, 3) A special case of CubicBezierPath where all the \\(N\\) cubic\nB\u00e9zier curves are connected, forming a quadratic spline: [[float, float, float], ...], ...] . This represents anything which can be converted to a\n:class: CubicSpline NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class BezierPoints", "response": "Point3D_Array shape: (PPC, 3) A Point3D_Array of \\(\\text{PPC}\\) control points\n( \\(\\text{PPC: Points Per Curve} = n + 1\\) ) for a single \\(n\\) -th degree B\u00e9zier curve: [[float, float, float], ...] . Please refer to the documentation of the function you are using for\nfurther type information.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class BezierPointsLike", "response": "Point3DLike_Array shape: (PPC, 3) A Point3DLike_Array of \\(\\text{PPC}\\) control points\n( \\(\\text{PPC: Points Per Curve} = n + 1\\) ) for a single \\(n\\) -th degree B\u00e9zier curve: [[float, float, float], ...] . This represents anything which can be converted to a\n:class: BezierPoints NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class BezierPoints_Array", "response": "NDArray[ PointDType ] shape: (N, PPC, 3) A NumPy array of \\(N\\) BezierPoints objects containing \\(\\text{PPC}\\) Point3D objects each\n( \\(\\text{PPC: Points Per Curve} = n + 1\\) ): [[[float, float, float], ...], ...] . Please refer to the documentation of the function you are using for\nfurther type information.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class BezierPointsLike_Array", "response": "BezierPoints_Array | Sequence[ BezierPointsLike ] shape: (N, PPC, 3) A sequence of \\(N\\) BezierPointsLike objects containing \\(\\text{PPC}\\) Point3DLike objects each\n( \\(\\text{PPC: Points Per Curve} = n + 1\\) ): [[[float, float, float], ...], ...] . This represents anything which can be converted to a\n:class: BezierPoints_Array NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class BezierPath", "response": "Point3D_Array shape: (PPC*N, 3) A Point3D_Array of \\(\\text{PPC} \\cdot N\\) points, where each\none of the \\(N\\) consecutive blocks of \\(\\text{PPC}\\) control\npoints ( \\(\\text{PPC: Points Per Curve} = n + 1\\) ) represents a\nB\u00e9zier curve of \\(n\\) -th degree: [[float, float, float], ...], ...] . Please refer to the documentation of the function you are using for\nfurther type information.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class BezierPathLike", "response": "Point3DLike_Array shape: (PPC*N, 3) A Point3DLike_Array of \\(\\text{PPC} \\cdot N\\) points, where each\none of the \\(N\\) consecutive blocks of \\(\\text{PPC}\\) control\npoints ( \\(\\text{PPC: Points Per Curve} = n + 1\\) ) represents a\nB\u00e9zier curve of \\(n\\) -th degree: [[float, float, float], ...], ...] . This represents anything which can be converted to a\n:class: BezierPath NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class Spline", "response": "BezierPath shape: (PPC*N, 3) A special case of BezierPath where all the \\(N\\) B\u00e9zier curves\nconsisting of \\(\\text{PPC}\\) Point3D objects\n( \\(\\text{PPC: Points Per Curve} = n + 1\\) ) are connected, forming\nan \\(n\\) -th degree spline: [[float, float, float], ...], ...] . Please refer to the documentation of the function you are using for\nfurther type information.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class SplineLike", "response": "BezierPathLike shape: (PPC*N, 3) A special case of BezierPathLike where all the \\(N\\) B\u00e9zier curves\nconsisting of \\(\\text{PPC}\\) Point3D objects\n( \\(\\text{PPC: Points Per Curve} = n + 1\\) ) are connected, forming\nan \\(n\\) -th degree spline: [[float, float, float], ...], ...] . This represents anything which can be converted to a\n:class: Spline NumPy array. Please refer to the documentation of the function you are using for\nfurther type information.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class FlatBezierPoints", "response": "NDArray[ PointDType ] | tuple[float, ...] shape: (3*PPC*N,) A flattened array of B\u00e9zier control points: [float, ...] .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class FunctionOverride", "response": "Callable Function type returning an Animation for the specified Mobject .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class PathFuncType", "response": "Callable[[ Point3DLike , Point3DLike , float], Point3DLike ] Function mapping two :class: Point3D objects and an alpha value to a new\n:class: Point3D .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class MappingFunction", "response": "Callable[[ Point3D ], Point3D ] A function mapping a :class: Point3D to another :class: Point3D .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class MultiMappingFunction", "response": "Callable[[ Point3D_Array ], Point3D_Array ] A function mapping a :class: Point3D_Array to another\n:class: Point3D_Array .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class PixelArray", "response": "NDArray[ ManimInt ] shape: (height, width) | (height, width, 3) | (height, width, 4) A rasterized image with a height of height pixels and a width of width pixels. Every value in the array is an integer from 0 to 255. Every pixel is represented either by a single integer indicating its\nlightness (for greyscale images), an RGB_Array_Int or an RGBA_Array_Int .", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class GrayscalePixelArray", "response": "PixelArray shape: (height, width) A 100% opaque grayscale PixelArray , where every pixel value is a ManimInt indicating its lightness (black -> gray -> white).", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class RGBPixelArray", "response": "PixelArray shape: (height, width, 3) A 100% opaque PixelArray in color, where every pixel value is an RGB_Array_Int object.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class RGBAPixelArray", "response": "PixelArray shape: (height, width, 4) A PixelArray in color where pixels can be transparent. Every pixel\nvalue is an RGBA_Array_Int object.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class StrPath", "response": "str | PathLike [ str ] A string or os.PathLike representing a path to a\ndirectory or file.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
{"prompt": "class StrOrBytesPath", "response": "str | bytes | PathLike [ str ] | PathLike [ bytes ] A string, bytes or os.PathLike object representing a path\nto a directory or file.", "source": "https://docs.manim.community/en/stable/reference/manim.typing.html"}
